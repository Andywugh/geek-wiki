<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>C++ on 程序员安仔</title><link>https://www.shellio.cc/categories/c++/</link><description>Recent content in C++ on 程序员安仔</description><generator>Hugo -- gohugo.io</generator><language>zh-hans</language><copyright>粤ICP备2023148789号</copyright><lastBuildDate>Thu, 06 Oct 2022 22:42:23 +0800</lastBuildDate><atom:link href="https://www.shellio.cc/categories/c++/index.xml" rel="self" type="application/rss+xml"/><item><title>C++ 常量</title><link>https://www.shellio.cc/docs/programing/c++/default/8/</link><pubDate>Thu, 06 Oct 2022 22:42:23 +0800</pubDate><guid>https://www.shellio.cc/docs/programing/c++/default/8/</guid><description>C++ 常量 常量是固定值，在程序执行期间不会改变。这些固定的值，又叫做字面量。
常量可以是任何的基本数据类型，可分为整型数字、浮点数字、字符、字符串和布尔值。
常量就像是常规的变量，只不过常量的值在定义后不能进行修改。
整数常量 整数常量可以是十进制、八进制或十六进制的常量。前缀指定基数：0x 或 0X 表示十六进制，0 表示八进制，不带前缀则默认表示十进制。
整数常量也可以带一个后缀，后缀是 U 和 L 的组合，U 表示无符号整数（unsigned），L 表示长整数（long）。后缀可以是大写，也可以是小写，U 和 L 的顺序任意。
下面列举几个整数常量的实例：
1212 // 合法的 2215u // 合法的 30xFeeL // 合法的 4078 // 非法的：8 不是八进制的数字 5032UU // 非法的：不能重复后缀 以下是各种类型的整数常量的实例：
185 // 十进制 20213 // 八进制 30x4b // 十六进制 430 // 整数 530u // 无符号整数 630l // 长整数 730ul // 无符号长整数 浮点常量 浮点常量由整数部分、小数点、小数部分和指数部分组成。您可以使用小数形式或者指数形式来表示浮点常量。
当使用小数形式表示时，必须包含小数点、指数，或同时包含两者。当使用指数形式表示时，必须包含整数部分、小数部分，或同时包含两者。带符号的指数是用 e 或 E 引入的。
下面列举几个浮点常量的实例：
13.14159 // 合法的 2314159E-5L // 合法的 3510E // 非法的：不完整的指数 4210f // 非法的：没有小数或指数 5.</description></item><item><title>C++ 环境设置</title><link>https://www.shellio.cc/docs/programing/c++/default/2/</link><pubDate>Thu, 06 Oct 2022 22:42:23 +0800</pubDate><guid>https://www.shellio.cc/docs/programing/c++/default/2/</guid><description>C++ 环境设置 本地环境设置 如果您想要设置 C++ 语言环境，您需要确保电脑上有以下两款可用的软件，文本编辑器和 C++ 编译器。
文本编辑器 这将用于输入您的程序。文本编辑器包括 Windows Notepad、OS Edit command、Brief、Epsilon、EMACS 和 vim/vi。
文本编辑器的名称和版本在不同的操作系统上可能会有所不同。例如，Notepad 通常用于 Windows 操作系统上，vim/vi 可用于 Windows 和 Linux/UNIX 操作系统上。
通过编辑器创建的文件通常称为源文件，源文件包含程序源代码。C++ 程序的源文件通常使用扩展名 .cpp、.cp 或 .c。
在开始编程之前，请确保您有一个文本编辑器，且有足够的经验来编写一个计算机程序，然后把它保存在一个文件中，编译并执行它。
C++ 编译器 写在源文件中的源代码是人类可读的源。它需要”编译”，转为机器语言，这样 CPU 可以按给定指令执行程序。
C++编译器用于把源代码编译成最终的可执行程序。
大多数的 C++ 编译器并不在乎源文件的扩展名，但是如果您未指定扩展名，则默认使用 .cpp。
最常用的免费可用的编译器是 GNU 的 C/C++ 编译器，如果您使用的是 HP 或 Solaris，则可以使用各自操作系统上的编译器。
以下部分将指导您如何在不同的操作系统上安装 GNU 的 C/C++ 编译器。这里同时提到 C/C++，主要是因为 GNU 的 gcc 编译器适合于 C 和 C++ 编程语言。
安装 GNU 的 C/C++ 编译器 UNIX/Linux 上的安装 如果您使用的是 Linux 或 UNIX，请在命令行使用下面的命令来检查您的系统上是否安装了 GCC：</description></item><item><title>C++ 日期 &amp; 时间</title><link>https://www.shellio.cc/docs/programing/c++/default/20/</link><pubDate>Thu, 06 Oct 2022 22:42:23 +0800</pubDate><guid>https://www.shellio.cc/docs/programing/c++/default/20/</guid><description>C++ 日期 &amp;amp; 时间 C++标准库没有提供所谓的日期类型。C++ 继承了 C 语言用于日期和时间操作的结构和函数。为了使用日期和时间相关的函数和结构，需要在 C++ 程序中引用 头文件。
有四个与时间相关的类型：clock_t、time_t、size_t 和 tm。类型 clock_t、size_t 和 time_t 能够把系统时间和日期表示为某种整数。
结构类型 tm 把日期和时间以 C 结构的形式保存，tm 结构的定义如下：
1struct tm { 2 int tm_sec; // 秒，正常范围从 0 到 59，但允许至 61 3 int tm_min; // 分，范围从 0 到 59 4 int tm_hour; // 小时，范围从 0 到 23 5 int tm_mday; // 一月中的第几天，范围从 1 到 31 6 int tm_mon; // 月，范围从 0 到 11 7 int tm_year; // 自 1900 年起的年数 8 int tm_wday; // 一周中的第几天，范围从 0 到 6，从星期日算起 9 int tm_yday; // 一年中的第几天，范围从 0 到 365，从 1 月 1 日算起 10 int tm_isdst; // 夏令时 下面是C/C++ 中关于日期和时间的重要函数。所有这些函数都是 C/C++ 标准库的组成部分，您可以在 C++ 标准库中查看一下各个函数的细节。</description></item><item><title>C++ 数据封装</title><link>https://www.shellio.cc/docs/programing/c++/default/28/</link><pubDate>Thu, 06 Oct 2022 22:42:23 +0800</pubDate><guid>https://www.shellio.cc/docs/programing/c++/default/28/</guid><description>C++ 数据封装 所有的C++ 程序都有以下两个基本要素：
**程序语句（代码）：**这是程序中执行动作的部分，它们被称为函数。 **程序数据：**数据是程序的信息，会受到程序函数的影响。 封装是面向对象编程中的把数据和操作数据的函数绑定在一起的一个概念，这样能避免受到外界的干扰和误用，从而确保了安全。数据封装引申出了另一个重要的 OOP 概念，即数据隐藏。
数据封装是一种把数据和操作数据的函数捆绑在一起的机制，数据抽象是一种仅向用户暴露接口而把具体的实现细节隐藏起来的机制。
C++通过创建类来支持封装和数据因此。我们已经知道，类包含私有成员（private）、保护成员（protected）和公有成员（public）成员。默认情况下，在类中定义的所有项目都是私有的。例如：
1class Box 2 public: 3 double getVolume(void) 4 { 5 return length * breadth * height; 6 } 7 private: 8 double length; // 长度 9 double breadth; // 宽度 10 double height; // 高度 11}; 变量length、breadth 和 height 都是私有的（private）。这意味着它们只能被 Box 类中的其他成员访问，而不能被程序中其他部分访问。这是实现封装的一种方式。
为了使类中的成员变成公有的（即，程序中的其他部分也能访问），必须在这些成员前使用 public 关键字进行声明。所有定义在 public 标识符后边的变量或函数可以被程序中所有其他的函数访问。
把一个类定义为另一个类的友元类，会暴露实现细节，从而降低了封装性。理想的做法是尽可能地对外隐藏每个类的实现细节。
数据封装的实例 C++程序中，任何带有公有和私有成员的类都可以作为数据封装和数据抽象的实例。请看下面的实例：
1#include &amp;lt;iostream&amp;gt; 2using namespace std; 3class Adder{ 4 public: 5 // 构造函数 6 Adder(int i = 0) 7 { 8 total = i; 9 } 10 // 对外的接口 11 void addNum(int number) 12 { 13 total += number; 14 } 15 // 对外的接口 16 int getTotal() 17 { 18 return total; 19 }; 20 private: 21 // 对外隐藏的数据 22 int total; 23}; 24int main( ) 25 Adder a; 26 a.</description></item><item><title>C++ 数据结构</title><link>https://www.shellio.cc/docs/programing/c++/default/22/</link><pubDate>Thu, 06 Oct 2022 22:42:23 +0800</pubDate><guid>https://www.shellio.cc/docs/programing/c++/default/22/</guid><description>C++ 数据结构 C/C++ 数组允许定义可存储相同类型数据项的变量，但是结构是 C++ 中另一种用户自定义的可用的数据类型，它允许您存储不同类型的数据项。
结构用于表示一条记录，假设您想要跟踪图书馆中书本的动态，您可能需要跟踪每本书的下列属性：
Title Author Subject Book ID 定义结构 为了定义结构，您必须使用 struct 语句。struct 语句定义了一个包含多个成员的新的数据类型，struct 语句的格式如下：
1struct [structure tag] 2 member definition; 3 member definition; 4 ... 5 member definition; 6} [one or more structure variables]; structure tag 是可选的，每个 member definition 是标准的变量定义，比如 int i; 或者 float f; 或者其他有效的变量定义。在结构定义的末尾，最后一个分号之前，您可以指定一个或多个结构变量，这是可选的。下面是声明 Book 结构的方式：
1struct Books 2 char title[50]; 3 char author[50]; 4 char subject[100]; 5 int book_id; }book;
访问结构成员 为了访问结构的成员，我们使用成员访问运算符（.）。成员访问运算符是结构变量名称和我们要访问的结构成员之间的一个句号。您可以使用 struct 关键字来定义结构类型的变量。下面的实例演示了结构的用法：</description></item><item><title>C++ 接口（抽象类）</title><link>https://www.shellio.cc/docs/programing/c++/default/29/</link><pubDate>Thu, 06 Oct 2022 22:42:23 +0800</pubDate><guid>https://www.shellio.cc/docs/programing/c++/default/29/</guid><description>C++ 接口（抽象类） 接口描述了类的行为和功能，而不需要完成类的特定实现。
C++接口是使用抽象类来实现的，抽象类与数据抽象互不混淆，数据抽象是一个把实现细节与相关的数据分离开的概念。
如果类中至少有一个函数被声明为纯虚函数，则这个类就是抽象类。纯虚函数是通过在声明中使用 “= 0” 来指定的，如下所示：
1class Box 2 public: 3 // 纯虚函数 4 virtual double getVolume() = 0; 5 private: 6 double length; // 长度 7 double breadth; // 宽度 8 double height; // 高度 9}; 设计抽象类（通常称为 ABC）的目的，是为了给其他类提供一个可以继承的适当的基类。抽象类不能被用于实例化对象，它只能作为接口使用。如果试图实例化一个抽象类的对象，会导致编译错误。
因此，如果一个 ABC 的子类需要被实例化，则必须实现每个虚函数，这也意味着 C++ 支持使用 ABC 声明接口。如果没有在派生类中重载纯虚函数，就尝试实例化该类的对象，会导致编译错误。
可用于实例化对象的类被称为具体类。
抽象类的实例 请看下面的实例，基类 Shape 提供了一个接口 getArea()，在两个派生类 Rectangle 和 Triangle 中分别实现了 getArea()：
1#include &amp;lt;iostream&amp;gt; 2using namespace std; 3// 基类 4class Shape 5public: 6 // 提供接口框架的纯虚函数 7 virtual int getArea() = 0; 8 void setWidth(int w) 9 { 10 width = w; 11 } 12 void setHeight(int h) 13 { 14 height = h; 15 } 16protected: 17 int width; 18 int height; 19}; 20// 派生类 21class Rectangle: public Shape 22public: 23 int getArea() 24 { 25 return (width * height); 26 } 27}; 28class Triangle: public Shape 29public: 30 int getArea() 31 { 32 return (width * height)/2; 33 } 34}; 35int main(void) 36 Rectangle Rect; 37 Triangle Tri; 38 Rect.</description></item><item><title>C++ 多态</title><link>https://www.shellio.cc/docs/programing/c++/default/26/</link><pubDate>Thu, 06 Oct 2022 22:42:23 +0800</pubDate><guid>https://www.shellio.cc/docs/programing/c++/default/26/</guid><description>C++ 多态 多态按字面的意思就是多种形态。当类之间存在层次结构，并且类之间是通过继承关联时，就会用到多态。
C++多态意味着调用成员函数时，会根据调用函数的对象的类型来执行不同的函数。
下面的实例中，基类 Shape 被派生为两个类，如下所示：
1#include &amp;lt;iostream&amp;gt; 2using namespace std; 3class Shape { 4 protected: 5 int width, height; 6 public: 7 Shape( int a=0, int b=0) 8 { 9 width = a; 10 height = b; 11 } 12 int area() 13 { 14 cout &amp;lt;&amp;lt; &amp;#34;Parent class area :&amp;#34; &amp;lt;&amp;lt;endl; 15 return 0; 16 } 17}; 18class Rectangle: public Shape{ 19 public: 20 Rectangle( int a=0, int b=0):Shape(a, b) { } 21 int area () 22 { 23 cout &amp;lt;&amp;lt; &amp;#34;Rectangle class area :&amp;#34; &amp;lt;&amp;lt;endl; 24 return (width * height); 25 } 26}; 27class Triangle: public Shape{ 28 public: 29 Triangle( int a=0, int b=0):Shape(a, b) { } 30 int area () 31 { 32 cout &amp;lt;&amp;lt; &amp;#34;Triangle class area :&amp;#34; &amp;lt;&amp;lt;endl; 33 return (width * height / 2); 34 } 35}; 36// 程序的主函数 37int main( ) 38 Shape *shape; 39 Rectangle rec(10,7); 40 Triangle tri(10,5); 41 // 存储矩形的地址 42 shape = &amp;amp;rec; 43 // 调用矩形的求面积函数 area 44 shape-&amp;gt;area(); 45 // 存储三角形的地址 46 shape = &amp;amp;tri; 47 // 调用三角形的求面积函数 area 48 shape-&amp;gt;area(); 49 return 0; 当上面的代码被编译和执行时，它会产生下列结果：</description></item><item><title>C++ 数据抽象</title><link>https://www.shellio.cc/docs/programing/c++/default/27/</link><pubDate>Thu, 06 Oct 2022 22:42:23 +0800</pubDate><guid>https://www.shellio.cc/docs/programing/c++/default/27/</guid><description>C++ 数据抽象 数据抽象是指，只向外界提供关键信息，并隐藏其后台的实现细节，即只表现必要的信息而不呈现细节。
数据抽象是一种依赖于接口和实现分离的编程（设计）技术。
让我们举一个现实生活中的真实例子，比如一台电视机，您可以打开和关闭、切换频道、调整音量、添加外部组件（如喇叭、录像机、DVD 播放器），但是您不知道它的内部实现细节，也就是说，您并不知道它是如何通过缆线接收信号，如何转换信号，并最终显示在屏幕上。
因此，我们可以说电视把它的内部实现和外部接口分离开了，您无需知道它的内部实现原理，直接通过它的外部接口（比如电源按钮、遥控器、声量控制器）就可以操控电视。
现在，让我们言归正传，就 C++ 编程而言，C++ 类为数据抽象提供了可能。它们向外界提供了大量用于操作对象数据的公共方法，也就是说，外界实际上并不清楚类的内部实现。
例如，您的程序可以调用 sort() 函数，而不需要知道函数中排序数据所用到的算法。实际上，函数排序的底层实现会因库的版本不同而有所差异，只要接口不变，函数调用就可以照常工作。
在C++ 中，我们使用类来定义我们自己的抽象数据类型（ADT）。您可以使用类 ostream 的 cout 对象来输出数据到标准输出，如下所示：
1#include &amp;lt;iostream&amp;gt; 2using namespace std; 3int main( ) 4 cout &amp;lt;&amp;lt; &amp;#34;Hello C++&amp;#34; &amp;lt;&amp;lt;endl; 5 return 0; 在这里，您不需要理解 cout 是如何在用户的屏幕上显示文本。您只需要知道公共接口即可，cout 的底层实现可以自由改变。
访问标签强制抽象 在C++ 中，我们使用访问标签来定义类的抽象接口。一个类可以包含零个或多个访问标签：
使用公共标签定义的成员都可以访问该程序的所有部分。一个类型的数据抽象视图是由它的公共成员来定义的。 使用私有标签定义的成员无法访问到使用类的代码。私有部分对使用类型的代码隐藏了实现细节。 访问标签出现的频率没有限制。每个访问标签指定了紧随其后的成员定义的访问级别。指定的访问级别会一直有效，直到遇到下一个访问标签或者遇到类主体的关闭右括号为止。
数据抽象的好处 数据抽象有两个重要的优势：
类的内部受到保护，不会因无意的用户级错误导致对象状态受损。 类实现可能随着时间的推移而发生变化，以便应对不断变化的需求，或者应对那些要求不改变用户级代码的错误报告。 如果只在类的私有部分定义数据成员，编写该类的作者就可以随意更改数据。如果实现发生改变，则只需要检查类的代码，看看这个改变会导致哪些影响。如果数据是公有的，则任何直接访问旧表示形式的数据成员的函数都可能受到影响。
数据抽象的实例 C++程序中，任何带有公有和私有成员的类都可以作为数据抽象的实例。请看下面的实例：
因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 1#include &amp;lt;iostream&amp;gt; 2using namespace std; 3class Adder{ 4 public: 5 // 构造函数 6 Adder(int i = 0) 7 { 8 total = i; 9 } 10 // 对外的接口 11 void addNum(int number) 12 { 13 total += number; 14 } 15 // 对外的接口 16 int getTotal() 17 { 18 return total; 19 }; 20 private: 21 // 对外隐藏的数据 22 int total; 23}; 24int main( ) 25 Adder a; 26 a.</description></item><item><title>C++ 类 &amp; 对象</title><link>https://www.shellio.cc/docs/programing/c++/default/23/</link><pubDate>Thu, 06 Oct 2022 22:42:23 +0800</pubDate><guid>https://www.shellio.cc/docs/programing/c++/default/23/</guid><description>C++ 类 &amp;amp; 对象 C++在 C 语言的基础上增加了面向对象编程，C++ 支持面向对象程序设计。类是 C++ 的核心特性，通常被称为用户定义的类型。
类用于指定对象的形式，它包含了数据表示法和用于处理数据的方法。类中的数据和方法称为类的成员。函数在一个类被称为类的成员。
C++ 类定义 定义一个类，本质上是定义一个数据类型的蓝图。这实际上并没有定义任何数据，但它定义了类的名称意味着什么，也就是说，它定义了类的对象包括了什么，以及可以在这个对象上执行哪些操作。
类定义是以关键字 class 开头，后跟类的名称。类的主体是包含在一对花括号中。类定义后必须跟着一个分号或一个声明列表。例如，我们使用关键字 class 定义 Box 数据类型，如下所示：
1class Box 2 public: 3 double length; // Length of a box 4 double breadth; // Breadth of a box 5 double height; // Height of a box 6}; 关键字public 确定了类成员的访问属性。在类对象作用域内，公共成员在类的外部是可访问的。您也可以指定类的成员为 private 或 protected，这个我们稍后会进行讲解。
定义 C++ 对象 类提供了对象的蓝图，所以基本上，对象是根据类来创建的。声明类的对象，就像声明基本类型的变量一样。下面的语句声明了类 Box 的两个对象：
1Box Box1; // 声明 Box1，类型为 Box 2Box Box2; // 声明 Box2，类型为 Box 对象Box1 和 Box2 都有它们各自的数据成员。</description></item><item><title>C++ 继承</title><link>https://www.shellio.cc/docs/programing/c++/default/24/</link><pubDate>Thu, 06 Oct 2022 22:42:23 +0800</pubDate><guid>https://www.shellio.cc/docs/programing/c++/default/24/</guid><description>C++ 继承 面向对象程序设计中最重要的一个概念是继承。继承允许我们依据另一个类来定义一个类，这使得创建和维护一个应用程序变得更容易。这样做，也达到了重用代码功能和提高执行时间的效果。
当创建一个类时，您不需要重新编写新的数据成员和成员函数，只需指定新建的类继承了一个已有的类的成员即可。这个已有的类称为基类，新建的类称为派生类。
继承代表了 is a 关系。例如，哺乳动物是动物，狗是哺乳动物，因此，狗是动物，等等。
基类 &amp;amp; 派生类 一个类可以派生自多个类，这意味着，它可以从多个基类继承数据和函数。定义一个派生类，我们使用一个类派生列表来指定基类。类派生列表以一个或多个基类命名，形式如下：
1class derived-class: access-specifier base-class 其中，访问修饰符 access-specifier 是 public、protected 或 private 其中的一个，base-class 是之前定义过的某个类的名称。如果未使用访问修饰符 access-specifier，则默认为 private。
假设有一个基类 Shape，Rectangle 是它的派生类，如下所示：
1#include &amp;lt;iostream&amp;gt; 2using namespace std; 3// 基类 4class Shape 5 public: 6 void setWidth(int w) 7 { 8 width = w; 9 } 10 void setHeight(int h) 11 { 12 height = h; 13 } 14 protected: 15 int width; 16 int height; 17}; 18// 派生类 19class Rectangle: public Shape 20 public: 21 int getArea() 22 { 23 return (width * height); 24 } 25}; 26int main(void) 27 Rectangle Rect; 28 Rect.</description></item><item><title>C++ 重载运算符和重载函数</title><link>https://www.shellio.cc/docs/programing/c++/default/25/</link><pubDate>Thu, 06 Oct 2022 22:42:23 +0800</pubDate><guid>https://www.shellio.cc/docs/programing/c++/default/25/</guid><description>C++ 重载运算符和重载函数 C++允许在同一作用域中的某个函数和运算符指定多个定义，分别称为函数重载和运算符重载。
重载声明是指一个与之前已经在该作用域内声明过的函数或方法具有相同名称的声明，但是它们的参数列表和定义（实现）不相同。
当您调用一个重载函数或重载运算符时，编译器通过把您所使用的参数类型与定义中的参数类型进行比较，决定选用最合适的定义。选择最合适的重载函数或重载运算符的过程，称为重载决策。
C++ 中的函数重载 在同一个作用域内，可以声明几个功能类似的同名函数，但是这些同名函数的形式参数（指参数的个数、类型或者顺序）必须不同。您不能仅通过返回类型的不同来重载函数。
下面的实例中，同名函数 print() 被用于输出不同的数据类型：
1#include &amp;lt;iostream&amp;gt; 2using namespace std; 3class printData 4 public: 5 void print(int i) { 6 cout &amp;lt;&amp;lt; &amp;#34;Printing int: &amp;#34; &amp;lt;&amp;lt; i &amp;lt;&amp;lt; endl; 7 } 8 void print(double f) { 9 cout &amp;lt;&amp;lt; &amp;#34;Printing float: &amp;#34; &amp;lt;&amp;lt; f &amp;lt;&amp;lt; endl; 10 } 11 void print(char* c) { 12 cout &amp;lt;&amp;lt; &amp;#34;Printing character: &amp;#34; &amp;lt;&amp;lt; c &amp;lt;&amp;lt; endl; 13 } 14}; 15int main(void) 16 printData pd; 17 // Call print to print integer 18 pd.</description></item><item><title>C++ 基本的输入输出</title><link>https://www.shellio.cc/docs/programing/c++/default/21/</link><pubDate>Thu, 06 Oct 2022 22:42:23 +0800</pubDate><guid>https://www.shellio.cc/docs/programing/c++/default/21/</guid><description>C++ 基本的输入输出 C++标准库提供了一组丰富的输入/输出功能，我们将在后续的章节进行介绍。本章将讨论 C++ 编程中最基本和最常见的 I/O 操作。
C++的 I/O 发生在流中，流是字节序列。如果字节流是从设备（如键盘、磁盘驱动器、网络连接等）流向内存，这叫做输入操作。如果字节流是从内存流向设备（如显示屏、打印机、磁盘驱动器、网络连接等），这叫做输出操作。
I/O 库头文件 下列的头文件在 C++ 编程中很重要。
头文件 函数和描述 &amp;lt;iostream&amp;gt; 该文件定义了 cin、cout、cerr 和 clog 对象，分别对应于标准输入流、标准输出流、非缓冲标准错误流和缓冲标准错误流。 &amp;lt;iomanip&amp;gt; 该文件通过所谓的参数化的流操纵器（比如 setw 和 setprecision），来声明对执行标准化 I/O 有用的服务。 &amp;lt;fstream&amp;gt; 该文件为用户控制的文件处理声明服务。我们将在文件和流的相关章节讨论它的细节。 标准输出流（cout） 预定义的对象 cout 是 ostream 类的一个实例。cout 对象”连接”到标准输出设备，通常是显示屏。cout 是与流插入运算符 &amp;laquo; 结合使用的，如下所示：
1#include &amp;lt;iostream&amp;gt; 2using namespace std; 3int main( ) 4 char str[] = &amp;#34;Hello C++&amp;#34;; 5 cout &amp;lt;&amp;lt; &amp;#34;Value of str is : &amp;#34; &amp;lt;&amp;lt; str &amp;lt;&amp;lt; endl; 6} 当上面的代码被编译和执行时，它会产生下列结果：</description></item><item><title>C++ 修饰符类型</title><link>https://www.shellio.cc/docs/programing/c++/default/9/</link><pubDate>Thu, 06 Oct 2022 22:42:23 +0800</pubDate><guid>https://www.shellio.cc/docs/programing/c++/default/9/</guid><description>C++ 修饰符类型 C++允许在 char、int 和 double 数据类型前放置修饰符。修饰符用于改变基本类型的含义，所以它更能满足各种情境的需求。
下面列出了数据类型修饰符：
signed unsigned long short 修饰符signed、unsigned、long 和 short 可应用于整型，signed 和 unsigned 可应用于字符型，long 可应用于双精度型。
修饰符signed 和 unsigned 也可以作为 long 或 short 修饰符的前缀。例如：unsigned long int。
C++允许使用速记符号来声明无符号短整数或无符号长整数。您可以不写 int，只写单词 unsigned short 或 unsigned long，int 是隐含的。例如，下面的两个语句都声明了无符号整型变量。
1unsigned x; 2unsigned int y; 为了理解 C++ 解释有符号整数和无符号整数修饰符之间的差别，我们来运行一下下面这个短程序：
1#include &amp;lt;iostream&amp;gt; 2using namespace std; 3/* 4 * 这个程序演示了有符号整数和无符号整数之间的差别 5*/ 6int main() 7 short int i; // 有符号短整数 8 short unsigned int j; // 无符号短整数 9 j = 50000; 10 i = j; 11 cout &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &amp;#34; &amp;#34; &amp;lt;&amp;lt; j; 12 return 0; 13} 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 当上面的程序运行时，会输出下列结果：</description></item><item><title>C++ 变量类型</title><link>https://www.shellio.cc/docs/programing/c++/default/6/</link><pubDate>Thu, 06 Oct 2022 22:42:23 +0800</pubDate><guid>https://www.shellio.cc/docs/programing/c++/default/6/</guid><description>C++ 变量类型 变量其实只不过是程序可操作的存储区的名称。C++ 中每个变量都有指定的类型，类型决定了变量存储的大小和布局，该范围内的值都可以存储在内存中，运算符可应用于变量上。
变量的名称可以由字母、数字和下划线字符组成。它必须以字母或下划线开头。大写字母和小写字母是不同的，因为 C++ 是大小写敏感的。
基于前一章讲解的基本类型，有以下几种基本的变量类型，将在下一章中进行讲解：
类型 描述 bool 存储值 true 或 false。 char 通常是一个八位字节（一个字节）。这是一个整数类型。 int 对机器而言，整数的最自然的大小。 float 单精度浮点值。 double 双精度浮点值。 void 表示类型的缺失。 wchar_t 宽字符类型。 C++也允许定义各种其他类型的变量，比如枚举、指针、数组、引用、数据结构、类等等，这将会在后续的章节中进行讲解。
下面我们将讲解如何定义、声明和使用各种类型的变量。
C++ 中的变量定义 变量定义就是告诉编译器在何处创建变量的存储，以及如何创建变量的存储。变量定义指定一个数据类型，并包含了该类型的一个或多个变量的列表，如下所示：
1type variable_list; 在这里，type 必须是一个有效的 C++ 数据类型，可以是 char、w_char、int、float、double、bool 或任何用户自定义的对象，variable_list 可以由一个或多个标识符名称组成，多个标识符之间用逗号分隔。下面列出几个有效的声明：
1int i, j, k; 2char c, ch; 3float f, salary; 4double d; 行 int i, j, k; 声明并定义了变量 i、j 和 k，这指示编译器创建类型为 int 的名为 i、j、k 的变量。
变量可以在声明的时候被初始化（指定一个初始值）。初始化器由一个等号，后跟一个常量表达式组成，如下所示：
1type variable_name = value; 下面列举几个实例：</description></item><item><title>C++ 变量作用域</title><link>https://www.shellio.cc/docs/programing/c++/default/7/</link><pubDate>Thu, 06 Oct 2022 22:42:23 +0800</pubDate><guid>https://www.shellio.cc/docs/programing/c++/default/7/</guid><description>C++ 变量作用域 作用域是程序的一个区域，一般来说有三个地方可以声明变量：
在函数或一个代码块内部声明的变量，称为局部变量。 在函数参数的定义中声明的变量，称为形式参数。 在所有函数外部声明的变量，称为全局变量。 我们将在后续的章节中学习什么是函数和参数。本章我们先来讲解声明是局部变量和全局变量。
局部变量 在函数或一个代码块内部声明的变量，称为局部变量。它们只能被函数内部或者代码块内部的语句使用。下面的实例使用了局部变量：
1#include &amp;lt;iostream&amp;gt; 2using namespace std; 3int main () 4 // 局部变量声明 5 int a, b; 6 int c; 7 // 实际初始化 8 a = 10; 9 b = 20; 10 c = a + b; 11 cout &amp;lt;&amp;lt; c; return 0; 12} 全局变量 在所有函数外部定义的变量（通常是在程序的头部），称为全局变量。全局变量的值在程序的整个生命周期内都是有效的。
全局变量可以被任何函数访问。也就是说，全局变量一旦声明，在整个程序中都是可用的。下面的实例使用了全局变量和局部变量：
1#include &amp;lt;iostream&amp;gt; 2using namespace std; 3// 全局变量声明 4int g; 5int main () 6 // 局部变量声明 7 int a, b; 8 // 实际初始化 9 a = 10; 10 b = 20; 11 g = a + b; 12 cout &amp;lt;&amp;lt; g; return 0; 13 } 在程序中，局部变量和全局变量的名称可以相同，但是在函数内，局部变量的值会覆盖全局变量的值。下面是一个实例：</description></item><item><title>C++ 基本语法</title><link>https://www.shellio.cc/docs/programing/c++/default/3/</link><pubDate>Thu, 06 Oct 2022 22:42:23 +0800</pubDate><guid>https://www.shellio.cc/docs/programing/c++/default/3/</guid><description>C++ 基本语法 C++程序可以定义为对象的集合，这些对象通过调用彼此的方法进行交互。现在让我们简要地看一下什么是类、对象，方法、即时变量。
对象 – 对象具有状态和行为。例如：一只狗的状态 – 颜色、名称、品种，行为 – 摇动、叫唤、吃。对象是类的实例。 类 – 类可以定义为描述对象行为/状态的模板/蓝图。 方法 – 从基本上说，一个方法表示一种行为。一个类可以包含多个方法。可以在方法中写入逻辑、操作数据以及执行所有的动作。 即时变量 – 每个对象都有其独特的即时变量。对象的状态是由这些即时变量的值创建的。 C++ 程序结构 让我们看一段简单的代码，可以输出单词 Hello World。
1#include &amp;lt;iostream&amp;gt; 2using namespace std; 3// main() 是程序开始执行的地方 4int main() 5 cout &amp;lt;&amp;lt; &amp;#34;Hello World&amp;#34;; // 输出 Hello World return 0; 6} 接下来我们讲解一下上面这段程序：
C++ 语言定义了一些头文件，这些头文件包含了程序中必需的或有用的信息。上面这段程序中，包含了头文件 。 行 using namespace std; 告诉编译器使用 std 命名空间。命名空间是 C++ 中一个相对新的概念。 下一行 // main() 是程序开始执行的地方 是一个单行注释。单行注释以 // 开头，在行末结束。 下一行 int main() 是主函数，程序从这里开始执行。 下一行 cout &amp;laquo; “Hello World”; 会在屏幕上显示消息 “Hello World”。 下一行 return 0; 终止 main( )函数，并向调用进程返回值 0。 编译 &amp;amp; 执行 C++ 程序 接下来让我们看看如何把源代码保存在一个文件中，以及如何编译并运行它。下面是简单的步骤：</description></item><item><title>C++ 文件和流</title><link>https://www.shellio.cc/docs/programing/c++/default/30/</link><pubDate>Thu, 06 Oct 2022 22:42:23 +0800</pubDate><guid>https://www.shellio.cc/docs/programing/c++/default/30/</guid><description>C++ 文件和流 到目前为止，我们已经使用了 iostream 标准库，它提供了 cin 和 cout 方法分别用于从标准输入读取流和向标准输出写入流。
本教程介绍如何从文件读取流和向文件写入流。这就需要用到 C++ 中另一个标准库 fstream，它定义了三个新的数据类型：
数据类型 描述 ofstream 该数据类型表示输出文件流，用于创建文件并向文件写入信息。 ifstream 该数据类型表示输入文件流，用于从文件读取信息。 fstream 该数据类型通常表示文件流，且同时具有 ofstream 和 ifstream 两种功能，这意味着它可以创建文件，向文件写入信息，从文件读取信息。 要在C++ 中进行文件处理，必须在 C++ 源代码文件中包含头文件 和 。
打开文件 在从文件读取信息或者向文件写入信息之前，必须先打开文件。ofstream 和 fstream 对象都可以用来打开文件进行写操作，如果只需要打开文件进行读操作，则使用 ifstream 对象。
下面是open() 函数的标准语法，open() 函数是 fstream、ifstream 和 ofstream 对象的一个成员。
1void open(const char *filename, ios::openmode mode); 在这里，open() 成员函数的第一参数指定要打开的文件的名称和位置，第二个参数定义文件被打开的模式。
模式标志 描述 ios::app 追加模式。所有写入都追加到文件末尾。 ios::ate 文件打开后定位到文件末尾。 ios::in 打开文件用于读取。 ios::out 打开文件用于写入。 ios::trunc 如果该文件已经存在，其内容将在打开文件之前被截断，即把文件长度设为 0。 您可以把以上两种或两种以上的模式结合使用。例如，如果您想要以写入模式打开文件，并希望截断文件，以防文件已存在，那么您可以使用下面的语法：
1ofstream outfile; 2outfile.open(&amp;#34;file.dat&amp;#34;, ios::out | ios::trunc ); 类似地，您如果想要打开一个文件用于读写，可以使用下面的语法：</description></item><item><title>C++ Web 编程</title><link>https://www.shellio.cc/docs/programing/c++/default/38/</link><pubDate>Thu, 06 Oct 2022 22:42:23 +0800</pubDate><guid>https://www.shellio.cc/docs/programing/c++/default/38/</guid><description>C++ Web 编程 什么是 CGI？ 公共网关接口（CGI），是一套标准，定义了信息是如何在 Web 服务器和客户端脚本之间进行交换的。 CGI 规范目前是由 NCSA 维护的，NCSA 定义 CGI 如下： 公共网关接口（CGI），是一种用于外部网关程序与信息服务器（如 HTTP 服务器）对接的接口标准。 目前的版本是 CGI/1.1，CGI/1.2 版本正在推进中。 Web 浏览 为了更好地了解 CGI 的概念，让我们点击一个超链接，浏览一个特定的网页或 URL，看看会发生什么。
您的浏览器联系上 HTTP Web 服务器，并请求 URL，即文件名。 Web 服务器将解析 URL，并查找文件名。如果找到请求的文件，Web 服务器会把文件发送回浏览器，否则发送一条错误消息，表明您请求了一个错误的文件。 Web 浏览器从 Web 服务器获取响应，并根据接收到的响应来显示文件或错误消息。 然而，以这种方式搭建起来的 HTTP 服务器，不管何时请求目录中的某个文件，HTTP 服务器发送回来的不是该文件，而是以程序形式执行，并把执行产生的输出发送回浏览器显示出来。
公共网关接口（CGI），是使得应用程序（称为 CGI 程序或 CGI 脚本）能够与 Web 服务器以及客户端进行交互的标准协议。这些 CGI 程序可以用 Python、PERL、Shell、C 或 C++ 等进行编写。
CGI 架构图 下图演示了 CGI 的架构：
Web 服务器配置 在您进行 CGI 编程之前，请确保您的 Web 服务器支持 CGI，并已配置成可以处理 CGI 程序。所有由 HTTP 服务器执行的 CGI 程序，都必须在预配置的目录中。该目录称为 CGI 目录，按照惯例命名为 /var/www/cgi-bin。虽然 CGI 文件是 C++ 可执行文件，但是按照惯例它的扩展名是 .</description></item><item><title>C++ 动态内存</title><link>https://www.shellio.cc/docs/programing/c++/default/32/</link><pubDate>Thu, 06 Oct 2022 22:42:23 +0800</pubDate><guid>https://www.shellio.cc/docs/programing/c++/default/32/</guid><description>C++ 动态内存 了解动态内存在 C++ 中是如何工作的是成为一名合格的 C++ 程序员必不可少的。C++ 程序中的内存分为两个部分：
**栈：**在函数内部声明的所有变量都将占用栈内存。 **堆：**这是程序中未使用的内存，在程序运行时可用于动态分配内存。 很多时候，您无法提前预知需要多少内存来存储某个定义变量中的特定信息，所需内存的大小需要在运行时才能确定。
在C++ 中，您可以使用特殊的运算符为给定类型的变量在运行时分配堆内的内存，这会返回所分配的空间地址。这种运算符即 new 运算符。
如果您不需要动态分配内存，可以使用 delete 运算符，删除之前由 new 运算符分配的内存。
new 和 delete 运算符 下面是使用 new 运算符来为任意的数据类型动态分配内存的通用语法：
1new data-type; 在这里，data-type 可以是包括数组在内的任意内置的数据类型，也可以是包括类或结构在内的用户自定义的任何数据类型。让我们先来看下内置的数据类型。例如，我们可以定义一个指向 double 类型的指针，然后请求内存，该内存在执行时被分配。我们可以按照下面的语句使用 new 运算符来完成这点：
1double* pvalue = NULL; // 初始化为 null 的指针 2pvalue = new double; // 为变量请求内存 如果自由存储区已被用完，可能无法成功分配内存。所以建议检查 new 运算符是否返回 NULL 指针，并采取以下适当的操作：
1double* pvalue = NULL; 2if( !(pvalue = new double )) 3 cout &amp;lt;&amp;lt; &amp;#34;Error: out of memory.</description></item><item><title>C++ STL 教程</title><link>https://www.shellio.cc/docs/programing/c++/default/39/</link><pubDate>Thu, 06 Oct 2022 22:42:23 +0800</pubDate><guid>https://www.shellio.cc/docs/programing/c++/default/39/</guid><description>C++ STL 教程 在前面的章节中，我们已经学习了 C++ 模板的概念。C++ STL（标准模板库）是一套功能强大的 C++ 模板类，提供了通用的模板类和函数，这些模板类和函数可以实现多种流行和常用的算法和数据结构，如向量、链表、队列、栈。
C++标准模板库的核心包括以下三个组件：
组件 描述 容器（Containers） 容器是用来管理某一类对象的集合。C++ 提供了各种不同类型的容器，比如 deque、list、vector、map 等。 算法（Algorithms） 算法作用于容器。它们提供了执行各种操作的方式，包括对容器内容执行初始化、排序、搜索和转换等操作。 迭代器（terators） 迭代器用于遍历对象集合的元素。这些集合可能是容器，也可能是容器的子集。 这三个组件都带有丰富的预定义函数，帮助我们通过简单的方式处理复杂的任务。
下面的程序演示了向量容器（一个 C++ 标准的模板），它与数组十分相似，唯一不同的是，向量在需要扩展大小的时候，会自动处理它自己的存储需求：
1#include &amp;lt;iostream&amp;gt; 2#include &amp;lt;vector&amp;gt; 3using namespace std; 4int main() 5 // 创建一个向量存储 int 6 vector&amp;lt;int&amp;gt; vec; 7 int i; 8 // 显示 vec 的原始大小 9 cout &amp;lt;&amp;lt; &amp;#34;vector size = &amp;#34; &amp;lt;&amp;lt; vec.size() &amp;lt;&amp;lt; endl; 10 // 推入 5 个值到向量中 11 for(i = 0; i &amp;lt; 5; i++){ 12 vec.</description></item><item><title>C++ 信号处理</title><link>https://www.shellio.cc/docs/programing/c++/default/36/</link><pubDate>Thu, 06 Oct 2022 22:42:23 +0800</pubDate><guid>https://www.shellio.cc/docs/programing/c++/default/36/</guid><description>C++ 信号处理 信号是由操作系统传给进程的中断，会提早终止一个程序。在 UNIX、LINUX、Mac OS X 或 Windows 系统上，可以通过按 Ctrl+C 产生中断。
有些信号不能被程序捕获，但是下表所列信号可以在程序中捕获，并可以基于信号采取适当的动作。这些信号是定义在 C++ 头文件 中。
信号 描述 SIGABRT 程序的异常终止，如调用 abort。 SIGFPE 错误的算术运算，比如除以零或导致溢出的操作。 SIGILL 检测非法指令。 SIGINT 接收到交互注意信号。 SIGSEGV 非法访问内存。 SIGTERM 发送到程序的终止请求。 signal() 函数 C++信号处理库提供了 signal 函数，用来捕获突发事件。以下是 signal() 函数的语法：
1void (*signal (int sig, void (*func)(int)))(int); 这个函数接收两个参数：第一个参数是一个整数，代表了信号的编号；第二个参数是一个指向信号处理函数的指针。
让我们编写一个简单的 C++ 程序，使用 signal() 函数捕获 SIGINT 信号。不管您想在程序中捕获什么信号，您都必须使用 signal 函数来注册信号，并将其与信号处理程序相关联。看看下面的实例：
1#include &amp;lt;iostream&amp;gt; 2#include &amp;lt;csignal&amp;gt; 3#include &amp;lt;unistd.h&amp;gt; 4using namespace std; 5void signalHandler( int signum ) 6 cout &amp;lt;&amp;lt; &amp;#34;Interrupt signal (&amp;#34; &amp;lt;&amp;lt; signum &amp;lt;&amp;lt; &amp;#34;) received.</description></item><item><title>C++ 多线程</title><link>https://www.shellio.cc/docs/programing/c++/default/37/</link><pubDate>Thu, 06 Oct 2022 22:42:23 +0800</pubDate><guid>https://www.shellio.cc/docs/programing/c++/default/37/</guid><description>C++ 多线程 多线程是多任务处理的一种特殊形式，多任务处理允许让电脑同时运行两个或两个以上的程序。在一般情况下，有两种类型的多任务处理：基于进程和基于线程。
基于进程的多任务处理处理的是程序的并发执行。基于线程的多任务处理的是同一程序的片段的并发执行。
多线程程序包含可以同时运行的两个或多个部分。这样的程序中的每个部分称为一个线程，每个线程定义了一个单独的执行路径。
C++不包含多线程应用程序的任何内置支持。相反，它完全依赖于操作系统来提供此功能。
本教程假设您使用的是 Linux 操作系统，我们要使用 POSIX 编写多线程 C++ 程序。POSIX Threads 或 Pthreads 提供的 API 可在多种类 Unix POSIX 系统上可用，比如 FreeBSD、NetBSD、GNU/Linux、Mac OS X 和 Solaris。
创建线程 有下面的例程，我们可以用它来创建一个 POSIX 线程：
1#include &amp;lt;pthread.h&amp;gt; 2pthread_create (thread, attr, start_routine, arg) 在这里，pthread_create 创建一个新的线程，并让它可执行。这个例程可在代码内的任何地方被调用任意次数。下面是关于参数的说明：
参数 描述 thread 一个不透明的、唯一的标识符，用来标识例程返回的新线程。 attr 一个不透明的属性对象，可以被用来设置线程属性。您可以指定线程属性对象，也可以使用默认值 NULL。 start_routine C++ 例程，一旦线程被创建就会执行。 arg 一个可能传递给 start_routine 的参数。它必须通过把引用作为指针强制转换为 void 类型进行传递。如果没有传递参数，则使用 NULL。 一个进程可以创建的最大线程数是依赖于实现的。线程一旦被创建，就是同等的，而且可以创建其他线程。线程之间没有隐含层次或依赖。
终止线程 有下面的例程，我们可以用它来终止一个 POSIX 线程：
1#include &amp;lt;pthread.h&amp;gt; 2pthread_exit (status) 在这里，pthread_exit 用于显式地退出一个线程。通常情况下，pthread_exit() 例程是在线程完成工作后无需继续存在时被调用。
如果main() 是在它所创建的线程之前结束，并通过 pthread_exit() 退出，那么其他线程将继续执行。否则，它们将在 main() 结束时自动被终止。</description></item><item><title>C++ 命名空间</title><link>https://www.shellio.cc/docs/programing/c++/default/33/</link><pubDate>Thu, 06 Oct 2022 22:42:23 +0800</pubDate><guid>https://www.shellio.cc/docs/programing/c++/default/33/</guid><description>C++ 命名空间 假设这样一种情况，当一个班上有两个名叫 Zara 的学生时，为了明确区分它们，我们在使用名字之外，不得不使用一些额外的信息，比如他们的家庭住址，或者他们父母的名字等等。
同样的情况也出现在 C++ 应用程序中。例如，您可能会写一个名为 xyz() 的函数，在另一个可用的库中也存在一个相同的函数 xyz()。这样，编译器就无法判断您所使用的是哪一个 xyz() 函数。
因此，引入了命名空间这个概念，专门用于解决上面的问题，它可作为附加信息来区分不同库中相同名称的函数、类、变量等。使用了命名空间即定义了上下文。本质上，命名空间就是定义了一个范围。
定义命名空间 命名空间的定义使用关键字 namespace，后跟命名空间的名称，如下所示：
1namespace namespace_name { 2 // 代码声明 为了调用带有命名空间的函数或变量，需要在前面加上命名空间的名称，如下所示：
1name::code; // code 可以是变量或函数 让我们来看看命名空间如何为变量或函数等实体定义范围：
1#include &amp;lt;iostream&amp;gt; 2using namespace std; 3// 第一个命名空间 4namespace first_space{ 5 void func(){ 6 cout &amp;lt;&amp;lt; &amp;#34;Inside first_space&amp;#34; &amp;lt;&amp;lt; endl; 7 } 8// 第二个命名空间 9namespace second_space{ 10 void func(){ 11 cout &amp;lt;&amp;lt; &amp;#34;Inside second_space&amp;#34; &amp;lt;&amp;lt; endl; 12 } 13int main () 14 // 调用第一个命名空间中的函数 15 first_space::func(); 16 // 调用第二个命名空间中的函数 17 second_space::func(); 18 return 0; 当上面的代码被编译和执行时，它会产生下列结果：</description></item><item><title>C++ 模板</title><link>https://www.shellio.cc/docs/programing/c++/default/34/</link><pubDate>Thu, 06 Oct 2022 22:42:23 +0800</pubDate><guid>https://www.shellio.cc/docs/programing/c++/default/34/</guid><description>C++ 模板 模板是泛型编程的基础，泛型编程即以一种独立于任何特定类型的方式编写代码。
模板是创建泛型类或函数的蓝图或公式。库容器，比如迭代器和算法，都是泛型编程的例子，它们都使用了模板的概念。
每个容器都有一个单一的定义，比如 向量，我们可以定义许多不同类型的向量，比如 vector 或 vector 。
您可以使用模板来定义函数和类，接下来让我们一起来看看如何使用。
函数模板 模板函数定义的一般形式如下所示：
1template &amp;lt;class type&amp;gt; ret-type func-name(parameter list) 2 // 函数的主体 3} 在这里，type 是函数所使用的数据类型的占位符名称。这个名称可以在函数定义中使用。
下面是函数模板的实例，返回两个数中的最大值：
1#include &amp;lt;iostream&amp;gt; 2#include &amp;lt;string&amp;gt; 3using namespace std; 4template &amp;lt;typename T&amp;gt; 5inline T const&amp;amp; Max (T const&amp;amp; a, T const&amp;amp; b) 6{ 7 return a &amp;lt; b ? b:a; 8} 9int main () 10 int i = 39; 11 int j = 20; 12 cout &amp;lt;&amp;lt; &amp;#34;Max(i, j): &amp;#34; &amp;lt;&amp;lt; Max(i, j) &amp;lt;&amp;lt; endl; 13 double f1 = 13.</description></item><item><title>C++ 预处理器</title><link>https://www.shellio.cc/docs/programing/c++/default/35/</link><pubDate>Thu, 06 Oct 2022 22:42:23 +0800</pubDate><guid>https://www.shellio.cc/docs/programing/c++/default/35/</guid><description>C++ 预处理器 预处理器是一些指令，指示编译器在实际编译之前所需完成的预处理。
所有的预处理器指令都是以井号（#）开头，只有空格字符可以出现在预处理指令之前。预处理指令不是 C++ 语句，所以它们不会以分号（;）结尾。
我们已经看到，之前所有的实例中都有 #include 指令。这个宏用于把头文件包含到源文件中。
C++ 还支持很多预处理指令，比如 #include、#define、#if、#else、#line 等，让我们一起看看这些重要指令。
#define 预处理 #define 预处理指令用于创建符号常量。该符号常量通常称为宏，指令的一般形式是：
1#define macro-name replacement-text 当这一行代码出现在一个文件中时，在该文件中后续出现的所有宏都将会在程序编译之前被替换为 replacement-text。例如：
1#include &amp;lt;iostream&amp;gt; 2using namespace std; 3#define PI 3.14159 4int main () 5 cout &amp;lt;&amp;lt; &amp;#34;Value of PI :&amp;#34; &amp;lt;&amp;lt; PI &amp;lt;&amp;lt; endl; 6 return 0; 现在，让我们测试这段代码，看看预处理的结果。假设源代码文件已经存在，接下来使用 -E 选项进行编译，并把结果重定向到 test.p。现在，如果您查看 test.p 文件，将会看到它已经包含大量的信息，而且在文件底部的值被改为如下：
1$gcc -E test.cpp &amp;gt; test.p 2... 3int main () 4 cout &amp;lt;&amp;lt; &amp;#34;Value of PI :&amp;#34; &amp;lt;&amp;lt; 3.</description></item><item><title>C++ 异常处理</title><link>https://www.shellio.cc/docs/programing/c++/default/31_miss/</link><pubDate>Thu, 06 Oct 2022 22:42:23 +0800</pubDate><guid>https://www.shellio.cc/docs/programing/c++/default/31_miss/</guid><description>C++ 异常处理 异常是程序在执行期间产生的问题。C++ 异常是指在程序运行时发生的特殊情况，比如尝试除以零的操作。
异常提供了一种转移程序控制权的方式。C++ 异常处理涉及到三个关键字：try、catch、throw。
throw: 当问题出现时，程序会抛出一个异常。这是通过使用 throw 关键字来完成的。 catch: 在您想要处理问题的地方，通过异常处理程序捕获异常。catch 关键字用于捕获异常。 try: try 块中的代码标识将被激活的特定异常。它后面通常跟着一个或多个 catch 块。 如果有一个块抛出一个异常，捕获异常的方法会使用 try 和 catch 关键字。try 块中放置可能抛出异常的代码，try 块中的代码被称为保护代码。使用 try/catch 语句的语法如下所示：
1try 2 // 保护代码 3}catch( ExceptionName e1 ) 4 // catch 块 5}catch( ExceptionName e2 ) 6 // catch 块 7}catch( ExceptionName eN ) 8 // catch 块 如果 try 块在不同的情境下会抛出不同的异常，这个时候可以尝试罗列多个 catch 语句，用于捕获不同类型的异常。
抛出异常 您可以使用 throw 语句在代码块中的任何地方抛出异常。throw 语句的操作数可以是任意的表达式，表达式的结果的类型决定了抛出的异常的类型。
以下是尝试除以零时抛出异常的实例：
1double division(int a, int b) 2 if( b == 0 ) 3 { 4 throw &amp;#34;Division by zero condition!</description></item><item><title>C++ 存储类</title><link>https://www.shellio.cc/docs/programing/c++/default/10/</link><pubDate>Thu, 06 Oct 2022 22:42:23 +0800</pubDate><guid>https://www.shellio.cc/docs/programing/c++/default/10/</guid><description>C++ 存储类 存储类定义 C++ 程序中变量/函数的范围（可见性）和生命周期。这些说明符放置在它们所修饰的类型之前。下面列出 C++ 程序中可用的存储类：
auto register static extern mutable auto 存储类 auto 存储类是所有局部变量默认的存储类。
1{ 2 int mount; 3 auto int month; 上面的实例定义了两个带有相同存储类的变量，auto 只能用在函数内，即 auto 只能修饰局部变量。
register 存储类 register 存储类用于定义存储在寄存器中而不是 RAM 中的局部变量。这意味着变量的最大尺寸等于寄存器的大小（通常是一个词），且不能对它应用一元的 ‘&amp;amp;’ 运算符（因为它没有内存位置）。
1{ 2 register int miles; 寄存器只用于需要快速访问的变量，比如计数器。还应注意的是，定义 ‘register’ 并不意味着变量将被存储在寄存器中，它意味着变量可能存储在寄存器中，这取决于硬件和实现的限制。
static 存储类 static 存储类指示编译器在程序的生命周期内保持局部变量的存在，而不需要在每次它进入和离开作用域时进行创建和销毁。因此，使用 static 修饰局部变量可以在函数调用之间保持局部变量的值。
static 修饰符也可以应用于全局变量。当 static 修饰全局变量时，会使变量的作用域限制在声明它的文件内。
在C++ 中，当 static 用在类数据成员上时，会导致仅有一个该成员的副本被类的所有对象共享。
1#include &amp;lt;iostream&amp;gt; 2// 函数声明 3void func(void); 4static int count = 10; /* 全局变量 */ 5int main() 6 while(count--) 7 { 8 func(); 9 } 10 return 0; 11// 函数定义 12void func( void ) 13 static int i = 5; // 局部静态变量 14 i++; 15 std::cout &amp;lt;&amp;lt; &amp;#34;变量 i 为 &amp;#34; &amp;lt;&amp;lt; i ; 16 std::cout &amp;lt;&amp;lt; &amp;#34; , 变量 count 为 &amp;#34; &amp;lt;&amp;lt; count &amp;lt;&amp;lt; std::endl; 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 当上面的代码被编译和执行时，它会产生下列结果：</description></item><item><title>C++ 指针</title><link>https://www.shellio.cc/docs/programing/c++/default/18/</link><pubDate>Thu, 06 Oct 2022 22:42:23 +0800</pubDate><guid>https://www.shellio.cc/docs/programing/c++/default/18/</guid><description>C++ 指针 学习C++ 的指针既简单又有趣。通过指针，可以简化一些 C++ 编程任务的执行，还有一些任务，如动态内存分配，没有指针是无法执行的。所以，想要成为一名优秀的 C++ 程序员，学习指针是很有必要的。
正如您所知道的，每一个变量都有一个内存位置，每一个内存位置都定义了可使用连字号（&amp;amp;）运算符访问的地址，它表示了在内存中的一个地址。请看下面的实例，它将输出定义的变量地址：
1#include &amp;lt;iostream&amp;gt; 2using namespace std; 3int main () 4 int var1; 5 char var2[10]; 6 cout &amp;lt;&amp;lt; &amp;#34;var1 变量的地址： &amp;#34;; 7 cout &amp;lt;&amp;lt; &amp;amp;var1 &amp;lt;&amp;lt; endl; 8 cout &amp;lt;&amp;lt; &amp;#34;var2 变量的地址： &amp;#34;; 9 cout &amp;lt;&amp;lt; &amp;amp;var2 &amp;lt;&amp;lt; endl; 10 return 0; 当上面的代码被编译和执行时，它会产生下列结果：
1var1 变量的地址： 0xbfebd5c0 2var2 变量的地址： 0xbfebd5b6 通过上面的实例，我们了解了什么是内存地址以及如何访问它。接下来让我们看看什么是指针。
什么是指针？ 指针是一个变量，其值为另一个变量的地址，即，内存位置的直接地址。就像其他变量或常量一样，您必须在使用指针存储其他变量地址之前，对其进行声明。指针变量声明的一般形式为：
1type *var-name; 在这里，type 是指针的基类型，它必须是一个有效的 C++ 数据类型，var-name 是指针变量的名称。用来声明指针的星号 * 与乘法中使用的星号是相同的。但是，在这个语句中，星号是用来指定一个变量是指针。以下是有效的指针声明：
1int *ip; /* 一个整型的指针 */ 2double *dp; /* 一个 double 型的指针 */ 3float *fp; /* 一个浮点型的指针 */ 4char *ch /* 一个字符型的指针 */ 所有指针的值的实际数据类型，不管是整型、浮点型、字符型，还是其他的数据类型，都是一样的，都是一个代表内存地址的长的十六进制数。不同数据类型的指针之间唯一的不同是，指针所指向的变量或常量的数据类型不同。</description></item><item><title>C++ 循环</title><link>https://www.shellio.cc/docs/programing/c++/default/12_miss/</link><pubDate>Thu, 06 Oct 2022 22:42:23 +0800</pubDate><guid>https://www.shellio.cc/docs/programing/c++/default/12_miss/</guid><description>C++ 循环 有的时候，可能需要多次执行同一块代码。一般情况下，语句是顺序执行的：函数中的第一个语句先执行，接着是第二个语句，依此类推。
编程语言提供了允许更为复杂的执行路径的多种控制结构。
循环语句允许我们多次执行一个语句或语句组，下面是大多数编程语言中循环语句的一般形式：
##
##
##
##
##
##
##
##
##
循环类型 C++编程语言提供了以下几种循环类型。点击链接查看每个类型的细节。
循环类型 描述 while 循环 当给定条件为真时，重复语句或语句组。它会在执行循环主体之前测试条件。 for 循环 多次执行一个语句序列，简化管理循环变量的代码。 do…while 循环 除了它是在循环主体结尾测试条件外，其他与 while 语句类似。 嵌套循环 您可以在 while、for 或 do..while 循环内使用一个或多个循环。 循环控制语句 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 循环控制语句更改执行的正常序列。当执行离开一个范围时，所有在该范围中创建的自动对象都会被销毁。
C++提供了下列的控制语句。点击链接查看每个语句的细节。
控制语句 描述 break 语句 终止 loop 或 switch 语句，程序流将继续执行紧接着 loop 或 switch 的下一条语句。 continue 语句 引起循环跳过主体的剩余部分，立即重新开始测试条件。 goto 语句 将控制转移到被标记的语句。但是不建议在程序中使用 goto 语句。 无限循环 如果条件永远不为假，则循环将变成无限循环。for 循环在传统意义上可用于实现无限循环。由于构成循环的三个表达式中任何一个都不是必需的，您可以将某些条件表达式留空来构成一个无限循环。
1#include &amp;lt;iostream&amp;gt; 2using namespace std; 3int main () 4 for( ; ; ) 5 { 6 printf(&amp;#34;This loop will run forever.</description></item><item><title>C++ 引用</title><link>https://www.shellio.cc/docs/programing/c++/default/19/</link><pubDate>Thu, 06 Oct 2022 22:42:23 +0800</pubDate><guid>https://www.shellio.cc/docs/programing/c++/default/19/</guid><description>C++ 引用 引用变量是一个别名，也就是说，它是某个已存在变量的另一个名字。一旦把引用初始化为某个变量，就可以使用该引用名称或变量名称来指向变量。
C++ 引用 vs 指针 引用很容易与指针混淆，它们之间有三个主要的不同：
不存在空引用。引用必须连接到一块合法的内存。 一旦引用被初始化为一个对象，就不能被指向到另一个对象。指针可以在任何时候指向到另一个对象。 引用必须在创建时被初始化。指针可以在任何时间被初始化。 C++ 中创建引用 试想变量名称是变量附属在内存位置中的标签，您可以把引用当成是变量附属在内存位置中的第二个标签。因此，您可以通过原始变量名称或引用来访问变量的内容。例如：
1int i = 17; 我们可以为 i 声明引用变量，如下所示：
1int&amp;amp; r = i; 在这些声明中，&amp;amp; 读作引用。因此，第一个声明可以读作 “r 是一个初始化为 i 的整型引用”，第二个声明可以读作 “s 是一个初始化为 d 的 double 型引用”。下面的实例使用了 int 和 double 引用：
1#include &amp;lt;iostream&amp;gt; 2using namespace std; 3int main () 4 // 声明简单的变量 5 int i; 6 double d; 7 // 声明引用变量 8 int&amp;amp; r = i; 9 double&amp;amp; s = d; 10 i = 5; 11 cout &amp;lt;&amp;lt; &amp;#34;Value of i : &amp;#34; &amp;lt;&amp;lt; i &amp;lt;&amp;lt; endl; 12 cout &amp;lt;&amp;lt; &amp;#34;Value of i reference : &amp;#34; &amp;lt;&amp;lt; r &amp;lt;&amp;lt; endl; 13 d = 11.</description></item><item><title>C++ 数组</title><link>https://www.shellio.cc/docs/programing/c++/default/16_miss/</link><pubDate>Thu, 06 Oct 2022 22:42:23 +0800</pubDate><guid>https://www.shellio.cc/docs/programing/c++/default/16_miss/</guid><description>C++ 数组 C++支持数组数据结构，它可以存储一个固定大小的相同类型元素的顺序集合。数组是用来存储一系列数据，但它往往被认为是一系列相同类型的变量。
数组的声明并不是声明一个个单独的变量，比如 number0、number1、…、number99，而是声明一个数组变量，比如 numbers，然后使用 numbers[0]、numbers[1]、…、numbers[99] 来代表一个个单独的变量。数组中的特定元素可以通过索引访问。
所有的数组都是由连续的内存位置组成。最低的地址对应第一个元素，最高的地址对应最后一个元素。
声明数组 在C++ 中要声明一个数组，需要指定元素的类型和元素的数量，如下所示：
1type arrayName [ arraySize ]; 这叫做一维数组。arraySize 必须是一个大于零的整数常量，type 可以是任意有效的 C++ 数据类型。例如，要声明一个类型为 double 的包含 10 个元素的数组 balance，声明语句如下：
1double balance[10]; 现在 balance 是一个可用的数组，可以容纳 10 个类型为 double 的数字。
初始化数组 在C++ 中，您可以逐个初始化数组，也可以使用一个初始化语句，如下所示：
1double balance[5] = {1000.0, 2.0, 3.4, 17.0, 50.0}; 大括号{ } 之间的值的数目不能大于我们在数组声明时在方括号 [ ] 中指定的元素数目。
如果您省略掉了数组的大小，数组的大小则为初始化时元素的个数。因此，如果：
1double balance[] = {1000.0, 2.0, 3.4, 17.0, 50.0}; 您将创建一个数组，它与前一个实例中所创建的数组是完全相同的。下面是一个为数组中某个元素赋值的实例：
1balance[4] = 50.0; 上述的语句把数组中第五个元素的值赋为 50.0。所有的数组都是以 0 作为它们第一个元素的索引，也被称为基索引，数组的最后一个索引是数组的总大小减去 1。以下是上面所讨论的数组的的图形表示：</description></item><item><title>C++ 字符串</title><link>https://www.shellio.cc/docs/programing/c++/default/17/</link><pubDate>Thu, 06 Oct 2022 22:42:23 +0800</pubDate><guid>https://www.shellio.cc/docs/programing/c++/default/17/</guid><description>C++ 字符串 C++提供了以下两种类型的字符串表示形式：
C 风格字符串 C++ 引入的 string 类类型 C 风格字符串 C风格的字符串起源于 C 语言，并在 C++ 中继续得到支持。字符串实际上是使用 null 字符 ” 终止的一维字符数组。因此，一个以 null 结尾的字符串，包含了组成字符串的字符。
下面的声明和初始化创建了一个 “Hello” 字符串。由于在数组的末尾存储了空字符，所以字符数组的大小比单词 “Hello” 的字符数多一个。char greeting[6] = {’H’, ‘e’, ‘l’, ‘l’, ‘o’, ”};
依据数组初始化规则，您可以把上面的语句写成以下语句：
1char greeting[] = &amp;#34;Hello&amp;#34;; 以下是C/C++ 中定义的字符串的内存表示：
其实，您不需要把 null 字符放在字符串常量的末尾。C++ 编译器会在初始化数组时，自动把 ” 放在字符串的末尾。让我们尝试输出上面的字符串
1#include &amp;lt;iostream&amp;gt; 2using namespace std; 3int main () 4 char greeting[6] = {&amp;#39;H&amp;#39;, &amp;#39;e&amp;#39;, &amp;#39;l&amp;#39;, &amp;#39;l&amp;#39;, &amp;#39;o&amp;#39;, &amp;#39;\0&amp;#39;}; 5 cout &amp;lt;&amp;lt; &amp;#34;Greeting message: &amp;#34;; 6 cout &amp;lt;&amp;lt; greeting &amp;lt;&amp;lt; endl; 7 return 0; 8} 当上面的代码被编译和执行时，它会产生下列结果：</description></item><item><title>C++ 判断</title><link>https://www.shellio.cc/docs/programing/c++/default/13_miss/</link><pubDate>Thu, 06 Oct 2022 22:42:23 +0800</pubDate><guid>https://www.shellio.cc/docs/programing/c++/default/13_miss/</guid><description>C++ 判断 判断结构要求程序员指定一个或多个要评估或测试的条件，以及条件为真时要执行的语句（必需的）和条件为假时要执行的语句（可选的）。
下面是大多数编程语言中典型的判断结构的一般形式：
##
##
##
##
##
##
##
##
##
判断语句 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 C++编程语言提供了以下类型的判断语句。点击链接查看每个语句的细节。
语句 描述 if 语句 一个 if 语句 由一个布尔表达式后跟一个或多个语句组成。 if…else 语句 一个 if 语句 后可跟一个可选的 else 语句，else 语句在布尔表达式为假时执行。 嵌套 if 语句 您可以在一个 if 或 else if 语句内使用另一个 if 或 else if 语句。 switch 语句 一个 switch 语句允许测试一个变量等于多个值时的情况。 嵌套 switch 语句 您可以在一个 switch 语句内使用另一个 switch 语句。 ? : 运算符 我们已经在前面的章节中讲解了 条件运算符 ? :，可以用来替代 if…else 语句。它的一般形式如下：</description></item><item><title>C++ 函数</title><link>https://www.shellio.cc/docs/programing/c++/default/14/</link><pubDate>Thu, 06 Oct 2022 22:42:23 +0800</pubDate><guid>https://www.shellio.cc/docs/programing/c++/default/14/</guid><description>C++ 函数 函数是一组一起执行一个任务的语句。每个 C++ 程序都至少有一个函数，即主函数 main() ，所有简单的程序都可以定义其他额外的函数。
您可以把代码划分到不同的函数中。如何划分代码到不同的函数中是由您来决定的，但在逻辑上，划分通常是根据每个函数执行一个特定的任务来进行的。
函数声明告诉编译器函数的名称、返回类型和参数。函数定义提供了函数的实际主体。
C++标准库提供了大量的程序可以调用的内置函数。例如，函数 strcat() 用来连接两个字符串，函数 memcpy() 用来复制内存到另一个位置。
函数还有很多叫法，比如方法、子例程或程序，等等。
定义函数 C++中的函数定义的一般形式如下：
1return_type function_name( parameter list ) 2 body of the function 在C++ 中，函数由一个函数头和一个函数主体组成。下面列出一个函数的所有组成部分：
**返回类型：**一个函数可以返回一个值。return_type 是函数返回的值的数据类型。有些函数执行所需的操作而不返回值，在这种情况下，return_type 是关键字 void。 **函数名称：**这是函数的实际名称。函数名和参数列表一起构成了函数签名。 **参数：**参数就像是占位符。当函数被调用时，您向参数传递一个值，这个值被称为实际参数。参数列表包括函数参数的类型、顺序、数量。参数是可选的，也就是说，函数可能不包含参数。 **函数主体：**函数主体包含一组定义函数执行任务的语句。 实例 以下是max() 函数的源代码。该函数有两个参数 num1 和 num2，会返回这两个数中较大的那个数：
1// 函数返回两个数中较大的那个数 2int max(int num1, int num2) 3 // 局部变量声明 4 int result; 5 if (num1 &amp;gt; num2) 6 result = num1; 7 else 8 result = num2; 9 return result; 函数声明 函数声明会告诉编译器函数名称及如何调用函数。函数的实际主体可以单独定义。</description></item><item><title>C++ 数字</title><link>https://www.shellio.cc/docs/programing/c++/default/15/</link><pubDate>Thu, 06 Oct 2022 22:42:23 +0800</pubDate><guid>https://www.shellio.cc/docs/programing/c++/default/15/</guid><description>C++ 数字 通常，当我们需要用到数字时，我们会使用原始的数据类型，如 int、short、long、float 和 double 等等。这些用于数字的数据类型，其可能的值和数值范围，我们已经在 C++ 数据类型一章中讨论过。
C++ 定义数字 我们已经在之前章节的各种实例中定义过数字。下面是一个 C++ 中定义各种类型数字的综合实例：
1#include &amp;lt;iostream&amp;gt; 2using namespace std; 3int main () 4 // 数字定义 5 short s; 6 int i; 7 long l; 8 float f; 9 double d; 10 // 数字赋值 11 s = 10; 12 i = 1000; 13 l = 1000000; 14 f = 230.47; 15 d = 30949.374; 16 // 数字输出 17 cout &amp;lt;&amp;lt; &amp;#34;short s :&amp;#34; &amp;lt;&amp;lt; s &amp;lt;&amp;lt; endl; 18 cout &amp;lt;&amp;lt; &amp;#34;int i :&amp;#34; &amp;lt;&amp;lt; i &amp;lt;&amp;lt; endl; 19 cout &amp;lt;&amp;lt; &amp;#34;long l :&amp;#34; &amp;lt;&amp;lt; l &amp;lt;&amp;lt; endl; 20 cout &amp;lt;&amp;lt; &amp;#34;float f :&amp;#34; &amp;lt;&amp;lt; f &amp;lt;&amp;lt; endl; 21 cout &amp;lt;&amp;lt; &amp;#34;double d :&amp;#34; &amp;lt;&amp;lt; d &amp;lt;&amp;lt; endl; 22 return 0; 当上面的代码被编译和执行时，它会产生下列结果：</description></item><item><title>C++ 运算符</title><link>https://www.shellio.cc/docs/programing/c++/default/11/</link><pubDate>Thu, 06 Oct 2022 22:42:23 +0800</pubDate><guid>https://www.shellio.cc/docs/programing/c++/default/11/</guid><description>C++ 运算符 运算符是一种告诉编译器执行特定的数学或逻辑操作的符号。C++ 内置了丰富的运算符，并提供了以下类型的运算符：
算术运算符 关系运算符 逻辑运算符 位运算符 赋值运算符 杂项运算符 本章将逐一介绍算术运算符、关系运算符、逻辑运算符、位运算符、赋值运算符和其他运算符。
算术运算符 下表显示了 C++ 支持的所有算术运算符。
假设变量 A 的值为 10，变量 B 的值为 20，则：
运算符 描述 实例 + 把两个操作数相加 A + B 将得到 30 – 从第一个操作数中减去第二个操作数 A – B 将得到 -10 * 把两个操作数相乘 A * B 将得到 200 / 分子除以分母 B / A 将得到 2 % 取模运算符，整除后的余数 B % A 将得到 0 ++ 自增运算符，整数值增加 1 A++ 将得到 11 — 自减运算符，整数值减少 1 A– 将得到 9 实例 请看下面的实例，了解 C++ 中所有可用的算术运算符。</description></item><item><title>C++ 注释</title><link>https://www.shellio.cc/docs/programing/c++/default/4/</link><pubDate>Thu, 06 Oct 2022 22:42:23 +0800</pubDate><guid>https://www.shellio.cc/docs/programing/c++/default/4/</guid><description>C++ 注释 程序的注释是解释性语句，您可以在 C++ 代码中包含注释，这将提高源代码的可读性。所有的编程语言都允许某种形式的注释。
C++支持单行注释和多行注释。注释中的所有字符会被 C++ 编译器忽略。
C++注释以 /* 开始，以 */ 终止。例如：
1/* 这是注释 */ 2/* C++ 注释也可以 3 * 跨行 4 */ 注释也能以 // 开始，直到行末为止。例如：
因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 1#include 2using namespace std; 3main() 4 cout &amp;lt;&amp;lt; &amp;#34;Hello World&amp;#34;; // 输出 Hello World return 0; 5} 当上面的代码被编译时，编译器会忽略 // prints Hello World，最后会产生以下结果：
1Hello World 在/* 和 */ 注释内部，// 字符没有特殊的含义。在 // 注释内，/* 和 */ 字符也没有特殊的含义。因此，您可以在一种注释内嵌套另一种注释。例如：
1/* 用于输出 Hello World 的注释 2cout &amp;lt;&amp;lt; &amp;#34;Hello World&amp;#34;; // 输出 Hello World */</description></item><item><title>C++ 标准库</title><link>https://www.shellio.cc/docs/programing/c++/default/40/</link><pubDate>Thu, 06 Oct 2022 22:42:23 +0800</pubDate><guid>https://www.shellio.cc/docs/programing/c++/default/40/</guid><description>C++ 标准库 C++标准库可以分为两部分：
标准函数库： 这个库是由通用的、独立的、不属于任何类的函数组成的。函数库继承自 C 语言。 面向对象类库： 这个库是类及其相关函数的集合。 C++标准库包含了所有的 C 标准库，为了支持类型安全，做了一定的添加和修改。
标准函数库 标准函数库分为以下几类：
输入/输出 I/O 字符串和字符处理 数学 时间、日期和本地化 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 动态分配 其他 宽字符函数 面向对象类库 标准的C++ 面向对象类库定义了大量支持一些常见操作的类，比如输入/输出 I/O、字符串处理、数值处理。面向对象类库包含以下内容：
标准的 C++ I/O 类 String 类 数值类 STL 容器类 STL 算法 STL 函数对象 STL 迭代器 STL 分配器 本地化库 异常处理类 杂项支持库</description></item><item><title>C++ 简介</title><link>https://www.shellio.cc/docs/programing/c++/default/42/</link><pubDate>Thu, 06 Oct 2022 22:42:23 +0800</pubDate><guid>https://www.shellio.cc/docs/programing/c++/default/42/</guid><description>在面试C++方面的工作时，经常会遇到各种面试题，这对应聘人员的知识掌握能力要求较高。本文将为大家带来的就是20道必须掌握的C++面试题，不要错过哦！
想要快速轻松掌握C++知识，请点击C++微课边学习边实践
问1：请用简单的语言告诉我C++ 是什么？
答：C++是在C语言的基础上开发的一种面向对象编程语言，应用广泛。C++支持多种编程范式 －－面向对象编程、泛型编程和过程化编程。 其编程领域众广，常用于系统开发，引擎开发等应用领域，是最受广大程序员受用的最强大编程语言之一,支持类：类、封装、重载等特性!
问2：C和C++的区别？
答：c++在c的基础上增添类，C是一个结构化语言，它的重点在于算法和数据结构。C程序的设计首要考虑的是如何通过一个过程，对输入（或环境条件）进行运算处理得到输出（或实现过程（事务）控制），而对于C++，首要考虑的是如何构造一个对象模型，让这个模型能够契合与之对应的问题域，这样就可以通过获取对象的状态信息得到输出或实现过程（事务）控制。
问3：什么是面向对象（OOP）？
答：面向对象是一种对现实世界理解和抽象的方法、思想，通过将需求要素转化为对象进行问题处理的一种思想。
问4：什么是多态？
答：多态是指相同的操作或函数、过程可作用于多种类型的对象上并获得不同的结果。不同的对象，收到同一消息可以产生不同的结果，这种现象称为多态。
问5：设计模式懂嘛，简单举个例子？
答：
设计模式（Design pattern）是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。
比如单例模式，保证一个类仅有一个实例，并提供一个访问它的全局访问点。
适用于：当类只能有一个实例而且客户可以从一个众所周知的访问点访问它时；当这个唯一实例应该是通过子类化可扩展的，并且客户应该无需更改代码就能使用一个扩展的实例时。
比如工厂模式，定义一个用于创建对象的接口，让子类决定实例化哪一个类。Factory Method 使一个类的实例化延迟到其子类。
适用于：当一个类不知道它所必须创建的对象的类的时候；当一个类希望由它的子类来指定它所创建的对象的时候；当类将创建对象的职责委托给多个帮助子类中的某一个，并且你希望将哪一个帮助子类是代理者这一信息局部化的时候。
问6：STL库用过吗？常见的STL容器有哪些？算法用过哪几个？
答：
STL包括两部分内容：容器和算法。（重要的还有融合这二者的迭代器）
容器，即存放数据的地方。比如array等。
在STL中，容器分为两类：序列式容器和关联式容器。
序列式容器，其中的元素不一定有序，但都可以被排序。如：vector、list、deque、stack、queue、heap、priority_queue、slist；
关联式容器，内部结构基本上是一颗平衡二叉树。所谓关联，指每个元素都有一个键值和一个实值，元素按照一定的规则存放。如：RB-tree、set、map、multiset、multimap、hashtable、hash_set、hash_map、hash_multiset、hash_multimap。
下面各选取一个作为说明。
vector：它是一个动态分配存储空间的容器。区别于c++中的array，array分配的空间是静态的，分配之后不能被改变，而vector会自动重分配（扩展）空间。
set：其内部元素会根据元素的键值自动被排序。区别于map，它的键值就是实值，而map可以同时拥有不同的键值和实值。
算法，如排序，复制……以及个容器特定的算法。这点不用过多介绍，主要看下面迭代器的内容。
迭代器是STL的精髓，我们这样描述它：迭代器提供了一种方法，使它能够按照顺序访问某个容器所含的各个元素，但无需暴露该容器的内部结构。它将容器和算法分开，好让这二者独立设计。
问7：数据结构会吗？项目开发过程中主要用到那些？
答：数据结构中主要会用到数组，链表，树（较少），也会用到栈和队列的思想。
问8：const知道吗？解释其作用。
答：
1、 const修饰类的成员变量，表示成员常量，不能被修改；
2、 const修饰函数承诺在本函数内部不会修改类内的数据成员，不会调用其它非const成员函数；
3、 如果const构成函数重载，const对象只能调用const函数，非const对象优先调用非const函数；
4、 const函数只能调用const函数非const函数可以调用const函数；
5、 类体外定义的const成员函数，在定义和声明处都需要const修饰符；
问9：类的static变量在什么时候初始化？函数的static变量在什么时候初始化？
答：类的静态成员变量在类实例化之前就已经存在了，并且分配了内存。函数的static变量在执行此函数时进行初始化。
问10：堆和栈的区别？堆和栈的生命周期？
答：
一、堆栈空间分配区别：
1、 栈（操作系统）：由操作系统自动分配释放，存放函数的参数值，局部变量的值等其操作方式类似于数据结构中的栈；
2、 堆（操作系统）：一般由程序员分配释放，若程序员不释放，程序结束时可能由OS回收，分配方式倒是类似于链表；
二、堆栈缓存方式区别：
1、 栈使用的是一级缓存，他们通常都是被调用时处于存储空间中，调用完毕立即释放；
2、 堆是存放在二级缓存中，生命周期由虚拟机的垃圾回收算法来决定（并不是一旦成为孤儿对象就能被回收）所以调用这些对象的速度要相对来得低一些；
三、堆栈数据结构区别：
堆（数据结构）：堆可以被看成是一棵树，如：堆排序；
栈（数据结构）：一种先进后出的数据结构。
问11：C和C++的区别？
答：
C++在C的基础上增添类
C是一个结构化语言，它的重点在于算法和数据结构。</description></item><item><title>C++ 简介</title><link>https://www.shellio.cc/docs/programing/c++/default/43/</link><pubDate>Thu, 06 Oct 2022 22:42:23 +0800</pubDate><guid>https://www.shellio.cc/docs/programing/c++/default/43/</guid><description>map是C++中的一个标准容器，她提供了很好一对一的关系，在一些程序中建立一个map可以起到事半功倍的效果，本文为大家总结了map的一些基本简单的操作！
1、map最基本的构造函数；
map mapstring; map mapint;
map&amp;lt;sring, char&amp;gt;mapstring; map&amp;lt; char ,string&amp;gt;mapchar;
map mapchar; map mapint；
2、map添加数据；
1 map&amp;lt;int ,string&amp;gt; maplive; 2 1.maplive.insert(pair&amp;lt;int,string&amp;gt;(102,&amp;#34;aclive&amp;#34;)); 3 2.maplive.insert(map&amp;lt;int,string&amp;gt;::value_type(321,&amp;#34;hai&amp;#34;)); 4 3, maplive[112]=&amp;#34;April&amp;#34;;//map中最简单最常用的插入添加！ 3、map中元素的查找：
find()函数返回一个迭代器指向键值为key的元素，如果没找到就返回指向map尾部的迭代器。
1 map&amp;lt;int ,string &amp;gt;::iterator l_it;; 2 l_it=maplive.find(112); 3 if(l_it==maplive.end()) 4 cout&amp;lt;&amp;lt;&amp;#34;we do not find 112&amp;#34;&amp;lt;&amp;lt;endl; 5 else cout&amp;lt;&amp;lt;&amp;#34;wo find 112&amp;#34;&amp;lt;&amp;lt;endl; 4、map中元素的删除：
如果删除112；
1 map&amp;lt;int ,string &amp;gt;::iterator l_it;; 2 l_it=maplive.find(112); 3 if(l_it==maplive.end()) 4 cout&amp;lt;&amp;lt;&amp;#34;we do not find 112&amp;#34;&amp;lt;&amp;lt;endl; 5 else maplive.erase(l_it); //delete 112; 5、map中 swap的用法：</description></item><item><title>C++ 简介</title><link>https://www.shellio.cc/docs/programing/c++/default/44/</link><pubDate>Thu, 06 Oct 2022 22:42:23 +0800</pubDate><guid>https://www.shellio.cc/docs/programing/c++/default/44/</guid><description>在c++中，vector是一个十分有用的容器。它能够像容器一样存放各种类型的对象，简单地说，vector是一个能够存放任意类型的动态数组，能够增加和压缩数据。
使用vector注意事项：
1、 如果你要表示的向量长度较长（需要为向量内部保存很多数），容易导致内存泄漏，而且效率会很低；
2、 Vector作为函数的参数或者返回值时，需要注意它的写法：；
1double Distance(vector&amp;lt;int&amp;gt;&amp;amp;a, vector&amp;lt;int&amp;gt;&amp;amp;b) 其中的“&amp;amp;”绝对不能少！！！
实例：
vector test;//建立一个vector，int为数组元素的数据类型，test为动态数组名
简单的使用方法如下：
1vector&amp;lt;int&amp;gt;test;//建立一个vector 2test.push_back(1); 3test.push_back(2);//把1和2压入vector，这样test[0]就是1,test[1]就是2 自己见到的实例：
1vector&amp;lt;vector&amp;lt;Point2f&amp;gt; &amp;gt; points; //定义一个二维数组 2points[0].size(); //指第一行的列数 1、基本操作
(1)头文件#include .
(2)创建vector对象，vector vec;
(3)尾部插入数字：vec.push_back(a);
(4)使用下标访问元素，cout&amp;laquo;vec[0]&amp;laquo;endl;记住下标是从0开始的。
(5)使用迭代器访问元素.
1vector&amp;lt;int&amp;gt;::iterator it; 2for(it=vec.begin();it!=vec.end();it++) 3 cout&amp;lt;&amp;lt;*it&amp;lt;&amp;lt;endl; (6)插入元素：vec.insert(vec.begin()+i,a);在第i+1个元素前面插入a;
(7)删除元素：vec.erase(vec.begin()+2);删除第3个元素
vec.erase(vec.begin()+i,vec.end()+j);删除区间[i,j-1];区间从0开始
(8)向量大小:vec.size();
(9)清空:vec.clear();
特别提示：这里有begin()与end()函数、front()与back()的差别
2、重要说明
vector的元素不仅仅可以是int,double,string,还可以是结构体，但是要注意：结构体要定义为全局的，否则会出错。
1#include&amp;lt;stdio.h&amp;gt; 2#include&amp;lt;algorithm&amp;gt; 3#include&amp;lt;vector&amp;gt; 4#include&amp;lt;iostream&amp;gt; 5using namespace std; 6typedef struct rect 7{ 8 int id; 9 int length; 10 int width; 11　//对于向量元素是结构体的，可在结构体内部定义比较函数，下面按照id,length,width升序排序。 12　bool operator&amp;lt; (const rect &amp;amp;a) const 13 { 14 if(id!</description></item><item><title>C++ 简介</title><link>https://www.shellio.cc/docs/programing/c++/default/45/</link><pubDate>Thu, 06 Oct 2022 22:42:23 +0800</pubDate><guid>https://www.shellio.cc/docs/programing/c++/default/45/</guid><description>本文将为大家带来的是几款简单实用的C++编译器（非IDE），希望大家喜欢。
GCC（GNU Compiler Collection）
官方网站: https://gcc.gnu.org/ GCC有Windows移植版本，比较出名的就是MinGW和TDM-GCC
GNU编译器套件（GNU Compiler Collection）包括C、C++、Objective-C、Fortran、Java、Ada和Go语言的前端，也包括了这些语言的库（如libstdc++、libgcj等等）。GCC的初衷是为GNU操作系统专门编写的一款编译器。GNU系统是彻底的自由软件。此处，“自由”的含义是它尊重用户的自由。
llvm+Clang
LLVM官方网站：http://llvm.org/
Clang官方网站：http://clang.llvm.org/get_started.html
LLVM是构架编译器(compiler)的框架系统，以C++编写而成，用于优化以任意程序语言编写的程序的编译时间(compile-time)、链接时间(link-time)、运行时间(run-time)以及空闲时间(idle-time)，对开发者保持开放，并兼容已有脚本。LLVM计划启动于2000年，最初由University of Illinois at Urbana-Champaign的Chris Lattner主持开展。2006年Chris Lattner加盟Apple Inc.并致力于LLVM在Apple开发体系中的应用。Apple也是LLVM计划的主要资助者.
LowLevel Virtual Machine (LLVM) 是一个开源的编译器架构，它已经被成功应用到多个应用领域。Clang ( 发音为 /kl??/) 是 LLVM 的一个编译器前端，它目前支持 C, C++, Objective-C 以及 Objective-C++ 等编程语言。Clang 对源程序进行词法分析和语义分析，并将分析结果转换为 Abstract Syntax Tree ( 抽象语法树 ) ，最后使用 LLVM 作为后端代码的生成器。
Clang 的开发目标是提供一个可以替代 GCC 的前端编译器。与 GCC 相比，Clang 是一个重新设计的编译器前端，具有一系列优点，例如模块化，代码简单易懂，占用内存小以及容易扩展和重用等。由于 Clang 在设计上的优异性，使得 Clang 非常适合用于设计源代码级别的分析和转化工具。Clang 也已经被应用到一些重要的开发领域，如 Static Analysis 是一个基于 Clang 的静态代码分析工具。
Watcom C/C++
官方网站：http://www.openwatcom.org/index.php/Download
在DOS开发环境中，Watcom C/C++ 编译器 以编译后的exe运行高速而著称，且首个支持Intel 80386 “保护模式”的编译器。于90年代中期，大批的雄心技术游戏(例如 Doom、Descent、Duke Nukem 3D 都以 Watcom C 写成）</description></item><item><title>C++ 有用的资源</title><link>https://www.shellio.cc/docs/programing/c++/default/41/</link><pubDate>Thu, 06 Oct 2022 22:42:23 +0800</pubDate><guid>https://www.shellio.cc/docs/programing/c++/default/41/</guid><description>C++ 有用的资源 以下资源包含了 C++ 有关的网站、书籍和文章。请使用它们来进一步学习 C++ 的知识。
C++ 有用的网站 C++ Programming Language Tutorials − C++ 编程语言教程。 C++ Programming − 这本书涵盖了 C++ 语言编程、软件交互设计、C++ 语言的现实生活应用。 C++ FAQ − C++ 常见问题 Free Country − Free Country 提供了免费的 C++ 源代码和 C++ 库，这些源代码和库涵盖了压缩、存档、游戏编程、标准模板库和 GUI 编程等 C++ 编程领域。 C and C++ Users Group − C 和 C++ 的用户团体提供了免费的涵盖各种编程领域 C++ 项目的源代码，包括 AI、动画、编译器、数据库、调试、加密、游戏、图形、GUI、语言工具、系统编程等。 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 C++ 有用的书籍</description></item><item><title>C++ 数据类型</title><link>https://www.shellio.cc/docs/programing/c++/default/5/</link><pubDate>Thu, 06 Oct 2022 22:42:23 +0800</pubDate><guid>https://www.shellio.cc/docs/programing/c++/default/5/</guid><description>C++ 数据类型 使用编程语言进行编程时，需要用到各种变量来存储各种信息。变量保留的是它所存储的值的内存位置。这意味着，当您创建一个变量时，就会在内存中保留一些空间。
您可能需要存储各种数据类型（比如字符型、宽字符型、整型、浮点型、双浮点型、布尔型等）的信息，操作系统会根据变量的数据类型，来分配内存和决定在保留内存中存储什么。
基本的内置类型 C++为程序员提供了种类丰富的内置数据类型和用户自定义的数据类型。下表列出了七种基本的 C++ 数据类型：
类型 关键字 布尔型 bool 字符型 char 整型 int 浮点型 float 双浮点型 double 无类型 void 宽字符型 wchar_t 一些基本类型可以使用一个或多个类型修饰符进行修饰：
signed unsigned short long 下表显示了各种变量类型在内存中存储值时需要占用的内存，以及该类型的变量所能存储的最大值和最小值。
**注意：**不同系统会有所差异。
类型 位 范围 char 1 个字节 -128 到 127 或者 0 到 255 unsigned char 1 个字节 0 到 255 signed char 1 个字节 -128 到 127 int 4 个字节 -2147483648 到 2147483647 unsigned int 4 个字节 0 到 4294967295 signed int 4 个字节 -2147483648 到 2147483647 short int 2 个字节 -32768 到 32767 unsigned short int 2 个字节 0 到 65,535 signed short int 2 个字节 -32768 到 32767 long int 8 个字节 -9,223,372,036,854,775,808 到 9,223,372,036,854,775,807 signed long int 8 个字节 -9,223,372,036,854,775,808 到 9,223,372,036,854,775,807 unsigned long int 8 个字节 0 to 18,446,744,073,709,551,615 float 4 个字节 +/- 3.</description></item><item><title>C++ 简介</title><link>https://www.shellio.cc/docs/programing/c++/default/1/</link><pubDate>Thu, 06 Oct 2022 22:42:23 +0800</pubDate><guid>https://www.shellio.cc/docs/programing/c++/default/1/</guid><description>C++ 简介 C++是一种静态类型的、编译式的、通用的、大小写敏感的、不规则的编程语言，支持过程化编程、面向对象编程和泛型编程。
C++被认为是一种中级语言，它综合了高级语言和低级语言的特点。
C++是由 Bjarne Stroustrup 于 1979 年在新泽西州美利山贝尔实验室开始设计开发的。C++ 进一步扩充和完善了 C 语言，最初命名为带类的C，后来在 1983 年更名为 C++。
C++是 C 的一个超集，事实上，任何合法的 C 程序都是合法的 C++ 程序。
**注意：**使用静态类型的编程语言是在编译时执行类型检查，而不是在运行时执行类型检查。
面向对象程序设计 C++完全支持面向对象的程序设计，包括面向对象开发的四大特性：
封装 数据隐藏 继承 多态 标准库 标准的C++ 由三个重要部分组成：
核心语言，提供了所有构件块，包括变量、数据类型和常量，等等。 C++ 标准库，提供了大量的函数，用于操作文件、字符串等。 标准模板库（STL），提供了大量的方法，用于操作数据结构等。 ANSI 标准 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 ANSI 标准是为了确保 C++ 的便携性 —— 您所编写的代码在 Mac、UNIX、Windows、Alpha 计算机上都能通过编译。
由于ANSI 标准已稳定使用了很长的时间，所有主要的 C++ 编译器的制造商都支持 ANSI 标准。
学习 C++ 学习C++，关键是要理解概念，而不应过于深究语言的技术细节。
学习程序设计语言的目的是为了成为一个更好的程序员，也就是说，是为了能更有效率地设计和实现新系统，以及维护旧系统。
C++支持多种编程风格。您可以使用 Fortran、C、Smalltalk 等任意一种语言的编程风格来编写代码。每种风格都能有效地保证运行时间效率和空间效率。
C++ 的使用 基本上每个应用程序领域的程序员都有使用 C++。
C++通常用于编写设备驱动程序和其他要求实时性的直接操作硬件的软件。
C++广泛用于教学和研究。
任何一个使用苹果电脑或 Windows PC 机的用户都在间接地使用 C++，因为这些系统的主要用户接口是使用 C++ 编写的。</description></item></channel></rss>