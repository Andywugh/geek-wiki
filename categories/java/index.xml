<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Java on 程序员安仔</title><link>https://www.hotmindshare.com/categories/java/</link><description>Recent content in Java on 程序员安仔</description><generator>Hugo -- gohugo.io</generator><language>zh-hans</language><copyright>粤ICP备2023148789号</copyright><lastBuildDate>Sat, 21 Oct 2023 12:22:54 +0800</lastBuildDate><atom:link href="https://www.hotmindshare.com/categories/java/index.xml" rel="self" type="application/rss+xml"/><item><title>Shiro InI 配置</title><link>https://www.hotmindshare.com/docs/java/shiro/5/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.hotmindshare.com/docs/java/shiro/5/</guid><description>INI 配置 之前章节我们已经接触过一些 INI 配置规则了，如果大家使用过如 Spring 之类的 IoC/DI 容器的话，Shiro 提供的 INI 配置也是非常类似的，即可以理解为是一个 IoC/DI 容器，但是区别在于它从一个根对象 securityManager 开始。
根对象 SecurityManager 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 从之前的 Shiro 架构图可以看出，Shiro 是从根对象 SecurityManager 进行身份验证和授权的；也就是所有操作都是自它开始的，这个对象是线程安全且真个应用只需要一个即可，因此 Shiro 提供了 SecurityUtils 让我们绑定它为全局的，方便后续操作。
因为Shiro 的类都是 POJO 的，因此都很容易放到任何 IoC 容器管理。但是和一般的 IoC 容器的区别在于，Shiro 从根对象 securityManager 开始导航；Shiro 支持的依赖注入：public 空参构造器对象的创建、setter 依赖注入。
1、 纯Java代码写法（com.github.zhangkaitao.shiro.chapter4.NonConfigurationCreateTest）：；
1DefaultSecurityManager securityManager = new DefaultSecurityManager(); 2//设置authenticator 3ModularRealmAuthenticator authenticator = new ModularRealmAuthenticator(); 4authenticator.setAuthenticationStrategy(new AtLeastOneSuccessfulStrategy()); 5securityManager.setAuthenticator(authenticator); 6//设置authorizer 7ModularRealmAuthorizer authorizer = new ModularRealmAuthorizer(); 8authorizer.setPermissionResolver(new WildcardPermissionResolver()); 9securityManager.setAuthorizer(authorizer); 10//设置Realm 11DruidDataSource ds = new DruidDataSource(); 12ds.</description></item><item><title>Shiro JSP 标签</title><link>https://www.hotmindshare.com/docs/java/shiro/10/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.hotmindshare.com/docs/java/shiro/10/</guid><description>JSP 标签 Shiro 提供了 JSTL 标签用于在 JSP/GSP 页面进行权限控制，如根据登录用户显示相应的页面按钮。
导入标签库
&amp;lt;%@taglib prefix=&amp;quot;shiro&amp;quot; uri=&amp;quot;http://shiro.apache.org/tags&amp;quot; %&amp;gt;
标签库定义在 shiro-web.jar 包下的 META-INF/shiro.tld 中定义。
guest 标签
1&amp;lt;shiro:guest&amp;gt; 2欢迎游客访问，&amp;lt;a href=&amp;#34;${pageContext.request.contextPath}/login.jsp&amp;#34;&amp;gt;登录&amp;lt;/a&amp;gt; 3&amp;lt;/shiro:guest&amp;gt; 用户没有身份验证时显示相应信息，即游客访问信息。
user 标签
1&amp;lt;shiro:guest&amp;gt; 2欢迎游客访问，&amp;lt;a href=&amp;#34;${pageContext.request.contextPath}/login.jsp&amp;#34;&amp;gt;登录&amp;lt;/a&amp;gt; 3&amp;lt;/shiro:guest&amp;gt; 用户已经身份验证 / 记住我登录后显示相应的信息。
authenticated 标签
1&amp;lt;shiro:authenticated&amp;gt; 2 用户[&amp;lt;shiro:principal/&amp;gt;]已身份验证通过 3&amp;lt;/shiro:authenticated&amp;gt; 用户已经身份验证通过，即 Subject.login 登录成功，不是记住我登录的。
notAuthenticated 标签
1&amp;lt;shiro:notAuthenticated&amp;gt; 2 未身份验证（包括记住我） 3&amp;lt;/shiro:notAuthenticated&amp;gt; 用户已经身份验证通过，即没有调用 Subject.login 进行登录，包括记住我自动登录的也属于未进行身份验证。
principal 标签
&amp;lt;shiro: principal/&amp;gt;
显示用户身份信息，默认调用 Subject.getPrincipal() 获取，即 Primary Principal。
&amp;lt;shiro:principal type=&amp;quot;java.lang.String&amp;quot;/&amp;gt;
相当于Subject.getPrincipals().oneByType(String.class)。
&amp;lt;shiro:principal type=&amp;quot;java.lang.String&amp;quot;/&amp;gt;
相当于Subject.getPrincipals().oneByType(String.class)。
&amp;lt;shiro:principal property=&amp;quot;username&amp;quot;/&amp;gt;
相当于((User)Subject.getPrincipals()).getUsername()。</description></item><item><title>Shiro OAuth2</title><link>https://www.hotmindshare.com/docs/java/shiro/18/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.hotmindshare.com/docs/java/shiro/18/</guid><description>OAuth2 集成 目前很多开放平台如新浪微博开放平台都在使用提供开放 API 接口供开发者使用，随之带来了第三方应用要到开放平台进行授权的问题，OAuth 就是干这个的，OAuth2 是 OAuth 协议的下一个版本，相比 OAuth1，OAuth2 整个授权流程更简单安全了，但不兼容 OAuth1，具体可以到 OAuth2 官网 http://oauth.net/2/ 查看，OAuth2 协议规范可以参考 http://tools.ietf.org/html/rfc6749。目前有好多参考实现供选择，可以到其官网查看下载。
本文使用 [Apache Oltu]()，其之前的名字叫 Apache Amber ，是 Java 版的参考实现。使用文档可参考 https://cwiki.apache.org/confluence/display/OLTU/Documentation。
OAuth 角色 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 资源拥有者（resource owner）：能授权访问受保护资源的一个实体，可以是一个人，那我们称之为最终用户；如新浪微博用户 zhangsan；
资源服务器（resource server）：存储受保护资源，客户端通过 access token 请求资源，资源服务器响应受保护资源给客户端；存储着用户 zhangsan 的微博等信息。
授权服务器（authorization server）：成功验证资源拥有者并获取授权之后，授权服务器颁发授权令牌（Access Token）给客户端。
客户端（client）：如新浪微博客户端 weico、微格等第三方应用，也可以是它自己的官方应用；其本身不存储资源，而是资源拥有者授权通过后，使用它的授权（授权令牌）访问受保护资源，然后客户端把相应的数据展示出来 / 提交到服务器。“客户端” 术语不代表任何特定实现（如应用运行在一台服务器、桌面、手机或其他设备）。
1、 客户端从资源拥有者那请求授权授权请求可以直接发给资源拥有者，或间接的通过授权服务器这种中介，后者更可取；
2、 客户端收到一个授权许可，代表资源服务器提供的授权；
3、 客户端使用它自己的私有证书及授权许可到授权服务器验证；
4、 如果验证成功，则下发一个访问令牌；
5、 客户端使用访问令牌向资源服务器请求受保护资源；
6、 资源服务器会验证访问令牌的有效性，如果成功则下发受保护资源；
更多流程的解释请参考 OAuth2 的协议规范 http://tools.ietf.org/html/rfc6749。
服务器端 本文把授权服务器和资源服务器整合在一起实现。
POM 依赖 此处我们使用 apache oltu oauth2 服务端实现，需要引入 authzserver（授权服务器依赖）和 resourceserver（资源服务器依赖）。</description></item><item><title>Shiro Realm</title><link>https://www.hotmindshare.com/docs/java/shiro/7/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.hotmindshare.com/docs/java/shiro/7/</guid><description>Realm 及相关对象 Realm 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 【Realm】及【Authorizer】部分都已经详细介绍过 Realm 了，接下来再来看一下一般真实环境下的 Realm 如何实现。
1、定义实体及关系
即用户– 角色之间是多对多关系，角色 – 权限之间是多对多关系；且用户和权限之间通过角色建立关系；在系统中验证时通过权限验证，角色只是权限集合，即所谓的显示角色；其实权限应该对应到资源（如菜单、URL、页面按钮、Java 方法等）中，即应该将权限字符串存储到资源实体中，但是目前为了简单化，直接提取一个权限表，【综合示例】部分会使用完整的表结构。
用户实体包括：编号 (id)、用户名 (username)、密码 (password)、盐 (salt)、是否锁定 (locked)；是否锁定用于封禁用户使用，其实最好使用 Enum 字段存储，可以实现更复杂的用户状态实现。 角色实体包括：、编号 (id)、角色标识符（role）、描述（description）、是否可用（available）；其中角色标识符用于在程序中进行隐式角色判断的，描述用于以后再前台界面显示的、是否可用表示角色当前是否激活。 权限实体包括：编号（id）、权限标识符（permission）、描述（description）、是否可用（available）；含义和角色实体类似不再阐述。
另外还有两个关系实体：用户 – 角色实体（用户编号、角色编号，且组合为复合主键）；角色 – 权限实体（角色编号、权限编号，且组合为复合主键）。
sql及实体请参考源代码中的 sql\shiro.sql 和 com.github.zhangkaitao.shiro.chapter6.entity 对应的实体。
2、环境准备
为了方便数据库操作，使用了 “org.springframework: spring-jdbc: 4.0.0.RELEASE” 依赖，虽然是 spring4 版本的，但使用上和 spring3 无区别。其他依赖请参考源码的 pom.xml。
3、定义 Service 及 Dao
为了实现的简单性，只实现必须的功能，其他的可以自己实现即可。
PermissionService
1public interface PermissionService { 2 public Permission createPermission(Permission permission); 3 public void deletePermission(Long permissionId); 实现基本的创建 / 删除权限。</description></item><item><title>Shiro RememberMe</title><link>https://www.hotmindshare.com/docs/java/shiro/14/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.hotmindshare.com/docs/java/shiro/14/</guid><description>RememberMe Shiro 提供了记住我（RememberMe）的功能，比如访问如淘宝等一些网站时，关闭了浏览器下次再打开时还是能记住你是谁，下次访问时无需再登录即可访问，基本流程如下：
1、 首先在登录页面选中RememberMe然后登录成功；如果是浏览器登录，一般会把RememberMe的Cookie写到客户端并保存下来；
2、 关闭浏览器再重新打开；会发现浏览器还是记住你的；
3、 访问一般的网页服务器端还是知道你是谁，且能正常访问；
4、 但是比如我们访问淘宝时，如果要查看我的订单或进行支付时，此时还是需要再进行身份认证的，以确保当前用户还是你；
RememberMe 配置 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 spring-shiro-web.xml 配置：
1&amp;lt;bean id=&amp;#34;sessionIdCookie&amp;#34; class=&amp;#34;org.apache.shiro.web.servlet.SimpleCookie&amp;#34;&amp;gt; 2 &amp;lt;constructor-arg value=&amp;#34;sid&amp;#34;/&amp;gt; 3 &amp;lt;property name=&amp;#34;httpOnly&amp;#34; value=&amp;#34;true&amp;#34;/&amp;gt; 4 &amp;lt;property name=&amp;#34;maxAge&amp;#34; value=&amp;#34;-1&amp;#34;/&amp;gt; 5&amp;lt;/bean&amp;gt; 6&amp;lt;bean id=&amp;#34;rememberMeCookie&amp;#34; class=&amp;#34;org.apache.shiro.web.servlet.SimpleCookie&amp;#34;&amp;gt; 7 &amp;lt;constructor-arg value=&amp;#34;rememberMe&amp;#34;/&amp;gt; 8 &amp;lt;property name=&amp;#34;httpOnly&amp;#34; value=&amp;#34;true&amp;#34;/&amp;gt; 9 &amp;lt;property name=&amp;#34;maxAge&amp;#34; value=&amp;#34;2592000&amp;#34;/&amp;gt;&amp;lt;!-- 30天 --&amp;gt; 10&amp;lt;/bean&amp;gt; sessionIdCookie：maxAge=-1 表示浏览器关闭时失效此 Cookie； rememberMeCookie：即记住我的 Cookie，保存时长 30 天； 1`&amp;lt;!-- rememberMe管理器 --&amp;gt;` 2&amp;lt;bean id=&amp;#34;rememberMeManager&amp;#34; 3class=&amp;#34;org.apache.shiro.web.mgt.CookieRememberMeManager&amp;#34;&amp;gt; 4 &amp;lt;property name=&amp;#34;cipherKey&amp;#34; value=&amp;#34; 5#{T(org.apache.shiro.codec.Base64).decode(&amp;#39;4AvVhmFLUs0KTA3Kprsdag==&amp;#39;)}&amp;#34;/&amp;gt; 6 &amp;lt;property name=&amp;#34;cookie&amp;#34; ref=&amp;#34;rememberMeCookie&amp;#34;/&amp;gt; 7&amp;lt;/bean&amp;gt; rememberMe 管理器，cipherKey 是加密 rememberMe Cookie 的密钥；默认 AES 算法；</description></item><item><title>Shiro Spring 集成</title><link>https://www.hotmindshare.com/docs/java/shiro/13/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.hotmindshare.com/docs/java/shiro/13/</guid><description>与 Spring集成 Shiro 的组件都是 JavaBean/POJO 式的组件，所以非常容易使用 Spring 进行组件管理，可以非常方便的从 ini 配置迁移到 Spring 进行管理，且支持 JavaSE 应用及 Web 应用的集成。
在示例之前，需要导入 shiro-spring 及 spring-context 依赖，具体请参考 pom.xml。
spring-beans.xml 配置文件提供了基础组件如 DataSource、DAO、Service 组件的配置。
JavaSE 应用 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 spring-shiro.xml 提供了普通 JavaSE 独立应用的 Spring 配置：
1&amp;lt;!-- 缓存管理器 使用Ehcache实现 --&amp;gt; 2&amp;lt;bean id=&amp;#34;cacheManager&amp;#34; class=&amp;#34;org.apache.shiro.cache.ehcache.EhCacheManager&amp;#34;&amp;gt; 3 &amp;lt;property name=&amp;#34;cacheManagerConfigFile&amp;#34; value=&amp;#34;classpath:ehcache.xml&amp;#34;/&amp;gt; 4&amp;lt;/bean&amp;gt; 5&amp;lt;!-- 凭证匹配器 --&amp;gt; 6&amp;lt;bean id=&amp;#34;credentialsMatcher&amp;#34; class=&amp;#34; 7com.github.zhangkaitao.shiro.chapter12.credentials.RetryLimitHashedCredentialsMatcher&amp;#34;&amp;gt; 8 &amp;lt;constructor-arg ref=&amp;#34;cacheManager&amp;#34;/&amp;gt; 9 &amp;lt;property name=&amp;#34;hashAlgorithmName&amp;#34; value=&amp;#34;md5&amp;#34;/&amp;gt; 10 &amp;lt;property name=&amp;#34;hashIterations&amp;#34; value=&amp;#34;2&amp;#34;/&amp;gt; 11 &amp;lt;property name=&amp;#34;storedCredentialsHexEncoded&amp;#34; value=&amp;#34;true&amp;#34;/&amp;gt; 12&amp;lt;/bean&amp;gt; 13&amp;lt;!</description></item><item><title>Shiro SSL</title><link>https://www.hotmindshare.com/docs/java/shiro/15/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.hotmindshare.com/docs/java/shiro/15/</guid><description>SSL 对于SSL 的支持，Shiro 只是判断当前 url 是否需要 SSL 登录，如果需要自动重定向到 https 进行访问。
首先生成数字证书，生成证书到 D:\localhost.keystore
使用JDK 的 keytool 命令，生成证书（包含证书 / 公钥 / 私钥）到 D:\localhost.keystore：
1keytool -genkey -keystore &amp;#34;D:\localhost.keystore&amp;#34; -alias localhost -keyalg RSA 2输入密钥库口令: 3再次输入新口令: 4您的名字与姓氏是什么? 5 [Unknown]: localhost 6您的组织单位名称是什么? 7 [Unknown]: sishuok.com 8您的组织名称是什么? 9 [Unknown]: sishuok.com 10您所在的城市或区域名称是什么? 11 [Unknown]: beijing 12您所在的省/市/自治区名称是什么? 13 [Unknown]: beijing 14该单位的双字母国家/地区代码是什么? 15 [Unknown]: cn 16CN=localhost, OU=sishuok.com, O=sishuok.com, L=beijing, ST=beijing, C=cn是否正确 17 [否]: y 18输入 &amp;lt;localhost&amp;gt; 的密钥口令 19 (如果和密钥库口令相同, 按回车): 20再次输入新口令: 通过如上步骤，生成证书到 D:\ localhost.</description></item><item><title>Shiro Web 集成</title><link>https://www.hotmindshare.com/docs/java/shiro/8/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.hotmindshare.com/docs/java/shiro/8/</guid><description>与 Web 集成 Shiro 提供了与 Web 集成的支持，其通过一个 ShiroFilter 入口来拦截需要安全控制的 URL，然后进行相应的控制，ShiroFilter 类似于如 Strut2/SpringMVC 这种 web 框架的前端控制器，其是安全控制的入口点，其负责读取配置（如 ini 配置文件），然后判断 URL 是否需要登录 / 权限等工作。
准备环境 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 1、创建 webapp 应用
此处我们使用了 jetty-maven-plugin 和 tomcat7-maven-plugin 插件；这样可以直接使用 “mvn jetty:run” 或“mvn tomcat7:run”直接运行 webapp 了。然后通过 URLhttp://localhost:8080/chapter7 / 访问即可。
2、依赖
Servlet3
1&amp;lt;dependency&amp;gt; 2 &amp;lt;groupId&amp;gt;javax.servlet&amp;lt;/groupId&amp;gt; 3 &amp;lt;artifactId&amp;gt;javax.servlet-api&amp;lt;/artifactId&amp;gt; 4 &amp;lt;version&amp;gt;3.0.1&amp;lt;/version&amp;gt; 5 &amp;lt;scope&amp;gt;provided&amp;lt;/scope&amp;gt; 6&amp;lt;/dependency&amp;gt; Servlet3 的知识可以参考 https://github.com/zhangkaitao/servlet3-showcase 及 Servlet3 规范 http://www.iteye.com/blogs/subjects/Servlet-3-1。
shiro-web
1&amp;lt;dependency&amp;gt; 2 &amp;lt;groupId&amp;gt;org.apache.shiro&amp;lt;/groupId&amp;gt; 3 &amp;lt;artifactId&amp;gt;shiro-web&amp;lt;/artifactId&amp;gt; 4 &amp;lt;version&amp;gt;1.2.2&amp;lt;/version&amp;gt; 5&amp;lt;/dependency&amp;gt; 其他依赖请参考源码的 pom.</description></item><item><title>Shiro 编码加密</title><link>https://www.hotmindshare.com/docs/java/shiro/6/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.hotmindshare.com/docs/java/shiro/6/</guid><description>编码/加密 在涉及到密码存储问题上，应该加密 / 生成密码摘要存储，而不是存储明文密码。比如之前的 600w csdn 账号泄露对用户可能造成很大损失，因此应加密 / 生成不可逆的摘要方式存储。
编码 / 解码 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 Shiro 提供了 base64 和 16 进制字符串编码 / 解码的 API 支持，方便一些编码解码操作。Shiro 内部的一些数据的存储 / 表示都使用了 base64 和 16 进制字符串。
1String str = &amp;#34;hello&amp;#34;; 2String base64Encoded = Base64.encodeToString(str.getBytes()); 3String str2 = Base64.decodeToString(base64Encoded); 4Assert.assertEquals(str, str2); 通过如上方式可以进行 base64 编码 / 解码操作，更多 API 请参考其 Javadoc。
1String str = &amp;#34;hello&amp;#34;; 2String base64Encoded = Hex.encodeToString(str.getBytes()); 3String str2 = new String(Hex.decode(base64Encoded.getBytes())); 4Assert.assertEquals(str, str2); 通过如上方式可以进行 16 进制字符串编码 / 解码操作，更多 API 请参考其 Javadoc。</description></item><item><title>Shiro 并发登录控制</title><link>https://www.hotmindshare.com/docs/java/shiro/19/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.hotmindshare.com/docs/java/shiro/19/</guid><description>并发登录人数控制 在某些项目中可能会遇到如每个账户同时只能有一个人登录或几个人同时登录，如果同时有多人登录：要么不让后者登录；要么踢出前者登录（强制退出）。比如 spring security 就直接提供了相应的功能；Shiro 的话没有提供默认实现，不过可以很容易的在 Shiro 中加入这个功能。
示例代码基于《第十六章 综合实例》完成，通过 Shiro Filter 机制扩展 KickoutSessionControlFilter 完成。
首先来看看如何配置使用（spring-config-shiro.xml）
kickoutSessionControlFilter 用于控制并发登录人数的
1&amp;lt;bean id=&amp;#34;kickoutSessionControlFilter&amp;#34; 2class=&amp;#34;com.github.zhangkaitao.shiro.chapter18.web.shiro.filter.KickoutSessionControlFilter&amp;#34;&amp;gt; 3 &amp;lt;property name=&amp;#34;cacheManager&amp;#34; ref=&amp;#34;cacheManager&amp;#34;/&amp;gt; 4 &amp;lt;property name=&amp;#34;sessionManager&amp;#34; ref=&amp;#34;sessionManager&amp;#34;/&amp;gt; 5 &amp;lt;property name=&amp;#34;kickoutAfter&amp;#34; value=&amp;#34;false&amp;#34;/&amp;gt; 6 &amp;lt;property name=&amp;#34;maxSession&amp;#34; value=&amp;#34;2&amp;#34;/&amp;gt; 7 &amp;lt;property name=&amp;#34;kickoutUrl&amp;#34; value=&amp;#34;/login?kickout=1&amp;#34;/&amp;gt; 8&amp;lt;/bean&amp;gt; cacheManager：使用 cacheManager 获取相应的 cache 来缓存用户登录的会话；用于保存用户—会话之间的关系的； sessionManager：用于根据会话 ID，获取会话进行踢出操作的； kickoutAfter：是否踢出后来登录的，默认是 false；即后者登录的用户踢出前者登录的用户； maxSession：同一个用户最大的会话数，默认 1；比如 2 的意思是同一个用户允许最多同时两个人登录； kickoutUrl：被踢出后重定向到的地址； shiroFilter 配置
1 &amp;lt;bean id=&amp;#34;shiroFilter&amp;#34; class=&amp;#34;org.apache.shiro.spring.web.ShiroFilterFactoryBean&amp;#34;&amp;gt; 2 &amp;lt;property name=&amp;#34;securityManager&amp;#34; ref=&amp;#34;securityManager&amp;#34;/&amp;gt; 3 &amp;lt;property name=&amp;#34;loginUrl&amp;#34; value=&amp;#34;/login&amp;#34;/&amp;gt; 4 &amp;lt;property name=&amp;#34;filters&amp;#34;&amp;gt; 5 &amp;lt;util:map&amp;gt; 6 &amp;lt;entry key=&amp;#34;authc&amp;#34; value-ref=&amp;#34;formAuthenticationFilter&amp;#34;/&amp;gt; 7 &amp;lt;entry key=&amp;#34;sysUser&amp;#34; value-ref=&amp;#34;sysUserFilter&amp;#34;/&amp;gt; 8 &amp;lt;entry key=&amp;#34;kickout&amp;#34; value-ref=&amp;#34;kickoutSessionControlFilter&amp;#34;/&amp;gt; 9 &amp;lt;/util:map&amp;gt; 10 &amp;lt;/property&amp;gt; 11 &amp;lt;property name=&amp;#34;filterChainDefinitions&amp;#34;&amp;gt; 12 &amp;lt;value&amp;gt; 13 /login = authc 14 /logout = logout 15 /authenticated = authc 16 /** = kickout,user,sysUser 17 &amp;lt;/value&amp;gt; 18 &amp;lt;/property&amp;gt; 19 &amp;lt;/bean&amp;gt; 此处配置除了登录等之外的地址都走 kickout 拦截器进行并发登录控制。</description></item><item><title>Shiro 单点登录</title><link>https://www.hotmindshare.com/docs/java/shiro/16/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.hotmindshare.com/docs/java/shiro/16/</guid><description>单点登录 Shiro 1.2 开始提供了 Jasig CAS 单点登录的支持，单点登录主要用于多系统集成，即在多个系统中，用户只需要到一个中央服务器登录一次即可访问这些系统中的任何一个，无须多次登录。此处我们使用 Jasig CAS v4.0.0-RC3 版本：
https://github.com/Jasig/cas/tree/v4.0.0-RC3
Jasig CAS 单点登录系统分为服务器端和客户端，服务器端提供单点登录，多个客户端（子系统）将跳转到该服务器进行登录验证，大体流程如下：
1、 访问客户端需要登录的页面http://localhost:9080/client/，此时会跳到单点登录服务器https://localhost:8443/server/login?service=https://localhost:9443/client/cas；
2、 如果此时单点登录服务器也没有登录的话，会显示登录表单页面，输入用户名/密码进行登录；
3、 登录成功后服务器端会回调客户端传入的地址：https://localhost:9443/client/cas?ticket=ST-1-eh2cIo92F9syvoMs5DOg-cas01.example.org，且带着一个ticket；
4、 客户端会把ticket提交给服务器来验证ticket是否有效；如果有效服务器端将返回用户身份；
5、 客户端可以再根据这个用户身份获取如当前系统用户/角色/权限信息；
本章使用了和《第十四章 SSL》一样的数字证书。
服务器端 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 我们使用了 Jasig CAS 服务器 v4.0.0-RC3 版本，可以到其官方的 github 下载：https://github.com/Jasig/cas/tree/v4.0.0-RC3 下载，然后将其 cas-server-webapp 模块封装到 shiro-example-chapter15-server 模块中，具体请参考源码。
1、 数字证书使用和《第十四章SSL》一样的数字证书，即将localhost.keystore拷贝到shiro-example-chapter15-server模块根目录下；
2、 在pom.xml中添加JettyMaven插件，并添加SSL支持：；
1&amp;lt;plugin&amp;gt; 2 &amp;lt;groupId&amp;gt;org.mortbay.jetty&amp;lt;/groupId&amp;gt; 3 &amp;lt;artifactId&amp;gt;jetty-maven-plugin&amp;lt;/artifactId&amp;gt; 4 &amp;lt;version&amp;gt;8.1.8.v20121106&amp;lt;/version&amp;gt; 5 &amp;lt;configuration&amp;gt; 6 &amp;lt;webAppConfig&amp;gt; 7 &amp;lt;contextPath&amp;gt;/${project.build.finalName}&amp;lt;/contextPath&amp;gt; 8 &amp;lt;/webAppConfig&amp;gt; 9 &amp;lt;connectors&amp;gt; 10 &amp;lt;connector implementation=&amp;#34;org.eclipse.jetty.server.nio.SelectChannelConnector&amp;#34;&amp;gt; 11 &amp;lt;port&amp;gt;8080&amp;lt;/port&amp;gt; 12 &amp;lt;/connector&amp;gt; 13 &amp;lt;connector implementation=&amp;#34;org.</description></item><item><title>Shiro 动态 URL</title><link>https://www.hotmindshare.com/docs/java/shiro/20/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.hotmindshare.com/docs/java/shiro/20/</guid><description>动态 URL 权限控制 用过Spring Security 的朋友应该比较熟悉对 URL 进行全局的权限控制，即访问 URL 时进行权限匹配；如果没有权限直接跳到相应的错误页面。Shiro 也支持类似的机制，不过需要稍微改造下来满足实际需求。不过在 Shiro 中，更多的是通过 AOP 进行分散的权限控制，即方法级别的；而通过 URL 进行权限控制是一种集中的权限控制。本章将介绍如何在 Shiro 中完成动态 URL 权限控制。
本章代码基于《第十六章 综合实例》，请先了解相关数据模型及基本流程后再学习本章。
表及数据 SQL
请运行shiro-example-chapter19/sql/ shiro-schema.sql 表结构
请运行shiro-example-chapter19/sql/ shiro-schema.sql 数据
实体
具体请参考 com.github.zhangkaitao.shiro.chapter19 包下的实体。
1public class UrlFilter implements Serializable { 2 private Long id; 3 private String name; //url名称/描述 4 private String url; //地址 5 private String roles; //所需要的角色，可省略 6 private String permissions; //所需要的权限，可省略 7} 表示拦截的 URL 和角色 / 权限之间的关系，多个角色 / 权限之间通过逗号分隔，此处还可以扩展其他的关系，另外可以加如 available 属性表示是否开启该拦截。</description></item><item><title>Shiro 多项目</title><link>https://www.hotmindshare.com/docs/java/shiro/24/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.hotmindshare.com/docs/java/shiro/24/</guid><description>多项目集中权限管理及分布式会话 在做一些企业内部项目时或一些互联网后台时；可能会涉及到集中权限管理，统一进行多项目的权限管理；另外也需要统一的会话管理，即实现单点身份认证和授权控制。
学习本章之前，请务必先学习《第十章 会话管理》和《第十六章 综合实例》，本章代码都是基于这两章的代码基础上完成的。
本章示例是同域名的场景下完成的，如果跨域请参考《第十五章 单点登录》和《第十七章 OAuth2 集成》了解使用 CAS 或 OAuth2 实现跨域的身份验证和授权。另外比如客户端 / 服务器端的安全校验可参考《第二十章 无状态 Web 应用集成》。
部署架构 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 1、 有三个应用：用于用户/权限控制的Server（端口：8080）；两个应用App1（端口9080）和App2（端口10080）；
2、 使用Nginx反向代理这三个应用，nginx.conf的server配置部分如下：；
1server { 2 listen 80; 3 server_name localhost; 4 charset utf-8; 5 location ~ ^/(chapter23-server)/ { 6 proxy_pass http://127.0.0.1:8080; 7 index /; 8 proxy_set_header Host $host; 9 } 10 location ~ ^/(chapter23-app1)/ { 11 proxy_pass http://127.0.0.1:9080; 12 index /; 13 proxy_set_header Host $host; 14 } 15 location ~ ^/(chapter23-app2)/ { 16 proxy_pass http://127.</description></item><item><title>Shiro 关于</title><link>https://www.hotmindshare.com/docs/java/shiro/1/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.hotmindshare.com/docs/java/shiro/1/</guid><description>跟我学 Shiro Apache Shiro 是一个强大易用的 Java 安全框架，提供了认证、授权、加密和会话管理等功能，对于任何一个应用程序，Shiro 都可以提供全面的安全管理服务。并且相对于其他安全框架，Shiro 要简单的多。本教程只介绍基本的 Shiro 使用，不会过多分析源码等，重在使用。
适用人群 Java 企业级安全应用开发人员。
学习前提 相比较Spring Security，Shiro 小巧的多，但是学习本教程前，你还是需要了解 Java 开发语言。
http://jinnianshilongnian.iteye.com/blog/2018936</description></item><item><title>Shiro 缓存机制</title><link>https://www.hotmindshare.com/docs/java/shiro/12/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.hotmindshare.com/docs/java/shiro/12/</guid><description>缓存机制 Shiro 提供了类似于 Spring 的 Cache 抽象，即 Shiro 本身不实现 Cache，但是对 Cache 进行了又抽象，方便更换不同的底层 Cache 实现。对于 Cache 的一些概念可以参考我的《Spring Cache 抽象详解》：http://jinnianshilongnian.iteye.com/blog/2001040。
Shiro 提供的 Cache 接口：
1public interface Cache&amp;lt;K, V&amp;gt; { 2 //根据Key获取缓存中的值 3 public V get(K key) throws CacheException; 4 //往缓存中放入key-value，返回缓存中之前的值 5 public V put(K key, V value) throws CacheException; 6 //移除缓存中key对应的值，返回该值 7 public V remove(K key) throws CacheException; 8 //清空整个缓存 9 public void clear() throws CacheException; 10 //返回缓存大小 11 public int size(); 12 //获取缓存中所有的key 13 public Set&amp;lt;K&amp;gt; keys(); 14 //获取缓存中所有的value 15 public Collection&amp;lt;V&amp;gt; values(); Shiro 提供的 CacheManager 接口：</description></item><item><title>Shiro 会话管理</title><link>https://www.hotmindshare.com/docs/java/shiro/11/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.hotmindshare.com/docs/java/shiro/11/</guid><description>会话管理 Shiro 提供了完整的企业级会话管理功能，不依赖于底层容器（如 web 容器 tomcat），不管 JavaSE 还是 JavaEE 环境都可以使用，提供了会话管理、会话事件监听、会话存储 / 持久化、容器无关的集群、失效 / 过期支持、对 Web 的透明支持、SSO 单点登录的支持等特性。即直接使用 Shiro 的会话管理可以直接替换如 Web 容器的会话管理。
会话 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 所谓会话，即用户访问应用时保持的连接关系，在多次交互中应用能够识别出当前访问的用户是谁，且可以在多次交互中保存一些数据。如访问一些网站时登录成功后，网站可以记住用户，且在退出之前都可以识别当前用户是谁。
Shiro 的会话支持不仅可以在普通的 JavaSE 应用中使用，也可以在 JavaEE 应用中使用，如 web 应用。且使用方式是一致的。
1login(&amp;#34;classpath:shiro.ini&amp;#34;, &amp;#34;zhang&amp;#34;, &amp;#34;123&amp;#34;); 2Subject subject = SecurityUtils.getSubject(); 3Session session = subject.getSession(); 登录成功后使用 Subject.getSession() 即可获取会话；其等价于 Subject.getSession(true)，即如果当前没有创建 Session 对象会创建一个；另外 Subject.getSession(false)，如果当前没有创建 Session 则返回 null（不过默认情况下如果启用会话存储功能的话在创建 Subject 时会主动创建一个 Session）。
session.getId();
获取当前会话的唯一标识。
session.getHost();
获取当前 Subject 的主机地址，该地址是通过 HostAuthenticationToken.getHost() 提供的。
1session.getTimeout(); 2session.setTimeout(毫秒); 获取/ 设置当前 Session 的过期时间；如果不设置默认是会话管理器的全局过期时间。</description></item><item><title>Shiro 集成验证码</title><link>https://www.hotmindshare.com/docs/java/shiro/23/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.hotmindshare.com/docs/java/shiro/23/</guid><description>集成验证码 在做用户登录功能时，很多时候都需要验证码支持，验证码的目的是为了防止机器人模拟真实用户登录而恶意访问，如暴力破解用户密码 / 恶意评论等。目前也有一些验证码比较简单，通过一些 OCR 工具就可以解析出来；另外还有一些验证码比较复杂（一般通过如扭曲、加线条 / 噪点等干扰）防止 OCR 工具识别；但是在中国就是人多，机器干不了的可以交给人来完成，所以在中国就有很多打码平台，人工识别验证码；因此即使比较复杂的如填字、算数等类型的验证码还是能识别的。所以验证码也不是绝对可靠的，目前比较可靠还是手机验证码，但是对于用户来说相对于验证码还是比较麻烦的。
对于验证码图片的生成，可以自己通过如 Java 提供的图像 API 自己去生成，也可以借助如 JCaptcha 这种开源 Java 类库生成验证码图片；JCaptcha 提供了常见的如扭曲、加噪点等干扰支持。本章代码基于《第十六章 综合实例》。
一、添加 JCaptcha 依赖
1&amp;lt;dependency&amp;gt; 2 &amp;lt;groupId&amp;gt;com.octo.captcha&amp;lt;/groupId&amp;gt; 3 &amp;lt;artifactId&amp;gt;jcaptcha&amp;lt;/artifactId&amp;gt; 4 &amp;lt;version&amp;gt;2.0-alpha-1&amp;lt;/version&amp;gt; 5&amp;lt;/dependency&amp;gt; 6&amp;lt;dependency&amp;gt; 7 &amp;lt;groupId&amp;gt;com.octo.captcha&amp;lt;/groupId&amp;gt; 8 &amp;lt;artifactId&amp;gt;jcaptcha-integration-simple-servlet&amp;lt;/artifactId&amp;gt; 9 &amp;lt;version&amp;gt;2.0-alpha-1&amp;lt;/version&amp;gt; 10 &amp;lt;exclusions&amp;gt; 11 &amp;lt;exclusion&amp;gt; 12 &amp;lt;artifactId&amp;gt;servlet-api&amp;lt;/artifactId&amp;gt; 13 &amp;lt;groupId&amp;gt;javax.servlet&amp;lt;/groupId&amp;gt; 14 &amp;lt;/exclusion&amp;gt; 15 &amp;lt;/exclusions&amp;gt; 16&amp;lt;/dependency&amp;gt; com.octo.captcha.jcaptcha 提供了 jcaptcha 核心；而 jcaptcha-integration-simple-servlet 提供了与 Servlet 集成。
二、GMailEngine
来自[https://code.google.com/p/musicvalley/source/browse/trunk/musicvalley/doc/springSecurity/springSecurityIII/src/main/java/com/spring/security/jcaptcha/GMailEngine.java?spec=svn447&amp;amp;r=447]()（目前无法访问了），仿照 JCaptcha2.0 编写类似 GMail 验证码的样式；具体请参考 com.github.zhangkaitao.shiro.chapter22.jcaptcha.GMailEngine。
三、MyManageableImageCaptchaService
提供了判断仓库中是否有相应的验证码存在。
1public class MyManageableImageCaptchaService extends 2 DefaultManageableImageCaptchaService { 3 public MyManageableImageCaptchaService( 4 com.</description></item><item><title>Shiro 简介</title><link>https://www.hotmindshare.com/docs/java/shiro/2/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.hotmindshare.com/docs/java/shiro/2/</guid><description>简介 Apache Shiro 是 Java 的一个安全框架。目前，使用 Apache Shiro 的人越来越多，因为它相当简单，对比 Spring Security，可能没有 Spring Security 做的功能强大，但是在实际工作时可能并不需要那么复杂的东西，所以使用小而简单的 Shiro 就足够了。对于它俩到底哪个好，这个不必纠结，能更简单的解决项目问题就好了。
本教程只介绍基本的 Shiro 使用，不会过多分析源码等，重在使用。
Shiro 可以非常容易的开发出足够好的应用，其不仅可以用在 JavaSE 环境，也可以用在 JavaEE 环境。Shiro 可以帮助我们完成：认证、授权、加密、会话管理、与 Web 集成、缓存等。这不就是我们想要的嘛，而且 Shiro 的 API 也是非常简单；其基本功能点如下图所示：
Authentication：身份认证 / 登录，验证用户是不是拥有相应的身份；
Authorization：授权，即权限验证，验证某个已认证的用户是否拥有某个权限；即判断用户是否能做事情，常见的如：验证某个用户是否拥有某个角色。或者细粒度的验证某个用户对某个资源是否具有某个权限；
Session Manager：会话管理，即用户登录后就是一次会话，在没有退出之前，它的所有信息都在会话中；会话可以是普通 JavaSE 环境的，也可以是如 Web 环境的；
Cryptography：加密，保护数据的安全性，如密码加密存储到数据库，而不是明文存储；
Web Support：Web 支持，可以非常容易的集成到 Web 环境；
Caching：缓存，比如用户登录后，其用户信息、拥有的角色 / 权限不必每次去查，这样可以提高效率；
Concurrency：shiro 支持多线程应用的并发验证，即如在一个线程中开启另一个线程，能把权限自动传播过去；
Testing：提供测试支持；
Run As：允许一个用户假装为另一个用户（如果他们允许）的身份进行访问；
Remember Me：记住我，这个是非常常见的功能，即一次登录后，下次再来的话不用登录了。
记住一点，Shiro 不会去维护用户、维护权限；这些需要我们自己去设计 / 提供；然后通过相应的接口注入给 Shiro 即可。
接下来我们分别从外部和内部来看看 Shiro 的架构，对于一个好的框架，从外部来看应该具有非常简单易于使用的 API，且 API 契约明确；从内部来看的话，其应该有一个可扩展的架构，即非常容易插入用户自定义实现，因为任何框架都不能满足所有需求。</description></item><item><title>Shiro 拦截器机制</title><link>https://www.hotmindshare.com/docs/java/shiro/9/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.hotmindshare.com/docs/java/shiro/9/</guid><description>拦截器机制 拦截器介绍 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 Shiro 使用了与 Servlet 一样的 Filter 接口进行扩展；所以如果对 Filter 不熟悉可以参考《Servlet 3.1 规范》http://www.iteye.com/blogs/subjects/Servlet-3-1了解 Filter 的工作原理。首先下图是 Shiro 拦截器的基础类图：
1、NameableFilter
NameableFilter 给 Filter 起个名字，如果没有设置默认就是 FilterName；还记得之前的如 authc 吗？当我们组装拦截器链时会根据这个名字找到相应的拦截器实例；
2、OncePerRequestFilter
OncePerRequestFilter 用于防止多次执行 Filter 的；也就是说一次请求只会走一次拦截器链；另外提供 enabled 属性，表示是否开启该拦截器实例，默认 enabled=true 表示开启，如果不想让某个拦截器工作，可以设置为 false 即可。
3、ShiroFilter
ShiroFilter 是整个 Shiro 的入口点，用于拦截需要安全控制的请求进行处理，这个之前已经用过了。
4、AdviceFilter
AdviceFilter 提供了 AOP 风格的支持，类似于 SpringMVC 中的 Interceptor：
1boolean preHandle(ServletRequest request, ServletResponse response) throws Exception 2void postHandle(ServletRequest request, ServletResponse response) throws Exception 3void afterCompletion(ServletRequest request, ServletResponse response, Exception exception) throws Exception; preHandler：类似于 AOP 中的前置增强；在拦截器链执行之前执行；如果返回 true 则继续拦截器链；否则中断后续的拦截器链的执行直接返回；进行预处理（如基于表单的身份验证、授权） postHandle：类似于 AOP 中的后置返回增强；在拦截器链执行完成后执行；进行后处理（如记录执行时间之类的）； afterCompletion：类似于 AOP 中的后置最终增强；即不管有没有异常都会执行；可以进行清理资源（如接触 Subject 与线程的绑定之类的）； 5、PathMatchingFilter</description></item><item><title>Shiro 身份验证</title><link>https://www.hotmindshare.com/docs/java/shiro/3/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.hotmindshare.com/docs/java/shiro/3/</guid><description>身份验证 身份验证，即在应用中谁能证明他就是他本人。一般提供如他们的身份 ID 一些标识信息来表明他就是他本人，如提供身份证，用户名 / 密码来证明。
在shiro 中，用户需要提供 principals （身份）和 credentials（证明）给 shiro，从而应用能验证用户身份：
principals：身份，即主体的标识属性，可以是任何东西，如用户名、邮箱等，唯一即可。一个主体可以有多个 principals，但只有一个 Primary principals，一般是用户名 / 密码 / 手机号。
credentials：证明 / 凭证，即只有主体知道的安全值，如密码 / 数字证书等。
最常见的 principals 和 credentials 组合就是用户名 / 密码了。接下来先进行一个基本的身份认证。
另外两个相关的概念是之前提到的 Subject 及 Realm，分别是主体及验证主体的数据源。
环境准备 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 本文使用 Maven 构建，因此需要一点 Maven 知识。首先准备环境依赖：
1&amp;lt;dependencies&amp;gt; 2 &amp;lt;dependency&amp;gt; 3 &amp;lt;groupId&amp;gt;junit&amp;lt;/groupId&amp;gt; 4 &amp;lt;artifactId&amp;gt;junit&amp;lt;/artifactId&amp;gt; 5 &amp;lt;version&amp;gt;4.9&amp;lt;/version&amp;gt; 6 &amp;lt;/dependency&amp;gt; 7 &amp;lt;dependency&amp;gt; 8 &amp;lt;groupId&amp;gt;commons-logging&amp;lt;/groupId&amp;gt; 9 &amp;lt;artifactId&amp;gt;commons-logging&amp;lt;/artifactId&amp;gt; 10 &amp;lt;version&amp;gt;1.1.3&amp;lt;/version&amp;gt; 11 &amp;lt;/dependency&amp;gt; 12 &amp;lt;dependency&amp;gt; 13 &amp;lt;groupId&amp;gt;org.apache.shiro&amp;lt;/groupId&amp;gt; 14 &amp;lt;artifactId&amp;gt;shiro-core&amp;lt;/artifactId&amp;gt; 15 &amp;lt;version&amp;gt;1.</description></item><item><title>Shiro 授权</title><link>https://www.hotmindshare.com/docs/java/shiro/4/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.hotmindshare.com/docs/java/shiro/4/</guid><description>授权 授权，也叫访问控制，即在应用中控制谁能访问哪些资源（如访问页面/编辑数据/页面操作等）。在授权中需了解的几个关键对象：主体（Subject）、资源（Resource）、权限（Permission）、角色（Role）。
主体
主体，即访问应用的用户，在 Shiro 中使用 Subject 代表该用户。用户只有授权后才允许访问相应的资源。
资源
在应用中用户可以访问的任何东西，比如访问 JSP 页面、查看/编辑某些数据、访问某个业务方法、打印文本等等都是资源。用户只要授权后才能访问。
权限
安全策略中的原子授权单位，通过权限我们可以表示在应用中用户有没有操作某个资源的权力。即权限表示在应用中用户能不能访问某个资源，如： 访问用户列表页面
查看/新增/修改/删除用户数据（即很多时候都是 CRUD（增查改删）式权限控制）
打印文档等等。。。
如上可以看出，权限代表了用户有没有操作某个资源的权利，即反映在某个资源上的操作允不允许，不反映谁去执行这个操作。所以后续还需要把权限赋予给用户，即定义哪个用户允许在某个资源上做什么操作（权限），Shiro 不会去做这件事情，而是由实现人员提供。
Shiro 支持粗粒度权限（如用户模块的所有权限）和细粒度权限（操作某个用户的权限，即实例级别的），后续部分介绍。
角色
角色代表了操作集合，可以理解为权限的集合，一般情况下我们会赋予用户角色而不是权限，即这样用户可以拥有一组权限，赋予权限时比较方便。典型的如：项目经理、技术总监、CTO、开发工程师等都是角色，不同的角色拥有一组不同的权限。
隐式角色：
即直接通过角色来验证用户有没有操作权限，如在应用中 CTO、技术总监、开发工程师可以使用打印机，假设某天不允许开发工程师使用打印机，此时需要从应用中删除相应代码；再如在应用中 CTO、技术总监可以查看用户、查看权限；突然有一天不允许技术总监查看用户、查看权限了，需要在相关代码中把技术总监角色从判断逻辑中删除掉；即粒度是以角色为单位进行访问控制的，粒度较粗；如果进行修改可能造成多处代码修改。
显示角色：
在程序中通过权限控制谁能访问某个资源，角色聚合一组权限集合；这样假设哪个角色不能访问某个资源，只需要从角色代表的权限集合中移除即可；无须修改多处代码；即粒度是以资源/实例为单位的；粒度较细。
请google 搜索“RBAC”和“RBAC新解”分别了解“基于角色的访问控制”“基于资源的访问控制(Resource-Based Access Control)”。
授权方式 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 Shiro 支持三种方式的授权：
编程式：通过写 if/else 授权代码块完成：
1Subject subject = SecurityUtils.getSubject(); 2if(subject.hasRole(“admin”)) { 3 //有权限 4} else { 5 //无权限 6} 注解式：通过在执行的 Java 方法上放置相应的注解完成：
1@RequiresRoles(&amp;#34;admin&amp;#34;) 2public void hello() { 3 //有权限 4} 没有权限将抛出相应的异常；
JSP/GSP 标签：在 JSP/GSP 页面通过相应的标签完成：</description></item><item><title>Shiro 授予身份和切换身份</title><link>https://www.hotmindshare.com/docs/java/shiro/22/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.hotmindshare.com/docs/java/shiro/22/</guid><description>授予身份及切换身份 在一些场景中，比如某个领导因为一些原因不能进行登录网站进行一些操作，他想把他网站上的工作委托给他的秘书，但是他不想把帐号 / 密码告诉他秘书，只是想把工作委托给他；此时和我们可以使用 Shiro 的 RunAs 功能，即允许一个用户假装为另一个用户（如果他们允许）的身份进行访问。
本章代码基于《第十六章 综合实例》，请先了解相关数据模型及基本流程后再学习本章。
表及数据 SQL
请运行shiro-example-chapter21/sql/ shiro-schema.sql 表结构
请运行shiro-example-chapter21/sql/ shiro-schema.sql 数据
实体
具体请参考 com.github.zhangkaitao.shiro.chapter21 包下的实体。
1public class UserRunAs implements Serializable { 2 private Long fromUserId;//授予身份帐号 3 private Long toUserId;//被授予身份帐号 4} 该实体定义了授予身份帐号（A）与被授予身份帐号（B）的关系，意思是 B 帐号将可以假装为 A 帐号的身份进行访问。
DAO
具体请参考 com.github.zhangkaitao.shiro.chapter21.dao 包下的 DAO 接口及实现。
Service
具体请参考 com.github.zhangkaitao.shiro.chapter21.service 包下的 Service 接口及实现。
1public interface UserRunAsService { 2 public void grantRunAs(Long fromUserId, Long toUserId); 3 public void revokeRunAs(Long fromUserId, Long toUserId); 4 public boolean exists(Long fromUserId, Long toUserId); 5 public List&amp;lt;Long&amp;gt; findFromUserIds(Long toUserId); 6 public List&amp;lt;Long&amp;gt; findToUserIds(Long fromUserId); 7} 提供授予身份、回收身份、关系存在判断及查找 API。</description></item><item><title>Shiro 无状态 Web</title><link>https://www.hotmindshare.com/docs/java/shiro/21/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.hotmindshare.com/docs/java/shiro/21/</guid><description>无状态 Web 应用集成 在一些环境中，可能需要把 Web 应用做成无状态的，即服务器端无状态，就是说服务器端不会存储像会话这种东西，而是每次请求时带上相应的用户名进行登录。如一些 REST 风格的 API，如果不使用 OAuth2 协议，就可以使用如 REST+HMAC 认证进行访问。HMAC（Hash-based Message Authentication Code）：基于散列的消息认证码，使用一个密钥和一个消息作为输入，生成它们的消息摘要。注意该密钥只有客户端和服务端知道，其他第三方是不知道的。访问时使用该消息摘要进行传播，服务端然后对该消息摘要进行验证。如果只传递用户名 + 密码的消息摘要，一旦被别人捕获可能会重复使用该摘要进行认证。解决办法如：
1、 每次客户端申请一个Token，然后使用该Token进行加密，而该Token是一次性的，即只能用一次；有点类似于OAuth2的Token机制，但是简单些；
2、 客户端每次生成一个唯一的Token，然后使用该Token加密，这样服务器端记录下这些Token，如果之前用过就认为是非法请求；
为了简单，本文直接对请求的数据（即全部请求的参数）生成消息摘要，即无法篡改数据，但是可能被别人窃取而能多次调用。解决办法如上所示。
服务器端 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 对于服务器端，不生成会话，而是每次请求时带上用户身份进行认证。
服务控制器 1@RestController 2public class ServiceController { 3 @RequestMapping(&amp;#34;/hello&amp;#34;) 4 public String hello1(String[] param1, String param2) { 5 return &amp;#34;hello&amp;#34; + param1[0] + param1[1] + param2; 6 } 7} 当访问/ hello 服务时，需要传入 param1、param2 两个请求参数。
加密工具类 com.github.zhangkaitao.shiro.chapter20.codec.HmacSHA256Utils：
1//使用指定的密码对内容生成消息摘要（散列值） 2public static String digest(String key, String content); 3//使用指定的密码对整个Map的内容生成消息摘要（散列值） 4public static String digest(String key, Map&amp;lt;String, ?</description></item><item><title>Shiro 在线会话管理</title><link>https://www.hotmindshare.com/docs/java/shiro/25/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.hotmindshare.com/docs/java/shiro/25/</guid><description>在线会话管理 有时候需要显示当前在线人数、当前在线用户，有时候可能需要强制某个用户下线等；此时就需要获取相应的在线用户并进行一些操作。
本章基于《第十六章 综合实例》代码构建。
会话控制器 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 1@RequiresPermissions(&amp;#34;session:*&amp;#34;) 2@Controller 3@RequestMapping(&amp;#34;/sessions&amp;#34;) 4public class SessionController { 5 @Autowired 6 private SessionDAO sessionDAO; 7 @RequestMapping() 8 public String list(Model model) { 9 Collection&amp;lt;Session&amp;gt; sessions = sessionDAO.getActiveSessions(); 10 model.addAttribute(&amp;#34;sessions&amp;#34;, sessions); 11 model.addAttribute(&amp;#34;sesessionCount&amp;#34;, sessions.size()); 12 return &amp;#34;sessions/list&amp;#34;; 13 } 14 @RequestMapping(&amp;#34;/{sessionId}/forceLogout&amp;#34;) 15 public String forceLogout(@PathVariable(&amp;#34;sessionId&amp;#34;) String sessionId, 16 RedirectAttributes redirectAttributes) { 17 try { 18 Session session = sessionDAO.readSession(sessionId); 19 if(session != null) { 20 session.</description></item><item><title>Shiro 综合实例</title><link>https://www.hotmindshare.com/docs/java/shiro/17/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.hotmindshare.com/docs/java/shiro/17/</guid><description>综合实例 简单数据字典 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 用户(sys_user)
名称
类型
长度
描述
id
bigint
&amp;nbsp;
编号 主键
username
varchar
100
用户名
password
varchar
100
密码
salt
varchar
50
盐
role_ids
varchar
100
角色列表
locked
bool
&amp;nbsp;
账户是否锁定
组织机构 (sys_organization)
名称
类型
长度
描述
id
bigint
&amp;nbsp;
编号 主键
name
varchar
100
组织机构名
priority
int
&amp;nbsp;
显示顺序
parent_id
bigint
&amp;nbsp;
父编号
parent_ids
varchar
100
父编号列表
available
bool
&amp;nbsp;
是否可用
资源(sys_resource)
名称
类型
长度
描述</description></item><item><title>八、Java 8 Lambda 表达式 （ 下 ）范例</title><link>https://www.hotmindshare.com/docs/java/java8/8/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.hotmindshare.com/docs/java/java8/8/</guid><description>经过Java 8 Lambda 表达式 （ 上 ）- 简介 和 Java 8 Lambda 表达式 （ 中 ）- 外部参数 两个章节的学习，想必你已经对 Java 8 中的 Lambda 表达式已经非常熟悉了。
本章节我们就来回顾下上面两章节的所学知识，然后写一些范例巩固下。
回顾 lambda 表达式是 java 8 引入的最重要的功能之一。 lambda 表达式为那些只包含一个方法的接口提供了简洁代码，例如函数接口 ( function interface )。 lambda 表达式还为集合的迭代提供了一种更为简单的方式。 对于那些使用匿名类或内部类实现的单个方法接口，在 Java 8 中，可以使用 lambda 表达式来实现。不仅功能相同，而且代码更简洁。 lambda 表达式真正的原理，是 「 为那些函数接口定义了它们包含的唯一方法，而且返回函数接口的实例 」
lambda 表达式语法 lambda 表达式语法非常易于阅读和理解
lambda 表达式语法看起来像
1(Argument part) -&amp;gt; Body part 例如
1、 如果某个方法没有参数，并打印信息，则可能像下面这样；
1 () -&amp;gt; System.out.println(&amp;#34;Your message&amp;#34;); 2、 如果某个方法接受两个参数，执行一些业务逻辑并返回值，则看起来可能像下面这样；</description></item><item><title>八、Java 9 新特性 – 集合不可变实例工厂方法</title><link>https://www.hotmindshare.com/docs/java/java9/8/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.hotmindshare.com/docs/java/java9/8/</guid><description>Java 9 为集合接口 ( List 、Set 、Map ) 提供了创建 不可变实例 的工厂方法。这些工厂方法为便利而生，以简介简单的方式创建这些集合
老式的创建集合的方法 我们先来看看默认的老式的创建集合的方法，创建一个文件 CollectionFactoryMethodTester.java ，并输入以下内容
1import java.util.ArrayList; 2import java.util.Collections; 3import java.util.HashMap; 4import java.util.HashSet; 5import java.util.List; 6import java.util.Map; 7import java.util.Set; 8public class CollectionFactoryMethodTester { 9 public static void main(String []args) { 10 Set&amp;lt;String&amp;gt; set = new HashSet&amp;lt;&amp;gt;(); 11 set.add(&amp;#34;A&amp;#34;); 12 set.add(&amp;#34;B&amp;#34;); 13 set.add(&amp;#34;C&amp;#34;); 14 set = Collections.unmodifiableSet(set); 15 System.out.println(set); 16 List&amp;lt;String&amp;gt; list = new ArrayList&amp;lt;&amp;gt;(); 17 list.add(&amp;#34;A&amp;#34;); 18 list.add(&amp;#34;B&amp;#34;); 19 list.add(&amp;#34;C&amp;#34;); 20 list = Collections.</description></item><item><title>八、Memcached replace 命令</title><link>https://www.hotmindshare.com/docs/java/memcached/8/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.hotmindshare.com/docs/java/memcached/8/</guid><description>Memcached replace 命令用于替换已存在的 key(键) 的 value(数据值)
语法 1replace key flags exptime bytes [noreply] 2value 参数说明 key : 键值 key-value 结构中的 key，用于查找缓存值。 flags ：可以包括键值对的整型参数，客户机使用它存储关于键值对的额外信息 exptime ：在缓存中保存键值对的时间长度（以秒为单位，0 表示永远） bytes ：在缓存中存储的字节数 noreply ：可选, 该参数告知服务器不需要返回数据 value ：存储的值（始终位于第二行）（可直接理解为key-value结构中的value） 返回值说明 如果数据替换成功，返回 STORED 如果键不存在，返回 NOT_STORED 如果执行错误，返回 CLIENT_ERROR 范例 1. 数据替换成功，返回 STORED 1flush_all 2OK 3set greeting 0 1000 11 4hello,world 5STORED 6replace greeting 0 1000 17 7hello,ddkk.com 8STORED 2. 如果键不存在，返回 NOT_STORED 1flush_all 2OK 3replace greeting 0 1000 17 4hello,ddkk.</description></item><item><title>八、Netty 教程 – 编写自己的文件服务器</title><link>https://www.hotmindshare.com/docs/java/netty/8/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.hotmindshare.com/docs/java/netty/8/</guid><description>作者：唐亚峰 | 出自：唐亚峰博客
前面已经讲了Netty的基本用法（请求/应答，拆包/粘包，序列化），本章以文件下载为例，编写一个相比传统Tomcat，Jetty等容器更加轻量级的文件服务器案例……
HTTP协议介绍 HTTP是一个属于应用层面向对象的协议（HTTP1.O，HTTP1.1，HTTP2.0），简洁，快速响应，几乎适用各大行业应用，覆盖广泛，但相比HTTPS安全性较差（具体区别不做过多概述，有兴趣可以百度百科一下）……
主要特点 支持Client/Server模式 简单，简洁，客户端只需要根据指定URL，带上规定的参数或者消息体请求即可 灵活，允许传输任意对象传输，内容类型由请求头的Content-Type标记 无状态，不存在对事务处理记忆功能，若存在后续请求，则需重新传输之前相关信息（容易导致每次连接传输的数据量增大），但在另外一方面，无状态就可以带来快速响应与轻量级负载的优势… 请求方式 1GET：获取Request-URI所标识的资源，常见的查询操作 2POST:在Request-URI所标识的资源后附加新的提交数据，可以存在消息体中，不一定体现在URL上，用于新增修改等操作 3HEAD：请求获取Request-URI所标识的响应消息头 4PUT：请求服务器存储的资源，以Request-URI做为标识，一般用作修改操作 5DELETE：请求服务器删除Request-URI所标识的记录 6TRACE：请求服务器回送收到的消息请求，测试或诊断 7CONNECT：保留将来使用 8OPTIONS：查询服务器性能，或查询与资源相关的选项和数据 标准路径：http://ip:port/path
HTTP请求头提供了关于请求，响应或者其他的发送实体的信息。HTTP的头信息包括通用头、请求头、响应头和实体头四个部分。每个头域由一个域名，冒号（:）和域值三部分组成。
通用头标：即可用于请求，也可用于响应，是作为一个整体而不是特定资源与事务相关联。 请求头标：允许客户端传递关于自身的信息和希望的响应形式。 响应头标：服务器和于传递自身信息的响应。 实体头标：定义被传送资源的信息。即可用于请求，也可用于响应。 HTTP响应头和请求头信息对照表：http://tools.jb51.net/table/http_header 有兴趣的可以看下，里面有详细介绍与描述
HTTP响应状态码和描述信息：http://tools.jb51.net/table/http_status_code
编写文件下载服务 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 简单描述了下HTTP，现在开始用Netty给我们提供的HTTP编写一个入门的服务端程序，含以下功能
路径映射 递归文件夹操作 文件下载 HttpFileServer 1@Override 2protected void initChannel(SocketChannel channel) throws Exception { 3 channel.pipeline().addLast(&amp;#34;http-decoder&amp;#34;, new HttpRequestDecoder()); 4 channel.pipeline().addLast(&amp;#34;http-aggregator&amp;#34;, new HttpObjectAggregator(8 * 1024)); 5 channel.pipeline().addLast(&amp;#34;http-encoder&amp;#34;, new HttpResponseEncoder()); 6 channel.pipeline().addLast(&amp;#34;http-chunked&amp;#34;, new ChunkedWriteHandler()); 7 channel.pipeline().addLast(&amp;#34;fileServerHandler&amp;#34;, new HttpFileServerHandler(path)); 8} 初始化添加HTTP相关编码器与解码器，对HTTP响应消息进行编码操作 如果把解析这块理解是一个黑盒的话，则输入是ByteBuf，输出是FullHttpRequest，通过该对象便可获取到所有与HTTP协议有关的信息。 HttpRequestDecoder先通过RequestLine和Header解析成HttpRequest对象，传入到HttpObjectAggregator，然后再通过body解析出HttpContent对象，传入到HttpObjectAggregator，当HttpObjectAggregator发现是LastHttpContent，则代表HTTP协议解析完成，封装FullHttpRequest 对于body内容的读取涉及到Content-Length和trunked两种方式，两种方式只是在解析协议时处理的不一致，最终输出是一致的。 ChunkedWriteHandler是为了支持异步发送过大数据流情况，不占用过多内存，防止JAVA内存溢出的问题… 挑优方案：http://blog.</description></item><item><title>八、Tomcat源码分析-Session源码解析</title><link>https://www.hotmindshare.com/docs/java/tomcat/8/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.hotmindshare.com/docs/java/tomcat/8/</guid><description>在web 开发中，我们经常会用到 Session 来保存会话信息，包括用户信息、权限信息，等等。在这篇文章中，我们将分析 tomcat 容器是如何创建 session、销毁 session，又是如何对 HttpSessionListener 进行事件通知
tomcat session 设计分析 tomcat session 组件图如下所示，其中 Context 对应一个 webapp 应用，每个 webapp 有多个 HttpSessionListener， 并且每个应用的 session 是独立管理的，而 session 的创建、销毁由 Manager 组件完成，它内部维护了 N 个 Session 实例对象。在前面的文章中，我们分析了 Context 组件，它的默认实现是 StandardContext，它与 Manager 是一对一的关系，Manager 创建、销毁会话时，需要借助 StandardContext 获取 HttpSessionListener 列表并进行事件通知，而 StandardContext 的后台线程会对 Manager 进行过期 Session 的清理工作
org.apache.catalina.Manager 接口的主要方法如下所示，它提供了 Context、org.apache.catalina.SessionIdGenerator 的 getter/setter 接口，以及创建、添加、移除、查找、遍历 Session 的 API 接口，此外还提供了 Session 持久化的接口（load/unload） 用于加载/卸载会话信息，当然持久化要看不同的实现类
1public interface Manager { 2 public Context getContext(); 3 public void setContext(Context context); 4 public SessionIdGenerator getSessionIdGenerator(); 5 public void setSessionIdGenerator(SessionIdGenerator sessionIdGenerator); 6 public void add(Session session); 7 public void addPropertyChangeListener(PropertyChangeListener listener); 8 public void changeSessionId(Session session); 9 public void changeSessionId(Session session, String newId); 10 public Session createEmptySession(); 11 public Session createSession(String sessionId); 12 public Session findSession(String id) throws IOException; 13 public Session[] findSessions(); 14 public void remove(Session session); 15 public void remove(Session session, boolean update); 16 public void removePropertyChangeListener(PropertyChangeListener listener); 17 public void unload() throws IOException; 18 public void backgroundProcess(); 19 public boolean willAttributeDistribute(String name, Object value); tomcat8.</description></item><item><title>二、Java 9 新特性 – 特性简介</title><link>https://www.hotmindshare.com/docs/java/java9/2/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.hotmindshare.com/docs/java/java9/2/</guid><description>Java 9 ( 又称为 jdk 1.9 ) 是 Java 编程语言开发的主要版本。它的初始版本于 2017 年 9 月21 日发布
按照今天的日期，也就是差不多一年前吧，但是，要知道，Java 10 都已经出来了…. 残废的 Java 9 ，大家还没用上，就开始过时了。
Java 9 的目标 Java 9 版本的主要目标是
1、 模块化JDK和Java标准版(JavaStandardEdition)，使得Java可以用在小型计算设备中；
今天，我才牢牢记住了 Java SE 的全称，竟然是 Java Standard Edition
2、 提高JDK和Java实现的整体安全性；
3、 简化JAVASE和JavaEE平台上的Java代码库和大型应用程序的构建和维护过程；
4、 设计和实现能够应用于JavaPlatform和JavaJDK上的标准模块系统；
其实看这几个主要目标，Java 9 的最大的变更应该就是开始模块化…，
这也导致了 Java 9 不突出的原因吧。毕竟 Java 开发人员日常使用 Java 9 的过程中，对模块化并没有明显的感知
Java 9 新特性 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 Java 9 在以上 4 个目标的基础上做了大量的工作，可以对外称道的应该有 90+ 个，但是，大部分都是小修小改，不足道也。
我们就介绍几个比较大一点的特性吧
1、 模块化(Module)；</description></item><item><title>二、Java8 IntStream,LongStream,DoubleStream</title><link>https://www.hotmindshare.com/docs/java/java8/2/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.hotmindshare.com/docs/java/java8/2/</guid><description>本章节我们提供一些 Java 8 中的 IntStream、LongStream 和 DoubleStream 使用范例。IntStream、LongStream 和 DoubleStream 分别表示原始 int 流、 原始 long 流 和 原始 double 流。
这三个原始流类提供了大量的方法用于操作流中的数据，同时提供了相应的静态方法来初始化它们自己。
这三个原始流类都在 java.util.stream 命名空间下。
java.util.stream.IntStream java.util.stream.IntStream 是一个原始整数值序列 ( sequence ) 。该流提供了许多方法可以对该流中的元素顺序执行或并行执行一些聚合操作，比如 max() 或 average()
聚合方法 方法 说明 rangeClosed(a,b) 返回子序列 [a,b]，包含起始值，增长步值为 1 range(a,b) 返回子序列 [a,b)，左闭右开，意味着不包括 b sum 计算所有元素的总和 sorted 排序元素 这些方法使用示例如下
IntStreamDemo.java 1package com.ddkk.util.stream; 2import java.util.stream.IntStream; 3public class IntStreamDemo { 4 public static void main(String[] args) { 5 System.out.println(&amp;#34;--Using IntStream.rangeClosed--&amp;#34;); 6 IntStream.</description></item><item><title>二、Linux(CentosUbuntu) Memcached 安装</title><link>https://www.hotmindshare.com/docs/java/memcached/2/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.hotmindshare.com/docs/java/memcached/2/</guid><description>Memcached 支持许多平台：Linux、FreeBSD、Centos、Ubuntu 、Solaris、Mac OS
当然也支持安装在 Windows 上
Linux 系统安装 Memcached，首先要先安装 libevent 库
安装 libevent Ubuntu / Debian 系统 1sudo apt-get install libevent libevent-devel Redhat / Fedora / Centos 系统 1yum install libevent libevent-devel FreeBSD 系统 1portmaster databases/libevent databases/libevent-devel MacOS 系统 1brew install libevent 安装 Memcached 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 使用软件管理器自动安装 Ubuntu / Debian 自动安装 1sudo apt-get install memcached Redhat / Fedora / Centos 自动安装 1yum install memcached FreeBSD 自动安装 1portmaster databases/memcached MacOS 使用 brew 安装 1brew install libmemcached memcached Linux 源代码安装 从[官方网站 (http://memcached.</description></item><item><title>二、Netty 教程 – NIO类库简介</title><link>https://www.hotmindshare.com/docs/java/netty/2/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.hotmindshare.com/docs/java/netty/2/</guid><description>作者：唐亚峰 | 出自：唐亚峰博客
在上一篇文章中介绍了传统I/O编程的弊端，本章将概述NIO的由来和和一些基本概念……
类库简介 2002年的时候，Sum公司推出了JDK1.4并且新增了NIO的类库，弥补了原来同步阻塞I/O带来的不足，官方称之为New I/O，寓意指新的I/O编程模型，但是由于旧版的Block I/O在民间更喜欢称它为Non Block I/O（非阻塞I/O）编程模型，在NIO的类库中，将原本java.net.Socket 以及 java.net.ServerSocket 分别升级成 java.nio.SocketChannel 和 java.nio.ServerSocketChannel，它们都支持阻塞与非阻塞模式，前者性能与可靠性较差，后者却恰恰相反，在开发过程中可以选取适合自己的模式，一般来说，低负载、低并发的应用程序可以选择同步阻塞IO以降低编程复杂度。但是对于高负载、高并发的网络应用，需要使用NIO的非阻塞模式进行开发….
Buffer Buffer是一个含读写数据操的作对象，在NIO库中，所有的对象都是用缓冲处理的，读写数据操作时都是通过缓冲区来处理，实际上它是一个数组，但通常它是一个字节数组（ByteBuffer），也可以使用其它种类的数组，但是一个缓冲区不仅仅是一个数组，缓冲区提供了对数据结构化访问及维护读写位置（limit）等信息…
Channel Channel是一个全双工的通道（同时支持双向传输，在BIO中都是单向流，即InputStream 和 OutputStream），因为是双向的，所以它可以更好的映射底层操作系统的API，特别是在UNIX网络编程模型中，底层操作系统的通道都是双全工的，同时支持读写…
Selector Selector是NIO中的基础，对NIO编程至关重要，它是一个多路复用器，提供选择已经准备就绪的任务功能，会不断轮训注册在它上面的Channel，如果某个Channel上面有新的TCP请求接入，它就会处于就绪状态，供Selector轮训出来，然后可与通过SelectorKey获取就绪的Channel集合，从而进行I/O操作…
异步非阻塞服务端实现 注意事项
与Selector 使用的 Channel 必须处于非阻塞模式 每次使用Selector时应该先判断下Selector是否已经被关闭，否则容易出现java.nio.channels.ClosedSelectorException错误 1public static void main(String[] args) { 2 int port = 4040; 3 MultiplexerTimeServer timeServer = new MultiplexerTimeServer(port); 4 new Thread(timeServer,&amp;#34;NIO-MultiplexerTimeServer-1&amp;#34;).start(); 5} 通过TimeServer的时序图，我们来看下实现的异步非阻塞的TimeServer代码
1public class MultiplexerTimeServer implements Runnable { 2 private Selector selector; 3 private ServerSocketChannel serverSocketChannel; 4 public MultiplexerTimeServer(int port) { 5 try { 6 selector = Selector.</description></item><item><title>二、Tomcat源码分析-tomcat框架设计</title><link>https://www.hotmindshare.com/docs/java/tomcat/2/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.hotmindshare.com/docs/java/tomcat/2/</guid><description>总体架构 tomcat的总体架构如下图所示（摘自http://blog.csdn.net/jiaomingliang/article/details/47393141）
如上图所示，tomcat由Server、Service、Engine、Connerctor、Host、Context组件组成，其中带有s的代表在一个tomcat实例上可以存在多个组件，比如Context(s)，tomcat允许我们部署多个应用，每个应用对应一个Context。这些组件在tomcat的conf/server.xml文件中可以找到，对tomcat的调优需要改动该文件
1server.xml 2&amp;lt;Service name=&amp;#34;Catalina&amp;#34;&amp;gt; 3 &amp;lt;Connector port=&amp;#34;8080&amp;#34; protocol=&amp;#34;HTTP/1.1&amp;#34; 4 connectionTimeout=&amp;#34;20000&amp;#34; 5 redirectPort=&amp;#34;8443&amp;#34; /&amp;gt; 6 &amp;lt;Connector port=&amp;#34;8080&amp;#34; protocol=&amp;#34;HTTP/1.1&amp;#34; 7 connectionTimeout=&amp;#34;20000&amp;#34; 8 redirectPort=&amp;#34;8443&amp;#34; /&amp;gt; 9 &amp;lt;Connector port=&amp;#34;8009&amp;#34; protocol=&amp;#34;AJP/1.3&amp;#34; redirectPort=&amp;#34;8443&amp;#34; /&amp;gt; 10 &amp;lt;Engine name=&amp;#34;Catalina&amp;#34; defaultHost=&amp;#34;localhost&amp;#34;&amp;gt; 11 &amp;lt;Realm className=&amp;#34;org.apache.catalina.realm.LockOutRealm&amp;#34;&amp;gt; 12 &amp;lt;Realm className=&amp;#34;org.apache.catalina.realm.UserDatabaseRealm&amp;#34; 13 resourceName=&amp;#34;UserDatabase&amp;#34;/&amp;gt; 14 &amp;lt;/Realm&amp;gt; 15 &amp;lt;Host name=&amp;#34;localhost&amp;#34; appBase=&amp;#34;webapps&amp;#34; 16 unpackWARs=&amp;#34;true&amp;#34; autoDeploy=&amp;#34;true&amp;#34;&amp;gt; 17 &amp;lt;Valve className=&amp;#34;org.apache.catalina.valves.AccessLogValve&amp;#34; directory=&amp;#34;logs&amp;#34; 18 prefix=&amp;#34;localhost_access_log&amp;#34; suffix=&amp;#34;.txt&amp;#34; 19 pattern=&amp;#34;%h %l %u %t &amp;#34;%r&amp;#34; %s %b&amp;#34; /&amp;gt; 20 &amp;lt;/Host&amp;gt; 21 &amp;lt;/Engine&amp;gt; Server Server组件对应org.</description></item><item><title>二十、Java 8 函数接口 （ Functional interface ）</title><link>https://www.hotmindshare.com/docs/java/java8/20/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.hotmindshare.com/docs/java/java8/20/</guid><description>Java 8 引入了 「 函数接口 」 ( funtional interface ) 的概念，「 函数接口 」就是那些有且只有显式定义一个方法的接口。
例如，具有单个方法 compareTo() 的接口 Comparable 接口，它只有一个功能，就是用于比较。
这种函数接口一般用于 Java 8 中的 Lambda 表达式 。 而且 Java 8 为了支持 Lambda 表达式，更是定义了许多函数接口。这些接口基本都在 java.util.function 包中。
函数接口 函数接口为 Java 8 Lambda 表达式和方法引用提供目标类型。每个函数接口都有一个 虚 ( abstract ) 方法，成为该函数接口的函数方法。用于适配该类型的 Lambda 表达式的参数类型和返回值类型。
函数接口可以在多个上下文中提供目标类型，例如赋值上下文，方法调用或强制转换上下文。
我们写一小段代码演示下
1// Assignment context 2Predicate&amp;lt;String&amp;gt; p = String::isEmpty; 3// Method invocation context 4stream.filter(e -&amp;gt; e.getSize() &amp;gt; 10)... 5// Cast context 6stream.map((ToIntFunction) e -&amp;gt; e.</description></item><item><title>二十、Java 9 新特性 – 其它特性</title><link>https://www.hotmindshare.com/docs/java/java9/20/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.hotmindshare.com/docs/java/java9/20/</guid><description>除了上面介绍的这些比较大的特性，Java 9 还存在着一些比较小的特性，我们就不一一展开了，只将它们罗列再此
1、 对GC（垃圾收集器）改进；
2、 堆遍历(Stack-Walking)API；
3、 过滤输入的序列化数据；
4、 废弃了AppletAPI；
5、 IndifyStringConcatenation；
6、 EnhancedMethodHandles；
7、 Java平台日志记录API和服务器(Service)；
8、 紧凑的字符串(CompactStrings)；
9、 Nashorn的解析API；
结束语 从这短短的十几篇讲解，我们可以看到 Java 9 的新特性并没有 Java 8 那么多
大多数都是对 Java 8 的增强而已。所以，是一个被忽略的改版。
因为在语法在没有大的更新，所以，其实，学习与不学习，都无关紧要了
重要的是，用的时候会查询就可以了</description></item><item><title>二十、Memcached stats sizes 命令</title><link>https://www.hotmindshare.com/docs/java/memcached/20/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.hotmindshare.com/docs/java/memcached/20/</guid><description>Memcached stats sizes 命令用于显示所有 item 的 大小 和 个数
语法 1stats sizes 该命令返回两列，第一列是 item 的大小，第二列是 item 的个数
Memcached 1.4.27 及以后的版本自动开启了 stats sizes 功能 这之前的版本需要在 Memcached 启动时带上 -o track_sizes 则来开启
范例 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 1flush_all 2OK 3set site 0 1000 11 4ddkk.com 5STORED 6set age 0 1000 2 728 8STORED 9stats sizes 10STAT 96 2 item 大小 96, 总共有2个key 11END 1、4.27 之前的版本，如果启动 memcached 时没有设置 -o track_sizes 选项会是如下结果
1flush_all 2OK 3set site 0 1000 11 4ddkk.</description></item><item><title>二十二、Java 连接 Memcached 服务</title><link>https://www.hotmindshare.com/docs/java/memcached/22/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.hotmindshare.com/docs/java/memcached/22/</guid><description>Memcached 是简单的 key-value 内存缓存系统
JAVA 操作 Memcached 有两大类库:
Spymemcached Spymemcached是 Memcached 的一个流行的Java client库 XMemcached 原淘宝的伯岩/庄晓丹开发的XMemcached，性能表现出色，广泛应用于 Java + Memcached 项目中 我们接下来的范例使用 2.0.13 版本的 Spymemcached 包
把 Spymemcached 添加 classpath 中 1. 先下载 Spymemcached 本站下载地址
https://ddkk.com/static/download/spymemcached-2.10.3.jar
Google Code jar 包下载地址
https://storage.googleapis.com/google-code-archive-downloads/v2/code.google.com/spymemcached/spymemcached-2.10.3.jar
可能无法下载，原因你懂得
2. 然后将 spymemcached-2.10.3.jar 拖到 classpath 环境变量中 Memcached 服务 假设你已经安装了 Memcached，如果你没有安装，可以到 Linux(Centos/Ubuntu) Memcached 安装 学习如何安装 Memcached
我们的范例的 Memcached 服务的主机为 127.0.0.1 端口为 11211
Java 连接 Memcached 范例 1package com.ddkk.demo; 2import net.spy.memcached.MemcachedClient; 3import java.</description></item><item><title>二十三、PHP 连接 Memcached 服务</title><link>https://www.hotmindshare.com/docs/java/memcached/23/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.hotmindshare.com/docs/java/memcached/23/</guid><description>在前面章节中我们已经介绍了如何安装 Memcached 服务,也介绍了 Memcached 的各种命令
现在我们为大家介绍 PHP 如何使用 Memcached 服务。
PHP Memcached 客户端 PHPMemcached 的客户端有两个：
1、 PHP-Memcache；
2、 PHP-Memcached推荐；
我们推荐大家使用 PHP-Memcached
PHP Memcached 扩展安装 PHPMemcached 扩展包下载地址： http://pecl.php.net/package/memcached ，你可以下载最新稳定包(stable)
1#下载 2wget http://pecl.php.net/get/memcached-3.0.3.tgz 3# 解压 4tar -zxvf memcached-3.0.3.tgz 5cd memcached-3.0.3 6# 生成编译配置文件 7/usr/local/php/bin/phpize 8./configure --with-php-config=/usr/local/php/bin/php-config 9# 编译安装 10make &amp;amp;&amp;amp; make install 注意： /usr/local/php/ 为php的安装路径，需要根据你安装的实际目录调整
如果你使用的是 PHP7 如果你是 PHP7 版本，则需要下载指定分支：
1git clone -b php7 https://github.com/php-memcached-dev/php-memcached.git 如果你的系统还未编译 libmemcached，则下载编译它：
https://launchpad.net/libmemcached/+download
配置 php.ini 安装成功后会显示你的 memcache.so 扩展的位置，例如：</description></item><item><title>二十一、Memcached flush_all 命令</title><link>https://www.hotmindshare.com/docs/java/memcached/21/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.hotmindshare.com/docs/java/memcached/21/</guid><description>Memcached flush_all 命令用于清空缓存。
也就是删除缓存中的所有 key=&amp;gt;value(键=&amp;gt;值) 对
语法 1flush_all [time] [noreply] time 参数是可选的，单位秒。 如果设置了值，则表示 Memcached 将在这个时间后才执行清空操作 noreply 参数是可选的，如果设置了值，则表示 Memcached 服务不用返回信息 flush_all noreply 命令没有任何效果的,因为它本来就没数据返回
范例 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 1 . 不带任何参数 1set site 0 1000 11 2ddkk.com 3STORED 4get site 5VALUE site 0 11 6ddkk.com 7END 8flush_all 9OK 10get site 11END 2. 10s 后清空缓存 1set site 0 1000 11 2ddkk.com 3STORED 4get site 5VALUE site 0 11 6ddkk.com 7END 8flush_all 10 设置 10秒后清空缓存 9OK 10get site 立刻获取有返回 11VALUE site 0 11 12ddkk.</description></item><item><title>九、Java 8 方法引用</title><link>https://www.hotmindshare.com/docs/java/java8/9/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.hotmindshare.com/docs/java/java8/9/</guid><description>Java 8 中新增加了 方法引用 这个概念。 但，什么是方法引用呢 ？
我们先来看一个例子，下面这个范例演示了如何遍历字符串列表并进行一些操作
LambdaTester.java 1import java.util.Arrays; 2import java.util.List; 3import java.util.function.Function; 4public class LambdaTester { 5 public static void main(String[] args) 6 { 7 LambdaTester tester = new LambdaTester(); 8 tester.run(); 9 } 10 public void run() 11 { 12 List&amp;lt;String&amp;gt; list = Arrays.asList(&amp;#34;Ram&amp;#34;,&amp;#34;Shyam&amp;#34;,&amp;#34;Kabir&amp;#34;); 13 // 输出 14 for(String st: list){ 15 System.out.println(st); 16 } 17 // 转换为大写 18 for(String st: list){ 19 upperAndPrint(st); 20 } 21 } 22 public static void upperAndPrint(String s) 23 { 24 System.</description></item><item><title>九、Java 9 新特性 – 接口 ( interface ) 的私有方法</title><link>https://www.hotmindshare.com/docs/java/java9/9/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.hotmindshare.com/docs/java/java9/9/</guid><description>在我的印象中，好像，从来没有，想过在 interface 中定义私有的方法。一来各种文档中的确没有这么介绍过，二来，好像从来没有谁这么做过，三来，好像定义了也不知道要怎么使用，毕竟，接口 interface 中的方法都会被具体的类重写一次，所以，似乎，私有方法都没啥大作用了。
比如说，很简单的，我们的 Java 基础教程: Java 接口 中，就没有论述私有方法这回事。
既然Java 9 添加了这项特性，那么，应该就有它的用途，我们一起来看看 Java 9 中的接口的私有方法是什么样的吧。
JDK 7 / JDK 6 回忆一下，Java 8 之前 ，接口好像就只允许两种类型的数据，一个是常量、另一个就是公开 ( public ) 的虚方法 ( abstract )，而且是虚方法哦，就是没有任何实现的方法，因为这些方法要被类来实现。
也就是说，Java 8 之前的版本不存在有着默认实现的方法
我们来看看一个示例，在我们的工作区创建一个文件 InterfacePrivateMethodTester.java ，并输入一下内容
1public class InterfacePrivateMethodTester { 2 public static void main(String []args) { 3 LogOracle log = new LogOracle(); 4 log.logInfo(&amp;#34;&amp;#34;); 5 log.logWarn(&amp;#34;&amp;#34;); 6 log.logError(&amp;#34;&amp;#34;); 7 log.logFatal(&amp;#34;&amp;#34;); 8 LogMySql log1 = new LogMySql(); 9 log1.</description></item><item><title>九、Memcached append 命令</title><link>https://www.hotmindshare.com/docs/java/memcached/9/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.hotmindshare.com/docs/java/memcached/9/</guid><description>Memcached append 命令用于向已存在 key(键) 的 value(数据值) 后面追加数据
语法 1append key flags exptime bytes [noreply] 2value 参数说明 key： 键值 key-value 结构中的 key flags ：可以包括键值对的整型参数，客户机使用它存储关于键值对的额外信息 exptime ：在缓存中保存键值对的时间长度（以秒为单位，0 表示永远） bytes ：在缓存中存储的字节数 noreply ：可选， 该参数告知服务器不需要返回数据 value ：存储的值（始终位于第二行）（可直接理解为key-value结构中的value） 返回值说明 如果数据添加成功，返回 STORED 如果键不存在，返回 NOT_STORED 如果执行错误，返回 CLIENT_ERROR 范例 1. 如果数据添加成功，返回 STORED 1flush_all 2OK 3set greeting 0 1000 6 4hello, 5STORED 6append greeting 0 1000 11 7ddkk.com 8STORED 9get greeting 10VALUE greeting 0 17 11hello,ddkk.com 12END 2. 如果键不存在，返回 NOT_STORED 1flush_all 2OK 3append greeting 0 1000 11 4ddkk.</description></item><item><title>九、Netty 教程 – 实现WebSocket通讯</title><link>https://www.hotmindshare.com/docs/java/netty/9/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.hotmindshare.com/docs/java/netty/9/</guid><description>作者：唐亚峰 | 出自：唐亚峰博客
WebSocket是 Html5 开始提供的一种浏览器与服务器间进行全双工通信的网络技术，支持数据在客户端与服务端双向传输，只要握手成功，两端会打开一个长连接进行持续交互…..
WebSocket WebSocket协议是基于TCP的一种新的网络协议，它实现了浏览器与服务器全双工(full-duplex)通信，允许服务器主动发送信息给客户端
优点及作用 Http协议的弊端：
Http协议为半双工协议。（半双工：同一时刻，数据只能在客户端和服务端一个方向上传输） Http协议冗长且繁琐 易收到攻击，如长轮询 非持久化协议 WebSocket的特性：
单一的 TCP 连接，采用全双工模式通信 对代理、防火墙和路由器透明 无头部信息和身份验证 无安全开销 通过 ping/pong 帧保持链路激活 持久化协议，连接建立后，服务器可以主动传递消息给客户端，不再需要客户端轮询 实现原理 在实现Websocket连线过程中，需要通过浏览器发出Websocket连线请求，然后服务器发出回应，这个过程通常称为握手 。在 WebSocket API，浏览器和服务器只需要做一个握手的动作，然后，浏览器和服务器之间就形成了一条快速通道。两者之间就直接可以数据互相传送。在此WebSocket 协议中，为我们实现即时服务带来了两大好处：
1、 Header互相沟通的Header是很小的-大概只有2Bytes；
1GET ws://localhost:5050/websocket HTTP/1.1 2Host: localhost:5050 3Connection: Upgrade 4Pragma: no-cache 5Cache-Control: no-cache 6Upgrade: websocket 7Origin: http://localhost:63342 8Sec-WebSocket-Version: 13 9User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/61.0.3163.79 Safari/537.36 10Accept-Encoding: gzip, deflate, br 11Accept-Language: zh-CN,zh;q=0.8 12Cookie: Idea-d796403=9d25c0a7-d062-4c0f-a2ff-e4da09ea564e 13Sec-WebSocket-Key: IzEaiuZLxeIhjjYDdTp+1g== 14Sec-WebSocket-Extensions: permessage-deflate; client_max_window_bits Sec-WebSocket-Key 是随机生成的，服务端会使用它加密后作为 Sec-WebSocket-Accept 的值返回；</description></item><item><title>九、Tomcat源码分析-类加载器</title><link>https://www.hotmindshare.com/docs/java/tomcat/9/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.hotmindshare.com/docs/java/tomcat/9/</guid><description>类加载器 在分析tomcat 类加载之前，我们简单的回顾下 java 体系的类加载器
启动类加载器（Bootstrap ClassLoader)：加载对象是java的核心类库，把一些的 java 类加载到 jvm 中，它并不是我们熟悉的 ClassLoader，而是 jvm 层面由 C/C++ 实现的类加载器，负责加载 $JAVA_HOME/jre/lib 目录下 jvm 指定的类库，它是无法被 java 应用程序直接使用的 扩展类加载器（Extension Classloader）：它是一个 ClassLoader 实例，父加载器是启动类加载器，它负责加载 $JAVA_HOME/jre/lib/ext 目录的类库 应用类加载器（Application ClassLoader）：又叫做系统类加载器(System ClassLoader)，负责加载用户类路径（-cp参数）指定的类库，可以通过 ClassLoader.getSystemClassLoader() 获取，它也是由启动类加载器加载的 自定义类加载器：应用程序根据自己的需求开发的类加载器，可以继承 ClassLoader，当然也可以不继承 下图描述了类加载器的关系图，其中自定义类加载器有N多个
我们知道 java.lang.ClassLoader 有双亲委派机制（准确的说是单亲，因为只有一个parent），这只是 java 建议的规范，我们也可以不遵循这条规则，但是建议遵循该规则。此外，有一点需要注意的是，类加载器不局限于 ClassLoader，我们也可以自己实现一个类加载器，只要你加载出来的 Class 符合 jvm 规范即可
我们在日常开发工作中，经常会遇到类冲突的情况，明明 classpath 下面的类有这个方法，但是一旦跑线上环境就出错，比如NoSuchMethodError、NoClassDefFoundError、NoClassDefFoundError 等。我们可以使用 jvm 参数 -verbose:class 方便地定位该问题，使用该参数可以快速地定位某个类是从哪个jar包加载的，而不是一味地埋头苦干，求百度，找Google。下面是使用 -verbose:class jvm 参数的部分日志输出
1[Loaded org.springframework.context.annotation.CommonAnnotationBeanPostProcessor from file:/D:/tomcat/webapps/touch/WEB-INF/lib/spring-context-4.3.7.RELEASE.jar] 2[Loaded com.alibaba.dubbo.rpc.InvokerListener from file:/D:/tomcat/webapps/touch/WEB-INF/lib/dubbo-2.5.3.jar] 我们有必要了解下关于类加载有几个重要的知识点：
在 Java 中我们用完全类名来标识一个类，而在 JVM 层面，使用完全类名 + CloassLoader 对象实例 ID 作为唯一标识，因此使用不同实例的类加载器，加载的两个同名的类，他们的类实例是不同的，并且不能强制转换 在双亲委派机制中，类加载器查找类时，是一层层往父类加载器查找的，最后才查看自己，如果都找不到则会抛出异常，而不是一层层往下找的 每个运行中的线程都有一个 CloassLoader，并且会从父线程中继承（默认是应用类加载器），在没有显式声明由哪个类加载器加载类时（比如 new 关键字），将默认由当前线程的类加载器加载该类 由于篇幅有限，关于类加载的过程这里不再展开了，可以参考厮大的博客</description></item><item><title>六、Java 8 Lambda 表达式 （ 上 ）- 简介</title><link>https://www.hotmindshare.com/docs/java/java8/6/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.hotmindshare.com/docs/java/java8/6/</guid><description>Lambda 表达式在 Java 8 中引入，并且被吹捧为 Java 8 最大的特性。
Lambda 表达式是函数式编程的的一个重要特性，标志者 Java 向函数式编程迈出了重要的第一步。
Java Lambda 表达式语法 Java Lambda 表达式的语法结构如下
1parameter -&amp;gt; expression body 实际代码可能如下
有参数且只有一条语句时 1(a,b) -&amp;gt; a + b 只有一个参数时 1a -&amp;gt; a 没有参数时 1() -&amp;gt; System.out.println(&amp;#34;DDKK.COM 弟弟快看，程序员编程资料站&amp;#34;) 有多条语句时 1(a,b) -&amp;gt; { 2 int c = a + b; 3 System.out.println(&amp;#34;DDKK.COM 弟弟快看，程序员编程资料站&amp;#34;) 针对这个 Java Lambda 表达式语法，有几个重要的特征需要说明
可选的参数类型声明 ： 无需声明参数的类型。编译器可以从参数的值推断出相同的值。 可选的参数周围的小括号 () ： 如果只有一个参数，可以忽略参数周围的小括号。但如果有多个参数，则必须添加小括号。 可选的大括号 {} : 如果 Lambda 表达式只包含一条语句，那么可以省略大括号。但如果有多条语句，则必须添加大括号。 可选的 return 关键字 ： 如果 Lambda 表达式只有一条语句，那么编译器会自动 return 该语句最后的结果。但如果显式使用了 return 语句，则必须添加大括号 {} ，哪怕只有一条语句。 Java Lambda 表达式的原理 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 后面我们会讲到，Java 8 中的 Lambda 表达式其实是一个特殊的只有一个方法的类的实例。</description></item><item><title>六、Java 9 新特性 – 改进 JavaDocs</title><link>https://www.hotmindshare.com/docs/java/java9/6/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.hotmindshare.com/docs/java/java9/6/</guid><description>一直以来，Java 生成的文档 JavaDoc 一直使用的都是 HTML 4 格式，这次 Java 9 良心大大的发现，使用了 HTML 5 ，但还不是默认的，如果要输出 HTML 5 格式，还必须在命令行程序中添加 -html5 选项。
旧的 JavaDoc 文档格式 我们先在当前工作区，例如我的是 D:\devops\java9 的 src 目录下创建一个文件 JavaDocTester.java ，内容如下
1/** 2 * @author MahKumar 3 * @version 0.1 4*/ 5public class JavaDocTester { 6 /** 7 * 默认的方法用于输出 Hello World 8 * &amp;lt;p&amp;gt;Hello world&amp;lt;/p&amp;gt; 9 * @param args 命令行参数 10 */ 11 public static void main(String []args) { 12 System.out.println(&amp;#34;Hello World&amp;#34;); 13 } 然后我们就可以使用 javadoc 命令输出该类的文档</description></item><item><title>六、Memcached set 命令</title><link>https://www.hotmindshare.com/docs/java/memcached/6/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.hotmindshare.com/docs/java/memcached/6/</guid><description>Memcached set 命令用于将 value(数据值) 存储在指定的 key(键) 中
语法： 1set key flags exptime bytes [noreply] 2value 范例 如果我们设置一个 key 为 site ,值为 ddkk.com, 过期时间为 1000 秒的键值对，那么命令一般如下
1set site 0 1000 11 2ddkk.com 参数说明
key ： 键值 key-value 结构中的 key，用于查找缓存值。 flags ：可以包括键值对的整型参数，客户机使用它存储关于键值对的额外信息 exptime ：在缓存中保存键值对的时间长度（以秒为单位，0 表示永远） bytes ：在缓存中存储的字节数 noreply ：可选， 该参数告知服务器不需要返回数据 value ：存储的值（始终位于第二行）（可直接理解为key-value结构中的value） 返回值说明 如果数据设置成功，返回 STORED 如果 key 已经存在，不管有没有过期都会更新数据，返回值为 STORED 如果执行错误，返回 CLIENT_ERROR 范例 1. 如果数据设置成功，返回 STORED 1flush_all 2OK 3set site 0 1000 11 4ddkk.</description></item><item><title>六、Netty 教程 – 序列化-JDK自带</title><link>https://www.hotmindshare.com/docs/java/netty/6/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.hotmindshare.com/docs/java/netty/6/</guid><description>作者：唐亚峰 | 出自：唐亚峰博客
在做JAVA开发的时候，接触最多的就是java.io.Serializable，通过该接口生成序列化ID，然后就可以通过java.io.ObjectInput与java.io.ObjectOutput进行序列化与反序列化，无需考虑跨语言调用，对序列化性能要求不高的情况，使用默认的是最方便的，虽然存在弊端，但也能满足大部分的需要….
为了更好的掌握Netty序列化相关知识，本章使用Netty给我们提供的ObjectEncoder与ObjectDecoder对订单请求与应答消息进行序列化操作…
开发例程 在服务端ChannelPipeline新增解码器io.netty.handler.codec.serialization.ObjectDecoder 在服务端ChannelPipeline新增解码器io.netty.handler.codec.serialization.ObjectEncoder 实体类实现java.io.Serializable序列化接口 1、 创建OrderRequest与OrderResponse两个Java类；
1public class OrderRequest implements java.io.Serializable { 2 private static final long serialVersionUID = 1826067782744144943L; 3 private Integer orderId; 4 private String userName; 5 private String productName; 6 private String phoneNumber; 7 private String address; 8 //省略 get set .. 9} 1public class OrderResponse implements java.io.Serializable { 2 private static final long serialVersionUID = -5003946216600820264L; 3 private Integer orderId; 4 private String respCode; 5 private String desc; 6} OrderServer 1、 重写ChannelInitializer中的initChannel方法，添加ObjectDecoder解码器与ObjectEncoder编码器；</description></item><item><title>六、Tomcat源码分析-启动分析(四) webapp</title><link>https://www.hotmindshare.com/docs/java/tomcat/6/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.hotmindshare.com/docs/java/tomcat/6/</guid><description>前言 上一篇文章中我们分析了 Service、Engine、Host、Pipeline、Valve 组件的启动逻辑，在 HostConfig 中会实例化 StandardContext，并启动 Context 容器，完成 webapp 应用程序的启动，这一块是最贴近我们开发的应用程序。在这一篇文章中，我们将要分析 tomcat 是如何解析并初始化应用程序定义的 Servlet、Filter、Listener 等
首先我们思考几个问题：
1、 tomcat如何支持servlet3.0的注解编程，比如对javax.servlet.annotation.WebListener注解的支持？；
如果 tomcat 利用 ClassLoader 加载 webapp 下面所有的 class，从而分析 Class 对象的注解，这样子肯定会导致很多问题，比如 MetaSpace 出现内存溢出，而且加载了很多不想干的类，我们知道 jvm 卸载 class 的条件非常苛刻，这显然是不可取的。因此，tomcat 开发了字节码解析的工具类，位于 org.apache.tomcat.util.bcel，bcel 即 ：Byte Code Engineering Library，专门用于解析 class 字节码，而不是像我们前面猜测的那样，把类加载到 jvm 中
1、 假如webapp目录有多个应用，使用的开源框架的jar版本不尽一致，tomcat是怎样避免出现类冲突？；
不同的 webapp 使用不同的 ClassLoader 实例加载 class，因此 webapp 内部加载的 class 是不同的，自然不会出现类冲突，当然这里要排除 ClassLoader 的 parent 能够加载的 class。关于 ClassLoader 这一块，后续会专门写一篇博客进行分析
1、Context 容器 首先，我们来看下StandardContext重要的几个属性，包括了我们熟悉的 ServletContext、servlet容器相关的Listener(比如 SessionListener 和 ContextListener)、FilterConfig</description></item><item><title>七、Java 8 Lambda 表达式 （ 中 ）- 外部参数</title><link>https://www.hotmindshare.com/docs/java/java8/7/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.hotmindshare.com/docs/java/java8/7/</guid><description>在Java 8 Lambda 表达式 （ 上 ）- 简介 章节中我们讲解了 Java 8 Lambda 表达式的一些基础知识。我们也了解 Java 8 Lambda 表达式的一些使用场景：
Java Lambda 表达式主要用于定义函数接口的内联实现。而函数接口，就是只包含了一个方法的接口。在前一章节中，我们使用了各种类型的 lambda 表达式来定义 MathOperation 接口的 operation 方法。 Java Lambda 表达式消除了对 匿名类 的需求，并为 Java 提供了非常简单但功能强大的函数编程功能。 Java 8 Lambda 表达式作用域 ( scope ) 因为Java 8 的 lambda 表达式其实是函数接口的内联实现，也就是匿名内部类，因此，可以引用任何外部的变量或者常量。
但是，lambda 对这些外部的变量是有要求的： 它们必须使用 final 修饰符修饰。
如果一个变量允许被第二次赋值，则 Lambda 表达式会抛出编译错误。
注意： 其实这条规则并不是非常严格执行的，普通变量也是可以的，只要，只要不进行第二次赋值就可以。
注意： 刚刚测试了下，其实只要不是当前作用域声明的变量，可以随意第二次赋值，也不会报错
范例一 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 Java 8 lambda 表达式使用外部 final 变量
LambdaTester.java 1public class LambdaTester 2 final static String salutation = &amp;#34;你好，&amp;#34;; 3 public static void main(String args[]) 4 { 5 GreetingService greetService1 = message -&amp;gt; 6 System.</description></item><item><title>七、Java 9 新特性 – 多版本共存 JAR</title><link>https://www.hotmindshare.com/docs/java/java9/7/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.hotmindshare.com/docs/java/java9/7/</guid><description>Java 9 之前的 JAR 格式中只能包含一个 Java 版本，显然，这是不符合 Java 这种开启了版本帝的发展线路了，想想，现在大多数 Java 还停留在 Java 6 7 8 的年代，Java 10 已经发布，如果要发布一个 JAR 格式的类库，意味着要编译多个版本的 JAR， 6 7 8 9 10 五个版本，看起来也太恐怖了。
Java 9 突然间良心发现，开始支持多版本共存的 JAR 了。
Java 9 引入了一个新的功能，其实也不算吧，就是增强了 JAR 格式，可以在同一个 JAR 中维护和使用不同版本的 java 类或资源
JAR 多版本共存原理 首先在JAR 中，文件 MANIFEST.MF 文件的 main 节中有一个条目 Multi-Release:true ， 用于指定该 JAR 包是多 Java 版本共存的
同时，JAR 目录下的子目录 META-INF 还包含一个 versions 子目录，其子目录 ( 从 9 开始，用于 Java 9 ) 存储特定于版本的类和资源文件</description></item><item><title>七、Memcached add 命令</title><link>https://www.hotmindshare.com/docs/java/memcached/7/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.hotmindshare.com/docs/java/memcached/7/</guid><description>Memcached add 命令用于将 value(数据值) 存储在指定的 key(键) 中
语法 1add key flags exptime bytes [noreply] 2value 参数说明 key ： 键值 key-value 结构中的 key flags ：可以包括键值对的整型参数，客户机使用它存储关于键值对的额外信息 exptime ：在缓存中保存键值对的时间长度（以秒为单位，0 表示永远） bytes ：在缓存中存储的字节数 noreply ：可选，该参数告知服务器不需要返回数据 value ：存储的值（始终位于第二行）（可直接理解为key-value结构中的value） 返回值说明 如果数据添加成功，返回 STORED 如果 key 已经存在，且没过期，则不会更新数据，返回值为 NOT_STORED 如果 key 已经存在，但已经过期，那么替换成功，返回值为 STORED 如果执行错误，返回 CLIENT_ERROR 范例 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 1. 如果数据添加成功，返回 STORED 1add site 0 1000 11 2ddkk.com 3STORED 2. 如果 key 已经存在，且没过期 如果key 已经存在，且没过期，则不会更新数据，返回值为 NOT_STORED
1flush_all 2OK 3add site 0 1000 11 4ddkk.</description></item><item><title>七、Netty 教程 – 序列化-Protobuf</title><link>https://www.hotmindshare.com/docs/java/netty/7/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.hotmindshare.com/docs/java/netty/7/</guid><description>作者：唐亚峰 | 出自：唐亚峰博客
上一章中，我们介绍了JAVA自带序列化，在java中我们如果需要序列化只需要继承Serializable接口就可以通过输入输出流进行序列化和反序列化，但在提供简单调用的同时也存在很多问题，本章将会逐渐的介绍….
为了更好的掌握Netty序列化相关知识，本章使用Netty给我们提供的ObjectEncoder与ObjectDecoder对订单请求与应答消息进行序列化操作…
Java序列化的弱点 不支持跨语言，当我们进行跨应用之间的服务调用的时候如果另外一个应用使用PHP语言来开发，这个时候我们发送过去的序列化对象，别人是无法进行反序列化的因为其内部实现对于别人来说完全就是黑盒。 序列化效率低下，字节流过大，这个我们可以做一个实验，还是上一节中的OrderRequest类，我们分别用java的序列化和使用二进制编码来做一个对比 序列化后字节码对比
1@Test 2public void test1() throws IOException { 3 Order order = new Order(1, &amp;#34;Levin&amp;#34;, &amp;#34;Netty Book&amp;#34;, &amp;#34;130****1912&amp;#34;, &amp;#34;China&amp;#34;); 4 ByteArrayOutputStream out = new ByteArrayOutputStream(); 5 ObjectOutputStream os = new ObjectOutputStream(out); 6 os.writeObject(order); 7 os.flush(); 8 System.out.println(&amp;#34;JDK序列化后的长度： &amp;#34; + out.toByteArray().length); 9 os.close(); 10 out.close(); 11 ByteBuffer buffer = ByteBuffer.allocate(1024); 12 buffer.put(order.getAddress().getBytes()); 13 buffer.put(order.getPhoneNumber().getBytes()); 14 buffer.put(order.getUserName().getBytes()); 15 buffer.put(order.getProductName().getBytes()); 16 buffer.flip(); 17 byte[] result = new byte[buffer.</description></item><item><title>七、Tomcat源码分析-spring boot集成tomcat</title><link>https://www.hotmindshare.com/docs/java/tomcat/7/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.hotmindshare.com/docs/java/tomcat/7/</guid><description>前言 本文基于 spring boot 1.5.9
spring boot 支持目前主流的 servlet 容器，包括 tomcat、jetty、undertow，可以在我们的项目中方便地集成这些 servlet 容器，减少了开发、运维的工作量。而传统的应用开发，需要经过繁锁的操作步骤：安装 tomcat –&amp;gt; 修改 tomcat 配置 –&amp;gt; 部署 war 包 –&amp;gt; 启动 tomcat –&amp;gt; 运维……，这个工作量不小，尤其是集群部署、应用迁移的时候。而采用 spring boot 之后，一切变得如此简单，打包 –&amp;gt; java -jar –&amp;gt; 运维，只需要一个 jar 包便可以随意部署安装。这篇文章，将对 spring boot 集成 tomcat 的源码进行分析，探索其内部的原理
SPI 在分析源码前，我们先来了解下 spring 的 SPI 机制。我们知道，jdk 为了方便应用程序进行扩展，提供了默认的 SPI 实现（ServiceLoader），dubbo 也有自己的 SPI。spring 也是如此，他为我们提供了 SpringFactoriesLoader，允许开发人员通过 META-INF/spring.factories 文件进行扩展，下面举一个例子方便理解
假如，我想要往 spring 容器中添加一个 ApplicationContextInitializer 做一些初始化工作，我们可以借助 spring 提供的这个 SPI 功能完成这个需求。
首先，在项目中创建 META-INF/spring.factories 文件，文件内容如下所示：
1org.springframework.context.ApplicationContextInitializer=\ 我们再写个 test case，便可以通过 SPI 的方式获取我们定义的 ApplicationContextInitializer。看似很简单的一个功能，但是 spring boot 正是利用这个强大的扩展点，在 spring framework 的基础上为我们集成了常用的开源框架</description></item><item><title>三、Java 9 新特性 – 环境配置</title><link>https://www.hotmindshare.com/docs/java/java9/3/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.hotmindshare.com/docs/java/java9/3/</guid><description>Java 9 的环境安装和配置其实很简单，因为跟 Java 7 / Java 8 的安装差不多，我们就不做过多的介绍了。
相关的安装教程，可以参考我们的 Java 基础教程：Java 开发环境配置
因为Java 当前的最新大版本为 Java 10 ，所以，我们建议你安装 Java 10 ，它同时也包含了 Java 9 的新特性
编辑器 顺便说一下，我们接下来的教程不会使用大型的 IDE ，比如 Idea 和 Netbeans 和 Eclipse 等，而只会使用一些较小的文本编辑器，比如 Sublime Text 3 和 Visual Studio Code
关于这些文本编辑器，网上的使用教程很多，其实，下载安装就好，没啥大的配置。
项目 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 既然不使用大型的、功能齐全的 IDE ，那么我们也不会建立大型的项目工程，一般情况下，我们直接单个文件解决所有问题，这样方便大家理解，也不会造成部分文件或代码缺失的问题。</description></item><item><title>三、Java8 Collectors.joining() 详解</title><link>https://www.hotmindshare.com/docs/java/java8/3/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.hotmindshare.com/docs/java/java8/3/</guid><description>本章节我们来详细讲讲 Java 8 流 ( stream ) 收集器 ( Collectors ) 中的 joining() 方法。该方法会返回一个 Collectors 实例，方便在流收集器上的链式操作。
Collectors.joining() 方法以遭遇元素的顺序拼接元素。我们可以传递可选的拼接字符串、前缀和后缀
joinning() 方法定义 假设我们的流中有四个元素 [&amp;quot;A&amp;quot;,&amp;quot;B&amp;quot;,&amp;quot;C&amp;quot;,&amp;quot;D&amp;quot;]，那么我们就可以按照以下方式来收集它们
joining() joinning() 无参数方法会返回一个 Collectors 实例，并且以空字符串 ( &amp;quot;&amp;quot; ) 来拼接收集到的所有元素
JoiningExample.java 1package com.ddkk.util.stream; 2import java.util.Arrays; 3import java.util.List; 4import java.util.stream.Collectors; 5public class JoiningExample { 6 public static void main(String[] args) { 7 List&amp;lt;String&amp;gt; list = Arrays.asList(&amp;#34;A&amp;#34;,&amp;#34;B&amp;#34;,&amp;#34;C&amp;#34;,&amp;#34;D&amp;#34;); 8 String result= list.stream().collect(Collectors.joining()); 9 System.out.println(result); 10 } 输出结果为 ABCD
joining(CharSequence delimiter) 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 joining(CharSequence delimiter) 接受一个参数字符串序列作为拼接符，并返回一个 Collectors 实例。假如我们传递的拼接符为 &amp;quot;-&amp;quot; 。那么输出结果为 A-B-C-D</description></item><item><title>三、Netty 教程 – 初窥Netty编程</title><link>https://www.hotmindshare.com/docs/java/netty/3/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.hotmindshare.com/docs/java/netty/3/</guid><description>作者：唐亚峰 | 出自：唐亚峰博客
在上一篇文章中介绍了NIO类库简介，从本章开始都围绕Netty展开讨论和概述……
什么是Netty Netty是业界有名且最流行的NIO框架之一，健壮，稳定，高性能，可定制，可扩展在同类框架都是首屈一指，而且成功的运用在各大商业项目中，比如Hadoop的RPC框架avro，当当接盘的DubboX都在使用…
Netty 的优点
API使用简单，开发门槛低 功能强大，多种解码与编码器 支持多种主流的通讯协议 定制能力强大，可以通过ChannelHandler对通讯框架灵活的扩展 相比业界主流NIO框架，Netty综合评价更高 成熟稳定，社区活跃 Netty 缺点
5.x 模型存在问题，已被废弃 编译 GIT：https://github.com/netty/netty
如果需要编译Netty，需要最低JDK1.7，在运行时Netty3.x只需要JDK1.5，同时博客参考 李林峰 大神的 《Netty权威指南第二版》…
因为主要是学习Netty，而不是实战，同时为了更好的适配即将推出的Netty6，用Netty5的API也许会更好点，就当为Netty6做技术储备吧…
如果使用Maven，在项目中需要添加
1&amp;lt;dependencies&amp;gt; 2 &amp;lt;dependency&amp;gt; 3 &amp;lt;groupId&amp;gt;io.netty&amp;lt;/groupId&amp;gt; 4 &amp;lt;artifactId&amp;gt;netty-all&amp;lt;/artifactId&amp;gt; 5 &amp;lt;version&amp;gt;5.0.0.Alpha2&amp;lt;/version&amp;gt; 6 &amp;lt;/dependency&amp;gt; 7&amp;lt;/dependencies&amp;gt; Hello Netty 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 继续用TimeServer 与 TimeClient 为例，改造代码使用Netty实现服务端与客户端的通讯，以及上一章博客遗留的数据丢失问题，在使用Netty后都是不在的…
TimeServer 1public static void bind(int port) { 2 EventLoopGroup masterGroup = new NioEventLoopGroup();//创建线程组 3 EventLoopGroup workerGroup = new NioEventLoopGroup(); 4 try { 5 ServerBootstrap bootstrap = new ServerBootstrap();//创建NIO服务端启动辅助类 6 bootstrap.</description></item><item><title>三、Tomcat源码分析-启动分析(一) Lifecycle</title><link>https://www.hotmindshare.com/docs/java/tomcat/3/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.hotmindshare.com/docs/java/tomcat/3/</guid><description>Lifecycle在其他框架中也很常见，比如spring，它常用于具有生命周期的组件，由Lifecycle控制组件的初始化、启动、销毁等动作，方便应用程序获取、释放某些资源，或者是触发某些特定的事件。Tomcat也是如此，在学习整个启动流程之前，我们先行了解下Lifecycle的实现机制，便于理解整个流程。
Lifecycle Lifecycle接口是一个公用的接口，定义了组件生命周期的一些方法，用于启动、停止Catalina组件。它是一个非常重要的接口，组件的生命周期包括：init、start、stop、destory，以及各种事件的常量、操作LifecycleListener的API，典型的观察者模式
1public interface Lifecycle { 2 // ----------------------- 定义各种EVENT事件 ----------------------- 3 public static final String BEFORE_INIT_EVENT = &amp;#34;before_init&amp;#34;; 4 public static final String AFTER_INIT_EVENT = &amp;#34;after_init&amp;#34;; 5 public static final String START_EVENT = &amp;#34;start&amp;#34;; 6 // 省略事件常量定义…… 7 /** 8 * 注册一个LifecycleListener 9 */ 10 public void addLifecycleListener(LifecycleListener listener); 11 /** 12 * 获取所有注册的LifecycleListener 13 */ 14 public LifecycleListener[] findLifecycleListeners(); 15 /** 16 * 移除指定的LifecycleListener 17 */ 18 public void removeLifecycleListener(LifecycleListener listener); 19 /** 20 * 组件被实例化之后，调用该方法完成初始化工作，发会出以下事件 21 * &amp;lt;ol&amp;gt; 22 * &amp;lt;li&amp;gt;INIT_EVENT: On the successful completion of component initialization.</description></item><item><title>三、Window 下安装 Memcached</title><link>https://www.hotmindshare.com/docs/java/memcached/3/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.hotmindshare.com/docs/java/memcached/3/</guid><description>Memcached 官网上并未提供 Memcached 的 Window 平台安装包
但已经有热心的网友自己编译了一些 Window 平台的包供大家使用
本站再此列出了大部分版本的下载连接，你需要根据自己的系统平台及需要的版本号点击对应的链接下载即可：
再此感谢下载连接的网站和贡献这些 window 安装包的朋友
在 1.4.5 版本以前 memcached 可以作为一个服务安装 推荐 32位系统 1.4.4版本
http://downloads.northscale.com/memcached-win32-1.4.4-14.zip
64位系统 1.4.4版本：
http://downloads.northscale.com/memcached-win64-1.4.4-14.zip
1.4.5 及之后的版本删除了作为一个服务安装的功能 32位系统 1.4.5版本
http://downloads.northscale.com/memcached-1.4.5-x86.zip
64位系统 1.4.5版本
http://downloads.northscale.com/memcached-1.4.5-amd64.zip
重要1.4.4 和 1.4.5 版本功能上没有多大的区别，如果你为了省事方便，可以下载 1.4.4 的版本
Memcached &amp;lt;1.4.5 版本安装步骤 1、 解压下载的安装包到指定目录，比如d:\dev\memcached；
2、 在1.4.5版本以前memcached可以作为一个服务安装，使用管理员权限运行以下命令：；
1d:\dev\memcached\memcached.exe -d install 注意： 你需要使用真实的 memcached.exe 路径 替代 d:\dev\memcached\memcached.exe
3、 然后我们用以下命令来启动和关闭memcached服务：；
开启Memcached 服务
1d:\dev\memcached\memcached.exe -d start 关闭Memcached 服务
1d:\dev\memcached\memcached.exe -d stop 4、 如果要修改Memcached的配置项,可以在命令行中执行；
1regedit.exe 命令打开注册表并找到 HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\memcached 来进行修改</description></item><item><title>十、Java 8 接口 ( interface ) 默认方法</title><link>https://www.hotmindshare.com/docs/java/java8/10/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.hotmindshare.com/docs/java/java8/10/</guid><description>总所周知，在 Java 7 和之前的版本中，接口 interface 是不能包含具体的方法实现的。
比如，下面的代码，是会报错的。
1public class InterfaceDefaultMethodTester 2 public static void main(String[] args) 3 { 4 } 5 interface Greeter { 6 public void greeter(String name) 7 { 8 Syste.out.println(&amp;#34;你好，&amp;#34; + name ); 9 } 10 } 运行结果如下
1[penglei@ddkk.com helloworld]$ javac InterfaceDefaultMethodTester.java &amp;amp;&amp;amp; java InterfaceDefaultMethodTester 2InterfaceDefaultMethodTester.java:10: 错误: 接口抽象方法不能带有主体 3 { 4 ^ 51 个错误 如果一个接口有多个实现，那么每个实现都要重复的一遍一遍的实现接口中的所有方法，岂不是很痛苦。
在Java 7 及以前的版本，对于一个接口有多个实现的时候，我们通常的做法就是让所有的实现继承另一个基础类，然后在这个基础类中实现这个方法。
这就是，为什么 Java 中的 I/O 那么多类的原因，一个庞大的家族体系，每次看到我都头疼。
但是Java 8 中，我想应该是 Java 8 核心开发者们也厌倦了这种不断的重复实现接口方法和庞大的类家族体系。竟然在 Java 8 中为接口提供了一个新的功能，允许某个接口方法有个默认实现。</description></item><item><title>十、Java 9 新特性 – 改进进程管理 API</title><link>https://www.hotmindshare.com/docs/java/java9/10/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.hotmindshare.com/docs/java/java9/10/</guid><description>Java 9 这个版本对进程管理方面的改进也是相当大的。在为数不多的几次 Java 项目中，有偶尔用到多线程，但对多进程和进程方面的了解还真是太少。
我想，大部分人应该跟我一样，在编程之外知道有进程的东西的存在，在 Java 中反而会忽视，因为多线程和并发 ( Concurrency ) 的存在感更强吧。
这次Java 9 对进程管理的改进主要是提供了 ProcessHandle 类
ProcessHandle 类 该类在java.lang 包中，且处于 java.base 模块中。
ProcessHandle 可以用于获取进程信息，监听和检查进程的状态，并且可以监听进程的退出
主要提供了以下几个方法
方法 说明 static allProcesses() 返回当前进程可见的所有进程的快照 static current() 返回当前进程的 ProcessHandle 实例 static of(long pid) 返回现有本机进程的 Optional &amp;lt;ProcessHandle&amp;gt; children() 返回进程的当前直接子进程的快照 compareTo(ProcessHandle other) 比较两个进程 descendants() 返回当前进程后代的快照 destroy() 请求杀死当前进程 destroyForcibly() 强制杀死该进程 equals(Object other) 如果 other 对象为非 null，且具有相同的实现，并且表示相同的系统进程，则返回 true; 否则返回 false hashCode() 返回此 ProcessHandle 的哈希值 info() 返回有关该进程的信息的快照 isAlive() 测试此 ProcessHandle 表示的进程是否处于活动状态 onExit() 当进程终止时返回 CompletableFuture &amp;lt;ProcessHandle&amp;gt; parent() 返回当前进程的父进程 Optional&amp;lt;ProcessHandle&amp;gt; ，因为当前进程可能是初始进程，所以父进程不一定存在 pid() 返回当前进程的系统进程的 id supportsNormalTermination() 如果 destroy() 正常终止进程，则返回 true ProcessHandle 类用于标识并提供对 native 进程的控制，可以监控每个单独的进程的活跃度，列出其子进程 ( 线程 ) ，获取有关进程的信息或将其销毁。</description></item><item><title>十、Memcached prepend 命令</title><link>https://www.hotmindshare.com/docs/java/memcached/10/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.hotmindshare.com/docs/java/memcached/10/</guid><description>Memcached prepend 命令用于向已存在 key(键) 的 value(数据值) 前面追加数据
语法 1prepend key flags exptime bytes [noreply] 2value 参数说明 key： 键值 key-value 结构中的 key flags ：可以包括键值对的整型参数，客户机使用它存储关于键值对的额外信息 exptime ：在缓存中保存键值对的时间长度（以秒为单位，0 表示永远） bytes ：在缓存中存储的字节数 noreply: 可选，该参数告知服务器不需要返回数据 value ：存储的值（始终位于第二行）（可直接理解为key-value结构中的value） 返回值说明 如果数据添加成功，返回 STORED 如果键不存在，返回 NOT_STORED 如果执行错误，返回 CLIENT_ERROR 范例 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 1. 如果数据添加成功返回 STORED 1flush_all 2OK 3set site 0 1000 7 4souyunku.cn 5STORED 6get site 7VALUE site 0 7 8souyunku.cn 9END 10prepend site 0 1000 4 11www. 12STORED 添加成功 13get site 14VALUE site 0 11 15ddkk.</description></item><item><title>十、Netty 教程 – ByteBuf详解</title><link>https://www.hotmindshare.com/docs/java/netty/10/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.hotmindshare.com/docs/java/netty/10/</guid><description>作者：唐亚峰 | 出自：唐亚峰博客
原生的ByteBuffer存在哪些问题呢，Netty为什么会设计ByteBuf呢，它的工作原理是什么…..
ByteBuffer存在的问题 ByteBuffer是JDK1.4中提供的java.nio.Buffer, 在内存中预留指定大小的存储空间来存放临时数据，其他Buffer的子类有：CharBuffer、DoubleBuffer、FloatBuffer、IntBuffer、LongBuffer 和 ShortBuffer
ByteBuffer的长度是固定的，一旦分配完成，容量就无法动态扩容收缩，分多了会浪费内存，分少了存放大的数据时会索引越界（当传输数据大于初始化长度时，会出现BufferOverflowException索引越界的异常），所以使用ByteBuffer时，为了解决这个问题，我们一般每次put操作时，都会对可用空间进行校检，如果剩余空间不足，需要重新创建一个新的ByteBuffer，然后将旧的ByteBuffer复制到新的ByteBuffer中去 ByteBuffer中只有通过position获得当前可操作的位置，调用get()方法，返回ByteBuffer[postion]处的值，如果是调用put方法,将数据放入ByteBuffer[postion]的位置 API功能有限，部分高级功能并不支持，需开发者自己实现，且使用原生ByteBuffer较为困难（不适合小白专业户） ByteBuf与ByteBuffer的区别 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 不同ByteBuf实现原理各不相同，我们先看最基本的ByteBuf与原生的ByteBuffer的区别
1ByteBuf buf = Unpooled.buffer(10); 2buf.writeBytes(&amp;#34;鏖战八方QQ群391619659&amp;#34;.getBytes());//扩容算法稍后讲解 3System.out.println(&amp;#34;Netty：&amp;#34; + buf); 4byte[] by = new byte[buf.readableBytes()]; 5buf.readBytes(by); 6System.out.println(&amp;#34;Netty：&amp;#34; + new String(by)); 7System.out.println(&amp;#34;//////////////////////////////////////////无耻的分割线//////////////////////////////////////////&amp;#34;); 8ByteBuffer bf1 = ByteBuffer.allocate(100); 9bf1.put(&amp;#34;鏖战八方QQ群391619659&amp;#34;.getBytes()); 10System.out.println(&amp;#34;JDK：&amp;#34;+bf1); 11System.out.println(&amp;#34;当前指针：&amp;#34; + bf1.position()); 12byte[] by1 = new byte[bf1.remaining()]; 13System.out.println(by1.length);//What&amp;#39;s 居然是74 14bf1.get(by1); 15System.out.println(&amp;#34;未使用flip：&amp;#34;+new String(by1));//居然是空的 16System.out.println(&amp;#34;//////////////////////////////////////////无耻的分割线//////////////////////////////////////////&amp;#34;); 17ByteBuffer bf2 = ByteBuffer.allocate(100); 18bf2.put(&amp;#34;鏖战八方QQ群391619659&amp;#34;.getBytes()); 19System.out.println(&amp;#34;JDK：&amp;#34;+bf2); 20System.out.println(&amp;#34;当前指针：&amp;#34; + bf2.position()); 21bf2.flip(); 22byte[] by2 = new byte[bf2.remaining()]; 23System.</description></item><item><title>十、Tomcat源码分析-关于tomcat热加载的一些思考</title><link>https://www.hotmindshare.com/docs/java/tomcat/10/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.hotmindshare.com/docs/java/tomcat/10/</guid><description>在前面的文章中，我们分析了 tomcat 类加载器的相关源码，也了解了 tomcat 支持类的热加载，意味着 tomcat 要涉及类的重复卸装/装载过程，这个过程是很敏感的，一旦处理不当，可能会引起内存泄露
卸载类 我们知道，class 信息存放在元数据区（1.7是 Perm 区），这一块的内存相比堆而言，只占据非常小的空间，但是如果处理不当，还是有可能会导致内存溢出。这让我回想起几年前的一个故障，线上环境启用了 tomcat 的自动 reload 功能，出现过 java.lang.OutOfMemoryError: PermGen space 问题，排查的结果是因为 tomcat 在自动重载应用的时候，没有正常卸载类，导致 Perm 区内存没能被释放而发生溢出。tomcat 会尽量避免这类问题的发生，但是不能百分之百保证不会出现，所以还是建议不要随意开启 reloadable 功能
卸载类的条件很苛刻，必须同时满足以下3点：
1、 该类所有的实例已经被回收；
2、 加载该类的ClassLoder已经被回收；
3、 该类对应的java.lang.Class对象没有任何地方被引用；
针对第1点，保证所有的实例被回收，这点不难，tomcat 在 Context 组件中实例化这些对象，持有直接或间接的引用，所以在热部署的时候，只要回收 Context 组件即可保证实例对象被回收。
在前面的文章中我们分析了 tomcat 类加载器，tomcat 使用 ParallelWebappClassLoader 加载 Class，在热部署的时候自然也会回收该类加载器。但是要注意的是，ParallelWebappClassLoader 会作为线程上下文的类加载器，因此要避免该类加载器对象在其他地方被引用。其实，这个问题是最隐晦的，jdk 中有些类会持有线程上下文的类加载器，作为一个优秀的开源产品，tomcat 为我们解决了很多诸如此类的问题
此外，还要保证类对应的 java.lang.Class 对象没有任何地方引用，只要 Class 对象作用域限制在 Context 组件的作用范围便不会发生泄露，tomcat 也是这么做了，使用 Context 实现了隔离机制
热加载问题 热加载会面临很多问题，有很多坑，需要非常丰富的经验。下面针对 tomcat 中涉及的类加载器泄露、对象泄露、文件锁等这几类常见的问题加以分析讨论。如果您对热加载感兴趣的话，可以研究下阿里开源的 jarlinks
文件锁 在Windows 系统下使用 URLConnection 读取本地 jar 包的资源时，它会将资源缓存起来，会导致该 jar 包资源被锁。如果这个时候使用 war 包进行重新部署，需要解压 war 包再把原来目录下面的 jar 包删除，由于 jar 包资源被锁，导致删除失败，重新部署自然也会失败。我们先来看一段代码，这段代码会抛出异常，java.</description></item><item><title>十八、Java 8 流 Stream ( 上 )</title><link>https://www.hotmindshare.com/docs/java/java8/18/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.hotmindshare.com/docs/java/java8/18/</guid><description>流(Stream ) 是 Java 8 新增加的一个重磅级的功能。流是一个抽象层。有了流，我们就可以使用类似于 SQL 语句的声明方式来处理数据。
比如，下面的 SQL 语句
1SELECT max(grade), student_id, student_name FROM Students; 上面这条 SQL 会自动返回最高学习绩点的学生的信息，而全程，开发人员却不用直接面对任何计算和比较。
在流（ Stream ) 出现之前，对于Java 中的集合框架的使用。开发人员不得不一次次的写一个循环，一次次的重复检查。当然了，这也什么，毕竟大家都是这样过来的。
更大的问题在于开发效率。面对当前的多核 CPU 计算机，面对并发编程。我们开发者常常会写出非常容易出错的并发执行的代码。
为了解决这些问题，Java 8 引入了流 ( Stream ) 这个概念，允许开发人员以声明的方式处理数据的同时，还能利用多核构架，而无需编写任何特殊的代码。
流是什么 ? Java 中的 流 ( Stream ) 表示来自 源 ( source ) 的一系列对象，它支持统计、求和、求平均值等聚合操作。
流具有以下特征：
元素序列 : 流以顺序方式提供特定类型的一组元素。流只会按需获取/计算元素。但它从不存储元素。 源 ( Source )：流可以将集合，数组或 I/O 资源作为输入源。 聚合操作： 流支持聚合操作，如 filter、map、limit、reduce、find、match 等 管道 ( pipelining )：大多数流操作都返回流本身，以便可以对其结果进行流水线操作。这些操作称为 中间 操作，它们的功能是获取输入，处理它们并将输出返回到目标。collect() 方法是一个终端操作，通常在流水线操作结束时出现，以标记流的结尾。 原子性迭代 ( Automatic iterations ) ： 与需要显式迭代的集合相比，流操作在内部对所提供的源元素进行迭代。 流的创建 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 Java 8 在推出流的同时，对集合框架也进行了一些比较大变更。主要是在 Collection 接口上提供了两种生成 Stream 的方法:</description></item><item><title>十八、Java 9 新特性 – CompletableFuture API ( 中 )</title><link>https://www.hotmindshare.com/docs/java/java9/18/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.hotmindshare.com/docs/java/java9/18/</guid><description>上一章节中我们提到，Java 9 添加了 CompletableFuture 类的子类化的支持。其实呢 ？ Java 9 对 CompletableFuture 类的子类化的支持也是新增了两个方法。
一个是defaultExecutor() 方法，返回默认的执行器 ( Executor )，一个是 newIncompleteFuture() 返回一个 CompletableFuture 的新实例。下面，我们就一一介绍这两个方法吧。
注意： 这个两个方法都是由 CompletableFuture 类提供的。
defaultExecutor() 方法 defaultExecutor() 方法的原型如下
1public Executor defaultExecutor() 这个方法没有任何参数，但可以返回一个默认的执行器 ( Executor )，这个执行器可以作为那些没有指定执行器的异步方法的执行器
简单的说，就是为异步方法提供一个执行器
子类中可以重写此方法，以返回一个最小化的独立线程作为执行器
newIncompleteFuture() 方法 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 newIncompleteFuture() 方法的原型如下
1public &amp;lt;U&amp;gt; CompletableFuture&amp;lt;U&amp;gt; newIncompleteFuture() 返回CompletionStage方法返回的的新的不完整 CompletableFuture，默认实现是返回 CompletableFuture 类的实例
CompletableFuture 类的子类应覆盖此方法，以返回与此 CompletableFuture 相同的类的实例</description></item><item><title>十八、Memcached stats items 命令</title><link>https://www.hotmindshare.com/docs/java/memcached/18/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.hotmindshare.com/docs/java/memcached/18/</guid><description>Memcached stats items 命令用于显示各个 slab 中 item 的数目和存储时长(最后一次访问距离现在的秒数)
语法 1stats items 范例 1flush_all 2OK 3set site 0 1000 11 4ddkk.com 5STORED 6set age 0 1000 2 728 8STORED 9stats items 10STAT items:1:number 2 11STAT items:1:age 477 12STAT items:1:evicted 0 13STAT items:1:evicted_nonzero 0 14STAT items:1:evicted_time 0 15STAT items:1:outofmemory 0 16STAT items:1:tailrepairs 0 17STAT items:1:reclaimed 0 18STAT items:1:expired_unfetched 0 19STAT items:1:evicted_unfetched 0 20STAT items:1:crawler_reclaimed 0 21STAT items:1:crawler_items_checked 0 22STAT items:1:lrutail_reflocked 0 23END</description></item><item><title>十二、Java 8 集合遍历 forEach() 方法</title><link>https://www.hotmindshare.com/docs/java/java8/12/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.hotmindshare.com/docs/java/java8/12/</guid><description>本文中，我们将介绍一个 java.util.concurrent 包提供的用于解决并发生产者 – 消费者问题的最有用的类 – BlockQueue。我们将介绍BlockingQueue 接口的 API 以及如何使用该接口的方法使编写并发程序更容易。
在本文的后面，我们将展示一个具有多个生产者线程和多个消费者线程的简单程序的示例。
BlockingQueue 的队列类型 java.util.concurrent 提供了两种类型的 BlockingQueue：
1、 无限队列（unboundedqueue）–几乎可以无限增长；
2、 有限队列（boundedqueue）–定义了最大容量；
无限队列 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 创建一个无限队列的方法很简单
1BlockingQueue&amp;lt;String&amp;gt; blockingQueue = new LinkedBlockingDeque&amp;lt;&amp;gt;(); 上面这段代码中，blockingQueue 的容量将设置为 Integer.MAX_VALUE 。
向无限队列添加元素的所有操作都将永远不会阻塞，因此它可以增长到非常大的容量。
使用无限 BlockingQueue 设计生产者 – 消费者模型时最重要的是 消费者应该能够像生产者向队列添加消息一样快地消费消息 。否则，内存可能会填满，然后就会得到一个 OutOfMemory 异常。
有限队列 第二种类型的队列是有限队列。我们可以通过将容量作为参数传递给构造函数来创建这样的队列
1BlockingQueue&amp;lt;String&amp;gt; blockingQueue = new LinkedBlockingDeque&amp;lt;&amp;gt;(10); 上面这句代码中，我们设置了 blockingQueue 的容量为 10 。这意味着当消费者尝试将元素添加到已经满了的队列时，结果取决于添加元素的方法（ offer() 、add() 、put() ) ，它将阻塞，直到有足够的空间可以插入元素。否则，添加操作将会失败。
使用有限队列是设计并发程序的好方法，因为当我们将元素插入到已经满了的队列时，这些操作需要等到消费者赶上并在队列中提供一些空间。这种机制可以让那个我们不做任何其它更改就可以实现节流。
BlockingQueue API BlockingQueue 接口的所有方法可以分为两大类：负责向队列添加元素的方法和检索这些元素的方法。
在队列满/空的情况下，来自这两个组的每个方法的行为都不同。
添加元素 BlockingQueue 提供了以下方法用于添加元素
方法 说明 add() 如果插入成功则返回 true，否则抛出 IllegalStateException 异常 put() 将指定的元素插入队列，如果队列满了，那么会阻塞直到有空间插入 offer() 如果插入成功则返回 true，否则返回 false offer(E e, long timeout, TimeUnit unit) 尝试将元素插入队列，如果队列已满，那么会阻塞直到有空间插入 检索元素 BlockingQueue 提供了以下方法用于检索元素</description></item><item><title>十二、Java 9 新特性 – try-with-resources 语句</title><link>https://www.hotmindshare.com/docs/java/java9/12/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.hotmindshare.com/docs/java/java9/12/</guid><description>如果你使用过 Python ，应该对 with 语句不陌生，with 语句会创建一个独立的上下文，当执行流程离开该上下文时，就会立刻释放该上下文中的所有资源
这样的机制，我们都可以不用手动去关闭已经打开的资源，比如文件等，例如
1with open(&amp;#39;hello.txt&amp;#39;) as f: 2 print(f.read() 在执行流程离开 with 语句块之后，f 这个文件资源就会自动销毁
Java 9 为 java 也引入了这种机制，Java 9 称之为 「 try-with-resources 」
其实应该说 Java 9 之前也能实现这样的机制，只不过有点复杂
try-with-resources try-with-resources 首先是一个 try 语句，其次，该语句包含一个或多个正式声明的资源。这些资源是一个对象，当不再需要时就应该关闭它。
try-with-resources 语句可以确保在需求完成后关闭每个资源，当然了，这些可以自动关闭的资源也是有条件的，那就是必须实现java.lang.AutoCloseable 或 java.io.Closeable 接口
Java 9 之前，资源可以在 try 之前或 try 语句内部声明，正如下面的代码所示的那样。
我们将使用 BufferedReader 作为资源来读取字符串，然后关闭 BufferedReader
TryResourceTester.java 1import java.io.BufferedReader; 2import java.io.IOException; 3import java.io.Reader; 4import java.io.StringReader; 5public class TryResourceTester { 6 public static void main(String[] args) throws IOException { 7 System.</description></item><item><title>十二、Memcached get 命令</title><link>https://www.hotmindshare.com/docs/java/memcached/12/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.hotmindshare.com/docs/java/memcached/12/</guid><description>Memcached get 命令获取存储在 键(key) 中的 数据值(value)
语法 1get key 多个key 使用空格隔开
1get key1 key2 key3 key ： 键值对 key-value 结构中的 key，用于查找缓存值 如果key 不存在，则返回空
范例 1. get 单个 key 这个范例中，我们设置键 site 的值为 ddkk.com 存活时间设置为 1000 秒
1flush_all 2OK 3set site 0 1000 11 4ddkk.com 5STORED 6get site 7VALUE site 0 11 8ddkk.com 9END 2. get 多个 key 1flush_all 2OK 3set site 0 1000 11 4ddkk.com 5STORED 6set age 0 1000 2 728 8STORED 9get site age 10VALUE site 0 11 11ddkk.</description></item><item><title>十九、Java 8 流 Stream ( 下 )</title><link>https://www.hotmindshare.com/docs/java/java8/19/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.hotmindshare.com/docs/java/java8/19/</guid><description>上一章节 Java 8 流 Stream ( 上 ) 因为时间关系，我们介绍到一半半就停止了。本章节我们继续。
limit() 方法 limit() 方法用于减少( 限制 ) 流中的元素数量。
例如下面的代码段演示了如何使用 limit() 方法只输出 10 个随机数
1Random random = new Random(); 2random.ints().limit(10).forEach(System.out::println); sorted() 方法 sorted() 方法用于给流中的元素进行排序。
下面的范例演示了如何按照排序顺序打印 10 个随机数
1Random random = new Random(); 2random.ints().limit(10).sorted().forEach(System.out::println); 并发处理 parallelStream() 是需要并发处理的流的替代方案。stream() 方法产生的流只能是串行处理，可以理解为只在一个线程中，按照流中元素的顺序一个接一个的处理。
而并发处理，就是传说中的 map-reduce 方法，可以充分利用多核优势。
需要注意的是，parallelStream() 会打乱流的顺序，也就是返回的序列顺序不一定是输入的序列顺序。
例如下面的代码用于打印序列中的空字符串的数量
1List&amp;lt;String&amp;gt; strings = Arrays.asList(&amp;#34;abc&amp;#34;, &amp;#34;&amp;#34;, &amp;#34;bc&amp;#34;, &amp;#34;efg&amp;#34;, &amp;#34;abcd&amp;#34;,&amp;#34;&amp;#34;, &amp;#34;jkl&amp;#34;); 2//get count of empty string 3int count = strings.parallelStream().filter(string -&amp;gt; string.isEmpty()).count(); 因为stream() 返回是串行流，而 parallelStream() 返回的是并行流。因此在串行和并行之间切换是非常简单的。</description></item><item><title>十九、Java 9 新特性 – CompletableFuture API ( 下 )</title><link>https://www.hotmindshare.com/docs/java/java9/19/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.hotmindshare.com/docs/java/java9/19/</guid><description>Java 9 同时为 CompletableFuture 类添加了一些工厂方法
completedFuture(U value) 工厂方法 completedFuture(U value) 工厂方法的原型如下
1public static &amp;lt;U&amp;gt; CompletableFuture&amp;lt;U&amp;gt; completedFuture(U value) 此工厂方法返回一个已完成的、使用给定值的新 CompletableFuture 。
completedStage(U value) 工厂方法 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 completedStage(U value) 工厂方法的原型如下
1public static &amp;lt;U&amp;gt; CompletionStage&amp;lt;U&amp;gt; completedStage(U value) 此工厂方法返回一个新的使用给定值 value 的已完成的 CompletionStage，且仅支持接口 CompletionStage 中定义的那些方法
failedStage(Throwable ex) 工厂方法 failedStage(Throwable ex) 工厂方法的原型如下
1public static &amp;lt;U&amp;gt; CompletionStage&amp;lt;U&amp;gt; failedStage(Throwable ex) 此工厂方法返回一个新的 CompletionStage，使用给定异常的情况下异常完成，且仅支持接口 CompletionStage 中存在的那些方法</description></item><item><title>十九、Memcached stats slabs 命令</title><link>https://www.hotmindshare.com/docs/java/memcached/19/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.hotmindshare.com/docs/java/memcached/19/</guid><description>Memcached stats slabs 命令用于显示各个 slab 的信息，包括chunk的大小、数目、使用情况等
语法 1stats slabs 范例 1flush_all 2OK 3set site 0 1000 11 4ddkk.com 5STORED 6set age 0 1000 2 728 8STORED 9stats sizes 10STAT 96 2 11END 12stats slabs stats slabs 命令 13STAT 1:chunk_size 96 只用到了 slab 1 14STAT 1:chunks_per_page 10922 15STAT 1:total_pages 1 16STAT 1:total_chunks 10922 17STAT 1:used_chunks 2 18STAT 1:free_chunks 10920 19STAT 1:free_chunks_end 0 20STAT 1:mem_requested 151 21STAT 1:get_hits 0 22STAT 1:cmd_set 2 23STAT 1:delete_hits 0 24STAT 1:incr_hits 0 25STAT 1:decr_hits 0 26STAT 1:cas_hits 0 27STAT 1:cas_badval 0 28STAT 1:touch_hits 0 29STAT active_slabs 1 30STAT total_malloced 1048512 31END</description></item><item><title>十六、Java 8 新日期时间 API ( 中 ) – 时区日期时间</title><link>https://www.hotmindshare.com/docs/java/java8/16/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.hotmindshare.com/docs/java/java8/16/</guid><description>上一章节 Java 8 新日期时间 API ( 上 ) – 本地日期时间 我们对 Java 8 重新设计的日期时间 API 做了一些基础的介绍，同时详细介绍了和本地时间有关的几个类 LocalDateTime 、LocalDate 和 LocalTime 。
我同时也发现，这三个类没有任何时区相关的信息，但也不能说它们没处理时区，而只能说它们有选择的隐藏了时区的处理。它们内部会使用操作系统当前的时区。
以此同时，Java 在 java.time 包中也提供了几个类用于处理需要关注时区的日期时间 API。它们是 java.time.ZonedDateTime 和 java.time.ZoneId。前者用于处理需要时区的日期时间，后者用于处理时区。
ZonedDateTime 和 LocalDateTime 类似，几乎有着相同的 API。从某些方面说，ZonedLocalTime 如果不传递时区信息，那么它会默认使用操作系统的时区，这样，结果其实和 LocalDateTime 是类似的。
比如，我们可以使用 ZonedDateTime 的 now() 方法返回当前时区 ( 操作系统时区 ) 的日期时间，调用 parse() 方法可以将一个包含了时区信息的字符串格式的日期时间转化为一个 ZonedDateTime 实例。
Java8Tester.java 1import java.time.ZonedDateTime; 2public class Java8Tester { 3 public static void main(String args[]) { 4 Java8Tester tester = new Java8Tester(); 5 tester.</description></item><item><title>十六、Java 9 新特性 – 多分辨率图像 API</title><link>https://www.hotmindshare.com/docs/java/java9/16/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.hotmindshare.com/docs/java/java9/16/</guid><description>Java 9 引入了一种新的多分辨率图像 API，它支持具有不同分辨率变体的多个图像
这些API 允许将具有不同分辨率的一组图像用作单个多分辨率图像
方法 说明 getResolutionVariant(double destImageWidth, double destImageHeight) 获取特定图像，该图像是表示指定大小的逻辑图像的最佳变体 getResolutionVariants() 以可读列表的形式返回所有分辨率变体 接下来我们就来看看两个 API 如何使用吧。
假设存在三张图片
它们的地址分别为
1https://ddkk.com/static/upload/img/2018/09/03/20180903060845_4.png 2https://ddkk.com/static/upload/img/2018/09/03/20180903060900_4.png 3https://ddkk.com/static/upload/img/2018/09/03/20180903060914_4.png 在当前的工作区中创建一个文件 MultiResolutionTester.java 并输入以下内容
1import java.io.IOException; 2import java.net.URL; 3import java.net.MalformedURLException; 4import java.util.ArrayList; 5import java.util.List; 6import java.awt.Image; 7import java.awt.image.MultiResolutionImage; 8import java.awt.image.BaseMultiResolutionImage; 9import javax.imageio.ImageIO; 10public class MultiResolutionTester { 11 public static void main(String[] args) throws IOException, MalformedURLException { 12 List&amp;lt;String&amp;gt; imgUrls = List.of(&amp;#34;https://ddkk.com/static/upload/img/2018/09/03/20180903060845_4.png&amp;#34;, 13 &amp;#34;https://ddkk.com/static/upload/img/2018/09/03/20180903060900_4.png&amp;#34;, 14 &amp;#34;https://ddkk.com/static/upload/img/2018/09/03/20180903060914_4.png&amp;#34;); 15 List&amp;lt;Image&amp;gt; images = new ArrayList&amp;lt;Image&amp;gt;(); 16 for (String url : imgUrls) { 17 images.</description></item><item><title>十六、Memcached incr 与 decr 命令</title><link>https://www.hotmindshare.com/docs/java/memcached/16/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.hotmindshare.com/docs/java/memcached/16/</guid><description>Memcached decr 命令用于对已存在的 key(键) 的数字值进行自减操作
语法 1decr key decrement_value key : 键值 key-value 结构中的 key，用于查找缓存值 decrement_value ： 需要减少的数值 与incr 一样, decr 命令操作的数据必须是十进制的32位无符号整数
返回值 如果 key 不存在返回 NOT_FOUND 如果 key 的值不为数字，则返回 CLIENT_ERROR 其他错误返回 ERROR 范例 下面的范例，我们使用 countdown 作为 key，初始值为 100，之后进行减 5 操作
1set countdown 0 1000 3 2100 3STORED 4get countdown 5VALUE countdown 0 3 6100 7END 8decr countdown 5 995 10get countdown 11VALUE countdown 0 3 1295 13END 如果 key 不存在 如果key 不存在，那么返回 NOT_FOUND key 不存在错误</description></item><item><title>十七、Java 8 新日期时间 API ( 下 ) – 格式化</title><link>https://www.hotmindshare.com/docs/java/java8/17/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.hotmindshare.com/docs/java/java8/17/</guid><description>Java 8 似乎也对 java.text.SimpleDateFormat 也不太满意，竟然重新创建了一个 java.time.format 包，该包下包含了几个类和枚举用于格式化日期时间。
java.time.format 包 java.time.format 包提供了以下几个类用于格式化日期时间
类 说明 DateTimeFormatter 用于打印和解析日期时间对象的格式化程序 DateTimeFormatterBuilder 创建日期时间格式化样式的构建器 DecimalStyle 日期和时间格式中使用的本地化十进制样式 java.time.format 包还提供了以下几个枚举，包含了常见的几种日期时间格式。
枚举 说明 FormatStyle 包含了本地化日期，时间或日期时间格式器的样式的枚举 ResolverStyle 包含了解决日期和时间的不同方法的枚举 SignStyle 包含了如何处理正/负号的方法的枚举 TextStyle 包含了文本格式和解析的样式的枚举 DateTimeFormatter 类 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 DateTimeFormatter 类格式化日期时间的最重要的类，该类是一个最终类，只能实例化，不能被扩展和继承。
DateTimeFormatter 类的定义如下
1public final class DateTimeFormatter extends Object DateTimeFormatter 类用于打印和解析日期时间对象的格式化器。此类提供打印和解析的主要应用程序入口点，并提供 DateTimeFormatter 的常见模式
使用预定义的常量，比如 ISO_LOCAL_DATE 使用模式字母，例如 uuuu-MMM-dd 使用本地化样式，例如 long 或 medium 所有的日期时间类，包括本地日期时间和包含时区的日期时间类，都提供了两个重要的方法
1、 一个用于格式化，format(DateTimeFormatterformatter)；
2、 另一个用于解析，parse(CharSequencetext,DateTimeFormatterformatter)；
下面，我们写几个示例来演示下这两个方法，并演示下如和使用 DateTimeFormatter 类
Java8Tester 1import java.time.ZonedDateTime; 2import java.time.format.DateTimeFormatter; 3public class Java8Tester { 4 public static void main(String args[]) { 5 Java8Tester tester = new Java8Tester(); 6 tester.</description></item><item><title>十七、Java 9 新特性 – CompletableFuture API ( 上 )</title><link>https://www.hotmindshare.com/docs/java/java9/17/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.hotmindshare.com/docs/java/java9/17/</guid><description>CompletableFuture 类是在 Java 8 引入的。用于表示一个 Feture 的状态，可以通过设置其值或状态来明确表示 Feture 处于完成状态
说起来特拗口，理解起来就简单了
那个，Java 8 不是引入了并发编程了，对吧。并发编程里有一个概念就是并发执行是否完成了。这个是否完成了是由 java.util.concurrent.CompletionStage 来表示的。然后呢，CompletableFuture 是 CompletionStage 的父类。
如果你对 Java 的并发编程熟悉，那么一定直到，当并发完成时可以支持一个回调，这个回调也是由 CompletableFuture 提供的。
有时候会觉得，一个特性，应该在它出现的时候就比较完善了，直到别人提出了新的思维，才觉得原来还有改进的空间，就比如这个 CompletableFuture 吧
Java 9 竟然还给它添加了一些东西：
1、 支持延误和超时(timeout)机制；
2、 支持子类化；
3、 添加了一些新的工厂方法；
支持延误和超时机制 这两个功能是通过新增两个方法来达成的
方法 说明 completeOnTimeout(T value, long timeout, TimeUnit unit) 如果在指定时间内没完成，则返回一个指定的值 orTimeout(long timeout, TimeUnit unit) 如果在指定的时间内没完成，则抛出一个异常 TimeoutException 这两个方法的看起来是差不多的，都是在指定时间内没完成则执行一个动作，只不过前者是返回一个指定的值，后者则直接抛出异常
这两个方法的原型如下
1public CompletableFuture&amp;lt;T&amp;gt; completeOnTimeout(T value, long timeout, TimeUnit unit) 2public CompletableFuture&amp;lt;T&amp;gt; orTimeout(long timeout, TimeUnit unit) 范例 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 在我们的工作目录创建一个文件 CompletableFutureTimeoutTester.</description></item><item><title>十七、Memcached stats 命令</title><link>https://www.hotmindshare.com/docs/java/memcached/17/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.hotmindshare.com/docs/java/memcached/17/</guid><description>Memcached stats 命令返回 Memcached 的统计信息，比如 PID(进程号)、版本号、连接数等。
语法 1stats stats 返回的每一项解释如下 pid ： memcache服务器进程ID uptime ：服务器已运行秒数 time ：服务器当前Unix时间戳 version：memcache版本 pointer_size ：操作系统指针大小 rusage_user ：进程累计用户时间 rusage_system ：进程累计系统时间 curr_connections ：当前连接数量 total_connections ：Memcached运行以来连接总数 connection_structures ：Memcached分配的连接结构数量 cmd_get ：get命令请求次数 cmd_set ：set命令请求次数 cmd_flush ：flush命令请求次数 get_hits ：get命令命中次数 get_misses ：get命令未命中次数 delete_misses ：delete命令未命中次数 delete_hits ：delete命令命中次数 incr_misses ：incr命令未命中次数 incr_hits ：incr命令命中次数 decr_misses ：decr命令未命中次数 decr_hits ：decr命令命中次数 cas_misses ：cas命令未命中次数 cas_hits ：cas命令命中次数 cas_badval ：使用擦拭次数 auth_cmds ：认证命令处理的次数 auth_errors ：认证失败数目 bytes_read ：读取总字节数 bytes_written ：发送总字节数 limit_maxbytes ：分配的内存总大小（字节） accepting_conns ：服务器是否达到过最大连接（0/1） listen_disabled_num ：失效的监听数 threads ：当前线程数 conn_yields ：连接操作主动放弃数目 bytes ：当前存储占用的字节数 curr_items ：当前存储的数据总数 total_items ：启动以来存储的数据总数 evictions ：LRU释放的对象数目 reclaimed ：已过期的数据条目来存储新数据的数目 范例 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 1flush_all 2OK 3set site 0 1000 11 4ddkk.</description></item><item><title>十三、Java 8 可选值 java.util.Optional 类</title><link>https://www.hotmindshare.com/docs/java/java8/13/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.hotmindshare.com/docs/java/java8/13/</guid><description>在不考虑竖起来的情况下，抛一个硬币，落地时，显示正面的情况只有两种：是正面和不是正面。很多时候，这是一个 「 谓词 」，也就是返回布尔类型 ( bool )。但有时候，我们需要返回另一种类型：存在 和 空。
存在 就是硬币落地时显示为正面 空 就是硬币落地式显示的不是正面。 从另一方面说，结果就是 有值 和 空 。
一个类，如果可以同时表示 有值 和 空 ，我们称这种类为 可选类 ( Optional )
从某些方面说，Optional 类型就是 「那里有一个值，它等于 x，或者那里没有那个值」
JAVA 8 java.util.Optional 类 Java 8 在 java.util 包中添加了一个新的类 Optional 。
Optional 类是一个容器，用于表示可能包含也可能不包含非 null 值。如果存在值，isPresent() 方法将返回 true，get() 将返回该值。
Optional 类提供了许多方法用于处理 「 可用 」 或 「 不可用 」 ，而不是简单的检查空值情况。
java.util.Optional 类的声明如下
1public final class Optional&amp;lt;T&amp;gt; extends Object 注意：该类是一个最终类，不能被继承和扩展。
Optional 类提供了以下静态方法来创建 Optional 类的实例 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 Optional 类提供了三个静态方法用于创建 Optional 类的实例，这三个方法的返回值都是 Optional&amp;lt;T&amp;gt;</description></item><item><title>十三、Java 9 新特性 – 增强 @Deprecated 注解</title><link>https://www.hotmindshare.com/docs/java/java9/13/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.hotmindshare.com/docs/java/java9/13/</guid><description>@Deprecated 注解很早就存在了，如果我记得没错的话，好像是 Java 5 ( 后来我去查了资料，也的确是 Java 5 就引入了 ) 。
一个使用 @Deprecated 注解的元素，无论是一个类或是一个方法，可能是由以下原因导致了不应该再使用它
1、 使用它可能会导致错误；
2、 在未来的版本中不被兼容；
3、 在未来的版本中可能会被删除；
4、 存在更好的更有效的替代方法；
如果一个程序或代码片段使用了 @Deprecated 注解的元素，那么编译器就会生成一个警告信息，表明这个元素是不被推荐使用的。
我们都一直延续了这样的习惯好久，直到 Java 9 的发布，我才发现 @Deprecated 注解还可以做的更好
Java 9 对 @Deprecated 注解做了两项重要的增强。
1、 forRemoval–指示在将来的版本中是否要删除带注解的元素默认值为false；
2、 since–返回注解元素刚添加@Deprecated注解的版本；
一看不知道，看了很吃惊，这两个属性，还是蛮有作用的
@Deprecated 的 since 属性 对since 的使用，你可以查阅 Java 9 的官方文档中 Boolean 类型的文档，在该文档中演示了如何在 @Deprecated 注解上使用 since 属性
文档地址 https://docs.oracle.com/javase/9/docs/api/java/lang/Boolean.html#Boolean-boolean-
可以看到下图中粉色框框的内容
@Deprecated 的 forRemoval 属性 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 关于@Deprecated 的 forRemoval 属性的使用，可以查看官方提供的文档中的有关 System 类的部分，该部分演示了 @Deprecated 注解使用 forRemoval 属性</description></item><item><title>十三、Memcached gets 命令</title><link>https://www.hotmindshare.com/docs/java/memcached/13/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.hotmindshare.com/docs/java/memcached/13/</guid><description>Memcached gets 命令获取带有 CAS 令牌存 的 value(数据值) ，
语法 1gets key 多个key 使用空格隔开:
1gets key1 key2 key3 key ：键值 key-value 结构中的 key，用于查找缓存值 返回结果中，最后一列的数字为 CAS 令牌
如果key 不存在，则返回空
范例 使用gets 命令的输出结果中，在最后一列的数字 1 代表了 key 为 DDKK.COM 弟弟快看，程序员编程资料站 的 CAS 令牌
只 gets 一个 key
1flush_all 2OK 3set site 0 1000 11 4ddkk.com 5STORED 6set age 0 1000 2 728 8STORED 9gets site 10VALUE site 0 11 18 11ddkk.com 12END gets 多个 key 1flush_all 2OK 3set site 0 1000 11 4ddkk.</description></item><item><title>十四、Java 8 Nashorn JavaScript</title><link>https://www.hotmindshare.com/docs/java/java8/14/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.hotmindshare.com/docs/java/java8/14/</guid><description>对于Java 中的 JavaScript 引擎， Java 8 引入了 Nashorn 来代替原先的 Rhino。
Nashorn 使用 Java 7 中引入的调用动态特性，且直接编译内存中的代码并将字节码传递给 JVM。这两项改进，直接给 Nashorn 带了至少 2 到 10 倍的性能提升。
jjs 在Nashorn JavaScript 引擎中。JAVA 8 引入了一个新的命令行工具 jjs，用于在控制台执行 javascript 代码。
例如我们可以在当前目录下 ( 任意位置 ) 创建一个 JavaScript 文件 hello.js ，然后输入以下内容
1print(&amp;#39;你好，DDKK.COM 弟弟快看，程序员编程资料站，教程 ！&amp;#39;); 保存文件后，使用下面的 jjs 命令运行它
1jjs hello.js 运行结果如下
1[penglei@ddkk.com helloworld]$ jjs hello.js 2你好，DDKK.COM 弟弟快看，程序员编程资料站，教程 ！ jjs 交互式解释器 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 我们也可以直接在命令行中输出 jjs 进入 Java 8 提供的 jjs 交互式解释器。
1[penglei@ddkk.com helloworld]$ jjs 2jjs&amp;gt; 然后输入一些 JavaScript 语句，就会立即显示结果</description></item><item><title>十四、Java 9 新特性 – 内部类的方块操作符</title><link>https://www.hotmindshare.com/docs/java/java9/14/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.hotmindshare.com/docs/java/java9/14/</guid><description>方块操作符 ( &amp;lt;&amp;gt; ) 在 Java 7 中就引入了，目的是为了使代码更可读。
但是呢，这个操作符一直不能在匿名内部类中使用
Java 9 修正了这个问题，就是可以在匿名内部类中使用方块操作符了，在匿名类大行其道的今天，这才叫优化了阅读体验…
我们来看看一段 Java 9 之前的代码
DiamondOperatorTester.java 1public class DiamondOperatorTester { 2 public static void main(String[] args) { 3 Handler&amp;lt;Integer&amp;gt; intHandler = new Handler&amp;lt;Integer&amp;gt;(1) { 4 @Override 5 public void handle() { 6 System.out.println(content); 7 } 8 }; 9 intHandler.handle(); 10 Handler&amp;lt;? extends Number&amp;gt; intHandler1 = new Handler&amp;lt;Number&amp;gt;(2) { 11 @Override 12 public void handle() { 13 System.out.println(content); 14 } 15 }; 16 intHandler1.</description></item><item><title>十四、Memcached delete 命令</title><link>https://www.hotmindshare.com/docs/java/memcached/14/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.hotmindshare.com/docs/java/memcached/14/</guid><description>Memcached delete 命令用于删除已存在的 key(键)
语法： 1delete key [noreply] key ： 键值对 key-value 结构中的 key，用于查找缓存值 noreply: 可选, 该参数告知服务器不需要返回数据 删除成功时返回 DELETED
范例 我们先设置 site 的值为 ddkk.com ,存活时间 1000 秒，然后使用 delete 命令删除
1flush_all 2OK 3set site 0 1000 11 4ddkk.com 5STORED 6get site 7VALUE site 0 11 8ddkk.com 9END 10delete site 11DELETED 12get site 13END 删除一个不存在的键(key) 会返回 NOT_FOUND key不存在信息
1flush_all 2OK 3delete site 4NOT_FOUND</description></item><item><title>十五、Java 8 新日期时间 API ( 上 ) – 本地日期时间</title><link>https://www.hotmindshare.com/docs/java/java8/15/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.hotmindshare.com/docs/java/java8/15/</guid><description>作为开发者，经常需要处理日期时间。如果你跟随者 Java 5 一路走来，那么一定会对 java.util.Date 、java.util.Calendar 、java.util.GregoiranCalendar 和 java.text.SimpleDateFormat 四大类非常熟悉，它们分别用于处理日期、日历、日历表示、日期时间格式化。
这四个类，对于编程老人来讲，应该是习惯了，但对于编程新人来讲，就有好多疑问，有好多陷阱和坑等着它们跳，比如
1、 非线程安全：java.util.Date并不是线程安全的开发者在使用这个类时必须自己处理多线程并发问题；
2、 设计不佳：一方面日期和日期格式化分布在多个包中另一方面，java.util.Date的默认日期，年竟然是从1900开始，月从1开始，日从0开始，没有统一性而且Date类也缺少直接操作日期的相关方法；
3、 时区处理困难：因为设计不佳，开发人员不得不编写大量代码来处理时区问题；
4、 还有其它一些问题；
面对种种问题，Java 8 终于重新设计了所有日期时间、日历及时区相关的 API。并把它们都统一放置在 java.time 包和子包下。并作出了以下改进
1、 新的日期时间API是线程安全的不仅没有setter方法，而且任何对实例的变更都会返回一个新的实例而保证原来的实例不变；
2、 新的日期时间API提供了大量的方法，用于修改日期时间的各个部分，并返回一个新的实例；
3、 在时区方面，新的日期时间API引入了域(domain)这个概念；
同时Java 8 还针对原来复杂的 API 进行重新组合和拆分，分成了好多个类。本章接下来的章节，我们就来详细介绍其中几个最重要的。
本地日期时间 API Java 8 为处理本地的日期时间提供了三个类 LocalDate 、LocalTime 和 LocalDateTime。分别用于处理 本地日期、本地时间 和 本地日期时间。
当使用这三个类时，开发者并不需要关心时区是什么。因为它默认使用的是操作系统的时区。
比如，可以使用 LocalDateTime.now() 方法返回当前的日期时间。
Java8Tester.java 1import java.time.LocalDateTime; 2public class Java8Tester { 3 public static void main(String args[]) { 4 Java8Tester tester = new Java8Tester(); 5 tester.</description></item><item><title>十五、Java 9 新特性 – Option 类</title><link>https://www.hotmindshare.com/docs/java/java9/15/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.hotmindshare.com/docs/java/java9/15/</guid><description>其实Option 类在 Java 8 中就引入了，用于避免 null 检查和 NullPointerException 指针问题
Java 9 中，又为该类添加了三个方法来改进它的功能
方法 说明 stream() 返回包含值的流，如果值不存在，则返回空流 ifPresentOrElse() 如果值存在则对值执行一些操作，否则执行另一个操作 or() 如果值存在，则返回用于描述该值的 Option，如果不存在则生成一个值 steam() 方法 steam() 方法的原型如下
1public Optional&amp;lt;T&amp;gt; or(Supplier&amp;lt;? extends Optional&amp;lt;? extends T&amp;gt;&amp;gt; supplier) 如果值存在，则返回包含值的有序的流，如果值不存在，则返回一个空流
范例 在我们的工作目录，创建一个文件 OptionStreamTester.java 并输入以下内容
1import java.util.Arrays; 2import java.util.List; 3import java.util.Optional; 4import java.util.stream.Collectors; 5import java.util.stream.Stream; 6public class OptionStreamTester { 7public static void main(String[] args) { 8 List&amp;lt;Optional&amp;lt;String&amp;gt;&amp;gt; list = Arrays.asList ( 9 Optional.empty(), 10 Optional.of(&amp;#34;A&amp;#34;), 11 Optional.empty(), 12 Optional.</description></item><item><title>十五、Memcached incr 与 decr 命令</title><link>https://www.hotmindshare.com/docs/java/memcached/15/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.hotmindshare.com/docs/java/memcached/15/</guid><description>Memcached incr 命令用于对已存在的 key(键) 的数字值进行自增操作
语法 1incr key increment_value key ： 键值 key-value 结构中的 key，用于查找缓存值 increment_value ： 需要增加的数值 incr 命令操作的数据必须是十进制的32位无符号整数
返回值 如果 key 不存在返回 NOT_FOUND 如果 key 的值不为数字，则返回 CLIENT_ERROR 其他错误返回 ERROR 范例 下面的范例，我们使用 countdown 作为 key，初始值为 5，之后进行加 5 操作
1set countdown 0 1000 1 2STORED 3incr countdown 5 410 5get countdown 6VALUE countdown 0 2 710 8END 如果 key 不存在 如果key 不存在，那么返回 NOT_FOUND key 不存在错误
1flush_all 2OK 3incr age 5 4NOT_FOUND 如果 key 的值不为数字 如果key 的值不为数字,那么返回 CLIENT_ERROR 自增值不是数字错误</description></item><item><title>十一、Java 8 接口静态方法</title><link>https://www.hotmindshare.com/docs/java/java8/11/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.hotmindshare.com/docs/java/java8/11/</guid><description>本章节我们来讨论下 java.util.concurrent.CountDownLatch 这个类，顺带演示下如何在一些实际例子中使用它。
CountDownLatch 类的作用呢？ 怎么说呢？ 简单来说，我们可以使用它来阻塞线程，直到其他线程完成给定任务。
并发编程中使用 CountDownLatch 简而言之，CountDownLatch 有一个计数器字段，我们可以根据需要减少它，因此，我们可以使用它来阻止调用线程，直到它被计数到零。
如果我们正在进行一些并行处理，我们可以使用与计数器相同的值来实例化 CountDownLatch，因为我们想要处理多个线程。然后，我们可以在每个线程完成后调用 countdown()，保证调用 await() 的依赖线程将阻塞，直到工作线程完成。
使用 CountDownLatch 等待线程池完成 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 我们通过创建一个 Worker 来尝试这个模式，并使用 CountDownLatch 字段来指示它何时完成
1public class Worker implements Runnable { 2 private List&amp;lt;String&amp;gt; outputScraper; 3 private CountDownLatch countDownLatch; 4 public Worker(List&amp;lt;String&amp;gt; outputScraper, CountDownLatch countDownLatch) { 5 this.outputScraper = outputScraper; 6 this.countDownLatch = countDownLatch; 7 } 8 @Override 9 public void run() { 10 doSomeWork(); 11 outputScraper.add(&amp;#34;Counted down&amp;#34;); 12 countDownLatch.</description></item><item><title>十一、Java 9 新特性 – 增强流 ( Stream ) API</title><link>https://www.hotmindshare.com/docs/java/java9/11/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.hotmindshare.com/docs/java/java9/11/</guid><description>Java 中引入了流 ( Stream ) 的概念，真的是大大方便了我们 java 程序员，我们可以使用流从一系列对象中执行聚合操作。
其实，Java 8 中的流已经很强大了，而且只要涉及到 IO，只要涉及到对一系列数据进行操作，几乎都有流的影子。
当然了，Java 9 还不忘对其继续增强，这次的改进主要是如何设置停止流的条件上。为此在流的实例上提供了四个方法 takeWhile(Predicate Interface) 、iterate 、ofNullable 和 dropWhile(Predicate Interface)
takeWhile(Predicate Interface) takeWhile(Predicate Interface) 方法会处理流中所有的数据，直到条件 predicate 返回 false 为止
该方法的原型如下
1default Stream&amp;lt;T&amp;gt; takeWhile(Predicate&amp;lt;? super T&amp;gt; predicate) takeWhile() 方法会返回一个有序的流 ( stream ) ，返回的流中包含了原始流中于给定条件 predicate 相匹配的所有元素的最长前缀。
注意： 并不是所有匹配的元素，而是最长匹配前缀，因为一旦某个元素的 pridicate 返回 false，就立刻停止了
范例 在当前工作区创建一个文件 StreamTakeWhileTester.java ，并输入以下代码
1import java.util.stream.Stream; 2public class StreamTakeWhileTester{ 3 public static void main(String[] args) 4 { 5 Stream.of(&amp;#34;I&amp;#34;,&amp;#34;love&amp;#34;,&amp;#34;you&amp;#34;,&amp;#34;&amp;#34;,&amp;#34;so&amp;#34;,&amp;#34;much&amp;#34;).takeWhile(s-&amp;gt;!s.isEmpty()) 6 .</description></item><item><title>十一、Memcached CAS 命令</title><link>https://www.hotmindshare.com/docs/java/memcached/11/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.hotmindshare.com/docs/java/memcached/11/</guid><description>CAS （Check-And-Set 或 Compare-And-Swap） 又称原子指令或者原子操作
Memcached CAS 命令用于执行一个 检查并设置 的操作
它仅在当前客户端最后一次取值后，该key 对应的值没有被其他客户端修改的情况下， 才能够将值写入。
语法 1cas key flags exptime bytes unique_cas_token [noreply] 2value 通过cas_token 参数进行检查操作， 这个参数是Memcach指定给已经存在的元素的一个唯一的64位值
参数说明 key： 键值 key-value 结构中的 key，用于查找缓存值。 flags ：可以包括键值对的整型参数，Memcached 使用它存储键值对的额外信息 exptime ：缓存中键值对存活的时间长度（以秒为单位，0 表示永远） bytes ：缓存中存储的字节数 unique_cas_token 通过 gets 命令获取的一个唯一的64位值。 noreply（可选） ： 该参数告知服务器不需要返回数据 value ：存储的值（始终位于第二行）（可直接理解为key-value结构中的value） 返回 如果数据添加成功，则返回 STORED 如果出现语法错误，则返回 ERROR 最后一次取值后另外一个用户也在更新该数据，返回 EXISTS Memcached 上不存在该键，则返回 NOT_FOUND 范例 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 使用CAS 命令之前，要先用 gets 命令获取令牌（token）
使用CAS 操作的步骤一般如下：
1、 如果没有设置唯一令牌，则CAS命令执行错误；
2、 如果键key不存在，执行失败；</description></item><item><title>四、Java 9 新特性 – 模块化</title><link>https://www.hotmindshare.com/docs/java/java9/4/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.hotmindshare.com/docs/java/java9/4/</guid><description>Java 9 最大的特性就是模块化 ( Module ) 了。本章，我们就对这个 模块化 进行一些简单的讲解，包括 Java 9 模块化的概念、如何实现、如何使用等
对于Java 9 来说，模块化 ( Module ) 是一个新引入的新型的编程组件 ( Component )
因为是一个组件，所以也是一个自我完备的系统，是代码和数据的自描述的集合，而且有一个自我标识的名称，也就是模块名
Java 9 模块化的特性 Java 9 为了引入新的模块化的编程方式，特意增强和改进了一些功能，也添加了一些新的特性
1、 Java程序编译运行过程中，引入了一个新的可选的阶段「链接时间」(linktime)；
这个阶段介于编译时和运行时之间
在该阶段，可以组装和优化一组模块，可以使用 jlink 工具制作自定义运行时镜像 ( image )
2、 javac、jlink和java三个命令都添加了一些可选项用于指定模块路径；
这些选项用于指定模块的定义位置
3、 增强JAR格式，更新JAR格式更新为模块化JAR，并且在JAR根目录下包含module-info.class文件；
4、 引入了JMOD格式，这种一种类似于JAR的新的打包格式，这种格式中可以包含本地(native)代码和配置文件；
5、 特意引入了module关键字，用于定义一个模块，不过这个关键字仅限于module-info.java中使用；
模块化的概念 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 从Java 9 为模块化的改变来看，Java 9 中的模块化其实就是一个 JAR 或 JMOD 格式的归档文件，该归档文件里包含了一些代码和数据还有一些配置文件，其中一定包含了一个名为 module-info.class 的文件，在该文件中定义了模块的一些信息
创建一个 Java 9 模块 接下来我们来看看如何定义一个 Java 9 模块，假设我们想要定义的模块名为 com.ddkk.module.greeting</description></item><item><title>四、Java8 Runnable Lambda 表达式</title><link>https://www.hotmindshare.com/docs/java/java8/4/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.hotmindshare.com/docs/java/java8/4/</guid><description>本章节我们重点来讲讲 Java 8 中的 Runnable Lambda 表达式。众所周知，Java 8 中的 Runable 和 Callable 两个接口都添加了 @FunctionalInterface 注解，因此我们可以直接使用 Lambda 表达式来代替它们的 run() 和 call() 方法
Runnable 表达式 Java 8 开始支持 Lambda 表达式，所以，好像，一夜间，所有添加了 @FunctionalInterface 注解的方法都可以使用 Lambda 表达式来创建实例，Runnable 也不例外，我们可以直接使用一个 Lambda 表达式来创建它的实例
1Runnable r = () -&amp;gt; System.out.println(&amp;#34;Hello World!&amp;#34;); 2Thread th = new Thread(r); 3th.start(); 运行结果输出为 Hello World ，是不是很神奇，如果没有 Lambda 表达式，那么原来的代码可能如下
1Runnable r = new Runnable() { 2 @Override 3 public void run() { 4 System.out.println(&amp;#34;Hello World!&amp;#34;); 5 } 6}; 7Thread th = new Thread(r); 8th.</description></item><item><title>四、Memcached 连接</title><link>https://www.hotmindshare.com/docs/java/memcached/4/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.hotmindshare.com/docs/java/memcached/4/</guid><description>可以通过 telnet 命令并指定 主机IP 和 **端口(port)**来连接 Memcached
语法 1telnet HOST PORT 命令中的 HOST 和 PORT 为运行 Memcached 服务的 IP 和 端口。
11211 为所有 Memcached 服务默认的端口号
范例 1. 连接到 127.0.0.1 上 11211 的 Memcached 服务 假设我们的 Memcached 服务运行在本机， IP 为 127.0.0.1 ,端口为 11211
那么连接到 Memcached 的命令为
1telnet 127.0.0.1 11211 输出如下
1$ telnet 127.0.0.1 11211 2Trying 127.0.0.1... 3Connected to localhost. 4Escape character is &amp;#39;^]&amp;#39;. 2. 进行简单的 set 和 get 操作 1$ telnet 127.</description></item><item><title>四、Netty 教程 – Netty粘包/拆包解决之道</title><link>https://www.hotmindshare.com/docs/java/netty/4/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.hotmindshare.com/docs/java/netty/4/</guid><description>作者：唐亚峰 | 出自：唐亚峰博客
TCP是个流协议，是一串没有界限的数据，TCP底层并不了解上层业务数据的含义，它会根据TCP缓冲区实际情况进行包的划分，在上一篇文章中介绍了什么是Netty，本章介绍Netty粘包和拆包…
粘包和拆包 学过TCP的都知道，它是属于传输层的协议，传输层除了有TCP协议外还有UDP协议，但是UDP是不存在拆包和粘包的。UDP是基于报文发送的，从UDP的帧结构可以看出，在UDP首部采用了16bit来指示UDP数据报文的长度，因此在应用层能很好的将不同的数据报文区分开，从而避免粘包和拆包的问题。
而TCP是基于字节流的，虽然应用层和TCP传输层之间的数据交互是大小不等的数据块，但是TCP把这些数据块仅仅看成一连串无结构的字节流，没有边界；另外从TCP的帧结构也可以看出，在TCP的首部没有表示数据长度的字段，基于上面两点，在使用TCP传输数据时，才有粘包或者拆包现象发生的可能。
服务端分两次读取到了两个独立的数据包，分别是D1和D2没有粘包和拆包 服务端一次接受到两个粘在一起的数据包，D2和D1，被称为TCP粘包服务端分两次读取到了两个数据包，第一次读取到完整的D1，D2部分内容，第二次读取了D2的剩余内容，这被称之为TCP拆包操作 服务端分两次读取到了两个数据包，第一次读取到了D1_1，第二次读取到了D1包的剩余内容和完整的D2数据包 如果此时服务端TCP接收滑窗非常小，而数据包内容相对较大的情况，很可能发生服务端多次拆包才能将D1和D2数据接收完整 产生原因 要发送的数据大于TCP发送缓冲区剩余空间大小，将会发生拆包。 待发送数据大于MSS（最大报文长度），TCP在传输前将进行拆包。 要发送的数据小于TCP发送缓冲区的大小，TCP将多次写入缓冲区的数据一次发送出去，将会发生粘包。 接收数据端的应用层没有及时读取接收缓冲区中的数据，将发生粘包。 解决方法 通过以上分析，我们清楚了粘包或拆包发生的原因，那么如何解决这个问题呢？解决问题的关键在于如何给每个数据包添加边界信息，常用的方法有如下几个：
发送端给每个数据包添加包首部（类似UDP），首部中应该至少包含数据包的长度，这样接收端在接收到数据后，通过读取包首部的长度字段，便知道每一个数据包的实际长度了 发送端将每个数据包封装为固定长度（不够的可以通过补0填充），这样接收端每次从接收缓冲区中读取固定长度的数据就自然而然的把每个数据包拆分开来。 可以在数据包之间设置边界，如添加特殊符号（如\r\n），这样，接收端通过这个边界就可以将不同的数据包拆分开。 Netty 解决方案 io.netty.handler.codec.callDecode(ChannelHandlerContext ctx, ByteBuf in, List&amp;lt;Object&amp;gt; out)
1protected void callDecode(ChannelHandlerContext ctx, ByteBuf in, List&amp;lt;Object&amp;gt; out) { 2 try { 3 while (in.isReadable()) { 4 int outSize = out.size(); 5 int oldInputLength = in.readableBytes(); 6 decode(ctx, in, out); 7 // Check if this handler was removed before continuing the loop.</description></item><item><title>四、Tomcat源码分析-启动分析(二) Catalina初始化</title><link>https://www.hotmindshare.com/docs/java/tomcat/4/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.hotmindshare.com/docs/java/tomcat/4/</guid><description>Bootstrap Tomcat运行是通过Bootstrap的main方法，在开发工具中，我们只需要运行Bootstrap的main方法，便可以启动tomcat进行代码调试和分析。Bootstrap是tomcat的入口，它会完成初始化ClassLoader，实例化Catalina以及load、start动作。在这一篇文章中，我们将会对tomcat初始化过程进行分析。
main方法 首先实例化Bootstrap，并调用init方法对其初始化
1Bootstrap bootstrap = new Bootstrap(); init 首先初始化commonLoader、catalinaLoader、sharedLoader，默认情况下这三个是相同的实例，用于加载不同的资源。然后，使用反射实例化Catalina，设置其parentClassLoader为sharedLoader
1public void init() throws Exception { 2 // 初始化commonLoader、catalinaLoader、sharedLoader，关于ClassLoader的后面再单独分析 3 initClassLoaders(); 4 Thread.currentThread().setContextClassLoader(catalinaLoader); 5 SecurityClassLoad.securityClassLoad(catalinaLoader); 6 // 反射方法实例化Catalina，后面初始化Catalina也用了很多反射，不知道意图是什么 7 Class&amp;lt;?&amp;gt; startupClass = catalinaLoader.loadClass(&amp;#34;org.apache.catalina.startup.Catalina&amp;#34;); 8 Object startupInstance = startupClass.getConstructor().newInstance(); 9 // 反射调用setParentClassLoader方法，设置其parentClassLoader为sharedLoader 10 String methodName = &amp;#34;setParentClassLoader&amp;#34;; 11 Class&amp;lt;?&amp;gt; paramTypes[] = new Class[1]; 12 paramTypes[0] = Class.forName(&amp;#34;java.lang.ClassLoader&amp;#34;); 13 Object paramValues[] = new Object[1]; 14 paramValues[0] = sharedLoader; 15 Method method = 16 startupInstance.</description></item><item><title>五、Java 8 java.util.Base64 编码解码</title><link>https://www.hotmindshare.com/docs/java/java8/5/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.hotmindshare.com/docs/java/java8/5/</guid><description>Base64 是一种常见的字符编码解码方式，一般用于将二进制数据编码为更具可读性的 Base64 进制格式。
在Java 6 （ JDK 1.6 ) 之前， JDK 一直没有包含 Base64 的实现类。因此大部分人都使用 Sum/Orale JDK 里面的 sun.misc.BASE64Encode 和sun.misc.BASE64Decode。然后这也成为很多 Java 开发者的习惯。一直沿用到今天的 Java8 中还有人在用。
JDK1.6 虽然添加了 Base64 的实现。但是，非常隐秘，竟然是在 javax.xml.bind 包下的 DatastypeConvert 类中的两个静态方法 parseBase64Binary 和 printBase64Binary.
Java 8 终于把 Base64 扶正了，在 java.util 包下提供了 Base64 类用于编码和解码 Base64 数据。
Java 8 java.util.Base64 Java 8 中的 java.util.Base64 类提供了三种类型的 Base64 编码解码格式：
1、 简单类型(simple):编码字符只包含A-Za-z0-9+/等64个字符且编码的时候不会包含任何换行符(\r、\n、\r\n）解码的时候也只会解码A-Za-z0-9+/内的字符，超出的则会被拒绝；
2、 URL:编码字符只包含A-Za-z0-9+_等64个字符和简单相比，就是把/换成了_因为没有/字符，因此这种编码方式非常适合URL和文件名等；
3、 MIME:编码会被映射为MIME友好格式：每一行输出不超过76个字符，而且每行以\r\n符结束但末尾行并不会包含\r\n；
内部类 java.util.Base64 还包含了两个内部静态类，分别实现了 RFC 4648 和 RFC 2045 中规范的 Base64 编码和解码方式。</description></item><item><title>五、Java 9 新特性 – REPL ( JShell )</title><link>https://www.hotmindshare.com/docs/java/java9/5/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.hotmindshare.com/docs/java/java9/5/</guid><description>REPL ，全称 Read Eval Print Loop ,中文 「 交互式解释器 」，其实，就是一种代码所见即所得的即时编译器
Java 9 引入了 REPL ，并将其命令为 「 JShell 」 ，这真是我们 Java 开发的福音，以后演示代码的时候再也不用搬着一个 IDE 到处跑了
对于我们 Java 开发者来说，应该是 Java 9 带来的最大的个性吧。我们终于可以像 Python 、 Ruby 和 Node.js 那样在 Shell 可见即可得的运行一些范例代码了
也就是说，使用 REPL，我们可以编写和测试基于 Java 的逻辑，无需使用 javac 进行编译，直接查看计算结果
运行 JShell 打开命令行提示符 ( Window 7 / Window xp ) 或 PowerShell ( Window 8 / Window 10 ) 或终端 ( Linux / Mac OSX ) ，并输入 jshell 进入 JShell。启动过程有点缓慢</description></item><item><title>五、Memcached quit 命令</title><link>https://www.hotmindshare.com/docs/java/memcached/5/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.hotmindshare.com/docs/java/memcached/5/</guid><description>Memcached quit 命令用户关闭一个客户端连接
语法 1quit 范例 连接到127.0.0.1 上 11211 的 Memcached 服务, 然后退出
1$ telnet 127.0.0.1 11211 2Trying 127.0.0.1... 3Connected to localhost. 4Escape character is &amp;#39;^]&amp;#39;. 5quit 退出 6Connection closed by foreign host. 从返回信息看是 Memcached 主动关闭了连接</description></item><item><title>五、Netty 教程 – 解码器详解</title><link>https://www.hotmindshare.com/docs/java/netty/5/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.hotmindshare.com/docs/java/netty/5/</guid><description>作者：唐亚峰 | 出自：唐亚峰博客
TCP以流的形式传输，在上一章，我们讲了粘包和拆包，以及LineBaseFrameDecoder使用和源码探讨，接下来讲讲Netty为我们实现的其它解码器…..
TCP以流的方式进行数据传输，上层的应用为了对消息进行区分，往往采用如下方式
固定消息长度，累计读取到长度和定长LEN的报文后，就认为读取到了个完整的消息，然后将计数器位置重置在读取下一个报文内容 将回车换行符作为消息结束符\r\n，列如FTP协议，这种方式在文本中应用比较广泛 将特殊分隔符作为消息结束符标志位，回车换行符就是一个特殊结束分隔符(DelimiterBasedFrameDecoder) 通过在消息头定义一个长度字段来标示消息的总长度(FixedLengthFrameDecoder) Netty对以上4种做个统一抽象封装，提供了四种不同解码器来解决对应问题，使用起来也非常的方便，了解了它们，我们就不需要自己对读取的报文人工解码，也不需要考虑TCP粘包和拆包的问题了…
Delimiter自定义分隔符 我将公共的部分做了一层抽离,定义成常量方便调用
1public interface EchoConstant { 2 String SEPARATOR = &amp;#34;$_&amp;#34;;//特殊分割符号,DelimiterBasedFrameDecoder使用 3 Integer ECHO_DELIMITER_PORT = 4040; 4 Integer ECHO_LENGTH_PORT = 5050; 5 String HOST = &amp;#34;127.0.0.1&amp;#34;; 6 Integer FRAME_LENGTH = 10;//固定消息长度,FixedLengthFrameDecoder使用 7} 定义EchoDelimiterServer，毫无疑问大部分代码和以前类似，区别是多了一个日志输出以及DelimiterBasedFrameDecoder的使用
划重点：在做开发调试的时候，我们可以使用Netty为我们提供的LoggingHandler输出日志
1public static void bind(int port) { 2 EventLoopGroup masterGroup = new NioEventLoopGroup();//线程组,含一组NIO线程,专门用来处理网络事件 3 EventLoopGroup workerGroup = new NioEventLoopGroup(); 4 try { 5 ServerBootstrap bootstrap = new ServerBootstrap();//NIO服务端启动辅助类 6 bootstrap.</description></item><item><title>五、Tomcat源码分析-启动分析(三) Catalina启动</title><link>https://www.hotmindshare.com/docs/java/tomcat/5/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.hotmindshare.com/docs/java/tomcat/5/</guid><description>在上一篇文章中，我们分析了tomcat的初始化过程，是由Bootstrap反射调用Catalina的load方法完成tomcat的初始化，包括server.xml的解析、实例化各大组件、初始化组件等逻辑。那么tomcat又是如何启动webapp应用，又是如何加载应用程序的ServletContextListener，以及Servlet呢？我们将在这篇文章进行分析
我们先来看下整体的启动逻辑，tomcat由上往下，挨个启动各个组件：
针对如此复杂的组件关系，tomcat 又是如何将各个组件串联起来，实现统一的生命周期管控呢？在这篇文章中，我们将分析 Service、Engine、Host、Pipeline、Valve 组件的启动逻辑，进一步理解tomcat的架构设计
1、Bootstrap 启动过程和初始化一样，由Bootstrap反射调用Catalina的start方法
1public void start() throws Exception { 2 if( catalinaDaemon==null ) init(); 3 Method method = catalinaDaemon.getClass().getMethod(&amp;#34;start&amp;#34;, (Class [] )null); 4 method.invoke(catalinaDaemon, (Object [])null); 2、Catalina 主要分为以下三个步骤，其核心逻辑在于Server组件：
1、 调用Server的start方法，启动Server组件；
2、 注册jvm关闭的勾子程序，用于安全地关闭Server组件，以及其它组件；
3、 开启shutdown端口的监听并阻塞，用于监听关闭指令；
1public void start() { 2 // 省略若干代码...... 3 // Start the new server 4 try { 5 getServer().start(); 6 } catch (LifecycleException e) { 7 // 省略...... 8 return; 9 } 10 // 注册勾子，用于安全关闭tomcat 11 if (useShutdownHook) { 12 if (shutdownHook == null) { 13 shutdownHook = new CatalinaShutdownHook(); 14 } 15 Runtime.</description></item><item><title>一、Java 9 新特性 – 介绍</title><link>https://www.hotmindshare.com/docs/java/java9/1/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.hotmindshare.com/docs/java/java9/1/</guid><description>Java 9 推出好长时间了，但是它有什么新的东西和废弃了什么东西，我一直没认真去了解过。
本专栏，我一边收集各种资料，一边写一些基础的介绍文章。
Java 9 Java 9 应该是当初最为期待的版本吧。当时因为 Java 8 带来了很多新特性，大家都以为 Java 9 会持续带来更多的新特性。结果呢 ？ 虽然说不上多惊艳，但还是马马虎虎过得去了。
Java 9 是非常理论上应该是名利双收的，但实际上，夹在 Java 7 Java 8 和 Java 10 之间，其实大部分人都还停留在 Java 8 ，如果要升级，早就到了 Java 10 了…
所以，其实，我这个专栏，应该算是介绍性的文章，以简单直观的方式解释了Java 9的基本到高级功能及其用法。如果可以，就深入一点。
我是 Java 9 专栏的读者么 ？ 只要你会 Java，你就可以阅读这个专栏。
本专栏对大多数 Java 开发人员非常有用，从初学者到专家
完成阅读本专栏后，你将发现自己在 Java 9 中具有中等水平的专业知识，当然了，继续的提高还要你的继续努力实践
阅读前提 在你继续阅读本专栏之前，我希望你有一定的 Java 语言基础，或者其它使用 Java Runtime 的语言基础，这样你将事半功倍。
除此之外，别无要求</description></item><item><title>一、Java8 收集器 – java.util.stream.Collectors</title><link>https://www.hotmindshare.com/docs/java/java8/1/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.hotmindshare.com/docs/java/java8/1/</guid><description>Java 8 流的新类 java.util.stream.Collectors 实现了 java.util.stream.Collector 接口，同时又提供了大量的方法对流 ( stream ) 的元素执行 map and reduce 操作，或者统计操作。
本章节，我们就来看看那些常用的方法，顺便写几个示例练练手。
Collectors.averagingDouble() Collectors.averagingDouble() 方法将流中的所有元素视为 double 类型并计算他们的平均值。该方法返回的是同一个 Collectors 实例，因此可以进行链式操作。
Collectors.averagingDouble() 接受一个参数，这个参数是一个 lambda 表达式，用于对所有的元素执行一个 map 操作。
Java 所有集合的 stream().collect() 可以接受一个收集器实例作为其参数并返回该收集器的计算结果
例如下面的代码，collect() 方法会把所有的元素收集起来然后传递给 Collectors.averagingDouble(d-&amp;gt;d*2) 收集器，对每个元素执行 *2 操作后计算平均值
AveragingDoubleExample.java 1package com.ddkk.util.stream; 2import java.util.Arrays; 3import java.util.List; 4import java.util.stream.Collectors; 5public class AveragingDoubleExample { 6 public static void main(String[] args) { 7 List&amp;lt;Integer&amp;gt; list = Arrays.asList(1,2,3,4); 8 Double result = list.stream().collect(Collectors.averagingDouble(d-&amp;gt;d*2)); 9 System.</description></item><item><title>一、Memcached 教程</title><link>https://www.hotmindshare.com/docs/java/memcached/1/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.hotmindshare.com/docs/java/memcached/1/</guid><description>Memcached是一个自由开源的，高性能，分布式内存键值对缓存系统
Memcached 是一种基于内存的key-value存储，用来存储小块的任意数据（字符串、对象），这些数据可以是数据库调用、API调用或者是页面渲染的结果
Memcached 的简洁设计便于快速开发，减轻开发难度，解决了大数据量缓存的很多问题
它的API 通俗易懂，非常容易开发，且兼容大部分流行的开发语言。
简单的说： Memcached 是一个简洁的key-value内存缓存存储系统
使用 Memcached 后的架构图 有了Memcached ，我们就可以通过缓存数据库查询结果，减少数据库访问次数，以提高动态Web应用的速度、提高可扩展性
![Memcached 缓存构架] (/static/i/memcached_goujia.jpg)
Memcached 官网 http://memcached.org/
Memcached 特征 Memcached作为高速运行的分布式缓存服务器，具有以下的特点
协议简单，使用文本协议，使用换行符作为命令结束 基于 libevent 的事件处理 内置内存存储方式 Memcached 使用客户端哈希的不互相通信的分布式</description></item><item><title>一、Netty 教程 – 传统I/O编程（BIO）</title><link>https://www.hotmindshare.com/docs/java/netty/1/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.hotmindshare.com/docs/java/netty/1/</guid><description>作者：唐亚峰 | 出自：唐亚峰博客
有一段时间没写博客了，Spring Cloud 基本的都已经写完（后续会写一个SpringBootAdmin的整合），接下来会记录Netty相关的，早期的JAVA对NIO支持是非常糟糕的，直到2002年发布的JDK1.4中才第一次支持非阻塞I/O，这个类库为JDK通讯模型带来了翻天覆地的变化，在开始学习Netty之前先看看早期的写法是什么样的……
- 网络编程 网络编程的基本模型就是Client/Server模型，两个进程相互通讯，其中服务端提供位置信息（ip:port），客户端通过连接操作向服务端监听的地址发起连接请求，通过三次握手建立连接，如果成功则可以通过网络套字（Socket）进行通信…
- 同步阻塞I/O 采用BIO通信模型的服务端，通常由一个独立的Acceptor线程负责监听客户端链接，由它来接收到每个请求然后为每个客户端创建一个新的线程进行链路处理，处理完毕后通过输出流应答给客户端，然后线程销毁…
该模型最大的问题就是缺乏弹性伸缩能力，因为它是1 : 1 模型的，当客户端越多服务端线程开销越大，线程数膨胀后，系统性能就急剧下降了，然后堆栈，GC，等等问题就来找你唠嗑了…
- TimeServer 1import java.io.BufferedReader; 2import java.io.IOException; 3import java.io.InputStreamReader; 4import java.io.PrintWriter; 5import java.net.ServerSocket; 6import java.net.Socket; 7/** 8 * 初窥NIO-TimeServer：同步阻塞方式的I/O创建 9 * @author Levin 10 */ 11public class TimeServer { 12 public static void main(String[] args) { 13 int port = 4040; 14 System.out.println(&amp;#34;start server......&amp;#34; + port); 15 ServerSocket serverSocket = null; 16 try { 17 serverSocket = new ServerSocket(port); 18 while (true) { 19 new TimeServerHandler(serverSocket.</description></item><item><title>一、Tomcat源码分析-环境搭建</title><link>https://www.hotmindshare.com/docs/java/tomcat/1/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.hotmindshare.com/docs/java/tomcat/1/</guid><description>前言 为什么要学习tomcat源码？ tomcat是目前非常流行的web容器，其性能和稳定性也是非常出色的，学习其框架设计和底层的实现，不管是使用、性能调优，还是应用框架设计方面，肯定会有很大的帮助
tomcat版本 该系列博客的tomcat版本是8.5.24
下载源码 从apache官网下载tomcat源码包，本人以8.5.24版本为例，http://tomcat.apache.org/download-80.cgi
maven 本人习惯使用maven，因此将源码转成maven工程。新建pom.xml，加入相关依赖，如附录所示
导入开发工具 导入maven项目，因为有些测试类依赖了examples目录的类，因此把apache-tomcat-8.5.24-src\webapps\examples\WEB-INF\classes目录在开发工具上面设置为java源文件，编译的class输出目录设为classes，如下图所示
上传源码 在看源码过程中经常需要对源码进行注释，建议大家把源码上传至自己的git，方便后续查漏补缺。tips:在.gitignore文件需要忽略target目录(class文件输出目录)
附上本人的码云地址，git@gitee.com:bestkobe/tomcat.git
附录 pom.xml
1&amp;lt;?xml version=&amp;#34;1.0&amp;#34; encoding=&amp;#34;UTF-8&amp;#34;?&amp;gt; 2&amp;lt;project xmlns=&amp;#34;http://maven.apache.org/POM/4.0.0&amp;#34; xmlns:xsi=&amp;#34;http://www.w3.org/2001/XMLSchema-instance&amp;#34; 3 xsi:schemaLocation=&amp;#34;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&amp;#34;&amp;gt; 4 &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt; 5 &amp;lt;groupId&amp;gt;org.apache&amp;lt;/groupId&amp;gt; 6 &amp;lt;artifactId&amp;gt;tomcat&amp;lt;/artifactId&amp;gt; 7 &amp;lt;name&amp;gt;apache-tomcat-8.5.24&amp;lt;/name&amp;gt; 8 &amp;lt;version&amp;gt;8.5.24&amp;lt;/version&amp;gt; 9 &amp;lt;build&amp;gt; 10 &amp;lt;finalName&amp;gt;Tomcat-8.5.24&amp;lt;/finalName&amp;gt; 11 &amp;lt;sourceDirectory&amp;gt;java&amp;lt;/sourceDirectory&amp;gt; 12 &amp;lt;testSourceDirectory&amp;gt;test&amp;lt;/testSourceDirectory&amp;gt; 13 &amp;lt;resources&amp;gt; 14 &amp;lt;resource&amp;gt; 15 &amp;lt;directory&amp;gt;java&amp;lt;/directory&amp;gt; 16 &amp;lt;/resource&amp;gt; 17 &amp;lt;/resources&amp;gt; 18 &amp;lt;testResources&amp;gt; 19 &amp;lt;testResource&amp;gt; 20 &amp;lt;directory&amp;gt;test&amp;lt;/directory&amp;gt; 21 &amp;lt;/testResource&amp;gt; 22 &amp;lt;/testResources&amp;gt; 23 &amp;lt;plugins&amp;gt; 24 &amp;lt;plugin&amp;gt; 25 &amp;lt;groupId&amp;gt;org.apache.maven.plugins&amp;lt;/groupId&amp;gt; 26 &amp;lt;artifactId&amp;gt;maven-compiler-plugin&amp;lt;/artifactId&amp;gt; 27 &amp;lt;version&amp;gt;3.</description></item><item><title>一起来学 SpringBoot 2.x | 第八篇：通用Mapper与分页插件的集成</title><link>https://www.hotmindshare.com/docs/java/sprintboot2/8/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.hotmindshare.com/docs/java/sprintboot2/8/</guid><description>作者：唐亚峰 | 出自：https://blog.battcn.com
SpringBoot 是为了简化 Spring 应用的创建、运行、调试、部署等一系列问题而诞生的产物，自动装配的特性让我们可以更好的关注业务本身而不是外部的XML配置，我们只需遵循规范，引入相关的依赖就可以轻易的搭建出一个 WEB 工程
在一起来学SpringBoot | 第七篇：整合Mybatis一文中，我们介绍了Mybatis这款优秀的框架，顺便提及了民间大神开发的两款插件**（通用Mapper、PageHelper）**，从此告别简单CURD代码的编写….
插件介绍 以下两款插件作者均是同一个人，如果你想深入了解Mybatis以及插件开发可以购买作者的书籍
京东： https://item.jd.com/12103309.html 当当： http://product.dangdang.com/25098208.html 分页插件
GIT地址： https://github.com/pagehelper/Mybatis-PageHelper 在没有分页插件之前，写一个分页需要两条SQL语句，一条查询一条统计，然后才能计算出页码，这样的代码冗余而又枯燥，更重要的一点是**数据库迁移**，众所周知不同的数据库分页写法是不同的，而Mybatis不同于Hibernate的是它只提供动态SQL和结果集映射。值得庆幸的是，它虽然没有为分页提供良好的解决方案，但却提供了Interceptor以供开发者自己扩展，这也是这款分页插件的由来….
通用Mapper
GIT地址： https://gitee.com/free/Mapper 通用 Mapper 是一个可以实现任意 MyBatis 通用方法的框架，项目提供了常规的增删改查操作以及 Example 相关的单表操作。通用 Mapper 是为了解决 MyBatis 使用中 90% 的基本操作，使用它可以很方便的进行开发，可以节省开发人员大量的时间。
导入依赖 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 在pom.xml 中添加通用Mapper与分页插件的依赖包
1&amp;lt;!-- 通用Mapper插件 2 文档地址：https://gitee.com/free/Mapper/wikis/Home --&amp;gt; 3&amp;lt;dependency&amp;gt; 4 &amp;lt;groupId&amp;gt;tk.mybatis&amp;lt;/groupId&amp;gt; 5 &amp;lt;artifactId&amp;gt;mapper-spring-boot-starter&amp;lt;/artifactId&amp;gt; 6 &amp;lt;version&amp;gt;2.0.2&amp;lt;/version&amp;gt; 7&amp;lt;/dependency&amp;gt; 8&amp;lt;!-- 分页插件 9 文档地址：https://github.com/pagehelper/Mybatis-PageHelper/blob/master/wikis/zh/HowToUse.md --&amp;gt; 10&amp;lt;dependency&amp;gt; 11 &amp;lt;groupId&amp;gt;com.github.pagehelper&amp;lt;/groupId&amp;gt; 12 &amp;lt;artifactId&amp;gt;pagehelper-spring-boot-starter&amp;lt;/artifactId&amp;gt; 13 &amp;lt;version&amp;gt;1.2.5&amp;lt;/version&amp;gt; 14&amp;lt;/dependency&amp;gt; 15&amp;lt;!-- MYSQL包 --&amp;gt; 16&amp;lt;dependency&amp;gt; 17 &amp;lt;groupId&amp;gt;mysql&amp;lt;/groupId&amp;gt; 18 &amp;lt;artifactId&amp;gt;mysql-connector-java&amp;lt;/artifactId&amp;gt; 19&amp;lt;/dependency&amp;gt; 20&amp;lt;!</description></item><item><title>一起来学 SpringBoot 2.x | 第二篇：SpringBoot配置详解</title><link>https://www.hotmindshare.com/docs/java/sprintboot2/2/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.hotmindshare.com/docs/java/sprintboot2/2/</guid><description>作者：唐亚峰 | 出自：https://blog.battcn.com
SpringBoot 是为了简化 Spring 应用的创建、运行、调试、部署等一系列问题而诞生的产物，自动装配的特性让我们可以更好的关注业务本身而不是外部的XML配置，我们只需遵循规范，引入相关的依赖就可以轻易的搭建出一个 WEB 工程
上一篇介绍了 SpringBoot 由来及构建方式，通过第一章的教程我们对 SpringBoot 不在感到陌生，可以发现 SpringBoot 虽然干掉了 XML 但未做到 零配置，它体现出了一种 约定优于配置，也称作按约定编程，是一种软件设计范式，旨在减少软件开发人员需做决定的数量，获得简单的好处，而又不失灵活性。 一般情况下默认的配置足够满足日常开发所需，但在特殊的情况下，我们往往需要用到自定义属性配置、自定义文件配置、多环境配置、外部命令引导等一系列功能。不用担心，这些 SpringBoot 都替我们考虑好了，我们只需要遵循它的规则配置即可
准备前提
为了让SpringBoot 更好的生成数据，我们需要添加如下依赖（该依赖可以不添加，但是在 IDEA 和 STS 中不会有属性提示，没有提示的配置就跟你用记事本写代码一样苦逼，出个问题弄哭你去），该依赖只会在编译时调用，所以不用担心会对生产造成影响…
1&amp;lt;dependency&amp;gt; 2 &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; 3 &amp;lt;artifactId&amp;gt;spring-boot-configuration-processor&amp;lt;/artifactId&amp;gt; 4 &amp;lt;optional&amp;gt;true&amp;lt;/optional&amp;gt; 5&amp;lt;/dependency&amp;gt; 自定义属性配置 在application.properties 写入如下配置内容
1my1.age=22 2my1.name=battcn 其次定义 MyProperties1.java 文件，用来映射我们在 application.properties 中的内容，这样一来我们就可以通过操作对象的方式来获得配置文件的内容了
1package com.battcn.properties; 2import org.springframework.boot.context.properties.ConfigurationProperties; 3import org.springframework.stereotype.Component; 4/** 5 * @author Levin 6 * @since 2018/4/23 0023 7 */ 8@Component 9@ConfigurationProperties(prefix = &amp;#34;my1&amp;#34;) 10public class MyProperties1 { 11 private int age; 12 private String name; 13 // 省略 get set 14 @Override 15 public String toString() { 16 return &amp;#34;MyProperties1{&amp;#34; + 17 &amp;#34;age=&amp;#34; + age + 18 &amp;#34;, name=&amp;#39;&amp;#34; + name + &amp;#39;\&amp;#39;&amp;#39; + 19 &amp;#39;}&amp;#39;; 20 } 21} 接下来就是定义我们的 PropertiesController 用来注入 MyProperties1 测试我们编写的代码，值得注意的是 Spring4.</description></item><item><title>一起来学 SpringBoot 2.x | 第二十二篇：轻松搞定重复提交（本地锁）</title><link>https://www.hotmindshare.com/docs/java/sprintboot2/22/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.hotmindshare.com/docs/java/sprintboot2/22/</guid><description>作者：唐亚峰 | 出自：https://blog.battcn.com
SpringBoot 是为了简化 Spring 应用的创建、运行、调试、部署等一系列问题而诞生的产物，自动装配的特性让我们可以更好的关注业务本身而不是外部的XML配置，我们只需遵循规范，引入相关的依赖就可以轻易的搭建出一个 WEB 工程
在平时开发中，如果网速比较慢的情况下，用户提交表单后，发现服务器半天都没有响应，那么用户可能会以为是自己没有提交表单，就会再点击提交按钮重复提交表单，我们在开发中必须防止表单重复提交….
重复提交 字面意思就是提交了很多次，这种情况一般都是前端给你挖的坑….
前段时间在开发中遇到一个这样的问题；前端小哥哥调用接口的时候存在 循环调用 的问题，正常情况下发送一个请求添加一条数据，结果变成了同一时刻并发的发送了 N 个请求，服务端瞬间懵逼的插入了 N 条一模一样的数据，前端小哥哥也不知道问题在哪里（恩...坑就这样挖好了，反正不填坑，气死你） 这时候咋办呢；后端干呗，反正脏活累活，背锅的事情也没少干了，多一件也不多….
本章目标 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 利用自定义注解、Spring Aop、Guava Cache 实现表单防重复提交（不适用于分布式哦，后面会讲分布式方式...）
具体代码 非常简单…
导入依赖 在pom.xml 中添加上 spring-boot-starter-web 的依赖即可
1&amp;lt;dependencies&amp;gt; 2 &amp;lt;dependency&amp;gt; 3 &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; 4 &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt; 5 &amp;lt;/dependency&amp;gt; 6 &amp;lt;dependency&amp;gt; 7 &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; 8 &amp;lt;artifactId&amp;gt;spring-boot-starter-aop&amp;lt;/artifactId&amp;gt; 9 &amp;lt;/dependency&amp;gt; 10 &amp;lt;dependency&amp;gt; 11 &amp;lt;groupId&amp;gt;com.google.guava&amp;lt;/groupId&amp;gt; 12 &amp;lt;artifactId&amp;gt;guava&amp;lt;/artifactId&amp;gt; 13 &amp;lt;version&amp;gt;21.0&amp;lt;/version&amp;gt; 14 &amp;lt;/dependency&amp;gt; 15&amp;lt;/dependencies&amp;gt; Lock 注解 创建一个 LocalLock 注解，简单点就一个 key 可以了，由于暂时未用到 redis 所以 expire 是摆设….</description></item><item><title>一起来学 SpringBoot 2.x | 第二十六篇：轻松搞定安全框架（Shiro）</title><link>https://www.hotmindshare.com/docs/java/sprintboot2/26/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.hotmindshare.com/docs/java/sprintboot2/26/</guid><description>作者：唐亚峰 | 出自：https://blog.battcn.com
SpringBoot 是为了简化 Spring 应用的创建、运行、调试、部署等一系列问题而诞生的产物，自动装配的特性让我们可以更好的关注业务本身而不是外部的XML配置，我们只需遵循规范，引入相关的依赖就可以轻易的搭建出一个 WEB 工程
Shiro 是 Apache 旗下开源的一款强大且易用的Java安全框架，身份验证、授权、加密、会话管理。 相比 Spring Security 而言 Shiro 更加轻量级，且 API 更易于理解…
Shiro Shiro 主要分为 安全认证 和 接口授权 两个部分，其中的核心组件为 Subject、SecurityManager、Realms，公共部分 Shiro 都已经为我们封装好了，我们只需要按照一定的规则去编写响应的代码即可…
Subject 即表示主体，将用户的概念理解为当前操作的主体，因为它即可以是一个通过浏览器请求的用户，也可能是一个运行的程序，外部应用与 Subject 进行交互，记录当前操作用户。Subject 代表了当前用户的安全操作，SecurityManager 则管理所有用户的安全操作。 SecurityManager 即安全管理器，对所有的 Subject 进行安全管理，并通过它来提供安全管理的各种服务（认证、授权等） Realm 充当了应用与数据安全间的 桥梁 或 连接器。当对用户执行认证（登录）和授权（访问控制）验证时，Shiro 会从应用配置的 Realm 中查找用户及其权限信息。 本章目标 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 利用Spring Boot 与 Shiro 实现安全认证和授权….
导入依赖 依赖spring-boot-starter-web…
1&amp;lt;properties&amp;gt; 2 &amp;lt;project.build.sourceEncoding&amp;gt;UTF-8&amp;lt;/project.build.sourceEncoding&amp;gt; 3 &amp;lt;project.reporting.outputEncoding&amp;gt;UTF-8&amp;lt;/project.reporting.outputEncoding&amp;gt; 4 &amp;lt;java.version&amp;gt;1.8&amp;lt;/java.version&amp;gt; 5 &amp;lt;shiro.version&amp;gt;1.4.0&amp;lt;/shiro.version&amp;gt; 6&amp;lt;/properties&amp;gt; 7&amp;lt;dependencies&amp;gt; 8 &amp;lt;dependency&amp;gt; 9 &amp;lt;groupId&amp;gt;org.</description></item><item><title>一起来学 SpringBoot 2.x | 第二十篇：轻松搞定数据验证（二）</title><link>https://www.hotmindshare.com/docs/java/sprintboot2/20/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.hotmindshare.com/docs/java/sprintboot2/20/</guid><description>作者：唐亚峰 | 出自：https://blog.battcn.com
SpringBoot 是为了简化 Spring 应用的创建、运行、调试、部署等一系列问题而诞生的产物，自动装配的特性让我们可以更好的关注业务本身而不是外部的XML配置，我们只需遵循规范，引入相关的依赖就可以轻易的搭建出一个 WEB 工程
一起来学SpringBoot | 第十九篇：轻松搞定数据验证（一） 中介绍了数据有效性校验的重要性，也简单介绍了如何用轻松的方式搞定数据有效性校验，但是当系统自带的注解无法满足我们的要求时候应该咋办呢？这就是本章将给各位介绍的**自定义 Validator 注解**
为何要自定义 javax.validation 包与 hibernate-validator 包中存在的注解几乎可以满足大部分的要求，又拥有基于正则表达式的@Pattern，为什么还需要自己去定义呢？
原因如下
正则效率不高 正则可读性不好 正则门槛较高，很多开发者并不会编写正则表达式 本章目标 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 熟悉ConstraintValidator 接口并且编写自己的数据验证注解
具体代码 非常简单…
导入依赖 在pom.xml 中添加上 spring-boot-starter-web 的依赖即可
1&amp;lt;dependencies&amp;gt; 2 &amp;lt;dependency&amp;gt; 3 &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; 4 &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt; 5 &amp;lt;/dependency&amp;gt; 6 &amp;lt;dependency&amp;gt; 7 &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; 8 &amp;lt;artifactId&amp;gt;spring-boot-starter-test&amp;lt;/artifactId&amp;gt; 9 &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt; 10 &amp;lt;/dependency&amp;gt; 11&amp;lt;/dependencies&amp;gt; 自定义注解 这里定义了一个 @DateTime 注解，在该注解上标注了 @Constraint 注解，它的作用就是指定一个具体的校验器类
关键字段（强制性）
message： 验证失败提示的消息内容 groups： 为约束指定验证组（非常不错的一个功能，下一章介绍） payload： 不太清楚（欢迎留言交流） 1package com.</description></item><item><title>一起来学 SpringBoot 2.x | 第二十七篇：优雅解决分布式限流</title><link>https://www.hotmindshare.com/docs/java/sprintboot2/27/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.hotmindshare.com/docs/java/sprintboot2/27/</guid><description>作者：唐亚峰 | 出自：https://blog.battcn.com
SpringBoot 是为了简化 Spring 应用的创建、运行、调试、部署等一系列问题而诞生的产物， 自动装配的特性让我们可以更好的关注业务本身而不是外部的XML配置，我们只需遵循规范，引入相关的依赖就可以轻易的搭建出一个WEB工程
在前面的两篇文章中，介绍了一些限流的类型和策略，本篇从 SpringBoot、 Redis 应用层面来实现分布式的限流….
分布式限流 单机版中我们了解到 AtomicInteger、 RateLimiter、 Semaphore 这几种解决方案，但它们也仅仅是单机的解决手段，在集群环境下就透心凉了，后面又讲述了 Nginx 的限流手段，可它又属于网关层面的策略之一，并不能解决所有问题。例如供短信接口，你无法保证消费方是否会做好限流控制，所以自己在应用层实现限流还是很有必要的。
本章目标 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 利用自定义注解、 SpringAop、 RedisCache 实现分布式限流….
具体代码 很简单…
导入依赖 在pom.xml 中添加上 starter-web、 starter-aop、 starter-data-redis 的依赖即可，习惯了使用 commons-lang3 和 guava 中的一些工具包…
1&amp;lt;dependencies&amp;gt; 2 &amp;lt;!-- 默认就内嵌了Tomcat 容器，如需要更换容器也极其简单--&amp;gt; 3 &amp;lt;dependency&amp;gt; 4 &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; 5 &amp;lt;artifactId&amp;gt;spring-boot-starter-aop&amp;lt;/artifactId&amp;gt; 6 &amp;lt;/dependency&amp;gt; 7 &amp;lt;dependency&amp;gt; 8 &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; 9 &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt; 10 &amp;lt;/dependency&amp;gt; 11 &amp;lt;dependency&amp;gt; 12 &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; 13 &amp;lt;artifactId&amp;gt;spring-boot-starter-data-redis&amp;lt;/artifactId&amp;gt; 14 &amp;lt;/dependency&amp;gt; 15 &amp;lt;dependency&amp;gt; 16 &amp;lt;groupId&amp;gt;com.</description></item><item><title>一起来学 SpringBoot 2.x | 第二十三篇：轻松搞定重复提交（分布式锁）</title><link>https://www.hotmindshare.com/docs/java/sprintboot2/23/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.hotmindshare.com/docs/java/sprintboot2/23/</guid><description>作者：唐亚峰 | 出自：https://blog.battcn.com
SpringBoot 是为了简化 Spring 应用的创建、运行、调试、部署等一系列问题而诞生的产物，自动装配的特性让我们可以更好的关注业务本身而不是外部的XML配置，我们只需遵循规范，引入相关的依赖就可以轻易的搭建出一个 WEB 工程
在一起来学SpringBoot | 第二十二篇：轻松搞定重复提交（一） 一文中介绍了单机版的重复提交解决方案，在如今这个分布式与集群横行的世道中，那怎么够用呢，所以本章重点来了....
重复提交（分布式） 单机版中我们用的是Guava Cache，但是这玩意存在集群的时候就凉了，所以我们还是要借助类似Redis、ZooKeeper 之类的中间件实现分布式锁。
本章目标 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 利用自定义注解、Spring Aop、Redis Cache 实现分布式锁，你想锁表单锁表单，想锁接口锁接口….
具体代码 也很简单…
导入依赖 在pom.xml 中添加上 starter-web、starter-aop、starter-data-redis 的依赖即可
1&amp;lt;dependencies&amp;gt; 2 &amp;lt;dependency&amp;gt; 3 &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; 4 &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt; 5 &amp;lt;/dependency&amp;gt; 6 &amp;lt;dependency&amp;gt; 7 &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; 8 &amp;lt;artifactId&amp;gt;spring-boot-starter-aop&amp;lt;/artifactId&amp;gt; 9 &amp;lt;/dependency&amp;gt; 10 &amp;lt;dependency&amp;gt; 11 &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; 12 &amp;lt;artifactId&amp;gt;spring-boot-starter-data-redis&amp;lt;/artifactId&amp;gt; 13 &amp;lt;/dependency&amp;gt; 14&amp;lt;/dependencies&amp;gt; 属性配置 在application.properites 资源文件中添加 redis 相关的配置项
1spring.redis.host=localhost 2spring.redis.port=6379 3spring.redis.password=battcn CacheLock 注解 创建一个 CacheLock 注解，本章内容都是实战使用过的，所以属性配置会相对完善了，话不多说注释都给各位写齐全了….</description></item><item><title>一起来学 SpringBoot 2.x | 第二十四篇：数据库管理与迁移（Liquibase）</title><link>https://www.hotmindshare.com/docs/java/sprintboot2/24/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.hotmindshare.com/docs/java/sprintboot2/24/</guid><description>作者：唐亚峰 | 出自：https://blog.battcn.com
SpringBoot 是为了简化 Spring 应用的创建、运行、调试、部署等一系列问题而诞生的产物，自动装配的特性让我们可以更好的关注业务本身而不是外部的XML配置，我们只需遵循规范，引入相关的依赖就可以轻易的搭建出一个 WEB 工程
目前Spring Boot 支持较好的两款工具分别是 flyway、liquibase，支持 sql script，在初始化数据源之后执行指定的脚本代码或者脚本文件，本章基于 Liquibase…
Liquibase LiquiBase 是一个用于数据库重构和迁移的开源工具，通过 changelog文件 的形式记录数据库的变更，然后执行 changelog文件 中的修改，将数据库更新或回滚到一致的状态。
主要特点
支持几乎所有主流的数据库，如MySQL、PostgreSQL、Oracle、Sql Server、DB2等 支持多开发者的协作维护； 日志文件支持多种格式；如XML、YAML、SON、SQL等 支持多种运行方式；如命令行、Spring 集成、Maven 插件、Gradle 插件等 在平时开发中，无可避免测试库增加字段或者修改字段以及创建表之类的，环境切换的时候如果忘记修改数据库那么肯定会出现 不可描述的事情 ，这个时候不妨考虑考虑Liquibase。
官方文档：http://www.liquibase.org/documentation/index.html
本章目标 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 利用Spring Boot 集成 Liquibase，避免因粗心大意导致环境迁移时缺少字段….
导入依赖 依赖spring-boot-starter-jdbc 目的是为了让 liquibase 能够获得 datasource ，这里换成 mybatis、hibernate 等也是一样，主要偷懒不想写配置….
1&amp;lt;dependencies&amp;gt; 2 &amp;lt;dependency&amp;gt; 3 &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; 4 &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt; 5 &amp;lt;/dependency&amp;gt; 6 &amp;lt;dependency&amp;gt; 7 &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; 8 &amp;lt;artifactId&amp;gt;spring-boot-starter-jdbc&amp;lt;/artifactId&amp;gt; 9 &amp;lt;/dependency&amp;gt; 10 &amp;lt;dependency&amp;gt; 11 &amp;lt;groupId&amp;gt;mysql&amp;lt;/groupId&amp;gt; 12 &amp;lt;artifactId&amp;gt;mysql-connector-java&amp;lt;/artifactId&amp;gt; 13 &amp;lt;/dependency&amp;gt; 14 &amp;lt;dependency&amp;gt; 15 &amp;lt;groupId&amp;gt;org.</description></item><item><title>一起来学 SpringBoot 2.x | 第二十五篇：打造属于你的聊天室（WebSocket）</title><link>https://www.hotmindshare.com/docs/java/sprintboot2/25/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.hotmindshare.com/docs/java/sprintboot2/25/</guid><description>作者：唐亚峰 | 出自：https://blog.battcn.com
SpringBoot 是为了简化 Spring 应用的创建、运行、调试、部署等一系列问题而诞生的产物，自动装配的特性让我们可以更好的关注业务本身而不是外部的XML配置，我们只需遵循规范，引入相关的依赖就可以轻易的搭建出一个 WEB 工程
Webscoket 对浏览器有一定的要求，所以使用之前要考虑兼容性的问题….
Webscoket WebSocket 是 HTML5 新增的一种在单个 TCP 连接上进行全双工通讯的协议，与 HTTP 协议没有太大关系….
在 WebSocket API 中，浏览器和服务器只需要做一个握手的动作，然后，浏览器和服务器之间就形成了一条快速通道。两者之间就直接可以数据互相传送。
浏览器通过 JavaScript 向服务器发出建立 WebSocket 连接的请求，连接建立以后，客户端和服务器端就可以通过 TCP 连接直接交换数据。
当你获取 WebSocket 连接后，你可以通过 send() 方法来向服务器发送数据，并通过 onmessage() 事件来接收服务器返回的数据..
长连接
与AJAX 轮训的方式差不多，但长连接不像 AJAX 轮训一样，而是采用的阻塞模型（一直打电话，没收到就不挂电话）；客户端发起连接后，如果没消息，就一直不返回 Response 给客户端。直到有消息才返回，返回完之后，客户端再次建立连接，周而复始。
在没有WebSocket 之前，大家常用的手段应该就是轮训了，比如每隔几秒发起一次请求，但这样带来的就是高性能开销，都知道一次 HTTP 响应是需要经过三次握手和四次挥手，远不如 TCP 长连接来的划算
WebSocket 事件
本章目标 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 利用Spring Boot 与 WebSocke 打造 一对一 和 一对多 的在线聊天….
导入依赖 依赖spring-boot-starter-websocket…
1&amp;lt;dependencies&amp;gt; 2 &amp;lt;dependency&amp;gt; 3 &amp;lt;groupId&amp;gt;org.</description></item><item><title>一起来学 SpringBoot 2.x | 第二十一篇：轻松搞定数据验证（三）</title><link>https://www.hotmindshare.com/docs/java/sprintboot2/21/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.hotmindshare.com/docs/java/sprintboot2/21/</guid><description>作者：唐亚峰 | 出自：https://blog.battcn.com
SpringBoot 是为了简化 Spring 应用的创建、运行、调试、部署等一系列问题而诞生的产物，自动装配的特性让我们可以更好的关注业务本身而不是外部的XML配置，我们只需遵循规范，引入相关的依赖就可以轻易的搭建出一个 WEB 工程
前面两章中详细介绍了数据有效性校验的重要性、自定有数据有效性校验注解 本章也是轻松搞定数据验证的最后一篇， 一起来揭开神秘的分组验证
分组验证 有的时候，我们对一个实体类需要有多中验证方式，在不同的情况下使用不同验证方式，比如说对于一个实体类来的 id 来说，新增的时候是不需要的，对于更新时是必须的，这个时候你是选择写一个实体类呢还是写两个呢？
在自定有数据有效性校验注解中介绍到注解需要有一个 groups 属性，这个属性的作用又是什么呢？
接下来就让我们看看如何用一个验证类实现多个接口之间不同规则的验证…
本章目标 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 利用一个验证类实现多个接口之间不同规则的验证…
具体代码 非常简单…
导入依赖 在pom.xml 中添加上 spring-boot-starter-web 的依赖即可
1&amp;lt;dependencies&amp;gt; 2 &amp;lt;dependency&amp;gt; 3 &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; 4 &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt; 5 &amp;lt;/dependency&amp;gt; 6 &amp;lt;dependency&amp;gt; 7 &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; 8 &amp;lt;artifactId&amp;gt;spring-boot-starter-test&amp;lt;/artifactId&amp;gt; 9 &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt; 10 &amp;lt;/dependency&amp;gt; 11&amp;lt;/dependencies&amp;gt; 分组验证器 定义一个验证组，里面写上不同的空接口类即可
1package com.battcn.groups; 2/** 3 * 验证组 4 * 5 * @author Levin 6 * @since 2018/6/7 0007 7 */ 8public class Groups { 9 public interface Update { 10 } 11 public interface Default { 12 } 13} 实体类 **groups 属性的作用就让 @Validated 注解只验证与自身 value 属性相匹配的字段，可多个，只要满足就会去纳入验证范围；**我们都知道针对新增的数据我们并不需要验证 ID 是否存在，我们只在做修改操作的时候需要用到，因此这里将 ID 字段归纳到 Groups.</description></item><item><title>一起来学 SpringBoot 2.x | 第九篇：整合Lettuce Redis</title><link>https://www.hotmindshare.com/docs/java/sprintboot2/9/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.hotmindshare.com/docs/java/sprintboot2/9/</guid><description>作者：唐亚峰 | 出自：https://blog.battcn.com
SpringBoot 是为了简化 Spring 应用的创建、运行、调试、部署等一系列问题而诞生的产物，自动装配的特性让我们可以更好的关注业务本身而不是外部的XML配置，我们只需遵循规范，引入相关的依赖就可以轻易的搭建出一个 WEB 工程
Spring Boot 除了支持常见的ORM框架外，更是对常用的中间件提供了非常好封装，随着Spring Boot2.x的到来，支持的组件越来越丰富，也越来越成熟，其中对Redis的支持不仅仅是丰富了它的API，更是替换掉底层Jedis的依赖，取而代之换成了Lettuce(生菜)
Redis介绍 Redis是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。相比Memcached它支持存储的类型相对更多**（字符、哈希、集合、有序集合、列表、GEO）**，同时Redis是线程安全的。2010年3月15日起，Redis的开发工作由VMware主持，2013年5月开始，Redis的开发由Pivotal赞助。
Lettuce 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 Lettuce 和 Jedis 的都是连接Redis Server的客户端程序。Jedis在实现上是直连redis server，多线程环境下非线程安全，除非使用连接池，为每个Jedis实例增加物理连接。Lettuce基于Netty的连接实例（StatefulRedisConnection），可以在多个线程间并发访问，且线程安全，满足多线程环境下的并发访问，同时它是可伸缩的设计，一个连接实例不够的情况也可以按需增加连接实例。
导入依赖 在pom.xml 中spring-boot-starter-data-redis的依赖，Spring Boot2.x 后底层不在是Jedis如果做版本升级的朋友需要注意下
1&amp;lt;dependency&amp;gt; 2 &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; 3 &amp;lt;artifactId&amp;gt;spring-boot-starter-data-redis&amp;lt;/artifactId&amp;gt; 4&amp;lt;/dependency&amp;gt; 5&amp;lt;dependency&amp;gt; 6 &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; 7 &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt; 8&amp;lt;/dependency&amp;gt; 9&amp;lt;dependency&amp;gt; 10 &amp;lt;groupId&amp;gt;org.apache.commons&amp;lt;/groupId&amp;gt; 11 &amp;lt;artifactId&amp;gt;commons-pool2&amp;lt;/artifactId&amp;gt; 12&amp;lt;/dependency&amp;gt; 13&amp;lt;dependency&amp;gt; 14 &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; 15 &amp;lt;artifactId&amp;gt;spring-boot-starter-test&amp;lt;/artifactId&amp;gt; 16 &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt; 17&amp;lt;/dependency&amp;gt; 属性配置 在application.properties 文件中配置如下内容，由于Spring Boot2.x 的改动，连接池相关配置需要通过spring.redis.lettuce.pool 或者 spring.redis.jedis.pool 进行配置了
1spring.redis.host=localhost 2spring.redis.password=battcn 3# 连接超时时间（毫秒） 4spring.redis.timeout=10000 5# Redis默认情况下有16个分片，这里配置具体使用的分片，默认是0 6spring.</description></item><item><title>一起来学 SpringBoot 2.x | 第六篇：整合SpringDataJpa</title><link>https://www.hotmindshare.com/docs/java/sprintboot2/6/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.hotmindshare.com/docs/java/sprintboot2/6/</guid><description>作者：唐亚峰 | 出自：https://blog.battcn.com
SpringBoot 是为了简化 Spring 应用的创建、运行、调试、部署等一系列问题而诞生的产物，自动装配的特性让我们可以更好的关注业务本身而不是外部的XML配置，我们只需遵循规范，引入相关的依赖就可以轻易的搭建出一个 WEB 工程
[上一篇][Link1]介绍了Spring JdbcTemplate的使用，对比原始的JDBC而言，它更加的简洁。但随着表的增加，重复的CRUD工作让我们苦不堪言，这时候Spring Data Jpa的作用就体现出来了…..
JPA JPA是Java Persistence API的简称，中文名Java持久层API，是官方（Sun）在JDK5.0后提出的Java持久化规范。其目的是为了简化现有JAVA EE和JAVA SE应用开发工作，以及整合现有的ORM技术实现规范统一
JPA的总体思想和现有Hibernate、TopLink、JDO等ORM框架大体一致。总的来说，JPA包括以下3方面的技术：
ORM映射元数据： 支持XML和注解两种元数据的形式，元数据描述对象和表之间的映射关系，框架据此将实体对象持久化到数据库表中； API： 操作实体对象来执行CRUD操作，框架在后台替代我们完成所有的事情，开发者从繁琐的JDBC和SQL代码中解脱出来。 查询语言： 通过面向对象而非面向数据库的查询语言查询数据，避免程序的SQL语句紧密耦合。 JPA只是一种规范，它需要第三方自行实现其功能，在众多框架中Hibernate是最为强大的一个。从功能上来说，JPA就是Hibernate功能的一个子集。Hibernate 从3.2开始，就开始兼容JPA。同时Hibernate3.2获得了Sun TCK的JPA(Java Persistence API) 兼容认证。
Spring Data JPA 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 常见的ORM框架中Hibernate的JPA最为完整，因此Spring Data JPA 是采用基于JPA规范的Hibernate框架基础下提供了Repository层的实现。Spring Data Repository极大地简化了实现各种持久层的数据库访问而写的样板代码量，同时CrudRepository提供了丰富的CRUD功能去管理实体类。
优点
丰富的API，简单操作无需编写额外的代码 丰富的SQL日志输出 缺点
学习成本较大，需要学习HQL 配置复杂，虽然SpringBoot简化的大量的配置，关系映射多表查询配置依旧不容易 性能较差，对比JdbcTemplate、Mybatis等ORM框架，它的性能无异于是最差的 导入依赖 在pom.xml 中添加 spring-boot-starter-data-jpa 的依赖
1&amp;lt;!-- Spring JDBC 的依赖包，使用 spring-boot-starter-jdbc 或 spring-boot-starter-data-jpa 将会自动获得HikariCP依赖 --&amp;gt; 2&amp;lt;dependency&amp;gt; 3 &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; 4 &amp;lt;artifactId&amp;gt;spring-boot-starter-data-jpa&amp;lt;/artifactId&amp;gt; 5&amp;lt;/dependency&amp;gt; 6&amp;lt;!</description></item><item><title>一起来学 SpringBoot 2.x | 第七篇：整合Mybatis</title><link>https://www.hotmindshare.com/docs/java/sprintboot2/7/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.hotmindshare.com/docs/java/sprintboot2/7/</guid><description>作者：唐亚峰 | 出自：https://blog.battcn.com
SpringBoot 是为了简化 Spring 应用的创建、运行、调试、部署等一系列问题而诞生的产物，自动装配的特性让我们可以更好的关注业务本身而不是外部的XML配置，我们只需遵循规范，引入相关的依赖就可以轻易的搭建出一个 WEB 工程
MyBatis 是一款优秀的持久层框架，它支持定制化 SQL、存储过程以及高级映射，几乎避免了所有的 JDBC 代码和手动设置参数以及获取结果集，使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的 POJOs(Plain Old Java Objects,普通的 Java对象)映射成数据库中的记录，在国内可谓是占据了半壁江山……
ORM对比图 以下针对**Spring JDBC、Spring Data Jpa、Mybatis**三款框架做了个粗略的对比。一般应用的性能瓶颈并不是在于ORM，所以这三个框架技术选型应该考虑项目的场景、团队的技能掌握情况、开发周期(开发效率)…
框架对比 Spring JDBC Spring Data Jpa Mybatis 性能 性能最好 性能最差 居中 代码量 多 少 多 学习成本 低 高 居中 推荐指数 ❤❤❤ ❤❤❤❤❤ ❤❤❤❤❤ 个人观点
抛开学习成本而言，对于业务简单的中小型项目中使用Spring Data Jpa 开发无异于是最快速的。但是鉴于国内市场环境而言，掌握Mybatis无异于是佳的选择，低学习成本和动态SQL解耦的特点使得更容易被人们所接受。对于业务复杂且对性能要求较高的项目来说Mybatis往往能更好的胜任，可以自己进行SQL优化，同时更让我喜欢的是Mybatis分页插件与通用Mapper(单表CURD无需自己手写)有了这两款插件的支持，还有什么理由拒绝Mybatis呢
导入依赖 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 在pom.xml 中添加 Mybatis 的依赖包mybatis-spring-boot-starter，该包拥有自动装配的特点
1&amp;lt;dependency&amp;gt; 2 &amp;lt;groupId&amp;gt;org.mybatis.spring.boot&amp;lt;/groupId&amp;gt; 3 &amp;lt;artifactId&amp;gt;mybatis-spring-boot-starter&amp;lt;/artifactId&amp;gt; 4 &amp;lt;version&amp;gt;1.3.2&amp;lt;/version&amp;gt; 5&amp;lt;/dependency&amp;gt; 6&amp;lt;!</description></item><item><title>一起来学 SpringBoot 2.x | 第三篇：SpringBoot日志配置</title><link>https://www.hotmindshare.com/docs/java/sprintboot2/3/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.hotmindshare.com/docs/java/sprintboot2/3/</guid><description>作者：唐亚峰 | 出自：https://blog.battcn.com
SpringBoot 是为了简化 Spring 应用的创建、运行、调试、部署等一系列问题而诞生的产物，自动装配的特性让我们可以更好的关注业务本身而不是外部的XML配置，我们只需遵循规范，引入相关的依赖就可以轻易的搭建出一个 WEB 工程
Spring Boot 内部采用的是 Commons Logging进行日志记录，但在底层为 Java Util Logging、Log4J2、Logback 等日志框架提供了默认配置 。
Java 虽然有很多可用的日志框架，但请不要担心，一般来说，使用 SpringBoot 默认的 Logback 就可以了。
日志格式 SpringBoot 的默认输出的日志格式如下：
12014-03-05 10:57:51.112 INFO 45469 --- [ main] org.apache.catalina.core.StandardEngine : Starting Servlet Engine: Apache Tomcat/7.0.52 22014-03-05 10:57:51.253 INFO 45469 --- [ost-startStop-1] o.a.c.c.C.[Tomcat].[localhost].[/] : Initializing Spring embedded WebApplicationContext 32014-03-05 10:57:51.253 INFO 45469 --- [ost-startStop-1] o.s.web.context.ContextLoader : Root WebApplicationContext: initialization completed in 1358 ms 42014-03-05 10:57:51.</description></item><item><title>一起来学 SpringBoot 2.x | 第十八篇：轻松搞定全局异常</title><link>https://www.hotmindshare.com/docs/java/sprintboot2/18/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.hotmindshare.com/docs/java/sprintboot2/18/</guid><description>作者：唐亚峰 | 出自：https://blog.battcn.com
SpringBoot 是为了简化 Spring 应用的创建、运行、调试、部署等一系列问题而诞生的产物，自动装配的特性让我们可以更好的关注业务本身而不是外部的XML配置，我们只需遵循规范，引入相关的依赖就可以轻易的搭建出一个 WEB 工程
实际项目开发中，程序往往会发生各式各样的异常情况，特别是身为服务端开发人员的我们，总是不停的编写接口提供给前端调用，分工协作的情况下，避免不了异常的发生，如果直接将错误的信息直接暴露给用户，这样的体验可想而知，且对黑客而言，详细异常信息往往会提供非常大的帮助…
初窥异常 一个简单的异常请求的接口
1@GetMapping(&amp;#34;/test1&amp;#34;) 2public String test1() { 3 // TODO 这里只是模拟异常，假设业务处理的时候出现错误了，或者空指针了等等... 4 int i = 10 / 0; 5 return &amp;#34;test1&amp;#34;; 6} 打开浏览器访问它的时候发现
又或者是用 postman 等模拟工具
如果这接口是给第三方调用或者是自己公司的系统，看到这种错误估计得暴走吧….
笨方法（极其不建议）
采用try-catch的方式，手动捕获异常信息，然后返回对应的结果集，相信很多人都看到过类似的代码（如：封装成Result对象）；该方法虽然间接性的解决错误暴露的问题，同样的弊端也很明显，增加了大量的代码量，当异常过多的情况下对应的catch层愈发的多了起来，很难管理这些业务异常和错误码之间的匹配，所以最好的方法就是通过简单配置全局掌控….
1@GetMapping(&amp;#34;/test2&amp;#34;) 2public Map&amp;lt;String, String&amp;gt; test2() { 3 Map&amp;lt;String, String&amp;gt; result = new HashMap&amp;lt;&amp;gt;(16); 4 // TODO 直接捕获所有代码块，然后在 cache 5 try { 6 int i = 10 / 0; 7 result.put(&amp;#34;code&amp;#34;, &amp;#34;200&amp;#34;); 8 result.</description></item><item><title>一起来学 SpringBoot 2.x | 第十二篇：初探RabbitMQ消息队列</title><link>https://www.hotmindshare.com/docs/java/sprintboot2/12/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.hotmindshare.com/docs/java/sprintboot2/12/</guid><description>作者：唐亚峰 | 出自：https://blog.battcn.com
SpringBoot 是为了简化 Spring 应用的创建、运行、调试、部署等一系列问题而诞生的产物，自动装配的特性让我们可以更好的关注业务本身而不是外部的XML配置，我们只需遵循规范，引入相关的依赖就可以轻易的搭建出一个 WEB 工程
**MQ全称（Message Queue）又名消息队列，是一种异步通讯的中间件。**可以将它理解成邮局，发送者将消息传递到邮局，然后由邮局帮我们发送给具体的消息接收者（消费者），具体发送过程与时间我们无需关心，它也不会干扰我进行其它事情。常见的MQ有kafka、activemq、zeromq、rabbitmq 等等，各大MQ的对比和优劣势可以自行Google
rabbitmq RabbitMQ是一个遵循AMQP协议，由面向高并发的erlanng语言开发而成，用在实时的对可靠性要求比较高的消息传递上，支持多种语言客户端。支持延迟队列（这是一个非常有用的功能）….
基础概念 **Broker：**简单来说就是消息队列服务器实体
**Exchange：**消息交换机，它指定消息按什么规则，路由到哪个队列
**Queue：**消息队列载体，每个消息都会被投入到一个或多个队列
**Binding：**绑定，它的作用就是把exchange和queue按照路由规则绑定起来
**Routing Key：**路由关键字，exchange根据这个关键字进行消息投递
**vhost：**虚拟主机，一个broker里可以开设多个vhost，用作不同用户的权限分离
**producer：**消息生产者，就是投递消息的程序
**consumer：**消息消费者，就是接受消息的程序
**channel：**消息通道，在客户端的每个连接里，可建立多个channel，每个channel代表一个会话任务
基于Centos7.x安装请参考： http://blog.battcn.com/2017/08/20/linux/linux-centos7-ribbitmq/
常见应用场景 1、 邮箱发送：用户注册后投递消息到rabbitmq中，由消息的消费方异步的发送邮件，提升系统响应速度；
2、 流量削峰：一般在秒杀活动中应用广泛，秒杀会因为流量过大，导致应用挂掉，为了解决这个问题，一般在应用前端加入消息队列用于控制活动人数，将超过此一定阀值的订单直接丢弃缓解短时间的高流量压垮应用；
3、 订单超时：利用rabbitmq的延迟队列，可以很简单的实现**订单超时**的功能，比如用户在下单后30分钟未支付取消订单；
4、 还有更多应用场景就不一一列举了…..；
导入依赖 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 在pom.xml 中添加 spring-boot-starter-amqp的依赖
1&amp;lt;dependencies&amp;gt; 2 &amp;lt;dependency&amp;gt; 3 &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; 4 &amp;lt;artifactId&amp;gt;spring-boot-starter-amqp&amp;lt;/artifactId&amp;gt; 5 &amp;lt;/dependency&amp;gt; 6 &amp;lt;dependency&amp;gt; 7 &amp;lt;groupId&amp;gt;com.alibaba&amp;lt;/groupId&amp;gt; 8 &amp;lt;artifactId&amp;gt;fastjson&amp;lt;/artifactId&amp;gt; 9 &amp;lt;version&amp;gt;1.2.46&amp;lt;/version&amp;gt; 10 &amp;lt;/dependency&amp;gt; 11 &amp;lt;dependency&amp;gt; 12 &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; 13 &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt; 14 &amp;lt;/dependency&amp;gt; 15 &amp;lt;dependency&amp;gt; 16 &amp;lt;groupId&amp;gt;org.</description></item><item><title>一起来学 SpringBoot 2.x | 第十九篇：轻松搞定数据验证（一）</title><link>https://www.hotmindshare.com/docs/java/sprintboot2/19/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.hotmindshare.com/docs/java/sprintboot2/19/</guid><description>作者：唐亚峰 | 出自：https://blog.battcn.com
SpringBoot 是为了简化 Spring 应用的创建、运行、调试、部署等一系列问题而诞生的产物，自动装配的特性让我们可以更好的关注业务本身而不是外部的XML配置，我们只需遵循规范，引入相关的依赖就可以轻易的搭建出一个 WEB 工程
对于任何一个应用而言，客户端做的数据有效性验证都不是安全有效的，而数据验证又是一个企业级项目架构上最为基础的功能模块，这时候就要求我们在服务端接收到数据的时候也对数据的有效性进行验证。为什么这么说呢？往往我们在编写程序的时候都会感觉后台的验证无关紧要，毕竟客户端已经做过验证了，后端没必要在浪费资源对数据进行验证了，但恰恰是这种思维最为容易被别人钻空子。毕竟只要有点开发经验的都知道，我们完全可以模拟 HTTP 请求到后台地址，模拟请求过程中发送一些涉及系统安全的数据到后台，后果可想而知….
为什么要轻松搞定？ 相信通过上面的阅读，大家对数据验证的重要性有了一定的了解，那么为什么我这里要说 轻松搞定呢？
下面这段代码很多人一定见到过，就是对参数进行有效性校验，但仔细观察的话就会发现；随着参数的增加，格式的变化，校验数据有效性的代码愈发的繁琐杂乱，一点都不轻松
1public String test1(String name) { 2 if (name == null) { 3 throw new NullPointerException(&amp;#34;name 不能为空&amp;#34;); 4 } 5 if (name.length() &amp;lt; 2 || name.length() &amp;gt; 10) { 6 throw new RuntimeException(&amp;#34;name 长度必须在 2 - 10 之间&amp;#34;); 7 } 8 return &amp;#34;success&amp;#34;; 9} 本章目标 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 通过Spring Boot 完成参数后台数据校验，轻松搞定数据有效性验证，留出更多的时间来和小姐姐聊天…
具体代码 通过上面的阅读大家也大致能了解到为啥需要对异常进行全局捕获了，接下来就看看 Spring Boot 提供的解决方案</description></item><item><title>一起来学 SpringBoot 2.x | 第十六篇：定时任务详解</title><link>https://www.hotmindshare.com/docs/java/sprintboot2/16/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.hotmindshare.com/docs/java/sprintboot2/16/</guid><description>作者：唐亚峰 | 出自：https://blog.battcn.com
SpringBoot 是为了简化 Spring 应用的创建、运行、调试、部署等一系列问题而诞生的产物，自动装配的特性让我们可以更好的关注业务本身而不是外部的XML配置，我们只需遵循规范，引入相关的依赖就可以轻易的搭建出一个 WEB 工程
在我们日常开发中，经常会遇到 数据定时增量同步、定时发送邮件、爬虫定时抓取 的需求；这时我们可以采用定时任务的方式去进行工作…..
定时任务概述 定时任务：顾名思义就是在指定/特定的时间进行工作，比如我们的手机闹钟，它就是一种定时任务。
实现方式
Timer： JDK自带的java.util.Timer；通过调度java.util.TimerTask的方式 让程序按照某一个频度执行，但不能在指定时间运行。 一般用的较少。
ScheduledExecutorService： JDK1.5新增的，位于java.util.concurrent包中；是基于线程池设计的定时任务类，每个调度任务都会被分配到线程池中，并发执行，互不影响。
Spring Task： Spring3.0 以后新增了task，一个轻量级的Quartz，功能够用，用法简单。
Quartz： 功能最为强大的调度器，可以让程序在指定时间执行，也可以按照某一个频度执行，它还可以动态开关，但是配置起来比较复杂。现如今开源社区中已经很多基于Quartz 实现的分布式定时任务项目（xxl-job、elastic-job）。
Timer 方式 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 基于Timer 实现的定时调度，基本就是手撸代码，目前应用较少，不是很推荐
1package com.battcn.timer; 2import java.time.LocalDateTime; 3import java.util.Timer; 4import java.util.TimerTask; 5/** 6 * 基于Timer实现的定时调度（不推荐，用该方式不如用 ScheduledExecutorService ） 7 * 8 * @author Levin 9 * @since 2018/5/29 0029 10 */ 11public class TimerDemo { 12 public static void main(String[] args) { 13 TimerTask timerTask = new TimerTask() { 14 @Override 15 public void run() { 16 System.</description></item><item><title>一起来学 SpringBoot 2.x | 第十篇：使用Spring Cache集成Redis</title><link>https://www.hotmindshare.com/docs/java/sprintboot2/10/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.hotmindshare.com/docs/java/sprintboot2/10/</guid><description>作者：唐亚峰 | 出自：https://blog.battcn.com
SpringBoot 是为了简化 Spring 应用的创建、运行、调试、部署等一系列问题而诞生的产物，自动装配的特性让我们可以更好的关注业务本身而不是外部的XML配置，我们只需遵循规范，引入相关的依赖就可以轻易的搭建出一个 WEB 工程
Spring 3.1 引入了激动人心的基于注释（annotation）的缓存（cache）技术，它本质上不是一个具体的缓存实现方案（例如 EHCache 或者 Redis），而是一个对缓存使用的抽象，通过在既有代码中添加少量它定义的各种 annotation，即能够达到缓存方法的返回对象的效果。
特点 具备相当的好的灵活性，不仅能够使用 **SpEL（Spring Expression Language）**来定义缓存的 key 和各种 condition，还提供开箱即用的缓存临时存储方案，也支持和主流的专业缓存例如 EHCache、Redis、Guava 的集成。
基于 annotation 即可使得现有代码支持缓存 开箱即用 Out-Of-The-Box，不用安装和部署额外第三方组件即可使用缓存 支持 Spring Express Language，能使用对象的任何属性或者方法来定义缓存的 key 和 condition 支持 AspectJ，并通过其实现任何方法的缓存支持 支持自定义 key 和自定义缓存管理者，具有相当的灵活性和扩展性 使用前后 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 下面针对Spring Cache使用前后给出了伪代码部分，具体中也许比这要更加复杂，但是Spring Cache都可以很好的应对
使用前
我们需要硬编码，如果切换Cache Client还需要修改代码，耦合度高，不易于维护
1public String get(String key) { 2 String value = userMapper.selectById(key); 3 if (value != null) { 4 cache.put(key,value); 5 } 6 return value; 7} 使用后</description></item><item><title>一起来学 SpringBoot 2.x | 第十七篇：轻松搞定文件上传</title><link>https://www.hotmindshare.com/docs/java/sprintboot2/17/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.hotmindshare.com/docs/java/sprintboot2/17/</guid><description>作者：唐亚峰 | 出自：https://blog.battcn.com
SpringBoot 是为了简化 Spring 应用的创建、运行、调试、部署等一系列问题而诞生的产物，自动装配的特性让我们可以更好的关注业务本身而不是外部的XML配置，我们只需遵循规范，引入相关的依赖就可以轻易的搭建出一个 WEB 工程
文件上传和下载是JAVA WEB中常见的一种操作，文件上传主要是将文件通过IO流传输到服务器的某一个特定的文件夹下；刚开始工作那会一个上传文件常常花费小半天的时间，繁琐的代码量以及XML配置让我是痛不欲生；值得庆幸的是有了Spring Boot短短的几句代码就能实现文件上传与本地写入操作….
文件上传 文件上传和下载是JAVA WEB中常见的一种操作，文件上传主要是将文件通过IO流传输到服务器的某一个特定的文件夹下；刚开始工作那会一个上传文件常常花费小半天的时间，繁琐的代码量以及XML配置让我是痛不欲生；值得庆幸的是有了Spring Boot短短的几句代码就能实现文件上传与本地写入操作….
导入依赖 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 在pom.xml 中添加上 spring-boot-starter-web 和 spring-boot-starter-thymeleaf 的依赖
1&amp;lt;dependencies&amp;gt; 2 &amp;lt;dependency&amp;gt; 3 &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; 4 &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt; 5 &amp;lt;/dependency&amp;gt; 6 &amp;lt;dependency&amp;gt; 7 &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; 8 &amp;lt;artifactId&amp;gt;spring-boot-starter-thymeleaf&amp;lt;/artifactId&amp;gt; 9 &amp;lt;/dependency&amp;gt; 10 &amp;lt;dependency&amp;gt; 11 &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; 12 &amp;lt;artifactId&amp;gt;spring-boot-starter-test&amp;lt;/artifactId&amp;gt; 13 &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt; 14 &amp;lt;/dependency&amp;gt; 15&amp;lt;/dependencies&amp;gt; 配置文件 默认情况下 Spring Boot 无需做任何配置也能实现文件上传的功能，但有可能因默认配置不符而导致文件上传失败问题，所以了解相关配置信息更有助于我们对问题的定位和修复；
1# 禁用 thymeleaf 缓存 2spring.thymeleaf.cache=false 3# 是否支持批量上传 (默认值 true) 4spring.servlet.multipart.enabled=true 5# 上传文件的临时目录 （一般情况下不用特意修改） 6spring.</description></item><item><title>一起来学 SpringBoot 2.x | 第十三篇：RabbitMQ延迟队列</title><link>https://www.hotmindshare.com/docs/java/sprintboot2/13/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.hotmindshare.com/docs/java/sprintboot2/13/</guid><description>作者：唐亚峰 | 出自：https://blog.battcn.com
SpringBoot 是为了简化 Spring 应用的创建、运行、调试、部署等一系列问题而诞生的产物，自动装配的特性让我们可以更好的关注业务本身而不是外部的XML配置，我们只需遵循规范，引入相关的依赖就可以轻易的搭建出一个 WEB 工程
初探RabbitMQ消息队列中介绍了RabbitMQ的简单用法，顺带提及了下延迟队列的作用。所谓延时消息就是指当消息被发送以后，并不想让消费者立即拿到消息，而是等待指定时间后，消费者才拿到这个消息进行消费。
延迟队列 延迟队列能做什么？
订单业务： 在电商/点餐中，都有下单后 30 分钟内没有付款，就自动取消订单。 短信通知： 下单成功后 60s 之后给用户发送短信通知。 失败重试： 业务操作失败后，间隔一定的时间进行失败重试。 这类业务的特点就是：非实时的，需要延迟处理，需要进行失败重试。一种比较笨的方式是采用定时任务，轮训数据库，方法简单好用，但性能底下，在高并发情况下容易弄死数据库，间隔时间不好设置，时间过大，影响精度，过小影响性能，而且做不到按超时的时间顺序处理。另一种就是用**Java中的DelayQueue 位于java.util.concurrent包下，本质是由PriorityQueue和BlockingQueue实现的阻塞优先级队列。，这玩意最大的问题就是不支持分布式与持久化**
RabbitMQ 实现思路 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 RabbitMQ队列本身是没有直接实现支持延迟队列的功能，但可以通过它的Time-To-Live Extensions 与 Dead Letter Exchange 的特性模拟出延迟队列的功能。
Time-To-Live Extensions
RabbitMQ支持为队列或者消息设置TTL（time to live 存活时间）。TTL表明了一条消息可在队列中存活的最大时间。当某条消息被设置了TTL或者当某条消息进入了设置了TTL的队列时，这条消息会在TTL时间后**死亡成为Dead Letter**。如果既配置了消息的TTL，又配置了队列的TTL，那么较小的那个值会被取用。
Dead Letter Exchange
死信交换机，上文中提到设置了 TTL 的消息或队列最终会成为Dead Letter。如果为队列设置了Dead Letter Exchange（DLX），那么这些Dead Letter就会被重新发送到Dead Letter Exchange中，然后通过Dead Letter Exchange路由到其他队列，即可实现延迟队列的功能。
导入依赖 在pom.xml 中添加 spring-boot-starter-amqp的依赖
1&amp;lt;dependencies&amp;gt; 2 &amp;lt;dependency&amp;gt; 3 &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; 4 &amp;lt;artifactId&amp;gt;spring-boot-starter-amqp&amp;lt;/artifactId&amp;gt; 5 &amp;lt;/dependency&amp;gt; 6 &amp;lt;dependency&amp;gt; 7 &amp;lt;groupId&amp;gt;com.</description></item><item><title>一起来学 SpringBoot 2.x | 第十四篇：强大的 actuator 服务监控与管理</title><link>https://www.hotmindshare.com/docs/java/sprintboot2/14/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.hotmindshare.com/docs/java/sprintboot2/14/</guid><description>作者：唐亚峰 | 出自：https://blog.battcn.com
SpringBoot 是为了简化 Spring 应用的创建、运行、调试、部署等一系列问题而诞生的产物，自动装配的特性让我们可以更好的关注业务本身而不是外部的XML配置，我们只需遵循规范，引入相关的依赖就可以轻易的搭建出一个 WEB 工程
actuator是spring boot项目中非常强大一个功能，有助于对应用程序进行监视和管理，通过 restful api 请求来监管、审计、收集应用的运行情况，针对微服务而言它是必不可少的一个环节…
Endpoints actuator 的核心部分，它用来监视应用程序及交互，spring-boot-actuator中已经内置了非常多的 Endpoints（health、info、beans、httptrace、shutdown等等），同时也允许我们自己扩展自己的端点
Spring Boot 2.0 中的端点和之前的版本有较大不同,使用时需注意。另外端点的监控机制也有很大不同，启用了不代表可以直接访问，还需要将其暴露出来，传统的management.security管理已被标记为不推荐。
内置Endpoints id desc Sensitive auditevents 显示当前应用程序的审计事件信息 Yes beans 显示应用Spring Beans的完整列表 Yes caches 显示可用缓存信息 Yes conditions 显示自动装配类的状态及及应用信息 Yes configprops 显示所有 @ConfigurationProperties 列表 Yes env 显示 ConfigurableEnvironment 中的属性 Yes flyway 显示 Flyway 数据库迁移信息 Yes health 显示应用的健康信息（未认证只显示status，认证显示全部信息详情） No info 显示任意的应用信息（在资源文件写info.xxx即可） No liquibase 展示Liquibase 数据库迁移 Yes metrics 展示当前应用的 metrics 信息 Yes mappings 显示所有 @RequestMapping 路径集列表 Yes scheduledtasks 显示应用程序中的计划任务 Yes sessions 允许从Spring会话支持的会话存储中检索和删除用户会话。 Yes shutdown 允许应用以优雅的方式关闭（默认情况下不启用） Yes threaddump 执行一个线程dump Yes httptrace 显示HTTP跟踪信息（默认显示最后100个HTTP请求 – 响应交换） Yes 导入依赖 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 在pom.</description></item><item><title>一起来学 SpringBoot 2.x | 第十五篇：actuator与spring-boot-admin 可以说的秘密</title><link>https://www.hotmindshare.com/docs/java/sprintboot2/15/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.hotmindshare.com/docs/java/sprintboot2/15/</guid><description>作者：唐亚峰 | 出自：https://blog.battcn.com
SpringBoot 是为了简化 Spring 应用的创建、运行、调试、部署等一系列问题而诞生的产物，自动装配的特性让我们可以更好的关注业务本身而不是外部的XML配置，我们只需遵循规范，引入相关的依赖就可以轻易的搭建出一个 WEB 工程
一起来学SpringBoot | 第十四篇：强大的 actuator 服务监控与管理 中介绍了actuator 的作用，细心的朋友可能会发现通过http restful api的方式查看信息过于繁琐也不够直观，效率低下，运维人员看到JSON数据更是一脸懵逼，当服务过多的时候查看起来就过于操蛋了，每个服务都需要调用不同的接口来查看监控信息，备受各种困扰因素的我默默翻了下全球最大男性交友平台找到了spring-boot-admin
什么是SBA SBA 全称 Spring Boot Admin 是一个管理和监控 Spring Boot 应用程序的开源项目。分为admin-server 与 admin-client 两个组件，admin-server通过采集 actuator 端点数据，显示在 spring-boot-admin-ui 上，已知的端点几乎都有进行采集，通过 spring-boot-admin 可以动态切换日志级别、导出日志、导出heapdump、监控各项指标 等等….
Spring Boot Admin 在对单一应用服务监控的同时也提供了集群监控方案，支持通过eureka、consul、zookeeper等注册中心的方式实现多服务监控与管理…
导入依赖 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 在pom.xml 中添加 spring-boot-admin 的相关依赖，这里只演示单机版本的，因此就自己监控自己了
1&amp;lt;dependencies&amp;gt; 2 &amp;lt;!-- 服务端：带UI界面 --&amp;gt; 3 &amp;lt;dependency&amp;gt; 4 &amp;lt;groupId&amp;gt;de.codecentric&amp;lt;/groupId&amp;gt; 5 &amp;lt;artifactId&amp;gt;spring-boot-admin-starter-server&amp;lt;/artifactId&amp;gt; 6 &amp;lt;version&amp;gt;2.0.0&amp;lt;/version&amp;gt; 7 &amp;lt;/dependency&amp;gt; 8 &amp;lt;!-- 客户端包 --&amp;gt; 9 &amp;lt;dependency&amp;gt; 10 &amp;lt;groupId&amp;gt;de.</description></item><item><title>一起来学 SpringBoot 2.x | 第十一篇：集成Swagger在线调试</title><link>https://www.hotmindshare.com/docs/java/sprintboot2/11/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.hotmindshare.com/docs/java/sprintboot2/11/</guid><description>作者：唐亚峰 | 出自：https://blog.battcn.com
SpringBoot 是为了简化 Spring 应用的创建、运行、调试、部署等一系列问题而诞生的产物，自动装配的特性让我们可以更好的关注业务本身而不是外部的XML配置，我们只需遵循规范，引入相关的依赖就可以轻易的搭建出一个 WEB 工程
随着互联网技术的发展，现在的网站架构基本都由原来的后端渲染，变成了：前端渲染、前后端分离的形态，而且前端技术和后端技术在各自的道路上越走越远。
前端和后端唯一联系，变成了API接口；API文档自然就成了前后端开发人员联系的纽带，变得尤为的重要，swagger就是一款让你更好的书写API文档的框架。
文档工具 没有API文档工具之前，基本都是手写API文档的，如有在Word上写的，有在对应的项目目录下readme.md上写的，每个公司都有每个公司的玩法，无所谓好坏。但是这种手写文档带来的弊端就是维护起来苦不堪言，对于接口容易发生变化的开发者来说，维护文档就是噩梦….
好在现如今市场上书写API文档的工具有很多，常见的有 postman、yapi、阿里的RAP 但是能称之为框架的，估计也只有swagger了。
swagger 优缺点
集成方便，功能强大 在线调试与文档生成 代码耦合，需要注解支持，但不影响程序性能 导入依赖 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 在pom.xml 中添加 swagger-spring-boot-starter 的依赖
1 2 3 4 5 6 7 8 org.springframework.boot 9 10 11 12 13 14 15 spring-boot-starter-web 16 17 18 19 20 21 22 23 24 25 26 com.battcn 27 28 29 30 31 32 33 swagger-spring-boot-starter 34 35 36 37 38 39 40 1.</description></item><item><title>一起来学 SpringBoot 2.x | 第四篇：整合Thymeleaf模板</title><link>https://www.hotmindshare.com/docs/java/sprintboot2/4/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.hotmindshare.com/docs/java/sprintboot2/4/</guid><description>SpringBoot 是为了简化 Spring 应用的创建、运行、调试、部署等一系列问题而诞生的产物，自动装配的特性让我们可以更好的关注业务本身而不是外部的XML配置，我们只需遵循规范，引入相关的依赖就可以轻易的搭建出一个 WEB 工程
在前面几章中已经介绍了如何创建一个SpringBoot 项目，同时简单的描述了SpringBoot REST Web服务。除此之外它也是支持如JSP、Thymeleaf、FreeMarker、Mustache、Velocity 等各种模板引擎，同时还为开发者提供了自定义模板扩展的支持。
使用嵌入式Servlet容器时，请避免使用JSP，因为使用JSP打包后会存在一些限制。
在SpringBoot使用上述模板，默认从 **src/main/resources/templates**下加载。
thymeleaf介绍 Thymeleaf是现代化服务器端的Java模板引擎，不同与其它几种模板的是Thymeleaf的语法更加接近HTML，并且具有很高的扩展性。详细资料可以浏览官网。
特点
支持无网络环境下运行，由于它支持 html 原型，然后在 html 标签里增加额外的属性来达到模板+数据的展示方式。浏览器解释 html 时会忽略未定义的标签属性，所以 thymeleaf 的模板可以静态地运行；当有数据返回到页面时，Thymeleaf 标签会动态地替换掉静态内容，使页面动态显示。所以它可以让前端小姐姐在浏览器中查看页面的静态效果，又可以让程序员小哥哥在服务端查看带数据的动态页面效果。 开箱即用，为Spring提供方言，可直接套用模板实现JSTL、 OGNL表达式效果，避免每天因套用模板而修改JSTL、 OGNL标签的困扰。同时开发人员可以扩展自定义的方言。 SpringBoot官方推荐模板，提供了可选集成模块(spring-boot-starter-thymeleaf)，可以快速的实现表单绑定、属性编辑器、国际化等功能。 使用 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 首先要在 pom.xml 中添加对 thymeleaf 模板依赖
1 2 3 4 5 6 7 8 org.springframework.boot 9 10 11 12 13 14 15 spring-boot-starter-thymeleaf 16 17 18 19 然后创建一个 ThymeleafController 用来映射HTTP请求与页面的跳转，下面写了两种方式，第一种比较直观和优雅，第二种相对普遍且代码较少，且迎合从struts2跳坑的朋友们…
Spring4.3以后为简化@RequestMapping(method = RequestMethod.XXX)的写法，故而将其做了一层包装，也就是现在的GetMapping、PostMapping、PutMapping、DeleteMapping、PatchMapping 1package com.battcn.controller; 2import org.springframework.stereotype.Controller; 3import org.</description></item><item><title>一起来学 SpringBoot 2.x | 第五篇：使用 JdbcTemplate 访问数据库</title><link>https://www.hotmindshare.com/docs/java/sprintboot2/5/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.hotmindshare.com/docs/java/sprintboot2/5/</guid><description>作者：唐亚峰 | 出自：https://blog.battcn.com
SpringBoot 是为了简化 Spring 应用的创建、运行、调试、部署等一系列问题而诞生的产物，自动装配的特性让我们可以更好的关注业务本身而不是外部的XML配置，我们只需遵循规范，引入相关的依赖就可以轻易的搭建出一个 WEB 工程
Spring Framework对数据库的操作在JDBC上面做了深层次的封装，通过依赖注入功能，可以将 DataSource 注册到JdbcTemplate之中，使我们可以轻易的完成对象关系映射，并有助于规避常见的错误，在SpringBoot中我们可以很轻松的使用它。
特点
速度快，对比其它的ORM框架而言，JDBC的方式无异于是最快的 配置简单，Spring自家出品，几乎没有额外配置 学习成本低，毕竟JDBC是基础知识，JdbcTemplate更像是一个DBUtils 导入依赖 在pom.xml 中添加对 JdbcTemplate 的依赖
1&amp;lt;!-- Spring JDBC 的依赖包，使用 spring-boot-starter-jdbc 或 spring-boot-starter-data-jpa 将会自动获得HikariCP依赖 --&amp;gt; 2&amp;lt;dependency&amp;gt; 3 &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; 4 &amp;lt;artifactId&amp;gt;spring-boot-starter-jdbc&amp;lt;/artifactId&amp;gt; 5&amp;lt;/dependency&amp;gt; 6&amp;lt;!-- MYSQL包 --&amp;gt; 7&amp;lt;dependency&amp;gt; 8 &amp;lt;groupId&amp;gt;mysql&amp;lt;/groupId&amp;gt; 9 &amp;lt;artifactId&amp;gt;mysql-connector-java&amp;lt;/artifactId&amp;gt; 10&amp;lt;/dependency&amp;gt; 11&amp;lt;!-- 默认就内嵌了Tomcat 容器，如需要更换容器也极其简单--&amp;gt; 12&amp;lt;dependency&amp;gt; 13 &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; 14 &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt; 15&amp;lt;/dependency&amp;gt; 连接数据库 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 在application.properties中添加如下配置。值得注意的是，SpringBoot默认会自动配置DataSource，它将优先采用HikariCP连接池，如果没有该依赖的情况则选取tomcat-jdbc，如果前两者都不可用最后选取Commons DBCP2。通过spring.datasource.type属性可以指定其它种类的连接池
1spring.datasource.url=jdbc:mysql://localhost:3306/chapter4?useUnicode=true&amp;amp;characterEncoding=UTF-8&amp;amp;zeroDateTimeBehavior=convertToNull&amp;amp;allowMultiQueries=true&amp;amp;useSSL=false 2spring.datasource.password=root 3spring.datasource.username=root 4#spring.datasource.type 5#更多细微的配置可以通过下列前缀进行调整 6#spring.datasource.hikari 7#spring.datasource.tomcat 8#spring.datasource.dbcp2 启动项目，通过日志，可以看到默认情况下注入的是HikariDataSource
12018-05-07 10:33:54.</description></item><item><title>一起来学 SpringBoot 2.x | 第一篇：构建第一个 SpringBoot 工程</title><link>https://www.hotmindshare.com/docs/java/sprintboot2/1/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.hotmindshare.com/docs/java/sprintboot2/1/</guid><description>作者：唐亚峰 | 出自：https://blog.battcn.com
SpringBoot 是为了简化 Spring 应用的创建、运行、调试、部署等一系列问题而诞生的产物，自动装配的特性让我们可以更好的关注业务本身而不是外部的XML配置，我们只需遵循规范，引入相关的依赖就可以轻易的搭建出一个 WEB 工程
未接触SpringBoot 之前，搭建一个普通的 WEB 工程往往需要花费30分钟左右，如果遇到点奇葩的问题耽搁的时间会更长一点，但自从用了SpringBoot 后，真正体会到什么叫分分钟搭建一个WEB，让我拥有更多的时间跟我的小伙伴们唠嗑了。使用 SpringBoot 后发现一切是如此的简单（还记得读书那会被JAR包，xml支配的恐惧吗，如今都可以说 good bye）
设计的目标 为所有使用 Spring 的开发者提供一个更简单，快速的入门体验 提供一些常见的功能、如监控、WEB容器，健康，安全等功能 干掉XML，遵循规范，开箱即用 前提 SpringBoot 为我们提供了一系列的依赖包，所以需要构建工具的支持：Maven 或 Gradle。由于本人更习惯使用**Maven所以后续案例都是基于Maven 与 IntelliJ IDEA，同时这里是基于最新的SpringBoot2编写的哦...**
创建项目 初次接触，我们先来看看如何创建一个Spring Boot项目，这里以IntelliJ IDEA为例，其他的IDE工具小伙伴们自行搜索创建方式。创建完项目后，各位小伙伴请认真、细心的对比下与传统的WEB工程有何区别（如：目录结构）。
点击**File -&amp;gt; Project**
如果用过 Eclipse/IDEA 等工具的，对创建项目肯定不会陌生，但为了照顾第一次使用的我贴上了图文
选择**Spring Initializr**
到这一步选择的时候，如图中选项的是Spring Initializr(官方的构建插件，需要联网)，第二个是自己选择Maven构建，为了更好的适合初学者，我们将在本章用插件构建
填写项目基本信息
Group： 组织ID，一般分为多个段，这里我只说两段，第一段为域，第二段为公司名称。域又分为 org、com、cn等等，其中 org为非营利组织，com为商业组织。如阿里、淘宝（com.alibaba/com.taobao） Artifact: 唯一标识符，一般是项目名称 选择包
Spring Initializr 为我们提供了很多的选项，不同的选项有不同的作用，在初期我们只需要依赖**Web -&amp;gt; Web** 就可以了，选择好依赖包之后点击**Next -&amp;gt; Finish**
目录结果 1- src 2 -main 3 -java 4 -package 5 主函数，启动类，运行它如果运行了 Tomcat、Jetty、Undertow 等容器 6 -SpringbootApplication 7 -resouces 8 存放静态资源 js/css/images 等 9 - statics 10 存放 html 模板文件 11 - templates 12 主要的配置文件，SpringBoot启动时候会自动加载application.</description></item><item><title>Java 中的异步计算</title><link>https://www.hotmindshare.com/docs/java/concurrency/default/8/</link><pubDate>Thu, 06 Oct 2022 22:42:23 +0800</pubDate><guid>https://www.hotmindshare.com/docs/java/concurrency/default/8/</guid><description>本文我们来了解下 Java 8 引入的 CompletableFuture 类，了解下该类提供的功能和用例。
Java 中的异步计算 异步计算很难推理的，因为我们的大脑是同步的，会将任何计算看成是一系列的同步计算。
我们在实现异步计算时，往往会把回调的动作分散在代码中或者深深地嵌套在彼此内部，这种情况下，当我们需要处理其中一个步骤中可能发生的错误时，情况变得更糟。
人生的一大悲剧是，尽管 Java 5 已经看到了这种恶性循环，提供了Future 接口作为异步计算的结果，但它没有提供任何方法来组合这些计算或处理可能的错误。
直到Java 8，才引入了 CompletableFuture 类。该类不仅实现了 Future 接口，还实现了 CompletionStage 接口。此接口定义了可与异步计算步骤组合的异步计算步骤契约。
官方文档真是拗口，简单来说，CompletionStage 接口规范了一个异步计算步骤如何与另一个异步计算步骤组合。
CompletableFuture 类还是一个集大成者，即是一个构建块，也是一个框架，提供了大约 50 种不同的方法来构造，组合，执行异步计算步骤和处理错误。
API数量如此之多，第一眼看到简直就傻眼了，不过好在它们可以分门别类，因为它们大多属于几个明确且不同的用例。
将 CompletableFuture 当作简单的 Future 使用 为什么可以 ？
因为CompletableFuture 类实现了 Future 接口，因此我们可以将其用作 Future 实现，但需要自己实现额外的完成逻辑。
例如，我们可以使用无任何参数的构造函数来创建此类的实例，用于表示未来的某些结果，然后将其交给使用者，并在将来的某个时间调用 complete() 方法完成。消费者可以使用 get() 方法来阻止当前线程，直到提供此结果。
1public Future&amp;lt;String&amp;gt; calculateAsync() throws InterruptedException { 2 CompletableFuture&amp;lt;String&amp;gt; completableFuture 3 = new CompletableFuture&amp;lt;&amp;gt;(); 4 Executors.newCachedThreadPool().submit(() -&amp;gt; { 5 Thread.sleep(500); 6 completableFuture.complete(&amp;#34;Hello&amp;#34;); 7 return null; 8 }); 9 return completableFuture; 上面的实例中，我们创建了一个创建 CompletableFuture 实例的方法，把计算分离到另一个线程中并立即返回 Future。当计算完成后，该方法通过将结果提供给 complete() 方法来完成 Future。</description></item><item><title>ForkJoinPool 线程池</title><link>https://www.hotmindshare.com/docs/java/concurrency/default/2/</link><pubDate>Thu, 06 Oct 2022 22:42:23 +0800</pubDate><guid>https://www.hotmindshare.com/docs/java/concurrency/default/2/</guid><description>fork/join 框架是 Java 7 中引入的 ，它是一个工具，通过 「 分而治之 」 的方法尝试将所有可用的处理器内核使用起来帮助加速并行处理。
在实际使用过程中，这种 「 分而治之 」的方法意味着框架首先要 fork ，递归地将任务分解为较小的独立子任务，直到它们足够简单以便异步执行。然后，join 部分开始工作，将所有子任务的结果递归地连接成单个结果，或者在返回 void 的任务的情况下，程序只是等待每个子任务执行完毕。
为了提供有效的并行执行，fork/join 框架使用了一个名为 ForkJoinPool 的线程池，用于管理 ForkJoinWorkerThread 类型的工作线程。
ForkJoinPool 线程池 ForkJoinPool 是 fork/join 框架的核心，是 ExecutorService 的一个实现，用于管理工作线程，并提供了一些工具来帮助获取有关线程池状态和性能的信息。
工作线程一次只能执行一个任务。
ForkJoinPool 线程池并不会为每个子任务创建一个单独的线程，相反，池中的每个线程都有自己的双端队列用于存储任务 （ double-ended queue ）( 或 deque，发音 deck ）。
这种架构使用了一种名为工作窃取（ work-stealing ）算法来平衡线程的工作负载。
工作窃取（ work-stealing ）算法 要怎么解释 「 工作窃取算法 」 呢 ？
简单来说，就是 空闲的线程试图从繁忙线程的 deques 中 窃取 工作。
默认情况下，每个工作线程从其自己的双端队列中获取任务。但如果自己的双端队列中的任务已经执行完毕，双端队列为空时，工作线程就会从另一个忙线程的双端队列尾部或全局入口队列中获取任务，因为这是最大概率可能找到工作的地方。
这种方法最大限度地减少了线程竞争任务的可能性。它还减少了工作线程寻找任务的次数，因为它首先在最大可用的工作块上工作。
ForkJoinPool 线程池的实例化 Java 8 在Java 8 中，创建 ForkJoinPool 实例的最简单的方式就是使用其静态方法 commonPool()。</description></item><item><title>组合 Futures</title><link>https://www.hotmindshare.com/docs/java/concurrency/default/9/</link><pubDate>Thu, 06 Oct 2022 22:42:23 +0800</pubDate><guid>https://www.hotmindshare.com/docs/java/concurrency/default/9/</guid><description>上一章节中我们讲解了 CompletableFuture 的一些基本用法，比如如何使用和如何处理异步计算结果。本章节我们继续，主要讲解如何使用 CompletableFuture 来组合异步计算的结果
组合 Futures CompletableFuture API 最吸引人的部分，应该是能够在一系列链式计算步骤中组合 CompletableFuture 实例。这种链式的结果本身就是CompletableFuture，允许进一步链接和组合。
这种方法在函数式语言中无处不在，通常被称为 「一元 ( monadic ) 设计模式 」。
CompletableFuture 提供了方法 thenCompose() 用于按顺序链接两个 Futures。该方法的参数是一个能够返回 CompletableFuture 实例的函数或表达式。而该函数或表达式的参数则是先前计算步骤的结果，这允许我们在下一个 CompletableFuture 的 lambda 中使用这个值。
例如下面这个示例
1CompletableFuture&amp;lt;String&amp;gt; completableFuture 2 = CompletableFuture.supplyAsync(() -&amp;gt; DDKK.COM 弟弟快看) 3 .thenCompose(s -&amp;gt; CompletableFuture.supplyAsync(() -&amp;gt; s + 程序员编程资料站)); 4assertEquals(&amp;#34;DDKK.COM 弟弟快看，程序员编程资料站&amp;#34;, completableFuture.get()); thenCompose() 方法与 thenApply() 一起实现了一元设计模式的基本构建块，它们与Java 8 中提供的 Stream 和 Optional 类的 map 和flatMap 方法密切相关。
两个方法都接收一个函数并将其应用于计算结果，但 thenCompose() （ flatMap() ）方法接收一个函数，该函数返回相同类型的另一个对象，这样，就允许将这些类的实例组合为构建块。
如果要执行两个独立的 Futures 并对其结果执行某些操作，可以使用 Future 的 thenCombine() 并传递能够接收两个参数的函数或表达式来处理这两个结果。</description></item><item><title/><link>https://www.hotmindshare.com/docs/java/concurrency/default/6/</link><pubDate>Thu, 06 Oct 2022 22:42:23 +0800</pubDate><guid>https://www.hotmindshare.com/docs/java/concurrency/default/6/</guid><description>ForkJoinPool 是Java 7 中引入的 fork/join 框架的核心之一。它解决了一个常见的问题： 如何在递归中生成多个任务。因为，即使是使用一个简单的 ThreadPoolExecutor ，也会在不断的递归中快速耗尽线程。因为每个任务或子任务都需要自己的线程来运行。
在fork/join 框架中，任何任务都可以生成 ( fork ) 多个子任务并使用 join() 方法等待它们的完成。fork/join 框架的好处是它不会为每个任务或子任务创建新线程，而是实现了 工作窃取 ( Work Stealing ) 算法。关于 fork/join 框架的详细信息，你可以访问我们的 一文秒懂 Java Fork/Join。
接下来，我们看一个使用 ForkJoinPool 遍历节点树并计算所有叶值之和的简单示例。在这个示例中，树是一个由节点，int 值和一组子节点组成。
1static class TreeNode { 2 int value; 3 Set&amp;lt;TreeNode&amp;gt; children; 4 TreeNode(int value, TreeNode... children) { 5 this.value = value; 6 this.children = Sets.newHashSet(children); 7 } 创建了树 TreeNode 之后，如果我们想要并行地对树中的所有值求和，我们需要实现一个 RecursiveTask&amp;lt;Integer&amp;gt; 接口。每个任务都接收自己的节点，并将其值添加到其子节点的值之和上。
要计算子节点值的总和，任务实现执行以下操作
1、 将子节点集合转换为流(stream)；
2、
因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 映射前面操作中创建的流，为每个元素创建一个新的CountingTask；</description></item><item><title>给 Maven 添加 Guava 依赖</title><link>https://www.hotmindshare.com/docs/java/concurrency/default/7/</link><pubDate>Thu, 06 Oct 2022 22:42:23 +0800</pubDate><guid>https://www.hotmindshare.com/docs/java/concurrency/default/7/</guid><description>Guava 是托管在 Github.com 上的流行的 Google 开源的 Java 线程池库。
Guava 包含了许多有用的并发类，同时还包含了几个方便的 ExecutorService 实现，但这些实现类都无法通过直接实例化或子类化来创建实例。取而代之的是提供了 MoreExecutors 助手类来创建它们的实例。
给 Maven 添加 Guava 依赖 为了将Google Guava 库包含进当前的项目中，需要将下面的依赖项添加到 Maven pom 文件中。
1&amp;lt;dependency&amp;gt; 2 &amp;lt;groupId&amp;gt;com.google.guava&amp;lt;/groupId&amp;gt; 3 &amp;lt;artifactId&amp;gt;guava&amp;lt;/artifactId&amp;gt; 4 &amp;lt;version&amp;gt;26.0&amp;lt;/version&amp;gt; 5&amp;lt;/dependency&amp;gt; 你可以在 Maven 中央仓库 中找到最新版本的 Guava 库
直接执行者和直接执行者服务 有时候，我们希望在当前线程或线程池中执行任务，具体在哪里取决于某些条件。这种情况下，你应该会更喜欢使用单个 Executor 接口，且只需切换实现即可。
虽然将当前线程中的任务的 Executor 或 ExecutorService 的提取出来单独实现并不困难，但它仍然需要编写一些样板代码。
值得庆幸的是，Guava 为我们提供了预定义的实例。
下面的范例演示了如何在同一个线程中执行任务。简单起见，提交的任务会将当前线程休眠 500 毫秒并阻塞当前线程，并在执行的调用完成后让结果立即可用
1 Executor executor = MoreExecutors.directExecutor(); 2AtomicBoolean executed = new AtomicBoolean(); 3executor.execute(() -&amp;gt; { 4 try { 5 Thread.</description></item><item><title>Java 中的线程池</title><link>https://www.hotmindshare.com/docs/java/concurrency/default/3/</link><pubDate>Thu, 06 Oct 2022 22:42:23 +0800</pubDate><guid>https://www.hotmindshare.com/docs/java/concurrency/default/3/</guid><description>本文我们将讲解 Java 中的线程池 ( Thread Pool )，从 Java 标准库中的线程池的不同实现开始，到 Google 开发的 Guava 库的前世今生。
本章节涉及到很多前几个章节中阐述的知识点。我们希望你是按照顺序阅读下来的，不然有些知识会一头雾水。
Java 语言的实现中，把 Java 线程一一映射到操作系统级的线程，而后者是操作系统的资源，这意味着，如果开发者毫无节制地创建线程，那么线程资源就会被快速的耗尽。
在Windows 操作系统上，每个线程要预留出 1m 的内存空间，意味着 2G 的内存理论上做多只能创建 2048 个线程。而在 Linux 上，最大线程数由常量 PTHREAD_THREADS_MAX 决定，一般为 1024。
出于模拟并行性的目的，Java 线程之间的上下文切换也由操作系统完成。因为线程上下文切换需要消耗时间，所以，一个简单的观点是：产生的线程越多，每个线程花在实际工作上的时间就越少。
为什么会有线程上下文切换？
一台电脑，运行起来后，它的 CPU 是固定的，05 年之前，还是单核时代，也就是一次只能运行一个线程，虽然随着时间的推移，现在的 CPU 已经有很多个核心，比如 8 核 16 核之类的。但相比于一个应用程序能够创建的线程数，那真的是太少了。而每个核心一次只能运行一个线程，所以多个线程需要运行时就需要来回不停的在多个线程间切换，这就是线程之间的上下文切换。
为了节制创建线程的数量，也为了节省创建线程的开销，因此提出了线程池的概念。线程池模式有助于节省多线程应用程序中的资源，还可以在某些预定义的限制内包含并行性。
当我们使用线程池时，我们可以以并行任务的形式编写并发代码并将其提交到线程池的实例中执行。
这个线程池实例控制了多个重用线程以执行这些任务。
这种线程池模式，允许我们控制应用程序创建的线程数，生命周期，以及计划任务的执行并将传入的任务保留在队列中。
Java 中的线程池 Executors、Executor 和 ExecutorService Executors 是一个帮助类，提供了创建几种预配置线程池实例的方法。如果你不需要应用任何自定义的微调，可以调用这些方法创建默认配置的线程池，因为它能节省很多时间和代码。
Executor 和 ExecutorService 接口则用于与 Java 中不同线程池的实现协同工作。通常，你应该将代码与线程池的实际实现分离，并在整个应用程序中使用这些接口。
Executor 接口提供了一个 execute() 方法将 Runnable 实例提交到线程池中执行。
下面的代码是一个快速示例，演示了如何使用 Executors API 获取包含了单个线程池和无限队列支持的 Executor 实例，以便按顺序执行任务。</description></item><item><title>Java 并发编程面试题</title><link>https://www.hotmindshare.com/docs/java/concurrency/default/10/</link><pubDate>Thu, 06 Oct 2022 22:42:23 +0800</pubDate><guid>https://www.hotmindshare.com/docs/java/concurrency/default/10/</guid><description>应聘Java 岗，总是免不了几个 Java 并发编程的面试题，不过大多数都局限在 java.util.concurrent 包下的知识和实现问题。本文针对 Java 并发相关的常见的面试题做一些解释。
Q1: 进程和线程的区别？ 这是一个非常基础的面试题，如果这道题没有回答的比较满意，一般情况下，面试官会认为应聘者在并发方面的基础只是不牢固，就不会继续深入询问其它并发问题了。
1、 进程和线程都是并发单元，但它们有一个根本区别：进程不共享公共内存，而线程则共享；
2、 从操作系统的角度来看，进程是一个独立的软件，在其自己的虚拟内存空间中运行任何一个多任务操作系统（这几乎意味着任何现代操作系统）都必须将内存中的进程分开，这样一个失败的进程就不会通过加扰公共内存来拖累所有其它进程因此，进程通常是隔离的，它们通过进程间通信进行协作，进程间通信由操作系统定义为一种中间API；
3、 相反，线程是应用程序的一部分，它与同一应用程序的其他线程共享公共内存使用公共内存可以减少大量开销，因此使用线程可以更快的交换数据和进行线程间协作；
关于进程间通讯那一块可以不用回答，如果你不懂的话，不必然会导致接下来的某个问题是 进程间通讯的的原理.
Q2: 如何创建一个线程实例并且运行它？ 这道题考察的是对 Runnable 的理解。
创建一个线程的实例，有两种方法可供选择:
1、 把Runnable的实例传递给Thread的构造函数并调用start()方法；
1Thread thread1 = new Thread(() -&amp;gt; 2 System.out.println(&amp;#34;Hello World from Runnable!&amp;#34;)); 3thread1.start(); Runnable是一个函数接口，因此可以作为 lambda 表达式传递
2、 因为线程本身也实现了Runnable接口，所以另一种创建线程的方法是创建一个匿名子类，覆写它的run()方法，然后调用start()；
1Thread thread2 = new Thread() { 2 @Override 3 public void run() { 4 System.out.println(&amp;#34;Hello World from subclass!&amp;#34;); 5 } 6}; 7thread2.start(); Q3: 描述线程的不同状态以及何时发生状态转换 ？ 这道题考察的是对线程生命周期的理解。</description></item><item><title>扩展一个线程 （ Thread 类 )</title><link>https://www.hotmindshare.com/docs/java/concurrency/default/18/</link><pubDate>Thu, 06 Oct 2022 22:42:23 +0800</pubDate><guid>https://www.hotmindshare.com/docs/java/concurrency/default/18/</guid><description>写Java 代码的时候，我们经常会有这样的疑问：我到底是实现一个 Runnable 呢，还是扩展一个 Thread 类？
你的答案是什么呢？ 那有没有标准答案呢？
答案是什么呢？
我们先来分析下，看看哪种方法在实践中更有意义以及为什么？
扩展一个线程 （ Thread 类 ) 简单起见，我们就来定义一个扩展自 Thread 的 SimpleThread 类
1public class SimpleThread extends Thread { 2 private String message; 3 // standard logger, constructor 4 @Override 5 public void run() { 6 log.info(message); 7 } 代码也真是简单了，然后我们看看如何运行这个 SimpleThread 类
1@Test 2public void givenAThread_whenRunIt_thenResult() 3 throws Exception { 4 Thread thread = new SimpleThread( 5 &amp;#34;SimpleThread executed using Thread&amp;#34;); 6 thread.start(); 7 thread.</description></item><item><title>BlockingQueue 的队列类型</title><link>https://www.hotmindshare.com/docs/java/concurrency/default/12/</link><pubDate>Thu, 06 Oct 2022 22:42:23 +0800</pubDate><guid>https://www.hotmindshare.com/docs/java/concurrency/default/12/</guid><description>本文中，我们将介绍一个 java.util.concurrent 包提供的用于解决并发生产者 – 消费者问题的最有用的类 – BlockQueue。我们将介绍BlockingQueue 接口的 API 以及如何使用该接口的方法使编写并发程序更容易。
在本文的后面，我们将展示一个具有多个生产者线程和多个消费者线程的简单程序的示例。
BlockingQueue 的队列类型 java.util.concurrent 提供了两种类型的 BlockingQueue：
1、 无限队列（unboundedqueue）–几乎可以无限增长；
2、 有限队列（boundedqueue）–定义了最大容量；
无限队列 创建一个无限队列的方法很简单
1BlockingQueue&amp;lt;String&amp;gt; blockingQueue = new LinkedBlockingDeque&amp;lt;&amp;gt;(); 上面这段代码中，blockingQueue 的容量将设置为 Integer.MAX_VALUE 。
向无限队列添加元素的所有操作都将永远不会阻塞，因此它可以增长到非常大的容量。
使用无限 BlockingQueue 设计生产者 – 消费者模型时最重要的是 消费者应该能够像生产者向队列添加消息一样快地消费消息 。否则，内存可能会填满，然后就会得到一个 OutOfMemory 异常。
有限队列 第二种类型的队列是有限队列。我们可以通过将容量作为参数传递给构造函数来创建这样的队列
1BlockingQueue&amp;lt;String&amp;gt; blockingQueue = new LinkedBlockingDeque&amp;lt;&amp;gt;(10); 上面这句代码中，我们设置了 blockingQueue 的容量为 10 。这意味着当消费者尝试将元素添加到已经满了的队列时，结果取决于添加元素的方法（ offer() 、add() 、put() ) ，它将阻塞，直到有足够的空间可以插入元素。否则，添加操作将会失败。
使用有限队列是设计并发程序的好方法，因为当我们将元素插入到已经满了的队列时，这些操作需要等到消费者赶上并在队列中提供一些空间。这种机制可以让那个我们不做任何其它更改就可以实现节流。
BlockingQueue API BlockingQueue 接口的所有方法可以分为两大类：负责向队列添加元素的方法和检索这些元素的方法。
在队列满/空的情况下，来自这两个组的每个方法的行为都不同。
添加元素 BlockingQueue 提供了以下方法用于添加元素
方法 说明 add() 如果插入成功则返回 true，否则抛出 IllegalStateException 异常 put() 将指定的元素插入队列，如果队列满了，那么会阻塞直到有空间插入 offer() 如果插入成功则返回 true，否则返回 false offer(E e, long timeout, TimeUnit unit) 尝试将元素插入队列，如果队列已满，那么会阻塞直到有空间插入 检索元素 BlockingQueue 提供了以下方法用于检索元素</description></item><item><title>Java 中的线程同步 ( Thread Synchronization )</title><link>https://www.hotmindshare.com/docs/java/concurrency/default/19_miss/</link><pubDate>Thu, 06 Oct 2022 22:42:23 +0800</pubDate><guid>https://www.hotmindshare.com/docs/java/concurrency/default/19_miss/</guid><description>大家有没有发现，其实 「 一文秒懂 」 系列讲述的都是多线程并发开发的问题。这个话题太大了，估计没有上百篇文章都解释不清楚。
本文，我们来讲解下 Java 并发中的基础的基础，核心的核心，Java 并发编程中的最基本的机制之一 – 「 线程同步 」
为了方便你理解并发编程中的各种概念和术语，我们首先会来一阵扫盲，讨论一些基本的并发相关术语和方法。接着，我们将开发一个简单的应用程序，并在合格应用程序里处理并发问题，以方便大家理解和巩固 wait() 和 notify()。
Java 中的线程同步 ( Thread Synchronization ) 在并发编程中，在多线程环境下，多个线程可能会尝试修改同一资源。如果线程管理不当，这显然会导致一致性问题。
Java 中的哨兵块 ( guarded block ) Java 中，可以用来协调多个线程操作的一个工具是 「 哨兵块 」。这个哨兵块会在恢复执行前检查特定条件。
基于这种哨兵检查的思想，Java 在所有类的基类 Object 中提供了两个方法
方法 说明 Object.wait() 暂停一个线程 Object.notify() 唤醒一个线程 是不是有点难以理解，别担心，看下面这个图，这个图描绘了线程的的生命周期。
虽然从上图中可以看出，有多个方法可以控制一个线程的生命周期，但本章节，我们只讨论 notify() 方法和 wait() 方法
wait() 方法 对照上图，简单的说，当我们调用 wait() 时会强制当前线程等待，直到某个其它线程在同一个对象上调用 notify() 或 notifyAll() 方法。
因此，当前线程必须拥有对象的监视器。根据 Java docs 的说法，这可能发生在
我们已经为给定对象执行了同步实例方法 我们已经在给定对象上执行了 synchronized 块的主体 通过为 Class 类型的对象执行同步静态方法 请注意，一次只有一个活动线程可以拥有对象的监视器。</description></item><item><title>ThreadLocalRandom Via Random</title><link>https://www.hotmindshare.com/docs/java/concurrency/default/16/</link><pubDate>Thu, 06 Oct 2022 22:42:23 +0800</pubDate><guid>https://www.hotmindshare.com/docs/java/concurrency/default/16/</guid><description>随机数生成是一个非常常见的操作，而且 Java 也提供了 java.util.Random 类用于生成随机数，而且呢，这个类也是线程安全的，就是有一点不好，在多线程下，它的性能不佳。
为什么多线程下，Random 的性能不佳？
因为，它采用了多个线程共享一个 Random 实例。这样就会导致多个线程争用。
为了解决这个问题，Java 7 引入了 java.util.concurrent.ThreadLocalRandom 类，用于在多线程环境中生成随机数。
本文接下来的部分，就来看看如何 ThreadLocalRandom 如何执行以及如何在实际应用程序中使用它。
ThreadLocalRandom Via Random ThreadLocalRandom 是 ThreadLocal 类和 Random 类的组合，它与当前线程隔离，通过简单地避免对 Random 对象的任何并发访问，在多线程环境中实现了更好的性能。
也就是说，相比于 java.util.Random 类全局的提供随机数生成， 使用 ThreadLocalRandom，一个线程获得的随机数不受另一个线程的影响。
另一个与 Random 类不同的是，ThreadLocalRandom 不支持显式设置种子。因为它重写了从 Random 继承的 setSeed(long seed) 方法，会在调用时始终抛出 UnsupportedOperationException。
接下来我们看看如何使用 ThreadLocalRandom 生成随机 int、long 和 double 值。
使用 ThreadLocalRandom 生成随机数 根据Oracle 文档，我们只需要调用 ThreadLocalRandom.current() 方法，就能返回当前线程的 ThreadLocalRandom 实例。然后，我们可以通过实例的相关方法来生成随机值。
比如下面的代码，生成一个没有任何边界的随机 int 值
1int unboundedRandomValue = ThreadLocalRandom.current().nextInt()); 其实是有边界的，它的边界就是 int 的边界。</description></item><item><title>Java 中的多线程</title><link>https://www.hotmindshare.com/docs/java/concurrency/default/17_miss/</link><pubDate>Thu, 06 Oct 2022 22:42:23 +0800</pubDate><guid>https://www.hotmindshare.com/docs/java/concurrency/default/17_miss/</guid><description>本文中，我想详细的讨论下 Java 中的核心概念 – 线程的生命周期。我会使用一张我自制的图片加上实用的代码片段，一步一步的详细剖析线程的各个状态和各个状态之间如何转换。
Java 中的多线程 Java 语言中， 多线程是由 Thread 的核心概念驱动的。因为多线程中的每一个线程都相互独立，有着自己的生命周期和状态转换。
我们先来看一张草图，这图描述了 Java 线程的各种状态和转换过程。
是不是很杂乱无章？ 看不懂没关系，我们接下来会详细介绍各个状态。
Java 线程中的生命周期 Java 中，每一个线程都是 java.lang.Thread 类的实例。而且，Java 个线程生命周期中的各个状态都定义在 Thread 类的一个静态的 State 枚举中。
State 枚举定义了线程的所有潜在状态。总共有 6 个，分别对应者上图中的 6 个绿色背景的矩形和椭圆型。
NEW : 新创建的，且未调用 start() 方法开始执行的线程。 RUNNABLE : 已经在运行中的线程或正在等待资源分配的准备运行的线程。 BLOCKED : 等待获取进入或重新进入同步块或方法的监视器锁的线程。 WAITING : 等待其他一些线程执行特定操作，没有任何时间限制。 TIMED_WAITING: 等待某个其他线程在指定时间段内执行特定操作 TERMINATED : 线程完成了它的任务。 需要注意的是： 在任何给定的时间点，线程只能处于这些状态之一。
NEW 状态，应该很好理解，比如，车，厂家生产出来，只要还没被卖出过，那么它就是新的 ( NEW ) RUNNABLE 只要线程不出于其它状态，它就是 RUNNABLE 状态。怎么理解呢？ 车买来了，只要它没坏没出什么毛病没借给别人，那么它就出于可开状态，不管是呆在家里吃灰还是已经在上路运行。 WAITING : 无时间显示的等待其它线程完成任务时就处于这个状态，怎么理解呢？比如长假告诉公路大堵车，要等待别人前进了几个蜗牛步我们才能往前几个蜗牛步，有时候一等就是昏天暗地，可能长达几天，也可能，一辈子吧。 TIMED_WAITING : 一直处于 WAITING 总不是办法，所以可能会设置一个超时时间，如果过了时间，就不等待了。同样的，如果可以后退，那么我们在堵车的时候可能会等待那么十几分钟，发现确实走不了，就等了呗。 TERMINATED : 当一个线程结束了它的任务（可能完成了，也可能没完成）就会处于这个状态。如果拿车做比喻，那么当车彻底报废，已经再也不能上路了，就处于这个状态。 其实拿车作比喻感觉有点怪，我觉得拿追女朋友来做比喻比较恰当些。</description></item><item><title>锁 ( lock ) 和同步块 ( synchronized block ) 之间的差异</title><link>https://www.hotmindshare.com/docs/java/concurrency/default/13/</link><pubDate>Thu, 06 Oct 2022 22:42:23 +0800</pubDate><guid>https://www.hotmindshare.com/docs/java/concurrency/default/13/</guid><description>对于Java 来讲，锁 （ Lock ) 是一种比标准同步块 （ synchronized block ） 更灵活，更复杂的线程同步机制。
其实，Java 1.5 就已经存在 Lock 接口了。这个 Lock 接口在 java.util.concurrent.lock 包中定义，提供了大量的锁操作。
本文中，我们将讲解 Lock 接口的不同实现并介绍如何在应用程序中使用锁。
锁 ( lock ) 和同步块 ( synchronized block ) 之间的差异 使用synchronized 块和使用 Lock API 之间几乎没有区别：
同步块完全包含在方法中 : 在独立的方法中，我们可以使用 Lock 提供的 lock() 和 unlock() 实现锁和解锁操作。 同步块不支持公平竞争，任何线程都可以获取释放的锁定，且不能指定优先级。但锁 ( Lock ) 就不一样了，可以通过指定公平属性来实现 Lock 中的公平性。这可以确保最长的等待线程被授予锁定权限。 如果线程无法访问同步块，则会阻塞该线程。Lock 则提供了 tryLock() 方法。线程只有在可用且不被任何其他线程保持时才获取锁定。这减少了线程等待锁定的阻塞时间。 处于 「 等待 」 状态以获取对同步块的访问的线程不能被中断。Lock 提供了一个 lockInterruptibly() 方法，可用于在等待锁定时中断线程。 从上面的对比来看，同步块的所有机制，锁 ( Lock ) 都有相应的 API 对应。</description></item><item><title>守护线程和用户线程的区别</title><link>https://www.hotmindshare.com/docs/java/concurrency/default/14/</link><pubDate>Thu, 06 Oct 2022 22:42:23 +0800</pubDate><guid>https://www.hotmindshare.com/docs/java/concurrency/default/14/</guid><description>在这篇简短的文章中，我们将讲解下 Java 中的守护线程，看看它们可以做什么。我们还将解释守护线程和用户线程之间的区别。
守护线程和用户线程的区别 Java 提供了两种类型的线程：守护线程 和 用户线程
用户线程 是高优先级线程。JVM 会在终止之前等待任何用户线程完成其任务。 用户线程 是低优先级线程。其唯一作用是为用户线程提供服务。 由于守护线程的作用是为用户线程提供服务，并且仅在用户线程运行时才需要，因此一旦所有用户线程完成执行，JVM 就会终止。也就是说 守护线程不会阻止 JVM 退出。
这也是为什么通常存在于守护线程中的无限循环不会导致问题，因为任何代码（包括 finally 块 ）都不会在所有用户线程完成执行后执行。
这也是为什么我们并不推荐 在守护线程中执行 I/O 任务 。因为可能导致无法正确关闭资源。
但是，守护线程并不是 100% 不能阻止 JVM 退出的。守护线程中设计不良的代码可能会阻止 JVM 退出。例如，在正在运行的守护线程上调用Thread.join() 可以阻止应用程序的关闭。
守护线程能用来做什么？ 常见的做法，就是将守护线程用于后台支持任务，比如垃圾回收、释放未使用对象的内存、从缓存中删除不需要的条目。
咦，按照这个解释，那么大多数 JVM 线程都是守护线程。
如何创建守护线程 ？ 守护线程也是一个线程，因此它的创建和启动其实和普通线程没什么区别？
要将普通线程设置为守护线程，方法很简单，只需要调用 Thread.setDaemon() 方法即可。
例如下面这段代码，假设我们继承 Thread 类创建了一个新类 NewThread 。那么我们就可以创建这个类的实例并设置为守护线程
1NewThread daemonThread = new NewThread(); 2daemonThread.setDaemon(true); 3daemonThread.start(); 在Java 语言中，线程的状态是自动继承的。任
因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 何线程都会继承创建它的线程的守护程序状态。怎么理解呢？
1、 如果一个线程是普通线程（用户线程），那么它创建的子线程默认也是普通线程（用户线程）；
2、 如果一个线程是守护线程，那么它创建的子线程默认也是守护线程；
因此，我们可以推演出： 由于主线程是用户线程，因此在 main() 方法内创建的任何线程默认为用户线程。</description></item><item><title>创建 Future</title><link>https://www.hotmindshare.com/docs/java/concurrency/default/15/</link><pubDate>Thu, 06 Oct 2022 22:42:23 +0800</pubDate><guid>https://www.hotmindshare.com/docs/java/concurrency/default/15/</guid><description>写了几篇 Java 一文秒懂 XXX 系列的文章后，对 Java 并发编程的设计思想真的是竖然起敬。
Future 定义在 java.util.concurrent 包中，这是一个接口，自 Java 1.5 以来一直存在的接口，用于处理异步调用和处理并发编程。
创建 Future 简单地说，Future 类表示异步计算的未来结果 – 在处理完成后最终将出现在 Future 中的结果。
是不是又很难理解，文字越少，内容越多。上面这句话的意思，就是主线程会创建一个 Future 接口的对象，然后启动并发线程，并告诉并发线程，一旦你执行完毕，就把结果存储在这个 Future 对象里。
因此，理解 Future 的第一步，就是要知道如何创建和返回 Future 实例。
一般情况下，我们会把长时间运行的逻辑放在异步线程中进行处理，这是使用 Future 接口最理想的场景。主线程只要简单的将异步任务封装在 Future 里，然后开始等待 Future 的完成，在这段等待的时间内，可以处理一些其它逻辑，一旦 Future 执行完毕，就可以从中获取执行的结果并进一步处理。
针对上面这种表述，我们来看看具体哪些场景可以使用 Future :
计算密集型（ 数学和科学计算 ） 操纵大数据结构（ 大数据 ） 远程方法调用（下载文件，HTML 爬取，Web 服务） 实现了 Future 的 FutureTask 我们先来看一段代码:
1public class SquareCalculator { 2 private ExecutorService executor 3 = Executors.newSingleThreadExecutor(); 4 public Future&amp;lt;Integer&amp;gt; calculate(Integer input) { 5 return executor.</description></item><item><title>并发编程中使用 CountDownLatch</title><link>https://www.hotmindshare.com/docs/java/concurrency/default/11/</link><pubDate>Thu, 06 Oct 2022 22:42:23 +0800</pubDate><guid>https://www.hotmindshare.com/docs/java/concurrency/default/11/</guid><description>本章节我们来讨论下 java.util.concurrent.CountDownLatch 这个类，顺带演示下如何在一些实际例子中使用它。
CountDownLatch 类的作用呢？ 怎么说呢？ 简单来说，我们可以使用它来阻塞线程，直到其他线程完成给定任务。
并发编程中使用 CountDownLatch 简而言之，CountDownLatch 有一个计数器字段，我们可以根据需要减少它，因此，我们可以使用它来阻止调用线程，直到它被计数到零。
如果我们正在进行一些并行处理，我们可以使用与计数器相同的值来实例化 CountDownLatch，因为我们想要处理多个线程。然后，我们可以在每个线程完成后调用 countdown()，保证调用 await() 的依赖线程将阻塞，直到工作线程完成。
使用 CountDownLatch 等待线程池完成 我们通过创建一个 Worker 来尝试这个模式，并使用 CountDownLatch 字段来指示它何时完成
1public class Worker implements Runnable { 2 private List&amp;lt;String&amp;gt; outputScraper; 3 private CountDownLatch countDownLatch; 4 public Worker(List&amp;lt;String&amp;gt; outputScraper, CountDownLatch countDownLatch) { 5 this.outputScraper = outputScraper; 6 this.countDownLatch = countDownLatch; 7 } 8 @Override 9 public void run() { 10 doSomeWork(); 11 outputScraper.add(&amp;#34;Counted down&amp;#34;); 12 countDownLatch.countDown(); 13 } 然后，我们创建一个测试，以证明我们可以让 CountDownLatch 等待 Worker 实例完成</description></item><item><title>ThreadPoolExecutor</title><link>https://www.hotmindshare.com/docs/java/concurrency/default/4/</link><pubDate>Thu, 06 Oct 2022 22:42:23 +0800</pubDate><guid>https://www.hotmindshare.com/docs/java/concurrency/default/4/</guid><description>因为上一章节篇幅有限，所以我决定把 一文秒懂 Java 线程池 拆分为三篇文章单独介绍。本章节，我们就来看看 ThreadPoolExecutor 。
ThreadPoolExecutor ThreadPoolExecutor 是一个可被继承 ( extends ) 的线程池实现，包含了用于微调的许多参数和钩子。
我们并不会讨论 ThreadPoolExecutor 类中的所有的参数和钩子，只会讨论几个主要的配置参数：
1、 corePoolSize；
2、 maximumPoolSize；
3、 keepAliveTime；
ThreadPoolExecutor 创建的线程池由固定数量的核心线程组成，这些线程在 ThreadPoolExecutor 生命周期内始终存在，除此之外还有一些额外的线程可能会被创建，并会在不需要时主动销毁。corePoolSize 参数用于指定在线程池中实例化并保留的核心线程数。如果所有核心线程都忙，并且提交了更多任务，则允许线程池增长到 maximumPoolSize 。
keepAliveTime 参数是额外的线程（ 即，实例化超过 corePoolSize 的线程 ）在空闲状态下的存活时间。
这三个参数涵盖了广泛的使用场景，但最典型的配置是在 Executors 静态方法中预定义的。
Executors.newFixedThreadPool() 例如，Executors.newFixedThreadPool() 静态方法创建了一个 ThreadPoolExecutor ，它的参数 corePoolSize 和 maximumPoolSize 都是相等的，且参数 keepAliveTime 始终为 0 ，也就意味着此线程池中的线程数始终相同。
1ThreadPoolExecutor executor = 2 (ThreadPoolExecutor) Executors.newFixedThreadPool(2); 3executor.submit(() -&amp;gt; { 4 Thread.sleep(1000); 5 return null; 6}); 7executor.submit(() -&amp;gt; { 8 Thread.</description></item><item><title>范例 2</title><link>https://www.hotmindshare.com/docs/java/concurrency/default/5/</link><pubDate>Thu, 06 Oct 2022 22:42:23 +0800</pubDate><guid>https://www.hotmindshare.com/docs/java/concurrency/default/5/</guid><description>ScheduledThreadPoolExecutor 扩展自 一文秒懂 Java 线程池之 ThreadPoolExecutor 讲解的 了ThreadPoolExecutor 类，并且添加了其它方法实现了 ScheduledExecutorService 接口。
schedule() 方法允许在指定的延迟后执行一次任务 scheduleAtFixedRate() 方法允许在指定的初始延迟后执行任务，然后以一定的周期重复执行，其中 period 参数用于指定两个任务的开始时间之间的间隔时间，因此任务执行的频率是固定的。 scheduleWithFixedDelay() 方法类似于 scheduleAtFixedRate() ，它也重复执行给定的任务，但period 参数用于指定前一个任务的结束和下一个任务的开始之间的间隔时间。也就是指定下一个任务延时多久后才执行。执行频率可能会有所不同，具体取决于执行任何给定任务所需的时间。 静态方法 Executors.newScheduledThreadPool() 方法用于创建包含了指定 corePoolSize，无上限 maximumPoolSize 和 0 存活时间 keepAliveTime 的 ScheduledThreadPoolExecutor 实例。
例如下面的示例创建了一个包含了 5 个核心线程的 `S
因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 cheduledThreadPoolExecutor实例，且每隔 500 毫秒运行一个输出Hello World` 的任务
1ScheduledExecutorService executor = Executors.newScheduledThreadPool(5); 2executor.schedule(() -&amp;gt; { 3 System.out.println(&amp;#34;Hello World&amp;#34;); 4}, 500, TimeUnit.MILLISECONDS); 范例 2 下面的代码则演示了如何在 500 毫秒延迟后执行任务，然后每 100 毫秒重复执行一次。
1CountDownLatch lock = new CountDownLatch(3); 2ScheduledExecutorService executor = Executors.</description></item><item><title>实例化 ExecutorService</title><link>https://www.hotmindshare.com/docs/java/concurrency/default/1/</link><pubDate>Thu, 06 Oct 2022 22:42:23 +0800</pubDate><guid>https://www.hotmindshare.com/docs/java/concurrency/default/1/</guid><description>ExecutorService 是 Java java.util.concurrent 包的重要组成部分，是 Java JDK 提供的框架，用于简化异步模式下任务的执行。
一般来说，ExecutorService 会自动提供一个线程池和相关 API，用于为其分配任务。
实例化 ExecutorService 实例化ExecutorService 的方式有两种：一种是工厂方法，另一种是直接创建。
Executors.newFixedThreadPool() 工厂方法创建 ExecutorService 实例 创建ExecutorService 实例的最简单方法是使用 Executors 类的提供的工厂方法。比如
1ExecutorService executor = Executors.newFixedThreadPool(10); 当然还有其它很多工厂方法，每种工厂方法都可以创建满足特定用例的预定义 ExecutorService 实例。你所需要做的就是找到自己想要的合适的方法。这些方法都在 Oracle 的 JDK 官方文档中有列出
直接创建 ExecutorService 的实例 因为ExecutorService 是只是一个接口，因此可以使用其任何实现类的实例。Java java.util.concurrent 包已经预定义了几种实现可供我们选择，或者你也可以创建自己的实现。
例如，ThreadPoolExecutor 类实现了 ExecutorService 接口并提供了一些构造函数用于配置执行程序服务及其内部池。
1ExecutorService executorService = 2 new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, 3 new LinkedBlockingQueue&amp;lt;Runnable&amp;gt;() 4); 你可能会注意到，上面的代码与工厂方法 newSingleThreadExecutor() 的 源代码 非常相似。对于大多数情况，不需要详细的手动配置。
将任务分配给 ExecutorService ExecutorService 可以执行 Runnable 和 Callable 任务。为了使本文简单易懂。我们将使用两个两个原始任务，如下面的代码所示。</description></item></channel></rss>