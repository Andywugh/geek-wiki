<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Netty on 程序员安仔</title><link>https://www.shellio.cc/docs/java/netty/</link><description>Recent content in Netty on 程序员安仔</description><generator>Hugo -- gohugo.io</generator><language>zh-hans</language><copyright>个人技术博客</copyright><atom:link href="https://www.shellio.cc/docs/java/netty/index.xml" rel="self" type="application/rss+xml"/><item><title>八、Netty 教程 – 编写自己的文件服务器</title><link>https://www.shellio.cc/docs/java/netty/8/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/netty/8/</guid><description>作者：唐亚峰 | 出自：唐亚峰博客
前面已经讲了Netty的基本用法（请求/应答，拆包/粘包，序列化），本章以文件下载为例，编写一个相比传统Tomcat，Jetty等容器更加轻量级的文件服务器案例……
HTTP协议介绍 HTTP是一个属于应用层面向对象的协议（HTTP1.O，HTTP1.1，HTTP2.0），简洁，快速响应，几乎适用各大行业应用，覆盖广泛，但相比HTTPS安全性较差（具体区别不做过多概述，有兴趣可以百度百科一下）……
主要特点 支持Client/Server模式 简单，简洁，客户端只需要根据指定URL，带上规定的参数或者消息体请求即可 灵活，允许传输任意对象传输，内容类型由请求头的Content-Type标记 无状态，不存在对事务处理记忆功能，若存在后续请求，则需重新传输之前相关信息（容易导致每次连接传输的数据量增大），但在另外一方面，无状态就可以带来快速响应与轻量级负载的优势… 请求方式 1GET：获取Request-URI所标识的资源，常见的查询操作 2POST:在Request-URI所标识的资源后附加新的提交数据，可以存在消息体中，不一定体现在URL上，用于新增修改等操作 3HEAD：请求获取Request-URI所标识的响应消息头 4PUT：请求服务器存储的资源，以Request-URI做为标识，一般用作修改操作 5DELETE：请求服务器删除Request-URI所标识的记录 6TRACE：请求服务器回送收到的消息请求，测试或诊断 7CONNECT：保留将来使用 8OPTIONS：查询服务器性能，或查询与资源相关的选项和数据 标准路径：http://ip:port/path
HTTP请求头提供了关于请求，响应或者其他的发送实体的信息。HTTP的头信息包括通用头、请求头、响应头和实体头四个部分。每个头域由一个域名，冒号（:）和域值三部分组成。
通用头标：即可用于请求，也可用于响应，是作为一个整体而不是特定资源与事务相关联。 请求头标：允许客户端传递关于自身的信息和希望的响应形式。 响应头标：服务器和于传递自身信息的响应。 实体头标：定义被传送资源的信息。即可用于请求，也可用于响应。 HTTP响应头和请求头信息对照表：http://tools.jb51.net/table/http_header 有兴趣的可以看下，里面有详细介绍与描述
HTTP响应状态码和描述信息：http://tools.jb51.net/table/http_status_code
编写文件下载服务 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 简单描述了下HTTP，现在开始用Netty给我们提供的HTTP编写一个入门的服务端程序，含以下功能
路径映射 递归文件夹操作 文件下载 HttpFileServer 1@Override 2protected void initChannel(SocketChannel channel) throws Exception { 3 channel.pipeline().addLast(&amp;#34;http-decoder&amp;#34;, new HttpRequestDecoder()); 4 channel.pipeline().addLast(&amp;#34;http-aggregator&amp;#34;, new HttpObjectAggregator(8 * 1024)); 5 channel.pipeline().addLast(&amp;#34;http-encoder&amp;#34;, new HttpResponseEncoder()); 6 channel.pipeline().addLast(&amp;#34;http-chunked&amp;#34;, new ChunkedWriteHandler()); 7 channel.pipeline().addLast(&amp;#34;fileServerHandler&amp;#34;, new HttpFileServerHandler(path)); 8} 初始化添加HTTP相关编码器与解码器，对HTTP响应消息进行编码操作 如果把解析这块理解是一个黑盒的话，则输入是ByteBuf，输出是FullHttpRequest，通过该对象便可获取到所有与HTTP协议有关的信息。 HttpRequestDecoder先通过RequestLine和Header解析成HttpRequest对象，传入到HttpObjectAggregator，然后再通过body解析出HttpContent对象，传入到HttpObjectAggregator，当HttpObjectAggregator发现是LastHttpContent，则代表HTTP协议解析完成，封装FullHttpRequest 对于body内容的读取涉及到Content-Length和trunked两种方式，两种方式只是在解析协议时处理的不一致，最终输出是一致的。 ChunkedWriteHandler是为了支持异步发送过大数据流情况，不占用过多内存，防止JAVA内存溢出的问题… 挑优方案：http://blog.</description></item><item><title>二、Netty 教程 – NIO类库简介</title><link>https://www.shellio.cc/docs/java/netty/2/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/netty/2/</guid><description>作者：唐亚峰 | 出自：唐亚峰博客
在上一篇文章中介绍了传统I/O编程的弊端，本章将概述NIO的由来和和一些基本概念……
类库简介 2002年的时候，Sum公司推出了JDK1.4并且新增了NIO的类库，弥补了原来同步阻塞I/O带来的不足，官方称之为New I/O，寓意指新的I/O编程模型，但是由于旧版的Block I/O在民间更喜欢称它为Non Block I/O（非阻塞I/O）编程模型，在NIO的类库中，将原本java.net.Socket 以及 java.net.ServerSocket 分别升级成 java.nio.SocketChannel 和 java.nio.ServerSocketChannel，它们都支持阻塞与非阻塞模式，前者性能与可靠性较差，后者却恰恰相反，在开发过程中可以选取适合自己的模式，一般来说，低负载、低并发的应用程序可以选择同步阻塞IO以降低编程复杂度。但是对于高负载、高并发的网络应用，需要使用NIO的非阻塞模式进行开发….
Buffer Buffer是一个含读写数据操的作对象，在NIO库中，所有的对象都是用缓冲处理的，读写数据操作时都是通过缓冲区来处理，实际上它是一个数组，但通常它是一个字节数组（ByteBuffer），也可以使用其它种类的数组，但是一个缓冲区不仅仅是一个数组，缓冲区提供了对数据结构化访问及维护读写位置（limit）等信息…
Channel Channel是一个全双工的通道（同时支持双向传输，在BIO中都是单向流，即InputStream 和 OutputStream），因为是双向的，所以它可以更好的映射底层操作系统的API，特别是在UNIX网络编程模型中，底层操作系统的通道都是双全工的，同时支持读写…
Selector Selector是NIO中的基础，对NIO编程至关重要，它是一个多路复用器，提供选择已经准备就绪的任务功能，会不断轮训注册在它上面的Channel，如果某个Channel上面有新的TCP请求接入，它就会处于就绪状态，供Selector轮训出来，然后可与通过SelectorKey获取就绪的Channel集合，从而进行I/O操作…
异步非阻塞服务端实现 注意事项
与Selector 使用的 Channel 必须处于非阻塞模式 每次使用Selector时应该先判断下Selector是否已经被关闭，否则容易出现java.nio.channels.ClosedSelectorException错误 1public static void main(String[] args) { 2 int port = 4040; 3 MultiplexerTimeServer timeServer = new MultiplexerTimeServer(port); 4 new Thread(timeServer,&amp;#34;NIO-MultiplexerTimeServer-1&amp;#34;).start(); 5} 通过TimeServer的时序图，我们来看下实现的异步非阻塞的TimeServer代码
1public class MultiplexerTimeServer implements Runnable { 2 private Selector selector; 3 private ServerSocketChannel serverSocketChannel; 4 public MultiplexerTimeServer(int port) { 5 try { 6 selector = Selector.</description></item><item><title>九、Netty 教程 – 实现WebSocket通讯</title><link>https://www.shellio.cc/docs/java/netty/9/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/netty/9/</guid><description>作者：唐亚峰 | 出自：唐亚峰博客
WebSocket是 Html5 开始提供的一种浏览器与服务器间进行全双工通信的网络技术，支持数据在客户端与服务端双向传输，只要握手成功，两端会打开一个长连接进行持续交互…..
WebSocket WebSocket协议是基于TCP的一种新的网络协议，它实现了浏览器与服务器全双工(full-duplex)通信，允许服务器主动发送信息给客户端
优点及作用 Http协议的弊端：
Http协议为半双工协议。（半双工：同一时刻，数据只能在客户端和服务端一个方向上传输） Http协议冗长且繁琐 易收到攻击，如长轮询 非持久化协议 WebSocket的特性：
单一的 TCP 连接，采用全双工模式通信 对代理、防火墙和路由器透明 无头部信息和身份验证 无安全开销 通过 ping/pong 帧保持链路激活 持久化协议，连接建立后，服务器可以主动传递消息给客户端，不再需要客户端轮询 实现原理 在实现Websocket连线过程中，需要通过浏览器发出Websocket连线请求，然后服务器发出回应，这个过程通常称为握手 。在 WebSocket API，浏览器和服务器只需要做一个握手的动作，然后，浏览器和服务器之间就形成了一条快速通道。两者之间就直接可以数据互相传送。在此WebSocket 协议中，为我们实现即时服务带来了两大好处：
1、 Header互相沟通的Header是很小的-大概只有2Bytes；
1GET ws://localhost:5050/websocket HTTP/1.1 2Host: localhost:5050 3Connection: Upgrade 4Pragma: no-cache 5Cache-Control: no-cache 6Upgrade: websocket 7Origin: http://localhost:63342 8Sec-WebSocket-Version: 13 9User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/61.0.3163.79 Safari/537.36 10Accept-Encoding: gzip, deflate, br 11Accept-Language: zh-CN,zh;q=0.8 12Cookie: Idea-d796403=9d25c0a7-d062-4c0f-a2ff-e4da09ea564e 13Sec-WebSocket-Key: IzEaiuZLxeIhjjYDdTp+1g== 14Sec-WebSocket-Extensions: permessage-deflate; client_max_window_bits Sec-WebSocket-Key 是随机生成的，服务端会使用它加密后作为 Sec-WebSocket-Accept 的值返回；</description></item><item><title>六、Netty 教程 – 序列化-JDK自带</title><link>https://www.shellio.cc/docs/java/netty/6/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/netty/6/</guid><description>作者：唐亚峰 | 出自：唐亚峰博客
在做JAVA开发的时候，接触最多的就是java.io.Serializable，通过该接口生成序列化ID，然后就可以通过java.io.ObjectInput与java.io.ObjectOutput进行序列化与反序列化，无需考虑跨语言调用，对序列化性能要求不高的情况，使用默认的是最方便的，虽然存在弊端，但也能满足大部分的需要….
为了更好的掌握Netty序列化相关知识，本章使用Netty给我们提供的ObjectEncoder与ObjectDecoder对订单请求与应答消息进行序列化操作…
开发例程 在服务端ChannelPipeline新增解码器io.netty.handler.codec.serialization.ObjectDecoder 在服务端ChannelPipeline新增解码器io.netty.handler.codec.serialization.ObjectEncoder 实体类实现java.io.Serializable序列化接口 1、 创建OrderRequest与OrderResponse两个Java类；
1public class OrderRequest implements java.io.Serializable { 2 private static final long serialVersionUID = 1826067782744144943L; 3 private Integer orderId; 4 private String userName; 5 private String productName; 6 private String phoneNumber; 7 private String address; 8 //省略 get set .. 9} 1public class OrderResponse implements java.io.Serializable { 2 private static final long serialVersionUID = -5003946216600820264L; 3 private Integer orderId; 4 private String respCode; 5 private String desc; 6} OrderServer 1、 重写ChannelInitializer中的initChannel方法，添加ObjectDecoder解码器与ObjectEncoder编码器；</description></item><item><title>七、Netty 教程 – 序列化-Protobuf</title><link>https://www.shellio.cc/docs/java/netty/7/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/netty/7/</guid><description>作者：唐亚峰 | 出自：唐亚峰博客
上一章中，我们介绍了JAVA自带序列化，在java中我们如果需要序列化只需要继承Serializable接口就可以通过输入输出流进行序列化和反序列化，但在提供简单调用的同时也存在很多问题，本章将会逐渐的介绍….
为了更好的掌握Netty序列化相关知识，本章使用Netty给我们提供的ObjectEncoder与ObjectDecoder对订单请求与应答消息进行序列化操作…
Java序列化的弱点 不支持跨语言，当我们进行跨应用之间的服务调用的时候如果另外一个应用使用PHP语言来开发，这个时候我们发送过去的序列化对象，别人是无法进行反序列化的因为其内部实现对于别人来说完全就是黑盒。 序列化效率低下，字节流过大，这个我们可以做一个实验，还是上一节中的OrderRequest类，我们分别用java的序列化和使用二进制编码来做一个对比 序列化后字节码对比
1@Test 2public void test1() throws IOException { 3 Order order = new Order(1, &amp;#34;Levin&amp;#34;, &amp;#34;Netty Book&amp;#34;, &amp;#34;130****1912&amp;#34;, &amp;#34;China&amp;#34;); 4 ByteArrayOutputStream out = new ByteArrayOutputStream(); 5 ObjectOutputStream os = new ObjectOutputStream(out); 6 os.writeObject(order); 7 os.flush(); 8 System.out.println(&amp;#34;JDK序列化后的长度： &amp;#34; + out.toByteArray().length); 9 os.close(); 10 out.close(); 11 ByteBuffer buffer = ByteBuffer.allocate(1024); 12 buffer.put(order.getAddress().getBytes()); 13 buffer.put(order.getPhoneNumber().getBytes()); 14 buffer.put(order.getUserName().getBytes()); 15 buffer.put(order.getProductName().getBytes()); 16 buffer.flip(); 17 byte[] result = new byte[buffer.</description></item><item><title>三、Netty 教程 – 初窥Netty编程</title><link>https://www.shellio.cc/docs/java/netty/3/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/netty/3/</guid><description>作者：唐亚峰 | 出自：唐亚峰博客
在上一篇文章中介绍了NIO类库简介，从本章开始都围绕Netty展开讨论和概述……
什么是Netty Netty是业界有名且最流行的NIO框架之一，健壮，稳定，高性能，可定制，可扩展在同类框架都是首屈一指，而且成功的运用在各大商业项目中，比如Hadoop的RPC框架avro，当当接盘的DubboX都在使用…
Netty 的优点
API使用简单，开发门槛低 功能强大，多种解码与编码器 支持多种主流的通讯协议 定制能力强大，可以通过ChannelHandler对通讯框架灵活的扩展 相比业界主流NIO框架，Netty综合评价更高 成熟稳定，社区活跃 Netty 缺点
5.x 模型存在问题，已被废弃 编译 GIT：https://github.com/netty/netty
如果需要编译Netty，需要最低JDK1.7，在运行时Netty3.x只需要JDK1.5，同时博客参考 李林峰 大神的 《Netty权威指南第二版》…
因为主要是学习Netty，而不是实战，同时为了更好的适配即将推出的Netty6，用Netty5的API也许会更好点，就当为Netty6做技术储备吧…
如果使用Maven，在项目中需要添加
1&amp;lt;dependencies&amp;gt; 2 &amp;lt;dependency&amp;gt; 3 &amp;lt;groupId&amp;gt;io.netty&amp;lt;/groupId&amp;gt; 4 &amp;lt;artifactId&amp;gt;netty-all&amp;lt;/artifactId&amp;gt; 5 &amp;lt;version&amp;gt;5.0.0.Alpha2&amp;lt;/version&amp;gt; 6 &amp;lt;/dependency&amp;gt; 7&amp;lt;/dependencies&amp;gt; Hello Netty 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 继续用TimeServer 与 TimeClient 为例，改造代码使用Netty实现服务端与客户端的通讯，以及上一章博客遗留的数据丢失问题，在使用Netty后都是不在的…
TimeServer 1public static void bind(int port) { 2 EventLoopGroup masterGroup = new NioEventLoopGroup();//创建线程组 3 EventLoopGroup workerGroup = new NioEventLoopGroup(); 4 try { 5 ServerBootstrap bootstrap = new ServerBootstrap();//创建NIO服务端启动辅助类 6 bootstrap.</description></item><item><title>十、Netty 教程 – ByteBuf详解</title><link>https://www.shellio.cc/docs/java/netty/10/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/netty/10/</guid><description>作者：唐亚峰 | 出自：唐亚峰博客
原生的ByteBuffer存在哪些问题呢，Netty为什么会设计ByteBuf呢，它的工作原理是什么…..
ByteBuffer存在的问题 ByteBuffer是JDK1.4中提供的java.nio.Buffer, 在内存中预留指定大小的存储空间来存放临时数据，其他Buffer的子类有：CharBuffer、DoubleBuffer、FloatBuffer、IntBuffer、LongBuffer 和 ShortBuffer
ByteBuffer的长度是固定的，一旦分配完成，容量就无法动态扩容收缩，分多了会浪费内存，分少了存放大的数据时会索引越界（当传输数据大于初始化长度时，会出现BufferOverflowException索引越界的异常），所以使用ByteBuffer时，为了解决这个问题，我们一般每次put操作时，都会对可用空间进行校检，如果剩余空间不足，需要重新创建一个新的ByteBuffer，然后将旧的ByteBuffer复制到新的ByteBuffer中去 ByteBuffer中只有通过position获得当前可操作的位置，调用get()方法，返回ByteBuffer[postion]处的值，如果是调用put方法,将数据放入ByteBuffer[postion]的位置 API功能有限，部分高级功能并不支持，需开发者自己实现，且使用原生ByteBuffer较为困难（不适合小白专业户） ByteBuf与ByteBuffer的区别 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 不同ByteBuf实现原理各不相同，我们先看最基本的ByteBuf与原生的ByteBuffer的区别
1ByteBuf buf = Unpooled.buffer(10); 2buf.writeBytes(&amp;#34;鏖战八方QQ群391619659&amp;#34;.getBytes());//扩容算法稍后讲解 3System.out.println(&amp;#34;Netty：&amp;#34; + buf); 4byte[] by = new byte[buf.readableBytes()]; 5buf.readBytes(by); 6System.out.println(&amp;#34;Netty：&amp;#34; + new String(by)); 7System.out.println(&amp;#34;//////////////////////////////////////////无耻的分割线//////////////////////////////////////////&amp;#34;); 8ByteBuffer bf1 = ByteBuffer.allocate(100); 9bf1.put(&amp;#34;鏖战八方QQ群391619659&amp;#34;.getBytes()); 10System.out.println(&amp;#34;JDK：&amp;#34;+bf1); 11System.out.println(&amp;#34;当前指针：&amp;#34; + bf1.position()); 12byte[] by1 = new byte[bf1.remaining()]; 13System.out.println(by1.length);//What&amp;#39;s 居然是74 14bf1.get(by1); 15System.out.println(&amp;#34;未使用flip：&amp;#34;+new String(by1));//居然是空的 16System.out.println(&amp;#34;//////////////////////////////////////////无耻的分割线//////////////////////////////////////////&amp;#34;); 17ByteBuffer bf2 = ByteBuffer.allocate(100); 18bf2.put(&amp;#34;鏖战八方QQ群391619659&amp;#34;.getBytes()); 19System.out.println(&amp;#34;JDK：&amp;#34;+bf2); 20System.out.println(&amp;#34;当前指针：&amp;#34; + bf2.position()); 21bf2.flip(); 22byte[] by2 = new byte[bf2.remaining()]; 23System.</description></item><item><title>四、Netty 教程 – Netty粘包/拆包解决之道</title><link>https://www.shellio.cc/docs/java/netty/4/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/netty/4/</guid><description>作者：唐亚峰 | 出自：唐亚峰博客
TCP是个流协议，是一串没有界限的数据，TCP底层并不了解上层业务数据的含义，它会根据TCP缓冲区实际情况进行包的划分，在上一篇文章中介绍了什么是Netty，本章介绍Netty粘包和拆包…
粘包和拆包 学过TCP的都知道，它是属于传输层的协议，传输层除了有TCP协议外还有UDP协议，但是UDP是不存在拆包和粘包的。UDP是基于报文发送的，从UDP的帧结构可以看出，在UDP首部采用了16bit来指示UDP数据报文的长度，因此在应用层能很好的将不同的数据报文区分开，从而避免粘包和拆包的问题。
而TCP是基于字节流的，虽然应用层和TCP传输层之间的数据交互是大小不等的数据块，但是TCP把这些数据块仅仅看成一连串无结构的字节流，没有边界；另外从TCP的帧结构也可以看出，在TCP的首部没有表示数据长度的字段，基于上面两点，在使用TCP传输数据时，才有粘包或者拆包现象发生的可能。
服务端分两次读取到了两个独立的数据包，分别是D1和D2没有粘包和拆包 服务端一次接受到两个粘在一起的数据包，D2和D1，被称为TCP粘包服务端分两次读取到了两个数据包，第一次读取到完整的D1，D2部分内容，第二次读取了D2的剩余内容，这被称之为TCP拆包操作 服务端分两次读取到了两个数据包，第一次读取到了D1_1，第二次读取到了D1包的剩余内容和完整的D2数据包 如果此时服务端TCP接收滑窗非常小，而数据包内容相对较大的情况，很可能发生服务端多次拆包才能将D1和D2数据接收完整 产生原因 要发送的数据大于TCP发送缓冲区剩余空间大小，将会发生拆包。 待发送数据大于MSS（最大报文长度），TCP在传输前将进行拆包。 要发送的数据小于TCP发送缓冲区的大小，TCP将多次写入缓冲区的数据一次发送出去，将会发生粘包。 接收数据端的应用层没有及时读取接收缓冲区中的数据，将发生粘包。 解决方法 通过以上分析，我们清楚了粘包或拆包发生的原因，那么如何解决这个问题呢？解决问题的关键在于如何给每个数据包添加边界信息，常用的方法有如下几个：
发送端给每个数据包添加包首部（类似UDP），首部中应该至少包含数据包的长度，这样接收端在接收到数据后，通过读取包首部的长度字段，便知道每一个数据包的实际长度了 发送端将每个数据包封装为固定长度（不够的可以通过补0填充），这样接收端每次从接收缓冲区中读取固定长度的数据就自然而然的把每个数据包拆分开来。 可以在数据包之间设置边界，如添加特殊符号（如\r\n），这样，接收端通过这个边界就可以将不同的数据包拆分开。 Netty 解决方案 io.netty.handler.codec.callDecode(ChannelHandlerContext ctx, ByteBuf in, List&amp;lt;Object&amp;gt; out)
1protected void callDecode(ChannelHandlerContext ctx, ByteBuf in, List&amp;lt;Object&amp;gt; out) { 2 try { 3 while (in.isReadable()) { 4 int outSize = out.size(); 5 int oldInputLength = in.readableBytes(); 6 decode(ctx, in, out); 7 // Check if this handler was removed before continuing the loop.</description></item><item><title>五、Netty 教程 – 解码器详解</title><link>https://www.shellio.cc/docs/java/netty/5/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/netty/5/</guid><description>作者：唐亚峰 | 出自：唐亚峰博客
TCP以流的形式传输，在上一章，我们讲了粘包和拆包，以及LineBaseFrameDecoder使用和源码探讨，接下来讲讲Netty为我们实现的其它解码器…..
TCP以流的方式进行数据传输，上层的应用为了对消息进行区分，往往采用如下方式
固定消息长度，累计读取到长度和定长LEN的报文后，就认为读取到了个完整的消息，然后将计数器位置重置在读取下一个报文内容 将回车换行符作为消息结束符\r\n，列如FTP协议，这种方式在文本中应用比较广泛 将特殊分隔符作为消息结束符标志位，回车换行符就是一个特殊结束分隔符(DelimiterBasedFrameDecoder) 通过在消息头定义一个长度字段来标示消息的总长度(FixedLengthFrameDecoder) Netty对以上4种做个统一抽象封装，提供了四种不同解码器来解决对应问题，使用起来也非常的方便，了解了它们，我们就不需要自己对读取的报文人工解码，也不需要考虑TCP粘包和拆包的问题了…
Delimiter自定义分隔符 我将公共的部分做了一层抽离,定义成常量方便调用
1public interface EchoConstant { 2 String SEPARATOR = &amp;#34;$_&amp;#34;;//特殊分割符号,DelimiterBasedFrameDecoder使用 3 Integer ECHO_DELIMITER_PORT = 4040; 4 Integer ECHO_LENGTH_PORT = 5050; 5 String HOST = &amp;#34;127.0.0.1&amp;#34;; 6 Integer FRAME_LENGTH = 10;//固定消息长度,FixedLengthFrameDecoder使用 7} 定义EchoDelimiterServer，毫无疑问大部分代码和以前类似，区别是多了一个日志输出以及DelimiterBasedFrameDecoder的使用
划重点：在做开发调试的时候，我们可以使用Netty为我们提供的LoggingHandler输出日志
1public static void bind(int port) { 2 EventLoopGroup masterGroup = new NioEventLoopGroup();//线程组,含一组NIO线程,专门用来处理网络事件 3 EventLoopGroup workerGroup = new NioEventLoopGroup(); 4 try { 5 ServerBootstrap bootstrap = new ServerBootstrap();//NIO服务端启动辅助类 6 bootstrap.</description></item><item><title>一、Netty 教程 – 传统I/O编程（BIO）</title><link>https://www.shellio.cc/docs/java/netty/1/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/netty/1/</guid><description>作者：唐亚峰 | 出自：唐亚峰博客
有一段时间没写博客了，Spring Cloud 基本的都已经写完（后续会写一个SpringBootAdmin的整合），接下来会记录Netty相关的，早期的JAVA对NIO支持是非常糟糕的，直到2002年发布的JDK1.4中才第一次支持非阻塞I/O，这个类库为JDK通讯模型带来了翻天覆地的变化，在开始学习Netty之前先看看早期的写法是什么样的……
- 网络编程 网络编程的基本模型就是Client/Server模型，两个进程相互通讯，其中服务端提供位置信息（ip:port），客户端通过连接操作向服务端监听的地址发起连接请求，通过三次握手建立连接，如果成功则可以通过网络套字（Socket）进行通信…
- 同步阻塞I/O 采用BIO通信模型的服务端，通常由一个独立的Acceptor线程负责监听客户端链接，由它来接收到每个请求然后为每个客户端创建一个新的线程进行链路处理，处理完毕后通过输出流应答给客户端，然后线程销毁…
该模型最大的问题就是缺乏弹性伸缩能力，因为它是1 : 1 模型的，当客户端越多服务端线程开销越大，线程数膨胀后，系统性能就急剧下降了，然后堆栈，GC，等等问题就来找你唠嗑了…
- TimeServer 1import java.io.BufferedReader; 2import java.io.IOException; 3import java.io.InputStreamReader; 4import java.io.PrintWriter; 5import java.net.ServerSocket; 6import java.net.Socket; 7/** 8 * 初窥NIO-TimeServer：同步阻塞方式的I/O创建 9 * @author Levin 10 */ 11public class TimeServer { 12 public static void main(String[] args) { 13 int port = 4040; 14 System.out.println(&amp;#34;start server......&amp;#34; + port); 15 ServerSocket serverSocket = null; 16 try { 17 serverSocket = new ServerSocket(port); 18 while (true) { 19 new TimeServerHandler(serverSocket.</description></item></channel></rss>