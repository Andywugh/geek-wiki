<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Tomcat源码分析 on 程序员安仔</title><link>https://www.shellio.cc/docs/java/tomcat/</link><description>Recent content in Tomcat源码分析 on 程序员安仔</description><generator>Hugo -- gohugo.io</generator><language>zh-hans</language><copyright>粤ICP备2023148789号</copyright><atom:link href="https://www.shellio.cc/docs/java/tomcat/index.xml" rel="self" type="application/rss+xml"/><item><title>八、Tomcat源码分析-Session源码解析</title><link>https://www.shellio.cc/docs/java/tomcat/8/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/tomcat/8/</guid><description>在web 开发中，我们经常会用到 Session 来保存会话信息，包括用户信息、权限信息，等等。在这篇文章中，我们将分析 tomcat 容器是如何创建 session、销毁 session，又是如何对 HttpSessionListener 进行事件通知
tomcat session 设计分析 tomcat session 组件图如下所示，其中 Context 对应一个 webapp 应用，每个 webapp 有多个 HttpSessionListener， 并且每个应用的 session 是独立管理的，而 session 的创建、销毁由 Manager 组件完成，它内部维护了 N 个 Session 实例对象。在前面的文章中，我们分析了 Context 组件，它的默认实现是 StandardContext，它与 Manager 是一对一的关系，Manager 创建、销毁会话时，需要借助 StandardContext 获取 HttpSessionListener 列表并进行事件通知，而 StandardContext 的后台线程会对 Manager 进行过期 Session 的清理工作
org.apache.catalina.Manager 接口的主要方法如下所示，它提供了 Context、org.apache.catalina.SessionIdGenerator 的 getter/setter 接口，以及创建、添加、移除、查找、遍历 Session 的 API 接口，此外还提供了 Session 持久化的接口（load/unload） 用于加载/卸载会话信息，当然持久化要看不同的实现类
1public interface Manager { 2 public Context getContext(); 3 public void setContext(Context context); 4 public SessionIdGenerator getSessionIdGenerator(); 5 public void setSessionIdGenerator(SessionIdGenerator sessionIdGenerator); 6 public void add(Session session); 7 public void addPropertyChangeListener(PropertyChangeListener listener); 8 public void changeSessionId(Session session); 9 public void changeSessionId(Session session, String newId); 10 public Session createEmptySession(); 11 public Session createSession(String sessionId); 12 public Session findSession(String id) throws IOException; 13 public Session[] findSessions(); 14 public void remove(Session session); 15 public void remove(Session session, boolean update); 16 public void removePropertyChangeListener(PropertyChangeListener listener); 17 public void unload() throws IOException; 18 public void backgroundProcess(); 19 public boolean willAttributeDistribute(String name, Object value); tomcat8.</description></item><item><title>二、Tomcat源码分析-tomcat框架设计</title><link>https://www.shellio.cc/docs/java/tomcat/2/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/tomcat/2/</guid><description>总体架构 tomcat的总体架构如下图所示（摘自http://blog.csdn.net/jiaomingliang/article/details/47393141）
如上图所示，tomcat由Server、Service、Engine、Connerctor、Host、Context组件组成，其中带有s的代表在一个tomcat实例上可以存在多个组件，比如Context(s)，tomcat允许我们部署多个应用，每个应用对应一个Context。这些组件在tomcat的conf/server.xml文件中可以找到，对tomcat的调优需要改动该文件
1server.xml 2&amp;lt;Service name=&amp;#34;Catalina&amp;#34;&amp;gt; 3 &amp;lt;Connector port=&amp;#34;8080&amp;#34; protocol=&amp;#34;HTTP/1.1&amp;#34; 4 connectionTimeout=&amp;#34;20000&amp;#34; 5 redirectPort=&amp;#34;8443&amp;#34; /&amp;gt; 6 &amp;lt;Connector port=&amp;#34;8080&amp;#34; protocol=&amp;#34;HTTP/1.1&amp;#34; 7 connectionTimeout=&amp;#34;20000&amp;#34; 8 redirectPort=&amp;#34;8443&amp;#34; /&amp;gt; 9 &amp;lt;Connector port=&amp;#34;8009&amp;#34; protocol=&amp;#34;AJP/1.3&amp;#34; redirectPort=&amp;#34;8443&amp;#34; /&amp;gt; 10 &amp;lt;Engine name=&amp;#34;Catalina&amp;#34; defaultHost=&amp;#34;localhost&amp;#34;&amp;gt; 11 &amp;lt;Realm className=&amp;#34;org.apache.catalina.realm.LockOutRealm&amp;#34;&amp;gt; 12 &amp;lt;Realm className=&amp;#34;org.apache.catalina.realm.UserDatabaseRealm&amp;#34; 13 resourceName=&amp;#34;UserDatabase&amp;#34;/&amp;gt; 14 &amp;lt;/Realm&amp;gt; 15 &amp;lt;Host name=&amp;#34;localhost&amp;#34; appBase=&amp;#34;webapps&amp;#34; 16 unpackWARs=&amp;#34;true&amp;#34; autoDeploy=&amp;#34;true&amp;#34;&amp;gt; 17 &amp;lt;Valve className=&amp;#34;org.apache.catalina.valves.AccessLogValve&amp;#34; directory=&amp;#34;logs&amp;#34; 18 prefix=&amp;#34;localhost_access_log&amp;#34; suffix=&amp;#34;.txt&amp;#34; 19 pattern=&amp;#34;%h %l %u %t &amp;#34;%r&amp;#34; %s %b&amp;#34; /&amp;gt; 20 &amp;lt;/Host&amp;gt; 21 &amp;lt;/Engine&amp;gt; Server Server组件对应org.</description></item><item><title>九、Tomcat源码分析-类加载器</title><link>https://www.shellio.cc/docs/java/tomcat/9/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/tomcat/9/</guid><description>类加载器 在分析tomcat 类加载之前，我们简单的回顾下 java 体系的类加载器
启动类加载器（Bootstrap ClassLoader)：加载对象是java的核心类库，把一些的 java 类加载到 jvm 中，它并不是我们熟悉的 ClassLoader，而是 jvm 层面由 C/C++ 实现的类加载器，负责加载 $JAVA_HOME/jre/lib 目录下 jvm 指定的类库，它是无法被 java 应用程序直接使用的 扩展类加载器（Extension Classloader）：它是一个 ClassLoader 实例，父加载器是启动类加载器，它负责加载 $JAVA_HOME/jre/lib/ext 目录的类库 应用类加载器（Application ClassLoader）：又叫做系统类加载器(System ClassLoader)，负责加载用户类路径（-cp参数）指定的类库，可以通过 ClassLoader.getSystemClassLoader() 获取，它也是由启动类加载器加载的 自定义类加载器：应用程序根据自己的需求开发的类加载器，可以继承 ClassLoader，当然也可以不继承 下图描述了类加载器的关系图，其中自定义类加载器有N多个
我们知道 java.lang.ClassLoader 有双亲委派机制（准确的说是单亲，因为只有一个parent），这只是 java 建议的规范，我们也可以不遵循这条规则，但是建议遵循该规则。此外，有一点需要注意的是，类加载器不局限于 ClassLoader，我们也可以自己实现一个类加载器，只要你加载出来的 Class 符合 jvm 规范即可
我们在日常开发工作中，经常会遇到类冲突的情况，明明 classpath 下面的类有这个方法，但是一旦跑线上环境就出错，比如NoSuchMethodError、NoClassDefFoundError、NoClassDefFoundError 等。我们可以使用 jvm 参数 -verbose:class 方便地定位该问题，使用该参数可以快速地定位某个类是从哪个jar包加载的，而不是一味地埋头苦干，求百度，找Google。下面是使用 -verbose:class jvm 参数的部分日志输出
1[Loaded org.springframework.context.annotation.CommonAnnotationBeanPostProcessor from file:/D:/tomcat/webapps/touch/WEB-INF/lib/spring-context-4.3.7.RELEASE.jar] 2[Loaded com.alibaba.dubbo.rpc.InvokerListener from file:/D:/tomcat/webapps/touch/WEB-INF/lib/dubbo-2.5.3.jar] 我们有必要了解下关于类加载有几个重要的知识点：
在 Java 中我们用完全类名来标识一个类，而在 JVM 层面，使用完全类名 + CloassLoader 对象实例 ID 作为唯一标识，因此使用不同实例的类加载器，加载的两个同名的类，他们的类实例是不同的，并且不能强制转换 在双亲委派机制中，类加载器查找类时，是一层层往父类加载器查找的，最后才查看自己，如果都找不到则会抛出异常，而不是一层层往下找的 每个运行中的线程都有一个 CloassLoader，并且会从父线程中继承（默认是应用类加载器），在没有显式声明由哪个类加载器加载类时（比如 new 关键字），将默认由当前线程的类加载器加载该类 由于篇幅有限，关于类加载的过程这里不再展开了，可以参考厮大的博客</description></item><item><title>六、Tomcat源码分析-启动分析(四) webapp</title><link>https://www.shellio.cc/docs/java/tomcat/6/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/tomcat/6/</guid><description>前言 上一篇文章中我们分析了 Service、Engine、Host、Pipeline、Valve 组件的启动逻辑，在 HostConfig 中会实例化 StandardContext，并启动 Context 容器，完成 webapp 应用程序的启动，这一块是最贴近我们开发的应用程序。在这一篇文章中，我们将要分析 tomcat 是如何解析并初始化应用程序定义的 Servlet、Filter、Listener 等
首先我们思考几个问题：
1、 tomcat如何支持servlet3.0的注解编程，比如对javax.servlet.annotation.WebListener注解的支持？；
如果 tomcat 利用 ClassLoader 加载 webapp 下面所有的 class，从而分析 Class 对象的注解，这样子肯定会导致很多问题，比如 MetaSpace 出现内存溢出，而且加载了很多不想干的类，我们知道 jvm 卸载 class 的条件非常苛刻，这显然是不可取的。因此，tomcat 开发了字节码解析的工具类，位于 org.apache.tomcat.util.bcel，bcel 即 ：Byte Code Engineering Library，专门用于解析 class 字节码，而不是像我们前面猜测的那样，把类加载到 jvm 中
1、 假如webapp目录有多个应用，使用的开源框架的jar版本不尽一致，tomcat是怎样避免出现类冲突？；
不同的 webapp 使用不同的 ClassLoader 实例加载 class，因此 webapp 内部加载的 class 是不同的，自然不会出现类冲突，当然这里要排除 ClassLoader 的 parent 能够加载的 class。关于 ClassLoader 这一块，后续会专门写一篇博客进行分析
1、Context 容器 首先，我们来看下StandardContext重要的几个属性，包括了我们熟悉的 ServletContext、servlet容器相关的Listener(比如 SessionListener 和 ContextListener)、FilterConfig</description></item><item><title>七、Tomcat源码分析-spring boot集成tomcat</title><link>https://www.shellio.cc/docs/java/tomcat/7/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/tomcat/7/</guid><description>前言 本文基于 spring boot 1.5.9
spring boot 支持目前主流的 servlet 容器，包括 tomcat、jetty、undertow，可以在我们的项目中方便地集成这些 servlet 容器，减少了开发、运维的工作量。而传统的应用开发，需要经过繁锁的操作步骤：安装 tomcat –&amp;gt; 修改 tomcat 配置 –&amp;gt; 部署 war 包 –&amp;gt; 启动 tomcat –&amp;gt; 运维……，这个工作量不小，尤其是集群部署、应用迁移的时候。而采用 spring boot 之后，一切变得如此简单，打包 –&amp;gt; java -jar –&amp;gt; 运维，只需要一个 jar 包便可以随意部署安装。这篇文章，将对 spring boot 集成 tomcat 的源码进行分析，探索其内部的原理
SPI 在分析源码前，我们先来了解下 spring 的 SPI 机制。我们知道，jdk 为了方便应用程序进行扩展，提供了默认的 SPI 实现（ServiceLoader），dubbo 也有自己的 SPI。spring 也是如此，他为我们提供了 SpringFactoriesLoader，允许开发人员通过 META-INF/spring.factories 文件进行扩展，下面举一个例子方便理解
假如，我想要往 spring 容器中添加一个 ApplicationContextInitializer 做一些初始化工作，我们可以借助 spring 提供的这个 SPI 功能完成这个需求。
首先，在项目中创建 META-INF/spring.factories 文件，文件内容如下所示：
1org.springframework.context.ApplicationContextInitializer=\ 我们再写个 test case，便可以通过 SPI 的方式获取我们定义的 ApplicationContextInitializer。看似很简单的一个功能，但是 spring boot 正是利用这个强大的扩展点，在 spring framework 的基础上为我们集成了常用的开源框架</description></item><item><title>三、Tomcat源码分析-启动分析(一) Lifecycle</title><link>https://www.shellio.cc/docs/java/tomcat/3/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/tomcat/3/</guid><description>Lifecycle在其他框架中也很常见，比如spring，它常用于具有生命周期的组件，由Lifecycle控制组件的初始化、启动、销毁等动作，方便应用程序获取、释放某些资源，或者是触发某些特定的事件。Tomcat也是如此，在学习整个启动流程之前，我们先行了解下Lifecycle的实现机制，便于理解整个流程。
Lifecycle Lifecycle接口是一个公用的接口，定义了组件生命周期的一些方法，用于启动、停止Catalina组件。它是一个非常重要的接口，组件的生命周期包括：init、start、stop、destory，以及各种事件的常量、操作LifecycleListener的API，典型的观察者模式
1public interface Lifecycle { 2 // ----------------------- 定义各种EVENT事件 ----------------------- 3 public static final String BEFORE_INIT_EVENT = &amp;#34;before_init&amp;#34;; 4 public static final String AFTER_INIT_EVENT = &amp;#34;after_init&amp;#34;; 5 public static final String START_EVENT = &amp;#34;start&amp;#34;; 6 // 省略事件常量定义…… 7 /** 8 * 注册一个LifecycleListener 9 */ 10 public void addLifecycleListener(LifecycleListener listener); 11 /** 12 * 获取所有注册的LifecycleListener 13 */ 14 public LifecycleListener[] findLifecycleListeners(); 15 /** 16 * 移除指定的LifecycleListener 17 */ 18 public void removeLifecycleListener(LifecycleListener listener); 19 /** 20 * 组件被实例化之后，调用该方法完成初始化工作，发会出以下事件 21 * &amp;lt;ol&amp;gt; 22 * &amp;lt;li&amp;gt;INIT_EVENT: On the successful completion of component initialization.</description></item><item><title>十、Tomcat源码分析-关于tomcat热加载的一些思考</title><link>https://www.shellio.cc/docs/java/tomcat/10/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/tomcat/10/</guid><description>在前面的文章中，我们分析了 tomcat 类加载器的相关源码，也了解了 tomcat 支持类的热加载，意味着 tomcat 要涉及类的重复卸装/装载过程，这个过程是很敏感的，一旦处理不当，可能会引起内存泄露
卸载类 我们知道，class 信息存放在元数据区（1.7是 Perm 区），这一块的内存相比堆而言，只占据非常小的空间，但是如果处理不当，还是有可能会导致内存溢出。这让我回想起几年前的一个故障，线上环境启用了 tomcat 的自动 reload 功能，出现过 java.lang.OutOfMemoryError: PermGen space 问题，排查的结果是因为 tomcat 在自动重载应用的时候，没有正常卸载类，导致 Perm 区内存没能被释放而发生溢出。tomcat 会尽量避免这类问题的发生，但是不能百分之百保证不会出现，所以还是建议不要随意开启 reloadable 功能
卸载类的条件很苛刻，必须同时满足以下3点：
1、 该类所有的实例已经被回收；
2、 加载该类的ClassLoder已经被回收；
3、 该类对应的java.lang.Class对象没有任何地方被引用；
针对第1点，保证所有的实例被回收，这点不难，tomcat 在 Context 组件中实例化这些对象，持有直接或间接的引用，所以在热部署的时候，只要回收 Context 组件即可保证实例对象被回收。
在前面的文章中我们分析了 tomcat 类加载器，tomcat 使用 ParallelWebappClassLoader 加载 Class，在热部署的时候自然也会回收该类加载器。但是要注意的是，ParallelWebappClassLoader 会作为线程上下文的类加载器，因此要避免该类加载器对象在其他地方被引用。其实，这个问题是最隐晦的，jdk 中有些类会持有线程上下文的类加载器，作为一个优秀的开源产品，tomcat 为我们解决了很多诸如此类的问题
此外，还要保证类对应的 java.lang.Class 对象没有任何地方引用，只要 Class 对象作用域限制在 Context 组件的作用范围便不会发生泄露，tomcat 也是这么做了，使用 Context 实现了隔离机制
热加载问题 热加载会面临很多问题，有很多坑，需要非常丰富的经验。下面针对 tomcat 中涉及的类加载器泄露、对象泄露、文件锁等这几类常见的问题加以分析讨论。如果您对热加载感兴趣的话，可以研究下阿里开源的 jarlinks
文件锁 在Windows 系统下使用 URLConnection 读取本地 jar 包的资源时，它会将资源缓存起来，会导致该 jar 包资源被锁。如果这个时候使用 war 包进行重新部署，需要解压 war 包再把原来目录下面的 jar 包删除，由于 jar 包资源被锁，导致删除失败，重新部署自然也会失败。我们先来看一段代码，这段代码会抛出异常，java.</description></item><item><title>四、Tomcat源码分析-启动分析(二) Catalina初始化</title><link>https://www.shellio.cc/docs/java/tomcat/4/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/tomcat/4/</guid><description>Bootstrap Tomcat运行是通过Bootstrap的main方法，在开发工具中，我们只需要运行Bootstrap的main方法，便可以启动tomcat进行代码调试和分析。Bootstrap是tomcat的入口，它会完成初始化ClassLoader，实例化Catalina以及load、start动作。在这一篇文章中，我们将会对tomcat初始化过程进行分析。
main方法 首先实例化Bootstrap，并调用init方法对其初始化
1Bootstrap bootstrap = new Bootstrap(); init 首先初始化commonLoader、catalinaLoader、sharedLoader，默认情况下这三个是相同的实例，用于加载不同的资源。然后，使用反射实例化Catalina，设置其parentClassLoader为sharedLoader
1public void init() throws Exception { 2 // 初始化commonLoader、catalinaLoader、sharedLoader，关于ClassLoader的后面再单独分析 3 initClassLoaders(); 4 Thread.currentThread().setContextClassLoader(catalinaLoader); 5 SecurityClassLoad.securityClassLoad(catalinaLoader); 6 // 反射方法实例化Catalina，后面初始化Catalina也用了很多反射，不知道意图是什么 7 Class&amp;lt;?&amp;gt; startupClass = catalinaLoader.loadClass(&amp;#34;org.apache.catalina.startup.Catalina&amp;#34;); 8 Object startupInstance = startupClass.getConstructor().newInstance(); 9 // 反射调用setParentClassLoader方法，设置其parentClassLoader为sharedLoader 10 String methodName = &amp;#34;setParentClassLoader&amp;#34;; 11 Class&amp;lt;?&amp;gt; paramTypes[] = new Class[1]; 12 paramTypes[0] = Class.forName(&amp;#34;java.lang.ClassLoader&amp;#34;); 13 Object paramValues[] = new Object[1]; 14 paramValues[0] = sharedLoader; 15 Method method = 16 startupInstance.</description></item><item><title>五、Tomcat源码分析-启动分析(三) Catalina启动</title><link>https://www.shellio.cc/docs/java/tomcat/5/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/tomcat/5/</guid><description>在上一篇文章中，我们分析了tomcat的初始化过程，是由Bootstrap反射调用Catalina的load方法完成tomcat的初始化，包括server.xml的解析、实例化各大组件、初始化组件等逻辑。那么tomcat又是如何启动webapp应用，又是如何加载应用程序的ServletContextListener，以及Servlet呢？我们将在这篇文章进行分析
我们先来看下整体的启动逻辑，tomcat由上往下，挨个启动各个组件：
针对如此复杂的组件关系，tomcat 又是如何将各个组件串联起来，实现统一的生命周期管控呢？在这篇文章中，我们将分析 Service、Engine、Host、Pipeline、Valve 组件的启动逻辑，进一步理解tomcat的架构设计
1、Bootstrap 启动过程和初始化一样，由Bootstrap反射调用Catalina的start方法
1public void start() throws Exception { 2 if( catalinaDaemon==null ) init(); 3 Method method = catalinaDaemon.getClass().getMethod(&amp;#34;start&amp;#34;, (Class [] )null); 4 method.invoke(catalinaDaemon, (Object [])null); 2、Catalina 主要分为以下三个步骤，其核心逻辑在于Server组件：
1、 调用Server的start方法，启动Server组件；
2、 注册jvm关闭的勾子程序，用于安全地关闭Server组件，以及其它组件；
3、 开启shutdown端口的监听并阻塞，用于监听关闭指令；
1public void start() { 2 // 省略若干代码...... 3 // Start the new server 4 try { 5 getServer().start(); 6 } catch (LifecycleException e) { 7 // 省略...... 8 return; 9 } 10 // 注册勾子，用于安全关闭tomcat 11 if (useShutdownHook) { 12 if (shutdownHook == null) { 13 shutdownHook = new CatalinaShutdownHook(); 14 } 15 Runtime.</description></item><item><title>一、Tomcat源码分析-环境搭建</title><link>https://www.shellio.cc/docs/java/tomcat/1/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/tomcat/1/</guid><description>前言 为什么要学习tomcat源码？ tomcat是目前非常流行的web容器，其性能和稳定性也是非常出色的，学习其框架设计和底层的实现，不管是使用、性能调优，还是应用框架设计方面，肯定会有很大的帮助
tomcat版本 该系列博客的tomcat版本是8.5.24
下载源码 从apache官网下载tomcat源码包，本人以8.5.24版本为例，http://tomcat.apache.org/download-80.cgi
maven 本人习惯使用maven，因此将源码转成maven工程。新建pom.xml，加入相关依赖，如附录所示
导入开发工具 导入maven项目，因为有些测试类依赖了examples目录的类，因此把apache-tomcat-8.5.24-src\webapps\examples\WEB-INF\classes目录在开发工具上面设置为java源文件，编译的class输出目录设为classes，如下图所示
上传源码 在看源码过程中经常需要对源码进行注释，建议大家把源码上传至自己的git，方便后续查漏补缺。tips:在.gitignore文件需要忽略target目录(class文件输出目录)
附上本人的码云地址，git@gitee.com:bestkobe/tomcat.git
附录 pom.xml
1&amp;lt;?xml version=&amp;#34;1.0&amp;#34; encoding=&amp;#34;UTF-8&amp;#34;?&amp;gt; 2&amp;lt;project xmlns=&amp;#34;http://maven.apache.org/POM/4.0.0&amp;#34; xmlns:xsi=&amp;#34;http://www.w3.org/2001/XMLSchema-instance&amp;#34; 3 xsi:schemaLocation=&amp;#34;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&amp;#34;&amp;gt; 4 &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt; 5 &amp;lt;groupId&amp;gt;org.apache&amp;lt;/groupId&amp;gt; 6 &amp;lt;artifactId&amp;gt;tomcat&amp;lt;/artifactId&amp;gt; 7 &amp;lt;name&amp;gt;apache-tomcat-8.5.24&amp;lt;/name&amp;gt; 8 &amp;lt;version&amp;gt;8.5.24&amp;lt;/version&amp;gt; 9 &amp;lt;build&amp;gt; 10 &amp;lt;finalName&amp;gt;Tomcat-8.5.24&amp;lt;/finalName&amp;gt; 11 &amp;lt;sourceDirectory&amp;gt;java&amp;lt;/sourceDirectory&amp;gt; 12 &amp;lt;testSourceDirectory&amp;gt;test&amp;lt;/testSourceDirectory&amp;gt; 13 &amp;lt;resources&amp;gt; 14 &amp;lt;resource&amp;gt; 15 &amp;lt;directory&amp;gt;java&amp;lt;/directory&amp;gt; 16 &amp;lt;/resource&amp;gt; 17 &amp;lt;/resources&amp;gt; 18 &amp;lt;testResources&amp;gt; 19 &amp;lt;testResource&amp;gt; 20 &amp;lt;directory&amp;gt;test&amp;lt;/directory&amp;gt; 21 &amp;lt;/testResource&amp;gt; 22 &amp;lt;/testResources&amp;gt; 23 &amp;lt;plugins&amp;gt; 24 &amp;lt;plugin&amp;gt; 25 &amp;lt;groupId&amp;gt;org.apache.maven.plugins&amp;lt;/groupId&amp;gt; 26 &amp;lt;artifactId&amp;gt;maven-compiler-plugin&amp;lt;/artifactId&amp;gt; 27 &amp;lt;version&amp;gt;3.</description></item></channel></rss>