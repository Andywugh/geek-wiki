<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>JFinal on 程序员安仔</title><link>https://www.shellio.cc/docs/java/jfinal/</link><description>Recent content in JFinal on 程序员安仔</description><generator>Hugo -- gohugo.io</generator><language>zh-hans</language><copyright>个人技术博客</copyright><atom:link href="https://www.shellio.cc/docs/java/jfinal/index.xml" rel="self" type="application/rss+xml"/><item><title>八、1.3 修改 web.xml</title><link>https://www.shellio.cc/docs/java/jfinal/8/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/jfinal/8/</guid><description>将如下内容添加至 web.xml
jfinal
com.jfinal.core.JFinalFilter
configClass demo.DemoConfig
jfinal
/*</description></item><item><title>二、0.1 极速 体验 Generator</title><link>https://www.shellio.cc/docs/java/jfinal/2/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/jfinal/2/</guid><description>JFinal 2.1 新增了 Generator 用来极速生成 Model、BaseModel、MappingKit、DataDictionary文件 。 使 用 时 通 常 只 需 配 置 Generator 的 四 个 参 数 即 可 ： baseModelPackageName 、 baseModelOutputDir、modelPackageName、modelOutputDir。四个参数分别表示 baseMode 的包 名，baseModel 的输出路径，modle 的包名，model 的输出路径，以下是示例代码：
1// base model 所使用的包名 2String baseModelPkg = &amp;#34;model.base&amp;#34;; 3// base model 文件保存路径 4String baseModelDir = PathKit.getWebRootPath() + &amp;#34;/../src/model/base&amp;#34;; 5// model 所使用的包名 6String modelPkg = &amp;#34;model&amp;#34;; 7// model 文件保存路径 8String modelDir = baseModelDir+ &amp;#34;/..&amp;#34;; 9Generator gernerator = new Generator(dataSource, baseModelPkg, baseModelDir,modelPkg, modelDir); 10gernerator.</description></item><item><title>二十、2.8 PropKit</title><link>https://www.shellio.cc/docs/java/jfinal/20/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/jfinal/20/</guid><description>PropKit 工具类用来操作外部配置文件。PropKit 可以极度方便地在系统任意时空使用，如 下是示例代码：
public class AppConfigextends JFinalConfig{
public void configConstant(Constantsme) {
// 第一次使用use加载的配置将成为主配置，可以通过PropKit.get(…)直接取值 PropKit.use(“a_little_config.txt”);
me.setDevMode(PropKit.getBoolean(“devMode”));
}
public void configPlugin(Pluginsme) {
// 非第一次使用use加载的配置，需要通过每次使用use来指定配置文件名再来取值 String redisHost= PropKit.use(“redis_config.txt”).get(“host”); int redisPort= PropKit.use(“redis_config.txt”).getInt(“port”); RedisPlugin rp =new RedisPlugin(“myRedis”, redisHost, redisPort);me.add(rp);
// 非第一次使用 use加载的配置，也可以先得到一个Prop对象，再通过该对象来获取值 Prop p =PropKit.use(“db_config.txt”);
DruidPlugin dp = new DruidPlugin(p.get(“jdbcUrl”), p.get(“user”)…); me.add(dp);
}
}
如上代码所示，PropKit 可同时加载多个配置文件，第一个被加载的配置文件可以使用 PorpKit.get(…)方法直接操作，非第一个被加载的配置文件则需要使用 PropKit.use(…).get(…) 来操作。PropKit 的使用并不限于在 YourJFinalConfig 中，可以在项目的任何地方使用， JFinalConfig 的 getProperty 方法其底层依赖于 PropKit 实现。</description></item><item><title>二十八、3.8 session 操作方法</title><link>https://www.shellio.cc/docs/java/jfinal/28/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/jfinal/28/</guid><description>通过setSessionAttr(key, value)可以向 session 中存放数据，getSessionAttr(key)可以从 session中读取数据。还可以通过 getSession()得到 session 对象从而使用全面的 session API。</description></item><item><title>二十二、3.2 Action</title><link>https://www.shellio.cc/docs/java/jfinal/22/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/jfinal/22/</guid><description>Controller 以及在其中定义的 public 无参方法称为一个 Action。Action 是请求的最小单位。
Action 方法必须在 Controller 中声明，该方法必须是 public 可见性且没有形参。
ublic class HelloController extends Controller {
public void index() { renderText(“此方法是一个action”);
}
public void test() { renderText(“此方法是一个action”);
}
}
以上代码中定义了两个 Action：HelloController.index()、HelloController.test()。在 Controller
中提供了 getPara、getModel 系列方法 setAttr 方法以及 render 系列方法供 Action 使用。</description></item><item><title>二十九、3.9 render 系列方法</title><link>https://www.shellio.cc/docs/java/jfinal/29/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/jfinal/29/</guid><description>render 系列方法将渲染不同类型的视图并返回给客户端。JFinal 目前支持的视图类型有：
FreeMarker、JSP、Velocity、JSON、File、Text、Html 等等。除了 JFinal 支持的视图型以外，还可以通过继承 Render 抽象类来无限扩展视图类型。
通常情况下使用 Controller.render(String)方法来渲染视图，使用 Controller.render(String)时 的 视 图 类 型 由JFinalConfig.configConstant(Constantsconstants) 配 置 中 的constants. setViewType(ViewType)来决定，该设置方法支持的 ViewType 有：FreeMarker、JSP、Velocity， 不进行配置时的缺省配置为 FreeMarker。
此外，还可以通过constants.setMainRenderFactory(IMainRenderFactory) 来设置 Controller.render(String)所使用的视图，IMainRenderFactory 专门用来对 Controller.render(String) 方法扩展除了 FreeMarker、JSP、Velocity 之外的视图。
假设在 JFinalConfig.configRoute(Routes routes) 中有 如下 Controller 映射配置 ：routes.add(“/user”, UserController.class, “/path”)， render(String view)使用例子：
方法调用
描述
render(”test.html”)
渲染名为 test.html 的视图，该视图的全路&amp;nbsp;径 为”/path/test.html”
render(”/other_path/test.html”)
渲染名为 test.html 的视图，该视图的全路&amp;nbsp;径 为”/other_path/test.html”，即当参数以”/”开头时将 采用绝对路径。
其它render 方法使用例子：
方法调用
描述
renderFreeMarker(”test.html”)
渲染&amp;nbsp;名为 test.html &amp;nbsp;的视图&amp;nbsp;，&amp;nbsp;且&amp;nbsp;视图类型为&amp;nbsp;
FreeMarker。
renderJsp(”test.html”)</description></item><item><title>二十六、3.6 getFile 文件上传</title><link>https://www.shellio.cc/docs/java/jfinal/26/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/jfinal/26/</guid><description>Controller 提供了 getFile 系列方法支持文件上传。**特别注意：**如果客户端请求为 multipart request（form 表单使用了 enctype=”multipart/form-data”），那么必须先调用 getFile 系列方法才 能使 getPara 系列方法正常工作，因为 multipart request 需要通过 getFile 系列方法解析请求体中 的数据，包括参数。
文件默认上传至项目根路径下的 upload 子路径之下，该路径称为文件上传基础路径。可以 在 JFinalConfig.configConstant(Constants me)方法中通过 me.setBaseUploadPath(baseUploadPath) 设置文件上传基础路径，该路径参数接受以”/”打头或者以 windows 磁盘盘符打头的绝对路径， 即可将基础路径指向项目根径之外，方便单机多实例部署。当该路径参数设置为相对路径时， 则是以项目根为基础的相对路径。</description></item><item><title>二十七、3.7 renderFile 文件下载</title><link>https://www.shellio.cc/docs/java/jfinal/27/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/jfinal/27/</guid><description>Controller 提供了 renderFile 系列方法支持文件下载。 文件默认下载路径为项目根路径下的 download 子路径之下，该路径称为文件下载基础路径。可以在 JFinalConfig.configConstant(Constants me) 方 法 中 通 过 me.setBaseDownloadPath(baseDownloadPath) 设置文件下载基础路径，该路径参数接受以”/”打 头或者以 windows 磁盘盘符打头的绝对路径，即可将基础路径指向项目根径之外，方便单机 多实例部署。当该路径参数设置为相对路径时，则是以项目根为基础的相对路径</description></item><item><title>二十三、3.3 getPara 系列方法</title><link>https://www.shellio.cc/docs/java/jfinal/23/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/jfinal/23/</guid><description>Controller 提供了 getPara 系列方法用来从请求中获取参数。getPara 系列方法分为两种类型。 第 一 种 类 型 为 第 一 个 形 参 为 String 的 getPara 系列 方法 。 该 系 列 方法 是对 HttpServletRequest.getParameter(String name) 的 封 装 ， 这 类 方 法 都 是 转 调 了 HttpServletRequest.getParameter(String name)。第二种类型为第一个形参为 int 或无形参的 getPara 系列方法。该系列方法是去获取 urlPara 中所带的参数值。getParaMap 与 getParaNames 分别对应 HttpServletRequest 的 getParameterMap 与 getParameterNames。
记忆技巧：第一个参数为 String 类型的将获取表单或者 url 中问号挂参的域值。第一个参数为int 或无参数的将获取 urlPara 中的参数值。
getPara 使用例子：
方法调用</description></item><item><title>二十四、3.4 getModel 与 getBean 系列方法</title><link>https://www.shellio.cc/docs/java/jfinal/24/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/jfinal/24/</guid><description>getModel 用来接收页面表单域传递过来的 model 对象，表单域名称以”modelName.attrName” 方式命名。除了 getModel 以外，还提供了一个 getBean 方法用于支持传统的 Java Bean。以下 是一个简单的示例：
1// 定义Model，在此为Blog 2public class Blog extends Model&amp;lt;Blog&amp;gt; { 3 public static final Blog me = new Blog(); 4// 在页面表单中采用modelName.attrName形式为作为表单域的name 5&amp;lt;form action=&amp;#34;/blog/save&amp;#34; method=&amp;#34;post&amp;#34;&amp;gt; 6 &amp;lt;input name=&amp;#34;blog.title&amp;#34; type=&amp;#34;text&amp;#34;&amp;gt; 7 &amp;lt;input name=&amp;#34;blog.content&amp;#34; type=&amp;#34;text&amp;#34;&amp;gt; 8 &amp;lt;input value=&amp;#34;提交&amp;#34; type=&amp;#34;submit&amp;#34;&amp;gt; 9&amp;lt;/form&amp;gt; 10public class BlogController extends Controller { 11 public void save() { 12 // 页面的modelName正好是Blog类名的首字母小写 13 Blog blog = getModel(Blog.class); 14 // 如果表单域的名称为 &amp;#34;otherName.title&amp;#34;可加上一个参数来获取 blog = getModel(Blog.</description></item><item><title>二十五、3.5 setAttr 方法</title><link>https://www.shellio.cc/docs/java/jfinal/25/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/jfinal/25/</guid><description>setAttr(String, Object)转调了 HttpServletRequest.setAttribute(String, Object)，该方法可以将 各种数据传递给 View 并在 View 中显示出来。</description></item><item><title>二十一、3.1 概述</title><link>https://www.shellio.cc/docs/java/jfinal/21/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/jfinal/21/</guid><description>Controller 是 JFinal 核心类之一，该类作为 MVC 模式中的控制器。基于 JFinal 的 Web 应 用的控制器需要继承该类。Controller 是定义 Action 方法的地点，是组织 Action 的一种方式， 一个 Controller 可以包含多个 Action。Controller 是线程安全的。</description></item><item><title>九、1.4 添加 java 文件</title><link>https://www.shellio.cc/docs/java/jfinal/9/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/jfinal/9/</guid><description>在项目src 目录下创建 demo 包，并在 demo 包下创建 DemoConfig 文件， 内容如下：
package demo;
import com.jfinal.config.*;
public class DemoConfig extends JFinalConfig {
public void configConstant(Constants me)
{ me.setDevMode(true);
}
public void configRoute(Routes me)
{ me.add(“/hello”,
HelloController.class);
}
public void configPlugin(Plugins me) {}
public void configInterceptor(Interceptors me) {}
public void configHandler(Handlers me) {}
注意：DemoConfig.java 文件所在的包以及自身文件名必须与 web.xml 中的 param-value 标 签内的配置相一致(在本例中该配置为 demo.DemoConfig)。
在demo 包下创建 HelloController 类文件， 内容如下：
package demo;
import com.jfinal.core.Controller;
public class HelloController extends Controller {</description></item><item><title>六、1.1 JFinal创建项目</title><link>https://www.shellio.cc/docs/java/jfinal/6/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/jfinal/6/</guid><description>JFinal 推荐使用 Eclipse IDE for Java EE Developers 做 为 开 发 环 境 。 点此下载
IDEA 用户快速上手参见这里：http://my.oschina.net/chixn/blog/471755
1）创建 Dynamic Web Project
2）填入项目基本信息
注意：Target runtime 一定要选择
3）修改 Default Output Folder，推荐输入 WebRoot\WEB-INF\classes
特别注意：此处的 Default out folder 必须要与 WebRoot\WEB-INF\classes 目录完全一致才可 以使用 JFinal 集成的 Jetty 来启动项目。
4）修改 Content directory，推荐输入 WebRoot
注意：此处也可以使用默认值 WebContent， 但上一步中的 WebRoot\WEB-INF\classes 则需要 改成 WebContent\WEB-INF\classes 才能对应上。</description></item><item><title>六十、8.1 概述</title><link>https://www.shellio.cc/docs/java/jfinal/60/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/jfinal/60/</guid><description>Validator 是 JFinal 校验组件，在 Validator 类中提供了非常方便的校验方法，学习简单，使用方便。</description></item><item><title>六十八、10.3 在 JFinal 中扩展</title><link>https://www.shellio.cc/docs/java/jfinal/68/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/jfinal/68/</guid><description>可以通过 FreeMarkerRender.getConfiguration().setSharedVariable(“myKit”, new MyKit()) 为FreeMarker 设置共享工具类，在 view 中使用 ${myKit.method(para)}。</description></item><item><title>六十二、8.3 Validator 配置</title><link>https://www.shellio.cc/docs/java/jfinal/62/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/jfinal/62/</guid><description>Validator 配置方式与拦截器完全一样，见如下代码：
public class UserController extends Controller {
@Before(LoginValidator. class) // 配置方式与拦截器完全一样
public void login() {
}
}</description></item><item><title>六十九、11.1 概述</title><link>https://www.shellio.cc/docs/java/jfinal/69/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/jfinal/69/</guid><description>JFinal 采用微内核全方位扩展架构，全方位是指其扩展方式在空间上的表现形式。JFinal 由 Handler、Interceptor、Controller、Render、Plugin 五大部分组成。本章将简单介绍此架构以 及基于此架构所做的一些较为常用的扩展。</description></item><item><title>六十六、10.1 概述</title><link>https://www.shellio.cc/docs/java/jfinal/66/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/jfinal/66/</guid><description>JFinal 默认使用 FreeMarker 作为 View，为了使 eclipse jee 能正确识别 html，所以默认使 用”.html”作为 FreeMarker 视图文件的扩展名(原为”.ftl”)。
如果需要使用 JSP 作为默认视图需要在 configConstant(Constants me)方法中进行配置，见 如下配置：
public void configConstant(Constants me) { me.setDevMode( true); me.setViewType(ViewType. JSP);
}</description></item><item><title>六十七、10.2 FreeMarker 示例</title><link>https://www.shellio.cc/docs/java/jfinal/67/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/jfinal/67/</guid><description>以下代码为 FreeMarker 经常使用的指令与插值:
&amp;gt; &amp;lt;\#list userList as user&amp;gt; &amp;gt; &amp;gt; $\{user.name\} $\{user.age\} $\{user.email\} 以上代码将 userList 中的 user 对象循环输出。</description></item><item><title>六十三、9.1 概述</title><link>https://www.shellio.cc/docs/java/jfinal/63/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/jfinal/63/</guid><description>JFinal 为国际化提供了极速化的支持，国际化模块仅三个类文件，使用方式要比 spring 这 类框架容易得多。</description></item><item><title>六十四、9.2 I18n 与 Res</title><link>https://www.shellio.cc/docs/java/jfinal/64/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/jfinal/64/</guid><description>I18n 对象可通过资源文件的 baseName 与 locale 参数获取到与之相对应的 Res 对象，Res 对象提供了 API 用来获取国际化数据。
以下给出具体使用步骤：
l创建 i18n_en_US.properties、 i18n_zh_CN.properties 资源文件， i18n 即为资源文件的baseName，可以是任意名称，在此示例中使用”i18n”作为 baseName i18n_en_US.properties 文件中添加如下内容：msg=Hello {0}, today is{1}. i18n_zh_CN.properties 文件中添加如下内容：msg=你好{0}, 今天是{1}. 在 YourJFinalConfig 中使用 me.setI18nDefaultBaseName(“i18n”)配置资源文件默认 baseName 特别注意，java 国际化规范要求 properties 文件的编辑需要使用专用的编辑器，否则会出 乱码，常用的有 Properties Editor，在此可以下载：http://www.oschina.net/p/properties+editor 以下是基于以上步骤以后的代码示例：
// 通过locale参数en_US得到对应的Res对象
Res resEn = I18n. use(“en_US”);
// 直接获取数据
String msgEn = resEn.get(“msg”);
// 获取数据并使用参数格式化
String msgEnFormat = resEn.format(“msg”, “james”, new Date());
// 通过locale参数zh_CN得到对应的Res对象
Res resZh = I18n. use(“zh_CN”);
// 直接获取数据</description></item><item><title>六十五、9.3 I18nInterceptor</title><link>https://www.shellio.cc/docs/java/jfinal/65/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/jfinal/65/</guid><description>I18nInterceptor 拦截器是针对于 web 应用提供的一个国际化组件，以下是在 freemarker 模板 中使用的例子：
//先将I18nInterceptor配置成全局拦截器
public void configInterceptor(Interceptors me) { me.add( new I18nInterceptor());
}
// 然后在 freemarker中即可通过_res对象来获取国际化数据
${_res.get(“msg”)}
以上代码通过配置了 I18nInterceptor 拦截 action 请求，然后即可在 freemarker 模板文件中 通过名为_res 对象来获取国际化数据，I18nInterceptor 的具体工作流程如下：
l试图从请求中通过 controller.getPara(“_locale”)获取 locale 参数，如果获取到则将其保存到cookie 之中 如 果 controller.getPara(“_locale”) 没 有 获 取 到 参 数 值 ， 则试图通过controller.getCookie(“_locale”)得到 locale 参数 如果以上两步仍然没有获取到 locale 参数值，则使用 I18n. defaultLocale 的值做为 locale 值 来使用 使用 前 面 三 步 中 得 到 的 locale 值 ， 通过 I18n.</description></item><item><title>六十一、8.2 Validator</title><link>https://www.shellio.cc/docs/java/jfinal/61/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/jfinal/61/</guid><description>Validator 自身实现了 Interceptor 接口，所以它也是一个拦截器，配置方式与拦截器完全一 样。以下是 Validator 示例：
public class LoginValidator extends Validator {
protected void validate(Controller c) { validateRequiredString(“name”, “nameMsg”, “请输入用户名”); validateRequiredString(“pass”, “passMsg”, “请输入密码”);
}
protected void handleError(Controller c) { c.keepPara(“name”);
c.render(“login.html”);
}
}
protected void validator(Controller c)方法中可以调用 validateXxx(…)系列方法进行后端校 验，protected void handleError(Controller c)方法中可以调用 c.keepPara(…)方法将提交的值再传 回页面以便保持原先输入的值，还可以调用 c.render(…) 方法来返回相应的页面。 注意 handleError(Controller c)只有在校验失败时才会调用。
以上代码 handleError 方法中的 keepXxx 方法用于将页面表单中的数据保持住并传递回页， 以便于用户无需再重复输入已经通过验证的表单域，如果传递过来的是 model 对象，可以使用 keepModel 方法来保持住用户输入过的数据。</description></item><item><title>七、1.2 放入 JFinal 库文件</title><link>https://www.shellio.cc/docs/java/jfinal/7/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/jfinal/7/</guid><description>将jfinal-xxx.jar 与jetty-server-8.1.8.jar 拷贝至项目 WEB-INF\lib 下即可。
注意：jetty-server-8.1.8.jar是开发时使用的运行环境，生产环境不需要此文件。</description></item><item><title>七十、11.2 架构</title><link>https://www.shellio.cc/docs/java/jfinal/70/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/jfinal/70/</guid><description>JFinal 顶层架构图如下：
未完待续 ……
JFinal 官方网站：http://www.jfinal.com JFinal 官方 QQ 群: 322076903、432462639</description></item><item><title>三、0.2 JFinal相关生成文件</title><link>https://www.shellio.cc/docs/java/jfinal/3/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/jfinal/3/</guid><description>BaseModel是用于被最终的 Model 继承的基类，所有的 getter、setter方法都将生成在此文 件内，这样就保障了最终 Model 的清爽与干净，BaseModel不需要人工维护，在数据库有任何 变化时重新生成一次即可。
MappingKit用于生成table 到 Model 的映射关系，并且会生成主键/复合主键的配置，也即 在 JFinal 2.1 中无需在 configPlugin(Plugins me)方法中书写任何样板式的映射代码。
DataDictionary 是指生成的数据字典，会生成数据表所有字段的名称、类型、长度、备注、是否主键等信息。</description></item><item><title>三十、4.1 概述</title><link>https://www.shellio.cc/docs/java/jfinal/30/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/jfinal/30/</guid><description>传统AOP 实现需要引入大量繁杂而多余的概念，例如：Aspect、Advice、Joinpoint、Poincut、 Introduction、Weaving、Around 等等，并且需要引入 IOC 容器并配合大量的 XML 或者 annotation 来进行组件装配。
传统AOP 不但学习成本极高，开发效率极低，开发体验极差，而且还影响系统性能，尤 其是在开发阶段造成项目启动缓慢，极大影响开发效率。
JFinal 采用极速化的 AOP 设计，专注 AOP 最核心的目标，将概念减少到极致，仅有三个 概念：Interceptor、Before、Clear，并且无需引入 IOC 也无需使用繁杂的 XML。</description></item><item><title>三十八、5.2 ActiveRecordPlugin</title><link>https://www.shellio.cc/docs/java/jfinal/38/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/jfinal/38/</guid><description>ActiveRecord 是作为 JFinal 的 Plugin 而存在的，所以使用时需要在 JFinalConfig 中配置ActiveRecordPlugin。
以下是Plugin 配置示例代码：
public class DemoConfig extends JFinalConfig {
public void configPlugin(Plugins me) {
C3p0Plugin cp = new C3p0Plugin(“jdbc:mysql://localhost/db_name”, “userName”, “password”);
me.add(cp);
ActiveRecordPlugin arp = new ActiveRecordPlugin(cp); me.add(arp);
arp.addMapping(“user”, User. class); arp. addMapping(“article”, “article_id”, Article. class);
}
}
以上代码配置了两个插件：C3p0Plugin 与 ActiveRecordPlugin，前者是 c3p0 数据源插件， 后者是 ActiveRecrod 支持插件。ActiveReceord 中定义了 addMapping(String tableName, Class&amp;lt;? extends Model&amp;gt; modelClass&amp;gt;)方法，该方法建立了数据库表名到 Model 的映射关系。
另外，以上代码中 arp.addMapping(“user”, User.class)，表的主键名为默认为“id”，如果主 键名称为 “user_id”则需要手动指定，如：arp.addMapping(“user”, “user_id”, User.class)。</description></item><item><title>三十二、4.3 Before</title><link>https://www.shellio.cc/docs/java/jfinal/32/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/jfinal/32/</guid><description>Before 注解用来对拦截器进行配置，该注解可配置 Class、Method 级别的拦截器，以下是 代码示例：
如上代码所示，Before 可以将拦截器配置为 Class 级别与 Method 级别，前者将拦截本类 中所有方法，后者仅拦截本方法。此外 Before 可以同时配置多个拦截器，只需用在大括号内 用逗号将多个拦截器进行分隔即可。
除了Class 与 Method 级别的拦截器以外，JFinal 还支持全局拦截器以及 Inject 拦截器（Inject
拦截将在后面介绍），全局拦截器分为控制层全局拦截器与业务层全局拦截器，前者拦截控制 层所有 Action 方法，后者拦截业务层所有方法。
全局拦截器需要在 YourJFinalConfig 进行配置，以下是配置示例：
1public class AppConfig extends JFinalConfig { 2 public void configInterceptor(Interceptors me) { 3 // 添加控制层全局拦截器 4 me.addGlobalActionInterceptor(new GlobalActionInterceptor()); 5 // 添加业务层全局拦截器 6 me.addGlobalServiceInterceptor(new GlobalServiceInterceptor()); 7 // 为兼容老版本保留的方法，功能与addGlobalActionInterceptor完全一样 8 me.add(new GlobalActionInterceptor()); 9 } 当某个Method 被多个级别的拦截器所拦截，拦截器各级别执行的次序依次为：Global、 Inject、Class、Method，如果同级中有多个拦截器，那么同级中的执行次序是：配置在前面的 先执行。</description></item><item><title>三十九、5.3 Model</title><link>https://www.shellio.cc/docs/java/jfinal/39/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/jfinal/39/</guid><description>Model 是 ActiveRecord 中最重要的组件之一，它充当 MVC 模式中的 Model 部分。以下是
Model 定义示例代码：
public class User extends Model {
public static final User dao = new User();
}
以上代码中的 User 通过继承 Model，便立即拥有的众多方便的操作数据库的方法。在 User 中声明的 dao 静态对象是为了方便查询操作而定义的，该对象并不是必须的。基于 ActiveRecord 的 Model 无需定义属性，无需定义 getter、setter 方法，无需 XML 配置，无需 Annotation 配置， 极大降低了代码量。
以下为Model 的一些常见用法：
// 创建name属性为James,age属性为25的User对象并添加到数据库
new User().set(“name”, “James”).set(“age”, 25).save();
// 删除id值为25的User User. dao.deleteById(25);
// 查询id值为25的User将其name属性改为James并更新到数据库
User. dao.findByIdLoadColumns (25).set(“name”, “James”).update();
// 查询id值为25的user, 且仅仅取name与age两个字段的值
User user = User. dao.findByIdLoadColumns (25, “name, age”);</description></item><item><title>三十六、4.7 Inject 拦截器</title><link>https://www.shellio.cc/docs/java/jfinal/36/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/jfinal/36/</guid><description>Inject 拦截器是指在使用 enhance 或 duang 方法增强时使用参数传入的拦截器。Inject 可以 对目标完全无侵入地应用 AOP。
假如需要增强的目标在 jar 包之中，无法使用 Before 注解对其配置拦截器，此时使用 Inject拦截器可以对 jar 包中的目标进行增强。如下是 Inject 拦截器示例：
1public void injectDemo() { 2 // 为enhance方法传入的拦截器称为Inject拦截器，下面代码中的Tx称为Inject拦截器 OrderService service = Enhancer.enhance(OrderService.class, Tx.class); service.payment(…); 如上代码中 Enhance.enhance()方法的第二个参数 Tx.class 被称之为 Inject 拦截器，使用此方法便可完全无侵入地对目标进行 AOP 增强。
Inject 拦截器与前面谈到的 Global、Class、Method 级别拦截器是同一层次上的概念。与 Class 级拦截器一样，Inject 拦截器将拦截被增强目标中的所有方法。Inject 拦截器可以被认为 就是 Class 级拦截器，只不过执行次序在 Class 级拦截器之前而已。</description></item><item><title>三十七、5.1 概述</title><link>https://www.shellio.cc/docs/java/jfinal/37/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/jfinal/37/</guid><description>ActiveRecord 是 JFinal 最核心的组成部分之一，通过 ActiveRecord 来操作数据库，将极大 地减少代码量，极大地提升开发效率。</description></item><item><title>三十三、4.4 Clear</title><link>https://www.shellio.cc/docs/java/jfinal/33/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/jfinal/33/</guid><description>拦截器从上到下依次分为 Global、Inject、Class、Method 四个层次，Clear 用于清除自身 所处层次以上层的拦截器。
Clear 声明在 Method 层时将针对 Global、Inject、Class 进行清除。Clear 声明在 Class 层时 将针对 Global、Inject 进行清除。Clear 注解携带参数时清除目标层中指定的拦截器。
Clear 用法记忆技巧： l共有 Global、Inject、Class、Method 四层拦截器
l清除只针对 Clear 本身所处层的向上所有层，本层与下层不清除
l不带参数时清除所有拦截器，带参时清除参数指定的拦截器
在某些应用场景之下，需要移除 Global 或 Class 拦截器。例如某个后台管理系统，配置了 一个全局的权限拦截器，但是其登录 action 就必须清除掉她，否则无法完成登录操作，以下是 代码示例：
1// login方法需要移除该权限拦截器才能正常登录 2@Before(AuthInterceptor.class) 3public class UserController extends Controller { 4 // AuthInterceptor 已被Clear清除掉，不会被其拦截 5 @Clear 6 public void login() { 7 } 8 // 此方法将被AuthInterceptor拦截 9 public void show() { 10 } Clear 注解带有参数时，能清除指定的拦截器，以下是一个更加全面的示例：</description></item><item><title>三十四、4.5 Interceptor 的触发</title><link>https://www.shellio.cc/docs/java/jfinal/34/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/jfinal/34/</guid><description>JFinal 中的 AOP 被划分为控制层 AOP 以及业务层 AOP，严格来说业务层 AOP 并非仅限 于在业务层使用，因为 JFinal AOP 可以应用于其它任何地方。
控制层拦截器的触发，只需发起 action 请求即可。业务层拦截器的触发需要先使用 enhance方法对目标对象进行增强，然后调用目标方法即可。以下是业务层 AOP 使用的例子：
1// 定义需要使用AOP的业务层类 2public class OrderService { 3 // 配置事务拦截器 4 @Before(Tx.class) 5 public void payment(int orderId, int userId) { 6 // service code here 7 } 8// 定义控制器，控制器提供了enhance系列方法可对目标进行AOP增强 9public class OrderController extends Controller { 10 public void payment() { 11 // 使用 enhance方法对业务层进行增强，使其具有AOP能力 OrderService service = enhance(OrderService.class); 12 // 调用payment方法时将会触发拦截器 13 service.</description></item><item><title>三十五、4.6 Duang、Enhancer</title><link>https://www.shellio.cc/docs/java/jfinal/35/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/jfinal/35/</guid><description>Duang、Enhancer 用来对目标进行增强，让其拥有 AOP 的能力。以下是代码示例：
1public class TestMain{ 2 public void main(String[] args) { 3 // 使用Duang.duang方法在任何地方对目标进行增强 4 OrderService service = Duang.duang(OrderService.class); 5 // 调用payment方法时将会触发拦截器 6 service.payment(…); 7 // 使用Enhancer.enhance方法在任何地方对目标进行增强 8 OrderService service = Enhancer.enhance(OrderService.class); 9 } Duang.duang()、Enhancer.enhance()与 Controller.enhance()系方法在功能上完全一样，她们 除了支持类增强以外，还支持对象增强，例如 duang(new OrderService())以对象为参数的用法， 功能本质上是一样的，在此不再赘述。
使用Duang、Enhancer 类可以对任意目标在任何地方增强，所以 JFinal 的 AOP 可以应用 于非 web 项目，只需要引入 jfinal.jar 包，然后使用 Enhancer.enhance()或 Duang.duang()即可极 速使用 JFinal 的 AOP 功能。</description></item><item><title>三十一、4.2 Interceptor</title><link>https://www.shellio.cc/docs/java/jfinal/31/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/jfinal/31/</guid><description>Interceptor 可以对方法进行拦截，并提供机会在方法的前后添加切面代码，实现 AOP 的 核心目标。Interceptor 接口仅仅定了一个方法 void intercept(Invocation inv)。以下是简单的示例：
1public class DemoInterceptor implements Interceptor { 2 public void intercept(Invocation inv) { System.out.println(&amp;#34;Before method invoking&amp;#34;); inv.invoke(); 3 System.out.println(&amp;#34;After method invoking&amp;#34;); 4 } 以上代码中的 DemoInterceptor 将拦截目标方法，并且在目标方法调用前后向控制台输出 文本。inv.invoke()这一行代码是对目标方法的调用，在这一行代码的前后插入切面代码可以很 方便地实现 AOP。
nvocation 作为 Interceptor 接口 intercept 方法中的唯一参数，提供了很多便利的方法在拦 截器中使用。以下为 Invocation 中的方法：
方法
描述
void invoke()
传递本次调用，调用剩下的拦截器与目标方法
Controller getController()
获取&amp;nbsp;Action 调用的&amp;nbsp;Controller 对象（仅用于控制层拦截）
String getActionKey()
获取&amp;nbsp;Action 调用的&amp;nbsp;action key 值（仅用于控制层拦截）
String getControllerKey()
获取&amp;nbsp;Action 调用的&amp;nbsp;controller key 值（仅用于控制层拦截）
String getViewPath()</description></item><item><title>十、1.5 JFinal启动项目</title><link>https://www.shellio.cc/docs/java/jfinal/10/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/jfinal/10/</guid><description>创建启动项如下图所示：
鼠标右键点击 Java Application 并选择 New 菜单项，新建 Java Application 启动项，如下图 所示：
在右侧窗口中的 Main class 输入框中填入: com.jfinal.core.JFinal 并点击 Debug 按钮启动项 目，如下图所示：</description></item><item><title>十八、2.6 configHandler (Handlers me)</title><link>https://www.shellio.cc/docs/java/jfinal/18/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/jfinal/18/</guid><description>此方法用来配置 JFinal 的 Handler，如下代码配置了名为 ResourceHandler 的处理器，Handler 可以接管所有 web 请求，并对应用拥有完全的控制权，可以很方便地实现更高层的功能性扩 展。
1public void configHandler(Handlers me) { 2 me.add(new ResourceHandler());</description></item><item><title>十二、1.7 Maven 下开发</title><link>https://www.shellio.cc/docs/java/jfinal/12/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/jfinal/12/</guid><description>如果使用 Maven 管理 jar 包依赖，只需要引入如下 dependency：
com.jfinal
jfinal
2.2
Manve 下启动 JFinal 与前面介绍的非 maven 方式基本相同，唯一的区别是在创建 Java Application 启动项时，在 Arguments 标签中的 Program arguments 中输入：src/main/webapp 80 / 5 参数用来指定 web 项目的根目录。如下示例代码是 main 方法启动方式：
public static void main(String[]args)
{ JFinal.start(“src/main/webapp”,80, “/”,
5);</description></item><item><title>十九、2.7 afterJFinalStart()与 beforeJFinalStop()</title><link>https://www.shellio.cc/docs/java/jfinal/19/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/jfinal/19/</guid><description>JFinalConfig 中的 afterJFinalStart()与 beforeJFinalStop()方法供开发者在 JFinalConfig 继承类中 覆盖 。 JFinal 会在系统启动完成后回调 afterJFinalStart() 方 法 ， 会 在 系 统 关 闭 前 回 调 beforeJFinalStop()方法。这两个方法可以很方便地在项目启动后与关闭前让开发者有机会进行 额外操作，如在系统启动后创建调度线程或在系统关闭前写回缓存。</description></item><item><title>十六、2.4 configPlugin (Plugins me)</title><link>https://www.shellio.cc/docs/java/jfinal/16/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/jfinal/16/</guid><description>此方法用来配置 JFinal 的 Plugin，如下代码配置了 C3p0 数据库连接池插件与 ActiveRecord数据库访问插件。通过以下的配置，可以在应用中使用 ActiveRecord 非常方便地操作数据库。
public void configPlugin(Pluginsme)
{ loadPropertyFile(“your_app_config.txt”);
C3p0Plugin c3p0Plugin = new C3p0Plugin(getProperty(“jdbcUrl”), getProperty(“user”), getProperty(“password”));
me.add(c3p0Plugin);
ActiveRecordPlugin arp = new ActiveRecordPlugin(c3p0Plugin);me.add(arp);
arp.addMapping(“user”,User.class);
JFinal 插件架构是其主要扩展方式之一，可以方便地创建插件并应用到项目中去。</description></item><item><title>十七、2.5 configInterceptor (Interceptors me)</title><link>https://www.shellio.cc/docs/java/jfinal/17/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/jfinal/17/</guid><description>此方法用来配置 JFinal 的全局拦截器，全局拦截器将拦截所有 action 请求，除非使用@Clear 在 Controller 中清除，如下代码配置了名为 AuthInterceptor 的拦截器。
public void configInterceptor(Interceptorsme)
{ me.add(newAuthInterceptor());
}
JFinal 的 Interceptor 非常类似于 Struts2，但使用起来更方便，Interceptor 配置粒度分为 Global、Class、Method 三个层次，其中以上代码配置粒度为全局。Class 与 Method 级的 Interceptor 配置将在后续章节中详细介绍。</description></item><item><title>十三、2.1 概述</title><link>https://www.shellio.cc/docs/java/jfinal/13/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/jfinal/13/</guid><description>基于JFinal 的 web 项目需要创建一个继承自 JFinalConfig 类的子类，该类用于对整个 web
项目进行配置。
JFinalConfig 子类需要实现五个抽象方法，如下所示：
public class DemoConfigextends JFinalConfig
{ publicvoid configConstant(Constants me)
{} public void configRoute(Routesme) {}
publicvoid configPlugin(Plugins me) {}
public void configInterceptor(Interceptors me) {}
public void configHandler(Handlersme) {}
}</description></item><item><title>十四、2.2 configConstant(Constants me)</title><link>https://www.shellio.cc/docs/java/jfinal/14/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/jfinal/14/</guid><description>此方法用来配置 JFinal 常量值，如开发模式常量 devMode 的配置，默认视图类型 ViewType的配置，如下代码配置了 JFinal 运行在开发模式下且默认视图类型为 JSP：
public void configConstant(Constantsme)
{ me.setDevMode(true);
me.setViewType(ViewType.JSP);
}
在开发模式下，JFinal 会对每次请求输出报告，如输出本次请求的 Controller、Method 以 及请求所携带的参数。JFinal 支持 JSP、FreeMarker、Velocity 三种常用视图。</description></item><item><title>十五、2.3 configRoute(Routes me)</title><link>https://www.shellio.cc/docs/java/jfinal/15/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/jfinal/15/</guid><description>此方法用来配置 JFinal 访问路由，如下代码配置了将”/hello”映射到 HelloController 这个控 制器 ， 通 过 以 下 的 配 置 ， http://localhost/hello 将 访 问 HelloController.index() 方法， 而 http://localhost/hello/methodName 将访问到 HelloController.methodName()方法。
public void configRoute(Routes me)
{ me.add(“/hello”,
HelloController.class);
Routes 类主要有如下两个方法：
public Routes add(String controllerKey, Class&amp;lt;? **extends** Controller&amp;gt;
controllerClass, String viewPath)
public Routes add(String controllerKey, Class&amp;lt;? extends Controller&amp;gt;
controllerClass)
第一个参数 controllerKey 是指访问某个 Controller 所需要的一个字符串，该字符串唯一对 应一个 Controller，controllerKey 仅能定位到 Controller。第二个参数 controllerClass 是该 controllerKey 所对应到的 Controller。第三个参数 viewPath 是指该 Controller 返回的视图的相对 路径(该参数具体细节将在 Controller 相关章节中给出)。当 viewPath 未指定时默认值为 controllerKey。</description></item><item><title>十一、1.6 开启浏览器看效果</title><link>https://www.shellio.cc/docs/java/jfinal/11/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/jfinal/11/</guid><description>打开浏览器在地址栏中输入: http://localhost/hello，输出内容为 Hello JFinal World 证明项目 框架搭建完成。如需完整 demo 示例可在 JFinal 官方网站下载：http://www.jfinal.com
注意：在 tomcat 下开发或运行项目时，需要先删除 jetty-server-xxx.jar 这个包，否则会引起冲 突。 Tomcat 启动项目不能使用上面介绍的启动方式，因为上面的启动方式需要用到jetty-server-xxx.jar。</description></item><item><title>四、0.3 Model 与 Bean 合体后主要优势</title><link>https://www.shellio.cc/docs/java/jfinal/4/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/jfinal/4/</guid><description> 充分利用海量的针对于 Bean 设计的第三方工具，例如 jackson、freemarker 快速响应数据库表变动，极速重构，提升开发效率，提升代码质量 拥有 IDE 代码提示不用记忆数据表字段名，消除记忆负担，避免手写字段名出现手误 BaseModel 设计令 Model 中依然保持清爽，在表结构变化时极速重构关联代码 自动化 table 至 Model 映射 自动化主键、复合主键名称识别与映射 MappingKit 承载映射代码，JFinalConfig 保持干净清爽 有利于分布式场景和无数据源时使用 Model 新设计避免了以往自动扫描映射设计的若干缺点：引入新概念(如注解)增加学习成本、性 能低、jar 包扫描可靠性与安全性低</description></item><item><title>四十、5.4 JavaBean 与 Model 合体</title><link>https://www.shellio.cc/docs/java/jfinal/40/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/jfinal/40/</guid><description>JFinal 2.1 版本提供了 ModelGenerator 、 BaseModelGenerator 、 MappingKitGernator 、 DataDictionaryGenerator，分别生成 Model、BaseModel、MappingKit、DataDictionary 四类文件。 可根据数据表自动化生成这四类文件。
相对于JFinal 2.1 之前的版本，生成后的 Model 继承自 BaseModel 而非继承自 Model， BaseModel 中拥有 getter、setter 方法遵守传统 java bean 规范，Model 继承自 BaseModel 即完成 了 JavaBean 与 Model 合体，拥有了传统 JavaBean 所有的优势，并且所有的 getter、setter 方法 完全无需人工干预，数据表有任何变动一键重新生成即可。
具体用法可在 jfinal 官网下载相关 GeneratorDemo，用法极度简单。</description></item><item><title>四十八、5.12 多数据源支持</title><link>https://www.shellio.cc/docs/java/jfinal/48/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/jfinal/48/</guid><description>ActiveRecordPlugin 可同时支持多数据源、多方言、多缓存、多事务级别等特性，对每个 ActiveRecordPlugin 可进行彼此独立的配置。简言之 JFinal 可以同时使用多数据源，并且可 以针对这多个数据源配置独立的方言、缓存、事务级别等。
当使用多数据源时，只需要对每个 ActiveRecordPlugin 指定一个 configName 即可，如下是代码示例：
public void configPlugin(Plugins me) {
// mysql 数据源
C3p0Plugin dsMysql = new C3p0Plugin(…); me.add(dsMysql);
// mysql ActiveRecrodPlugin 实例，并指定configName为 mysql ActiveRecordPlugin arpMysql = new ActiveRecordPlugin(“mysql”, dsMysql); me.add(arpMysql);
arpMysql.setCache( new EhCache()); arpMysql.addMapping(“user”, User. class);
// oracle 数据源
C3p0Plugin dsOracle = new C3p0Plugin(…); me.add(dsOracle);
// oracle ActiveRecrodPlugin 实例，并指定configName为 oracle ActiveRecordPlugin arpOracle = new ActiveRecordPlugin(“oracle”, dsOracle); me.add(arpOracle);
arpOracle.setDialect( new OracleDialect()); arpOracle.setTransactionLevel(8); arpOracle.addMapping(“blog”, Blog.</description></item><item><title>四十二、5.6 声明式事务</title><link>https://www.shellio.cc/docs/java/jfinal/42/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/jfinal/42/</guid><description>ActiveRecord 支持声名式事务，声明式事务需要使用 ActiveRecordPlugin 提供的拦截器来 实现，拦截器的配置方法见 Interceptor 有关章节。以下代码是声明式事务示例：
// 本例仅为示例, 并未严格考虑账户状态等业务逻辑
@Before(Tx. class)
public void trans_demo() {
// 获取转账金额
Integer transAmount = getParaToInt(“transAmount”);
// 获取转出账户id
Integer fromAccountId = getParaToInt(“fromAccountId”);
// 获取转入账户id
Integer toAccountId = getParaToInt(“toAccountId”);
// 转出操作
Db.update(“update account set cash = cash – ? where id = ?”, transAmount, fromAccountId);
// 转入操作
Db.update(“update account set cash = cash + ? where id = ?”, transAmount, toAccountId);
}
以上代码中，仅声明了一个 Tx 拦截器即为 action 添加了事务支持。除此之外 ActiveRecord 还配备了 TxByActionKeys、TxByActionKeyRegex、TxByMethods、TxByMethodRegex，分别 支持 actionKeys、actionKey 正则、actionMethods、actionMethod 正则声明式事务，以下是示例代码：</description></item><item><title>四十九、5.13 非 web 环境下使用 ActiveRecord</title><link>https://www.shellio.cc/docs/java/jfinal/49/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/jfinal/49/</guid><description>ActiveRecordPlugin 可以独立于 java web 环境运行在任何普通的 java 程序中，使用方式极 度简单，相对于 web 项目只需要手动调用一下其 start() 方法即可立即使用。以下是代码示例：
public class ActiveRecordTest {
public static void main(String[] args) {
DruidPlugin dp = new DruidPlugin(“localhost”, “userName”, “password”); ActiveRecordPlugin arp = new ActiveRecordPlugin(dp); arp.addMapping(“blog”, Blog. class);
// 与web环境唯一的不同是要手动调用一次相关插件的start()方法
dp.start();
arp.start();
// 通过上面简单的几行代码，即可立即开始使用
new Blog().set(“title”, “title”).set(“content”, “cxt text”).save(); Blog. me.findById(123);
}
}
注意：ActiveRecordPlugin 所依赖的其它插件也必须手动调用一下 start()方法，如上例中的 dp.start()。</description></item><item><title>四十六、5.10 复合主键</title><link>https://www.shellio.cc/docs/java/jfinal/46/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/jfinal/46/</guid><description>JFinal ActiveRecord 从 2.0 版本开始，采用极简设计支持复合主键，对于 Model 来说需要 在映射时指定复合主键名称，以下是具体例子：
ActiveRecordPlugin arp = new ActiveRecordPlugin(c3p0Plugin);
// 多数据源的配置仅仅是如下第二个参数指定一次复合主键名称
arp.addMapping(“user_role”, “userId, roleId”, UserRole. class);
//同时指定复合主键值即可查找记录 UserRole. dao.findById(123, 456);
//同时指定复合主键值即可删除记录 UserRole. dao.deleteById(123, 456);
如上代码所示，对于 Model 来说，只需要在添加 Model 映射时指定复合主键名称即可开 始使用复合主键，在后续的操作中 JFinal 会对复合主键支持的个数进行检测，当复合主键数量 不正确时会报异常，尤其是复合主键数量不够时能够确保数据安全。复合主键不限定只能有两 个，可以是数据库支持下的任意多个。
对于Db + Record 模式来说，复合主键的使用不需要配置，直接用即可：
Db. findById(“user_role”, “roleId, userId”, 123, 456);
Db. deleteById(“user_role”, “roleId, userId”, 123, 456);</description></item><item><title>四十七、5.11 Oracle 支持</title><link>https://www.shellio.cc/docs/java/jfinal/47/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/jfinal/47/</guid><description>Oracle 数据库具有一定的特殊性，JFinal 针对这些特殊性进行了一些额外的支持以方便广 大的 Oracle 使用者。以下是一个完整的 Oracle 配置示例：
public class DemoConfig extends JFinalConfig {
public void configPlugin(Plugins me) { C3p0Plugin cp = new C3p0Plugin(……);
//配置Oracle驱动
cp. setDriverClass(“oracle.jdbc.driver.OracleDriver”); me.add(cp);
ActiveRecordPlugin arp = new ActiveRecordPlugin(cp); me.add(arp);
// 配置Oracle方言
arp.setDialect(new OracleDialect());
// 配置属性名(字段名)大小写不敏感容器工厂 arp.setContainerFactory( new CaseInsensitiveContainerFactory()); arp.addMapping(“user”, “user_id”, User. class);
}
由于Oracle 数据库会自动将属性名(字段名)转换成大写，所以需要手动指定主键名为大写， 如：arp.addMaping(“user”, “ID”, User.class)。如果想让 ActiveRecord 对属性名（字段名）的大 小 写 不 敏 感 可 以 通 过 设 置 CaseInsensitiveContainerFactory 来达到 ， 有 了 这 个 设 置 ， 则 arp.</description></item><item><title>四十三、5.7 Cache</title><link>https://www.shellio.cc/docs/java/jfinal/43/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/jfinal/43/</guid><description>ActiveRecord 可以使用缓存以大大提高性能，以下代码是 Cache 使用示例：
public void list() {
List blogList = Blog. dao.findByCache(“cacheName”, “key”, “select * from blog”);
setAttr(“blogList”, blogList).render(“list.html”);
}
上例findByCache 方 法 中 的 cacheName 需 要 在 ehcache.xml 中配置 如： 。 此 外 Model.paginateByCache(…) 、 Db.findByCache(…) 、 Db.paginateByCache(…)方法都提供了 cache 支持。在使用时，只需传入 cacheName、key 以及 在 ehccache.xml 中配置相对应的 cacheName 就可以了。</description></item><item><title>四十四、5.8 Dialect 多数据库支持</title><link>https://www.shellio.cc/docs/java/jfinal/44/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/jfinal/44/</guid><description>目前ActiveRecordPlugin 提供了 MysqlDialect、OracleDialect、AnsiSqlDialect 实现类。 MysqlDialect 与 OracleDialect 分别实现对 Mysql 与 Oracle 的支持，AnsiSqlDialect 实现对遵守 ANSI SQL 数据库的支持。以下是数据库 Dialect 的配置代码：
public class DemoConfig extends JFinalConfig {
public void configPlugin(Plugins me) { ActiveRecordPlugin arp = new ActiveRecordPlugin(…); me.add(arp);
// 配置Postgresql方言
arp.setDialect(new PostgresqlDialect());
}
}</description></item><item><title>四十五、5.9 表关联操作</title><link>https://www.shellio.cc/docs/java/jfinal/45/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/jfinal/45/</guid><description>JFinal ActiveRecord 天然支持表关联操作，并不需要学习新的东西，此为无招胜有招。表 关联操作主要有两种方式：一是直接使用 sql 得到关联数据；二是在 Model 中添加获取关联数据的方法。
假定现有两张数据库表：user、blog，并且 user 到 blog 是一对多关系，blog 表中使用 user_id关联到 user 表。如下代码演示使用第一种方式得到 user_name：
public void relation() {
String sql = “select b.*, u.user_name from blog b inner join user u on b.user_id=u.id where b.id=?”;
Blog blog = Blog. dao.findFirst(sql, 123); String name = blog.getStr(“user_name”);
}
以下代码演示第二种方式在 Blog 中获取相关联的 User 以及在 User 中获取相关联的Blog：
public class Blog extends Model {
public static final Blog dao = new Blog();</description></item><item><title>四十一、5.5 JFinal 独创 Db + Record 模式</title><link>https://www.shellio.cc/docs/java/jfinal/41/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/jfinal/41/</guid><description>Db类及其配套的 Record 类，提供了在 Model 类之外更为丰富的数据库操作功能。使用 Db 与 Record 类时，无需对数据库表进行映射，Record 相当于一个通用的 Model。以下为 Db + Record 模式的一些常见用法：
// 创建name属性为James,age属性为25的record对象并添加到数据库
Record user = new Record().set(“name”, “James”).set(“age”, 25); Db. save(“user”, user);
// 删除id值为25的user表中的记录
Db. deleteById(“user”, 25);
// 查询id值为25的Record将其name属性改为James并更新到数据库 user = Db. findById(“user”, 25).set(“name”, “James”); Db. update(“user”, user);
// 获取user的name属性
String userName = user.getStr(“name”);
// 获取user的age属性
Integer userAge = user.getInt(“age”);
// 查询所有年龄大于18岁的user
List users = Db. find(“select * from user where age &amp;gt; 18”);
// 分页查询年龄大于18的user,当前页号为1,每页10个user</description></item><item><title>五、0.4 Model 与 Bean 合体后注意事项</title><link>https://www.shellio.cc/docs/java/jfinal/5/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/jfinal/5/</guid><description> 合体后 JSP 模板输出 Bean 中的数据将依赖其 getter 方法，输出的变量名即为 getter 方法去 掉”get”前缀字符后剩下的字符首字母变小写，如果希望 JSP 仍然使用之前的输出方式，可 以在系统启动时调用一下 ModelRecordElResolver. setResolveBeanAsModel(true); Controller 之中的 getModel()需要表单域名称对应于数据表字段名，而 getBean()则依赖于 setter 方法，表单域名对应于 setter 方法去掉”set”前缀字符后剩下的字符串字母变小写。 许多类似于 jackson、fastjson 的第三方工具依赖于 Bean 的 getter 方法进行操作，所以只有 合体后才可以使用 jackson、fastjson JFinalJson 将 Model 转换为 json 数据时，json 的 keyName 是原始的数据表字段名，而 jackson、 fastjson 这类依赖于 getter 方法转化成的 json 的 keyName 是数据表字段名转换而成的驼峰 命名 建议 mysql 数据表的字段名直接使用驼峰命名，这样可以令 json 的 keyName 完全一致， 也可以使 JSP 在页面中取值时使用完全一致的属性名。注意：mysql 数据表的名称仍然使 用下划线命名方式并使用小写字母，方便在 linux 与 windows 系统之间移植。 总之，合体后的 Bean 在使用时要清楚使用的是其 BaseModel 中的 getter、setter 方法还是 其 Model 中的 get(String attrName)方法</description></item><item><title>五十、6.1 概述</title><link>https://www.shellio.cc/docs/java/jfinal/50/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/jfinal/50/</guid><description>EhCachePlugin 是 JFinal 集成的缓存插件，通过使用 EhCachePlugin 可以提高系统的并发 访问速度。</description></item><item><title>五十八、7.3 Redis 与 Cache</title><link>https://www.shellio.cc/docs/java/jfinal/58/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/jfinal/58/</guid><description>Redis 与 Cache 联合起来可以非常方便地使用 Redis 服务，Redis 对象通过 use()方法来获取 到 Cache 对象，Cache 对象提供了丰富的 API 用于使用 Redis 服务，下面是具体使用示例：
public void redisDemo() {
// 获取名称为 bbs的 Redis Cache对象 Cache bbsCache = Redis. use(“bbs”); bbsCache.set(“key”, “value”); bbsCache.get(“key”);
// 获取名称为news的 Redis Cache对象 Cache newsCache = Redis. use(“news”); newsCache.set(“k”, “v”); newsCache.get(“k”);
// 最先创建的Cache将成为主Cache，所以可以省去cacheName参数来获取 bbsCache = Redis. use(); // 主缓存可以省去cacheName参数 bbsCache.set(“jfinal”, “awesome”);
}
以上代码中通过”bbs”、”news”做为 use 方法的参数分别获取到了两个 Cache 对象，使用这 两个对象即可操作其所对应的 Redis 服务端。
通常情况下只会创建一个 RedisPlugin 连接一个 redis 服务端，使用 Redis.use().set(key,value)即可。</description></item><item><title>五十二、6.3 CacheInterceptor</title><link>https://www.shellio.cc/docs/java/jfinal/52/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/jfinal/52/</guid><description>CacheInterceptor 可以将 action 所需数据全部缓存起来，下次请求到来时如果 cache 存在则 直接使用数据并 render，而不会去调用 action。此用法可使 action 完全不受 cache 相关代码所 污染，即插即用，以下是示例代码：
@Before(CacheInterceptor. class)
public void list() {
List blogList = Blog. dao.find(“select * from blog”); User user = User. dao.findById(getParaToInt()); setAttr(“blogList”, blogList);
setAttr(“user”, user); render(“blog.html”);
}
上例中的用法将使用 actionKey 作为 cacheName，在使用之前需要在 ehcache.xml 中配置以 actionKey 命名的 cache 如： ，注意 actionKey 作为 cacheName 配置 时斜杠”/”不能省略。此外 CacheInterceptor 还可以与 CacheName 注解配合使用，以此来取代默认的 actionKey 作为actionName，以下是示例代码：
@Before(CacheInterceptor. class)
@CacheName(“blogList”)
public void list() {
List blogList = Blog.</description></item><item><title>五十九、7.4 非 web 环境使用 RedisPlugin</title><link>https://www.shellio.cc/docs/java/jfinal/59/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/jfinal/59/</guid><description>RedisPlugin 也 可 以 在 非 web 环 境 下 使 用 ， 只需 引入 jfinal.jar 然 后 多 调用一下redisPlugin.start()即可，以下是代码示例：
public class RedisTest {
public static void main(String[] args) {
RedisPlugin rp = new RedisPlugin(“myRedis”, “localhost”);
// 与web下唯一区别是需要这里调用一次start()方法rp.start();
Redis. use().set(“key”, “value”);
Redis. use().get(“key”);
}
}</description></item><item><title>五十六、7.1 概述</title><link>https://www.shellio.cc/docs/java/jfinal/56/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/jfinal/56/</guid><description>RedisPlugin 是支持 Redis 的极速化插件。使用 RedisPlugin 可以极度方便的使用 redis，该 插件不仅提供了丰富的 API，而且还同时支持多 redis 服务端。Redis 拥有超高的性能，丰富的 数据结构，天然支持数据持久化，是目前应用非常广泛的 nosql 数据库。对于 redis 的有效应 用可极大提升系统性能，节省硬件成本。</description></item><item><title>五十七、7.2 RedisPlugin</title><link>https://www.shellio.cc/docs/java/jfinal/57/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/jfinal/57/</guid><description>RedisPlugin 是作为 JFinal 的 Plugin 而存在的，所以使用时需要在 JFinalConfig 中配置RedisPlugin，以下是 RedisPlugin 配置示例代码：
public class DemoConfig extends JFinalConfig {
public void configPlugin(Plugins me) {
// 用于缓存 bbs模块的 redis服务
RedisPlugin bbsRedis = new RedisPlugin(“bbs”, “localhost”); me.add(bbsRedis);
// 用于缓存news模块的 redis服务
RedisPlugin newsRedis = new RedisPlugin(“news”, “192.168.3.9”); me.add(newsRedis);
}
}
以上代码创建了两个 RedisPlugin 对象，分别为 bbsRedis 和 newsRedis。最先创建的 RedisPlugin 对象所持有的 Cache 对象将成为主缓存对象，主缓存对象可通过 Redis.use()直接获 取，否则需要提供 cacheName 参数才能获取，例如：Redis.use(“news”)。</description></item><item><title>五十三、6.4 EvictInterceptor</title><link>https://www.shellio.cc/docs/java/jfinal/53/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/jfinal/53/</guid><description>EvictInterceptor 可以根据 CacheName 注解自动清除缓存。以下是示例代码：
@Before(EvictInterceptor. class)
@CacheName(“blogList”)
public void update() { getModel(Blog.class).update(); redirect(“blog.html”);
}
上例中的用法将清除 cacheName 为 blogList 的缓存数据，与其配合的 CacheInterceptor 会 自动更新 cacheName 为 blogList 的缓存数据。</description></item><item><title>五十四、6.5 CacheKit</title><link>https://www.shellio.cc/docs/java/jfinal/54/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/jfinal/54/</guid><description>CacheKit 是缓存操作工具类，以下是示例代码：
public void list() {
List blogList = CacheKit. get(“blog”, “blogList”);
if (blogList == null) {
blogList = Blog. dao.find(“select * from blog”); CacheKit. put(“blog”, “blogList”, blogList);
}
setAttr(“blogList”, blogList); render(“blog.html”);
}
CacheKit 中最重要的两个方法是 get(String cacheName, Object key)与 put(String cacheName,Object key, Object value)。get 方法是从 cache 中取数据，put 方法是将数据放入 cache。参数 cacheName 与 ehcache.xml 中的 name 属性值对应；参数 key 是指取值用 到的 key；参数 value 是被缓存的数据。
以下代码是 CacheKit 中重载的 CacheKit.get(String, String, IDataLoader)方法使用示例：
public void list() {</description></item><item><title>五十五、6.6 ehcache.xml 简介</title><link>https://www.shellio.cc/docs/java/jfinal/55/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/jfinal/55/</guid><description>EhCache 的使用需要有 ehcache.xml 配置文件支持，该配置文件中配置了很多 cache 节点， 每个 cache 节点会配置一个 name 属性，例如： ，该属性是 CacheKit 取值所必须的。其它配置项如 eternal、 overflowToDisk、timeToIdleSeconds、 timeToLiveSeconds 详见 EhCache 官方文档。</description></item><item><title>五十一、6.2 EhCachePlugin</title><link>https://www.shellio.cc/docs/java/jfinal/51/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/jfinal/51/</guid><description>EhCachePlugin 是作为 JFinal 的 Plugin 而存在的，所以使用时需要在 JFinalConfig 中配置EhCachePlugin，以下是 Plugin 配置示例代码：
public class DemoConfig extends JFinalConfig {
public void configPlugin(Plugins me) { me.add( new EhCachePlugin());
}
}</description></item><item><title>一、JFinal 摘要</title><link>https://www.shellio.cc/docs/java/jfinal/1/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/jfinal/1/</guid><description>JFinal 是基于 Java 语言的极速 WEB + ORM 开发框架，其核心设计目标是开发迅速、代 码量少、学习简单、功能强大、轻量级、易扩展、Restful。在拥有 Java语言所有优势的同时 再拥有 ruby、python、php 等动态语言的开发效率！为您节约更多时间，去陪恋人、家人和朋 友 : )
JFinal 有如下主要特点： MVC 架构，设计精巧，使用简单 遵循 COC 原则，零配置，无 xml 独创 Db + Record 模式，灵活便利 ActiveRecord 支持，使数据库开发极致快速 自动加载修改后的 java 文件，开发过程中无需重启 web server AOP 支持，拦截器配置灵活，功能强大 Plugin 体系结构，扩展性强 多视图支持，支持 FreeMarker、JSP、Velocity 强大的 Validator 后端校验功能 功能齐全，拥有 struts2 绝大部分核心功能 体积小仅 303K，且无第三方依赖 JFinal 官方网站：http://www.jfinal.com
JFinal 官方 QQ 群: 322076903、432462639
JFinal 官方微信:</description></item></channel></rss>