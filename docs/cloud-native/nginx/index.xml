<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Nginx on 程序员安仔</title><link>https://www.hotmindshare.com/docs/cloud-native/nginx/</link><description>Recent content in Nginx on 程序员安仔</description><generator>Hugo -- gohugo.io</generator><language>zh-hans</language><copyright>粤ICP备2023148789号</copyright><atom:link href="https://www.hotmindshare.com/docs/cloud-native/nginx/index.xml" rel="self" type="application/rss+xml"/><item><title>八、Nginx 的模块化体系结构</title><link>https://www.hotmindshare.com/docs/cloud-native/nginx/8/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.hotmindshare.com/docs/cloud-native/nginx/8/</guid><description>Nginx 的模块化体系结构 Nginx 的内部结构是由核心部分和一系列的功能模块所组成。这样划分是为了使得每个模块的功能相对简单，便于开发，同时也便于对系统进行功能扩展。为了便于描述，下文中我们将使用 Nginx core 来称呼 Nginx 的核心功能部分。
Nginx 提供了 Web 服务器的基础功能，同时提供了 Web 服务反向代理，Email 服务反向代理功能。Nginx core实现了底层的通讯协议，为其他模块和 Nginx 进程构建了基本的运行时环境，并且构建了其他各模块的协作基础。除此之外，或者说大部分与协议相关的，或者应用相关的功能都是在这些模块中所实现的。
模块概述 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 Nginx 将各功能模块组织成一条链，当有请求到达的时候，请求依次经过这条链上的部分或者全部模块，进行处理。每个模块实现特定的功能。例如，实现对请求解压缩的模块，实现 SSI 的模块，实现与上游服务器进行通讯的模块，实现与 FastCGI 服务进行通讯的模块。
有两个模块比较特殊，他们居于 Nginx core 和各功能模块的中间。这两个模块就是 http 模块和 mail 模块。这 2 个模块在 Nginx core 之上实现了另外一层抽象，处理与 HTTP 协议和 Email 相关协议（SMTP/POP3/IMAP）有关的事件，并且确保这些事件能被以正确的顺序调用其他的一些功能模块。
目前HTTP 协议是被实现在 http 模块中的，但是有可能将来被剥离到一个单独的模块中，以扩展 Nginx 支持 SPDY 协议。
模块的分类 Nginx 的模块根据其功能基本上可以分为以下几种类型：
event module: 搭建了独立于操作系统的事件处理机制的框架，及提供了各具体事件的处理。包括 ngx_events_module， ngx_event_core_module和ngx_epoll_module 等。Nginx 具体使用何种事件处理模块，这依赖于具体的操作系统和编译选项。 phase handler: 此类型的模块也被直接称为 handler 模块。主要负责处理客户端请求并产生待响应内容，比如 ngx_http_static_module 模块，负责客户端的静态页面请求处理并将对应的磁盘文件准备为响应内容输出。 output filter: 也称为 filter 模块，主要是负责对输出的内容进行处理，可以对输出进行修改。例如，可以实现对输出的所有 html 页面增加预定义的 footbar 一类的工作，或者对输出的图片的 URL 进行替换之类的工作。 upstream: upstream 模块实现反向代理的功能，将真正的请求转发到后端服务器上，并从后端服务器上读取响应，发回客户端。upstream 模块是一种特殊的 handler，只不过响应内容不是真正由自己产生的，而是从后端服务器上读取的。 load-balancer: 负载均衡模块，实现特定的算法，在众多的后端服务器中，选择一个服务器出来作为某个请求的转发服务器。</description></item><item><title>二、什么是 Nginx</title><link>https://www.hotmindshare.com/docs/cloud-native/nginx/2/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.hotmindshare.com/docs/cloud-native/nginx/2/</guid><description>什么是 Nginx Nginx 是俄罗斯人编写的十分轻量级的 HTTP 服务器,Nginx，它的发音为“engine X”，是一个高性能的HTTP和反向代理服务器，同时也是一个 IMAP/POP3/SMTP 代理服务器。Nginx 是由俄罗斯人 Igor Sysoev 为俄罗斯访问量第二的 Rambler.ru 站点开发的，它已经在该站点运行超过两年半了。Igor Sysoev 在建立的项目时,使用基于 BSD 许可。
英文主页：http://nginx.net 。
到2013 年，目前有很多国内网站采用 Nginx 作为 Web 服务器，如国内知名的新浪、163、腾讯、Discuz、豆瓣等。据 netcraft 统计，Nginx 排名第 3，约占 15% 的份额(参见：http://news.netcraft.com/archives/category/web-server-survey/ )
Nginx 以事件驱动的方式编写，所以有非常好的性能，同时也是一个非常高效的反向代理、负载平衡。其拥有匹配 Lighttpd 的性能，同时还没有 Lighttpd 的内存泄漏问题，而且 Lighttpd 的 mod_proxy 也有一些问题并且很久没有更新。
现在，Igor 将源代码以类 BSD 许可证的形式发布。Nginx 因为它的稳定性、丰富的模块库、灵活的配置和低系统资源的消耗而闻名．业界一致认为它是 Apache2.2＋mod_proxy_balancer 的轻量级代替者，不仅是因为响应静态页面的速度非常快，而且它的模块数量达到 Apache 的近 2/3。对 proxy 和 rewrite 模块的支持很彻底，还支持 mod_fcgi、ssl、vhosts ，适合用来做 mongrel clusters 的前端 HTTP 响应。</description></item><item><title>二十、Nginx upstream 模块简介</title><link>https://www.hotmindshare.com/docs/cloud-native/nginx/20/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.hotmindshare.com/docs/cloud-native/nginx/20/</guid><description>upstream 模块简介 Nginx 模块一般被分成三大类：handler、filter 和 upstream。前面的章节中，读者已经了解了 handler、filter。利用这两类模块，可以使 Nginx 轻松完成任何单机工作。而本章介绍的 upstream 模块，将使 Nginx 跨越单机的限制，完成网络数据的接收、处理和转发。
数据转发功能，为 Nginx 提供了跨越单机的横向处理能力，使 Nginx 摆脱只能为终端节点提供单一功能的限制，而使它具备了网路应用级别的拆分、封装和整合的战略功能。在云模型大行其道的今天，数据转发是 Nginx 有能力构建一个网络应用的关键组件。当然，鉴于开发成本的问题，一个网络应用的关键组件一开始往往会采用高级编程语言开发。但是当系统到达一定规模，并且需要更重视性能的时候，为了达到所要求的性能目标，高级语言开发出的组件必须进行结构化修改。此时，对于修改代价而言，Nginx 的 upstream 模块呈现出极大的吸引力，因为它天生就快。作为附带，Nginx 的配置系统提供的层次化和松耦合使得系统的扩展性也达到比较高的程度。
言归正传，下面介绍 upstream 的写法。
upstream 模块接口 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 从本质上说，upstream 属于 handler，只是他不产生自己的内容，而是通过请求后端服务器得到内容，所以才称为 upstream（上游）。请求并取得响应内容的整个过程已经被封装到 Nginx 内部，所以 upstream 模块只需要开发若干回调函数，完成构造请求和解析响应等具体的工作。
这些回调函数如下表所示：
SN 描述 create_request 生成发送到后端服务器的请求缓冲（缓冲链），在初始化 upstream 时使用。 reinit_request 在某台后端服务器出错的情况，Nginx会尝试另一台后端服务器。Nginx 选定新的服务器以后，会先调用此函数，以重新初始化 upstream 模块的工作状态，然后再次进行 upstream 连接。 process_header 处理后端服务器返回的信息头部。所谓头部是与 upstreamserver 通信的协议规定的，比如 HTTP 协议的 header 部分，或者 memcached 协议的响应状态部分。 abort_request 在客户端放弃请求时被调用。不需要在函数中实现关闭后端服务器连接的功能，系统会自动完成关闭连接的步骤，所以一般此函数不会进行任何具体工作。 finalize_request 正常完成与后端服务器的请求后调用该函数，与 abort_request 相同，一般也不会进行任何具体工作。 input_filter 处理后端服务器返回的响应正文。Nginx 默认的 input_filter 会将收到的内容封装成为缓冲区链 ngx_chain。该链由 upstream 的 out_bufs 指针域定位，所以开发人员可以在模块以外通过该指针 得到后端服务器返回的正文数据。memcached 模块实现了自己的 input_filter，在后面会具体分析这个模块。 input_filter_init 初始化 input filter 的上下文。Nginx 默认的 input_filter_init 直接返回。 memcached 模块分析 memcache 是一款高性能的分布式 cache 系统，得到了非常广泛的应用。memcache 定义了一套私有通信协议，使得不能通过 HTTP 请求来访问 memcache。但协议本身简单高效，而且 memcache 使用广泛，所以大部分现代开发语言和平台都提供了 memcache 支持，方便开发者使用 memcache。</description></item><item><title>二十二、Nginx core 模块</title><link>https://www.hotmindshare.com/docs/cloud-native/nginx/22/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.hotmindshare.com/docs/cloud-native/nginx/22/</guid><description>core 模块 Nginx 的启动模块 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 启动模块从启动 Nginx 进程开始，做了一系列的初始化工作，源代码位于src/core/nginx.c，从 main 函数开始:
时间、正则、错误日志、ssl 等初始化 读入命令行参数 OS 相关初始化 读入并解析配置 核心模块初始化 创建各种暂时文件和目录 创建共享内存 打开 listen 的端口 所有模块初始化 启动 worker 进程</description></item><item><title>二十三、Nginx event 模块</title><link>https://www.hotmindshare.com/docs/cloud-native/nginx/23/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.hotmindshare.com/docs/cloud-native/nginx/23/</guid><description>event 模块 event 的类型和功能 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 Nginx 是以 event（事件）处理模型为基础的模块。它为了支持跨平台，抽象出了 event 模块。它支持的 event 处理类型有：AIO（异步IO），/dev/poll（Solaris 和 Unix 特有），epoll（Linux 特有），eventport（Solaris 10 特有），kqueue（BSD 特有），poll，rtsig（实时信号），select 等。
event 模块的主要功能就是，监听 accept 后建立的连接，对读写事件进行添加删除。事件处理模型和 Nginx 的非阻塞 IO 模型结合在一起使用。当 IO 可读可写的时候，相应的读写事件就会被唤醒，此时就会去处理事件的回调函数。
特别对于 Linux，Nginx 大部分 event 采用 epoll EPOLLET（边沿触发）的方法来触发事件，只有 listen 端口的读事件是 EPOLLLT（水平触发）。对于边沿触发，如果出现了可读事件，必须及时处理，否则可能会出现读事件不再触发，连接饿死的情况。
1typedef struct { 2 /* 添加删除事件 */ 3 ngx_int_t (*add)(ngx_event_t *ev, ngx_int_t event, ngx_uint_t flags); 4 ngx_int_t (*del)(ngx_event_t *ev, ngx_int_t event, ngx_uint_t flags); 5 ngx_int_t (*enable)(ngx_event_t *ev, ngx_int_t event, ngx_uint_t flags); 6 ngx_int_t (*disable)(ngx_event_t *ev, ngx_int_t event, ngx_uint_t flags); 7 /* 添加删除连接，会同时监听读写事件 */ 8 ngx_int_t (*add_conn)(ngx_connection_t *c); 9 ngx_int_t (*del_conn)(ngx_connection_t *c, ngx_uint_t flags); 10 ngx_int_t (*process_changes)(ngx_cycle_t *cycle, ngx_uint_t nowait); 11 /* 处理事件的函数 */ 12 ngx_int_t (*process_events)(ngx_cycle_t *cycle, ngx_msec_t timer, 13 ngx_uint_t flags); 14 ngx_int_t (*init)(ngx_cycle_t *cycle, ngx_msec_t timer); 15 void (*done)(ngx_cycle_t *cycle); 16} ngx_event_actions_t; 上述是event 处理抽象出来的关键结构体，可以看到，每个 event 处理模型，都需要实现部分功能。最关键的是 add 和 del 功能，就是最基本的添加和删除事件的函数。</description></item><item><title>二十四、Nginx 配置文件nginx.conf中文详解</title><link>https://www.hotmindshare.com/docs/cloud-native/nginx/24/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.hotmindshare.com/docs/cloud-native/nginx/24/</guid><description>Nginx配置文件nginx.conf中文详解 1 2\#定义Nginx运行的用户和用户组 3user www www; 4#nginx进程数，建议设置为等于CPU总核心数。 5worker_processes 8; 6#全局错误日志定义类型，[ debug | info | notice | warn | error | crit ] 7error_log /usr/local/nginx/logs/error.log info; 8#进程pid文件 9pid /usr/local/nginx/logs/nginx.pid; 10#指定进程可以打开的最大描述符：数目 11#工作模式与连接数上限 12#这个指令是指当一个nginx进程打开的最多文件描述符数目，理论值应该是最多打开文件数（ulimit -n）与nginx进程数相除，但是nginx分配请求并不是那么均匀，所以最好与ulimit -n 的值保持一致。 13#现在在linux 2.6内核下开启文件打开数为65535，worker_rlimit_nofile就相应应该填写65535。 14#这是因为nginx调度时分配请求到进程并不是那么的均衡，所以假如填写10240，总并发量达到3-4万时就有进程可能超过10240了，这时会返回502错误。 15worker_rlimit_nofile 65535; 16events 17 参考事件模型，use [ kqueue | rtsig | epoll | /dev/poll | select | poll ]; epoll模型 18 是Linux 2.6以上版本内核中的高性能网络I/O模型，linux建议epoll，如果跑在FreeBSD上面，就用kqueue模型。 19 补充说明： 20 与apache相类，nginx针对不同的操作系统，有不同的事件模型 21 A）标准事件模型 22 Select、poll属于标准事件模型，如果当前系统不存在更有效的方法，nginx会选择select或poll 23 B）高效事件模型 24 Kqueue：使用于FreeBSD 4.</description></item><item><title>二十一、Nginx 负载均衡模块</title><link>https://www.hotmindshare.com/docs/cloud-native/nginx/21/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.hotmindshare.com/docs/cloud-native/nginx/21/</guid><description>负载均衡模块 负载均衡模块用于从upstream指令定义的后端主机列表中选取一台主机。Nginx 先使用负载均衡模块找到一台主机，再使用 upstream 模块实现与这台主机的交互。为了方便介绍负载均衡模块，做到言之有物，以下选取 Nginx 内置的 ip hash 模块作为实际例子进行分析。
配置 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 要了解负载均衡模块的开发方法，首先需要了解负载均衡模块的使用方法。因为负载均衡模块与之前书中提到的模块差别比较大，所以我们从配置入手比较容易理解。
在配置文件中，我们如果需要使用 ip hash 的负载均衡算法。我们需要写一个类似下面的配置：
1upstream test { 2 ip_hash; 3 server 192.168.0.1; 4 server 192.168.0.2; 从配置我们可以看出负载均衡模块的使用场景：
1、 核心指令ip_hash只能在upstream{}中使用这条指令用于通知Nginx使用iphash负载均衡算法如果没加这条指令，Nginx会使用默认的roundrobin负载均衡模块请各位读者对比handler模块的配置，是不是有共同点？；
2、 upstream{}中的指令可能出现在server指令前，可能出现在server指令后，也可能出现在两条server指令之间各位读者可能会有疑问，有什么差别么？那么请各位读者尝试下面这个配置：；
1upstream test { 2 server 192.168.0.1 weight=5; 3 ip_hash; 4 server 192.168.0.2 weight=7; 神奇的事情出现了：
1nginx: [emerg] invalid parameter &amp;#34;weight=7&amp;#34; in nginx.conf:103 2configuration file nginx.conf test failed 可见ip_hash 指令的确能影响到配置的解析。
指令 配置决定指令系统，现在就来看 ip_hash 的指令定义：
1static ngx_command_t ngx_http_upstream_ip_hash_commands[] = { 2{ ngx_string(&amp;#34;ip_hash&amp;#34;), 3 NGX_HTTP_UPS_CONF|NGX_CONF_NOARGS, 4 ngx_http_upstream_ip_hash, 5 0, 6 0, 7 NULL }, 8ngx_null_command 9}; 没有特别的东西，除了指令属性是 NGX_HTTP_UPS_CONF。这个属性表示该指令的适用范围是 upstream{}。</description></item><item><title>九、Nginx 的请求处理</title><link>https://www.hotmindshare.com/docs/cloud-native/nginx/9/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.hotmindshare.com/docs/cloud-native/nginx/9/</guid><description>Nginx 的请求处理 Nginx 使用一个多进程模型来对外提供服务，其中一个 master 进程，多个 worker 进程。master 进程负责管理 Nginx 本身和其他 worker 进程。
所有实际上的业务处理逻辑都在 worker 进程。worker 进程中有一个函数，执行无限循环，不断处理收到的来自客户端的请求，并进行处理，直到整个 Nginx 服务被停止。
worker 进程中，ngx_worker_process_cycle()函数就是这个无限循环的处理函数。在这个函数中，一个请求的简单处理流程如下：
操作系统提供的机制（例如 epoll, kqueue 等）产生相关的事件。 接收和处理这些事件，如是接受到数据，则产生更高层的 request 对象。 处理 request 的 header 和 body。 产生响应，并发送回客户端。 完成 request 的处理。 重新初始化定时器及其他事件。 请求的处理流程 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 为了让大家更好的了解 Nginx 中请求处理过程，我们以 HTTP Request 为例，来做一下详细地说明。
从Nginx 的内部来看，一个 HTTP Request 的处理过程涉及到以下几个阶段。
初始化 HTTP Request（读取来自客户端的数据，生成 HTTP Request 对象，该对象含有该请求所有的信息）。 处理请求头。 处理请求体。 如果有的话，调用与此请求（URL 或者 Location）关联的 handler。 依次调用各 phase handler 进行处理。 在这里，我们需要了解一下 phase handler 这个概念。phase 字面的意思，就是阶段。所以 phase handlers 也就好理解了，就是包含若干个处理阶段的一些 handler。</description></item><item><title>六、Nginx 基本数据结构</title><link>https://www.hotmindshare.com/docs/cloud-native/nginx/6/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.hotmindshare.com/docs/cloud-native/nginx/6/</guid><description>基本数据结构 Nginx 的作者为追求极致的高效，自己实现了很多颇具特色的 Nginx 风格的数据结构以及公共函数。比如，Nginx 提供了带长度的字符串，根据编译器选项优化过的字符串拷贝函数 ngx_copy 等。所以，在我们写 Nginx 模块时，应该尽量调用 Nginx 提供的 api，尽管有些 api 只是对 glibc 的宏定义。本节，我们介绍 string、list、buffer、chain 等一系列最基本的数据结构及相关api的使用技巧以及注意事项。
ngx_str_t 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 在Nginx 源码目录的 src/core 下面的 ngx_string.h|c 里面，包含了字符串的封装以及字符串相关操作的 api。Nginx 提供了一个带长度的字符串结构 ngx_str_t，它的原型如下：
1typedef struct { 2 size_t len; 3 u_char *data; 4} ngx_str_t; 在结构体当中，data 指向字符串数据的第一个字符，字符串的结束用长度来表示，而不是由'\\0'来表示结束。所以，在写 Nginx 代码时，处理字符串的方法跟我们平时使用有很大的不一样，但要时刻记住，字符串不以'\\0'结束，尽量使用 Nginx 提供的字符串操作的 api 来操作字符串。
那么，Nginx 这样做有什么好处呢？首先，通过长度来表示字符串长度，减少计算字符串长度的次数。其次，Nginx 可以重复引用一段字符串内存，data 可以指向任意内存，长度表示结束，而不用去 copy 一份自己的字符串(因为如果要以'\\0'结束，而不能更改原字符串，所以势必要 copy 一段字符串)。我们在 ngx_http_request_t 结构体的成员中，可以找到很多字符串引用一段内存的例子，比如 request_line、uri、args 等等，这些字符串的 data 部分，都是指向在接收数据时创建 buffer 所指向的内存中，uri，args 就没有必要 copy 一份出来。这样的话，减少了很多不必要的内存分配与拷贝。
正是基于此特性，在 Nginx 中，必须谨慎的去修改一个字符串。在修改字符串时需要认真的去考虑：是否可以修改该字符串；字符串修改后，是否会对其它的引用造成影响。在后面介绍 ngx_unescape_uri 函数的时候，就会看到这一点。但是，使用 Nginx 的字符串会产生一些问题，glibc 提供的很多系统 api 函数大多是通过'\\0'来表示字符串的结束，所以我们在调用系统 api 时，就不能直接传入 str-&amp;gt;data 了。此时，通常的做法是创建一段 str-&amp;gt;len + 1 大小的内存，然后 copy 字符串，最后一个字节置为'\\0'。比较 hack 的做法是，将字符串最后一个字符的后一个字符 backup 一个，然后设置为'\\0'，在做完调用后，再由 backup 改回来，但前提条件是，你得确定这个字符是可以修改的，而且是有内存分配，不会越界，但一般不建议这么做。接下来，看看 Nginx 提供的操作字符串相关的 api。</description></item><item><title>七、Nginx 的配置系统</title><link>https://www.hotmindshare.com/docs/cloud-native/nginx/7/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.hotmindshare.com/docs/cloud-native/nginx/7/</guid><description>Nginx 的配置系统 Nginx 的配置系统由一个主配置文件和其他一些辅助的配置文件构成。这些配置文件均是纯文本文件，全部位于Nginx 安装目录下的 conf 目录下。
配置文件中以#开始的行，或者是前面有若干空格或者 TAB，然后再跟#的行，都被认为是注释，也就是只对编辑查看文件的用户有意义，程序在读取这些注释行的时候，其实际的内容是被忽略的。
由于除主配置文件 nginx.conf 以外的文件都是在某些情况下才使用的，而只有主配置文件是在任何情况下都被使用的。所以在这里我们就以主配置文件为例，来解释 Nginx 的配置系统。
在nginx.conf 中，包含若干配置项。每个配置项由配置指令和指令参数 2 个部分构成。指令参数也就是配置指令对应的配置值。
指令概述 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 配置指令是一个字符串，可以用单引号或者双引号括起来，也可以不括。但是如果配置指令包含空格，一定要引起来。
指令参数 指令的参数使用一个或者多个空格或者 TAB 字符与指令分开。指令的参数有一个或者多个 TOKEN 串组成。TOKEN 串之间由空格或者 TAB 键分隔。
TOKEN 串分为简单字符串或者是复合配置块。复合配置块即是由大括号括起来的一堆内容。一个复合配置块中可能包含若干其他的配置指令。
如果一个配置指令的参数全部由简单字符串构成，也就是不包含复合配置块，那么我们就说这个配置指令是一个简单配置项，否则称之为复杂配置项。例如下面这个是一个简单配置项：
1error_page 500 502 503 504 /50x.html; 对于简单配置，配置项的结尾使用分号结束。对于复杂配置项，包含多个 TOKEN 串的，一般都是简单 TOKEN 串放在前面，复合配置块一般位于最后，而且其结尾，并不需要再添加分号。例如下面这个复杂配置项：
1location / { 2 root /home/jizhao/nginx-book/build/html; 3 index index.html index.htm; 指令上下文 nginx.conf 中的配置信息，根据其逻辑上的意义，对它们进行了分类，也就是分成了多个作用域，或者称之为配置指令上下文。不同的作用域含有一个或者多个配置项。
当前Nginx 支持的几个指令上下文：
main: Nginx 在运行时与具体业务功能（比如http服务或者email服务代理）无关的一些参数，比如工作进程数，运行的身份等。 http: 与提供 http 服务相关的一些配置参数。例如：是否使用 keepalive 啊，是否使用gzip进行压缩等。 server: http 服务上支持若干虚拟主机。每个虚拟主机一个对应的 server 配置项，配置项里面包含该虚拟主机相关的配置。在提供 mail 服务的代理时，也可以建立若干 server，每个 server 通过监听的地址来区分。 location: http 服务中，某些特定的URL对应的一系列配置项。 mail: 实现 email 相关的 SMTP/IMAP/POP3 代理时，共享的一些配置项（因为可能实现多个代理，工作在多个监听地址上）。 指令上下文，可能有包含的情况出现。例如：通常 http 上下文和 mail 上下文一定是出现在 main 上下文里的。在一个上下文里，可能包含另外一种类型的上下文多次。例如：如果 http 服务，支持了多个虚拟主机，那么在 http 上下文里，就会出现多个 server 上下文。</description></item><item><title>三、Nginx 的特点</title><link>https://www.hotmindshare.com/docs/cloud-native/nginx/3/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.hotmindshare.com/docs/cloud-native/nginx/3/</guid><description>Nginx 特点 Nginx 做为 HTTP 服务器，有以下几项基本特性：
处理静态文件，索引文件以及自动索引；打开文件描述符缓冲． 无缓存的反向代理加速，简单的负载均衡和容错． FastCGI，简单的负载均衡和容错． 模块化的结构。包括 gzipping, byte ranges, chunked responses,以及 SSI-filter 等 filter。如果由 FastCGI 或其它代理服务器处理单页中存在的多个 SSI，则这项处理可以并行运行，而不需要相互等待。 支持 SSL 和 TLSSNI． Nginx 专为性能优化而开发，性能是其最重要的考量,实现上非常注重效率 。它支持内核 Poll 模型，能经受高负载的考验,有报告表明能支持高达 50,000 个并发连接数。
Nginx 具有很高的稳定性。其它 HTTP 服务器，当遇到访问的峰值，或者有人恶意发起慢速连接时，也很可能会导致服务器物理内存耗尽频繁交换，失去响应，只能重启服务器。例如当前 apache 一旦上到 200 个以上进程，web响应速度就明显非常缓慢了。而 Nginx 采取了分阶段资源分配技术，使得它的 CPU 与内存占用率非常低。Nginx 官方表示保持 10,000 个没有活动的连接，它只占 2.5M 内存，所以类似 DOS 这样的攻击对 Nginx 来说基本上是毫无用处的。就稳定性而言,Nginx 比 lighthttpd 更胜一筹。
Nginx 支持热部署。它的启动特别容易, 并且几乎可以做到 7*24 不间断运行，即使运行数个月也不需要重新启动。你还能够在不间断服务的情况下，对软件版本进行进行升级。
Nginx 采用 master-slave 模型,能够充分利用 SMP 的优势，且能够减少工作进程在磁盘 I/O 的阻塞延迟。当采用 select()/poll() 调用时，还可以限制每个进程的连接数。</description></item><item><title>十、Nginx handler 模块简介</title><link>https://www.hotmindshare.com/docs/cloud-native/nginx/10/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.hotmindshare.com/docs/cloud-native/nginx/10/</guid><description>handler 模块简介 相信大家在看了前一章的模块概述以后，都对 Nginx 的模块有了一个基本的认识。基本上作为第三方开发者最可能开发的就是三种类型的模块，即 handler，filter 和 load-balancer。Handler 模块就是接受来自客户端的请求并产生输出的模块。有些地方说 upstream 模块实际上也是一种 handler 模块，只不过它产生的内容来自于从后端服务器获取的，而非在本机产生的。
在上一章提到，配置文件中使用 location 指令可以配置 content handler 模块，当 Nginx 系统启动的时候，每个 handler 模块都有一次机会把自己关联到对应的 location上。如果有多个 handler 模块都关联了同一个 location，那么实际上只有一个 handler 模块真正会起作用。当然大多数情况下，模块开发人员都会避免出现这种情况。
handler 模块处理的结果通常有三种情况: 处理成功，处理失败（处理的时候发生了错误）或者是拒绝去处理。在拒绝处理的情况下，这个 location 的处理就会由默认的 handler 模块来进行处理。例如，当请求一个静态文件的时候，如果关联到这个 location 上的一个 handler 模块拒绝处理，就会由默认的 ngx_http_static_module 模块进行处理，该模块是一个典型的 handler 模块。
本章主要讲述的是如何编写 handler 模块，在研究 handler 模块编写之前先来了解一下模块的一些基本数据结构。</description></item><item><title>十八、Nginx 过滤模块简介</title><link>https://www.hotmindshare.com/docs/cloud-native/nginx/18/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.hotmindshare.com/docs/cloud-native/nginx/18/</guid><description>过滤模块简介 执行时间和内容 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 过滤（filter）模块是过滤响应头和内容的模块，可以对回复的头和内容进行处理。它的处理时间在获取回复内容之后，向用户发送响应之前。它的处理过程分为两个阶段，过滤 HTTP 回复的头部和主体，在这两个阶段可以分别对头部和主体进行修改。
在代码中有类似的函数：
1ngx_http_top_header_filter(r); 2ngx_http_top_body_filter(r, in); 就是分别对头部和主体进行过滤的函数。所有模块的响应内容要返回给客户端，都必须调用这两个接口。
执行顺序 过滤模块的调用是有顺序的，它的顺序在编译的时候就决定了。控制编译的脚本位于 auto/modules 中，当你编译完 Nginx 以后，可以在 objs 目录下面看到一个 ngx_modules.c 的文件。打开这个文件，有类似的代码：
1ngx_module_t *ngx_modules[] = { 2 ... 3 &amp;amp;ngx_http_write_filter_module, 4 &amp;amp;ngx_http_header_filter_module, 5 &amp;amp;ngx_http_chunked_filter_module, 6 &amp;amp;ngx_http_range_header_filter_module, 7 &amp;amp;ngx_http_gzip_filter_module, 8 &amp;amp;ngx_http_postpone_filter_module, 9 &amp;amp;ngx_http_ssi_filter_module, 10 &amp;amp;ngx_http_charset_filter_module, 11 &amp;amp;ngx_http_userid_filter_module, 12 &amp;amp;ngx_http_headers_filter_module, 13 &amp;amp;ngx_http_copy_filter_module, 14 &amp;amp;ngx_http_range_body_filter_module, 15 &amp;amp;ngx_http_not_modified_filter_module, 16 NULL 17}; 从write_filter 到 not_modified_filter，模块的执行顺序是反向的。也就是说最早执行的是 not_modified_filter，然后各个模块依次执行。一般情况下，第三方过滤模块的 config 文件会将模块名追加到变量 HTTP_AUX_FILTER_MODULES 中，此时该模块只能加入到 copy_filter 和 headers_filter 模块之间执行。
Nginx 执行的时候是怎么按照次序依次来执行各个过滤模块呢？它采用了一种很隐晦的方法，即通过局部的全局变量。比如，在每个 filter 模块，很可能看到如下代码：</description></item><item><title>十二、Nginx handler 模块的基本结构</title><link>https://www.hotmindshare.com/docs/cloud-native/nginx/12/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.hotmindshare.com/docs/cloud-native/nginx/12/</guid><description>handler 模块的基本结构 除了上一节介绍的模块的基本结构以外，handler 模块必须提供一个真正的处理函数，这个函数负责对来自客户端请求的真正处理。这个函数的处理，既可以选择自己直接生成内容，也可以选择拒绝处理，由后续的 handler 去进行处理，或者是选择丢给后续的 filter 进行处理。来看一下这个函数的原型申明。
1typedef ngx_int_t (*ngx_http_handler_pt)(ngx_http_request_t *r); r是http 请求。里面包含请求所有的信息，这里不详细说明了，可以参考别的章节的介绍。 该函数处理成功返回 NGX_OK，处理发生错误返回 NGX_ERROR，拒绝处理（留给后续的 handler 进行处理）返回 NGX_DECLINE。 返回 NGX_OK 也就代表给客户端的响应已经生成好了，否则返回 NGX_ERROR 就发生错误了。</description></item><item><title>十九、Nginx 过滤模块的分析</title><link>https://www.hotmindshare.com/docs/cloud-native/nginx/19/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.hotmindshare.com/docs/cloud-native/nginx/19/</guid><description>过滤模块的分析 相关结构体 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 ngx_chain_t 结构非常简单，是一个单向链表：
1typedef struct ngx_chain_s ngx_chain_t; 2struct ngx_chain_s { 3 ngx_buf_t *buf; 4 ngx_chain_t *next; 5}; 在过滤模块中，所有输出的内容都是通过一条单向链表所组成。这种单向链表的设计，正好应和了 Nginx 流式的输出模式。每次 Nginx 都是读到一部分的内容，就放到链表，然后输出出去。这种设计的好处是简单，非阻塞，但是相应的问题就是跨链表的内容操作非常麻烦，如果需要跨链表，很多时候都只能缓存链表的内容。
单链表负载的就是 ngx_buf_t，这个结构体使用非常广泛，先让我们看下该结构体的代码：
1struct ngx_buf_s { 2 u_char *pos; /* 当前buffer真实内容的起始位置 */ 3 u_char *last; /* 当前buffer真实内容的结束位置 */ 4 off_t file_pos; /* 在文件中真实内容的起始位置 */ 5 off_t file_last; /* 在文件中真实内容的结束位置 */ 6 u_char *start; /* buffer内存的开始分配的位置 */ 7 u_char *end; /* buffer内存的结束分配的位置 */ 8 ngx_buf_tag_t tag; /* buffer属于哪个模块的标志 */ 9 ngx_file_t *file; /* buffer所引用的文件 */ 10 /* 用来引用替换过后的buffer，以便当所有buffer输出以后， 11 * 这个影子buffer可以被释放。 12 */ 13 ngx_buf_t *shadow; 14 /* the buf&amp;#39;s content could be changed */ 15 unsigned temporary:1; 16 /* 17 * the buf&amp;#39;s content is in a memory cache or in a read only memory 18 * and must not be changed 19 */ 20 unsigned memory:1; 21 /* the buf&amp;#39;s content is mmap()ed and must not be changed */ 22 unsigned mmap:1; 23 unsigned recycled:1; /* 内存可以被输出并回收 */ 24 unsigned in_file:1; /* buffer的内容在文件中 */ 25 /* 马上全部输出buffer的内容, gzip模块里面用得比较多 */ 26 unsigned flush:1; 27 /* 基本上是一段输出链的最后一个buffer带的标志，标示可以输出， 28 * 有些零长度的buffer也可以置该标志 29 */ 30 unsigned sync:1; 31 /* 所有请求里面最后一块buffer，包含子请求 */ 32 unsigned last_buf:1; 33 /* 当前请求输出链的最后一块buffer */ 34 unsigned last_in_chain:1; 35 /* shadow链里面的最后buffer，可以释放buffer了 */ 36 unsigned last_shadow:1; 37 /* 是否是暂存文件 */ 38 unsigned temp_file:1; 39 /* 统计用，表示使用次数 */ 40 /* STUB */ int num; 41}; 一般buffer 结构体可以表示一块内存，内存的起始和结束地址分别用 start 和 end 表示，pos 和 last 表示实际的内容。如果内容已经处理过了，pos 的位置就可以往后移动。如果读取到新的内容，last 的位置就会往后移动。所以 buffer 可以在多次调用过程中使用。如果 last 等于 end，就说明这块内存已经用完了。如果 pos 等于 last，说明内存已经处理完了。下面是一个简单的示意图，说明 buffer 中指针的用法：</description></item><item><title>十六、Nginx handler 模块的编译和使用</title><link>https://www.hotmindshare.com/docs/cloud-native/nginx/16/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.hotmindshare.com/docs/cloud-native/nginx/16/</guid><description>handler 模块的编译和使用 模块的功能开发完了之后，模块的使用还需要编译才能够执行，下面我们来看下模块的编译和使用。
config 文件的编写 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 对于开发一个模块，我们是需要把这个模块的 C 代码组织到一个目录里，同时需要编写一个 config 文件。这个 config 文件的内容就是告诉 Nginx 的编译脚本，该如何进行编译。我们来看一下 hello handler module 的 config 文件的内容，然后再做解释。
1ngx_addon_name=ngx_http_hello_module 2HTTP_MODULES=&amp;#34;$HTTP_MODULES ngx_http_hello_module&amp;#34; 3NGX_ADDON_SRCS=&amp;#34;$NGX_ADDON_SRCS $ngx_addon_dir/ngx_http_hello_module.c&amp;#34; 其实文件很简单，几乎不需要做什么解释。大家一看都懂了。唯一需要说明的是，如果这个模块的实现有多个源文件，那么都在 NGX_ADDON_SRCS 这个变量里，依次写进去就可以。
编译 对于模块的编译，Nginx 并不像 apache 一样，提供了单独的编译工具，可以在没有 apache 源代码的情况下来单独编译一个模块的代码。Nginx 必须去到 Nginx 的源代码目录里，通过 configure 指令的参数，来进行编译。下面看一下 hello module 的 configure 指令：
1./configure --prefix=/usr/local/nginx-1.3.1 --add-module=/home/jizhao/open_source/book_module 我写的这个示例模块的代码和 config 文件都放在/home/jizhao/open_source/book_module这个目录下。所以一切都很明了，也没什么好说的了。
使用 使用一个模块需要根据这个模块定义的配置指令来做。比如我们这个简单的 hello handler module 的使用就很简单。在我的测试服务器的配置文件里，就是在 http 里面的默认的 server 里面加入如下的配置：
1location /test { 2 hello_string jizhao; 3 hello_counter on; 当我们访问这个地址的时候, lynx http://127.</description></item><item><title>十七、Nginx 更多 handler 模块示例分析</title><link>https://www.hotmindshare.com/docs/cloud-native/nginx/17/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.hotmindshare.com/docs/cloud-native/nginx/17/</guid><description>更多 handler 模块示例分析 http access module 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 该模块的代码位于src/http/modules/ngx_http_access_module.c中。该模块的作用是提供对于特定 host 的客户端的访问控制。可以限定特定 host 的客户端对于服务端全部，或者某个 server，或者是某个 location 的访问。
该模块的实现非常简单，总共也就只有几个函数。
1static ngx_int_t ngx_http_access_handler(ngx_http_request_t *r); 2static ngx_int_t ngx_http_access_inet(ngx_http_request_t *r, 3 ngx_http_access_loc_conf_t *alcf, in_addr_t addr); 4#if (NGX_HAVE_INET6) 5static ngx_int_t ngx_http_access_inet6(ngx_http_request_t *r, 6 ngx_http_access_loc_conf_t *alcf, u_char *p); 7#endif 8static ngx_int_t ngx_http_access_found(ngx_http_request_t *r, ngx_uint_t deny); 9static char *ngx_http_access_rule(ngx_conf_t *cf, ngx_command_t *cmd, 10 void *conf); 11static void *ngx_http_access_create_loc_conf(ngx_conf_t *cf); 12static char *ngx_http_access_merge_loc_conf(ngx_conf_t *cf, 13 void *parent, void *child); 14static ngx_int_t ngx_http_access_init(ngx_conf_t *cf); 对于与配置相关的几个函数都不需要做解释了，需要提一下的是函数 ngx_http_access_init，该函数在实现上把本模块挂载到了 NGX_HTTP_ACCESS_PHASE 阶段的 handler 上，从而使自己的被调用时机发生在了 NGX_HTTP_CONTENT_PHASE 等阶段前。因为进行客户端地址的限制检查，根本不需要等到这么后面。</description></item><item><title>十三、Nginx handler 模块的挂载</title><link>https://www.hotmindshare.com/docs/cloud-native/nginx/13/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.hotmindshare.com/docs/cloud-native/nginx/13/</guid><description>handler 模块的挂载 handler 模块真正的处理函数通过两种方式挂载到处理过程中，一种方式就是按处理阶段挂载;另外一种挂载方式就是按需挂载。
按处理阶段挂载 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 为了更精细地控制对于客户端请求的处理过程，Nginx 把这个处理过程划分成了 11 个阶段。他们从前到后，依次列举如下：
NGX_HTTP_POST_READ_PHASE: 读取请求内容阶段 NGX_HTTP_SERVER_REWRITE_PHASE: Server 请求地址重写阶段 NGX_HTTP_FIND_CONFIG_PHASE: 配置查找阶段: NGX_HTTP_REWRITE_PHASE: Location 请求地址重写阶段 NGX_HTTP_POST_REWRITE_PHASE: 请求地址重写提交阶段 NGX_HTTP_PREACCESS_PHASE: 访问权限检查准备阶段 NGX_HTTP_ACCESS_PHASE: 访问权限检查阶段 NGX_HTTP_POST_ACCESS_PHASE: 访问权限检查提交阶段 NGX_HTTP_TRY_FILES_PHASE: 配置项 try_files 处理阶段 NGX_HTTP_CONTENT_PHASE: 内容产生阶段 NGX_HTTP_LOG_PHASE: 日志模块处理阶段 一般情况下，我们自定义的模块，大多数是挂载在 NGX_HTTP_CONTENT_PHASE 阶段的。挂载的动作一般是在模块上下文调用的 postconfiguration 函数中。
注意：有几个阶段是特例，它不调用挂载地任何的handler，也就是你就不用挂载到这几个阶段了：
NGX_HTTP_FIND_CONFIG_PHASE NGX_HTTP_POST_ACCESS_PHASE NGX_HTTP_POST_REWRITE_PHASE NGX_HTTP_TRY_FILES_PHASE 所以其实真正是有 7 个 phase 你可以去挂载 handler。
挂载的代码如下（摘自 hello module）:
1static ngx_int_t 2ngx_http_hello_init(ngx_conf_t *cf) 3 ngx_http_handler_pt *h; 4 ngx_http_core_main_conf_t *cmcf; 5 cmcf = ngx_http_conf_get_module_main_conf(cf, ngx_http_core_module); 6 h = ngx_array_push(&amp;amp;cmcf-&amp;gt;phases[NGX_HTTP_CONTENT_PHASE].</description></item><item><title>十四、Nginx handler 的编写步骤</title><link>https://www.hotmindshare.com/docs/cloud-native/nginx/14/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.hotmindshare.com/docs/cloud-native/nginx/14/</guid><description>handler 的编写步骤 好，到了这里，让我们稍微整理一下思路，回顾一下实现一个 handler 的步骤:
1、 编写模块基本结构包括模块的定义，模块上下文结构，模块的配置结构等；
2、 实现handler的挂载函数根据模块的需求选择正确的挂载方式；
3、 编写handler处理函数模块的功能主要通过这个函数来完成；
看起来不是那么难，对吧？还是那句老话，世上无难事，只怕有心人! 现在我们来完整的分析前面提到的 hello handler module 示例的功能和代码。</description></item><item><title>十五、Nginx 示例-hello handler 模块</title><link>https://www.hotmindshare.com/docs/cloud-native/nginx/15/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.hotmindshare.com/docs/cloud-native/nginx/15/</guid><description>示例: hello handler 模块 在前面已经看到了这个 hello handler module 的部分重要的结构。该模块提供了 2 个配置指令，仅可以出现在 location 指令的作用域中。这两个指令是 hello_string, 该指令接受一个参数来设置显示的字符串。如果没有跟参数，那么就使用默认的字符串作为响应字符串。
另一个指令是 hello_counter，如果设置为 on，则会在响应的字符串后面追加 Visited Times:的字样，以统计请求的次数。
这里有两点注意一下：
1、 对于flag类型的配置指令，当值为off的时候，使用ngx_conf_set_flag_slot函数，会转化为0，为on，则转化为非0；
2、 另外一个是，我提供了merge_loc_conf函数，但是却没有设置到模块的上下文定义中这样有一个缺点，就是如果一个指令没有出现在配置文件中的时候，配置信息中的值，将永远会保持在create_loc_conf中的初始化的值那如果，在类似create_loc_conf这样的函数中，对创建出来的配置信息的值，没有设置为合理的值的话，后面用户又没有配置，就会出现问题；
下面来完整的给出 ngx_http_hello_module 模块的完整代码。
1#include &amp;lt;ngx_config.h&amp;gt; 2#include &amp;lt;ngx_core.h&amp;gt; 3#include &amp;lt;ngx_http.h&amp;gt; 4typedef struct 5 ngx_str_t hello_string; 6 ngx_int_t hello_counter; 7}ngx_http_hello_loc_conf_t; 8static ngx_int_t ngx_http_hello_init(ngx_conf_t *cf); 9static void *ngx_http_hello_create_loc_conf(ngx_conf_t *cf); 10static char *ngx_http_hello_string(ngx_conf_t *cf, ngx_command_t *cmd, 11 void *conf); 12static char *ngx_http_hello_counter(ngx_conf_t *cf, ngx_command_t *cmd, 13 void *conf); 14static ngx_command_t ngx_http_hello_commands[] = { 15 { 16 ngx_string(&amp;#34;hello_string&amp;#34;), 17 NGX_HTTP_LOC_CONF|NGX_CONF_NOARGS|NGX_CONF_TAKE1, 18 ngx_http_hello_string, 19 NGX_HTTP_LOC_CONF_OFFSET, 20 offsetof(ngx_http_hello_loc_conf_t, hello_string), 21 NULL }, 22 { 23 ngx_string(&amp;#34;hello_counter&amp;#34;), 24 NGX_HTTP_LOC_CONF|NGX_CONF_FLAG, 25 ngx_http_hello_counter, 26 NGX_HTTP_LOC_CONF_OFFSET, 27 offsetof(ngx_http_hello_loc_conf_t, hello_counter), 28 NULL }, 29 ngx_null_command 30}; 31/* 32static u_char ngx_hello_default_string[] = &amp;#34;Default String: Hello, world!</description></item><item><title>十一、Nginx 模块的基本结构</title><link>https://www.hotmindshare.com/docs/cloud-native/nginx/11/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.hotmindshare.com/docs/cloud-native/nginx/11/</guid><description>模块的基本结构 在这一节我们将会对通常的模块开发过程中，每个模块所包含的一些常用的部分进行说明。这些部分有些是必须的，有些不是必须的。同时这里所列出的这些东西对于其他类型的模块，例如 filter 模块等也都是相同的。
模块配置结构 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 基本上每个模块都会提供一些配置指令，以便于用户可以通过配置来控制该模块的行为。那么这些配置信息怎么存储呢？那就需要定义该模块的配置结构来进行存储。
大家都知道 Nginx 的配置信息分成了几个作用域(scope,有时也称作上下文)，这就是 main，server 以及 location。同样的每个模块提供的配置指令也可以出现在这几个作用域里。那对于这三个作用域的配置信息，每个模块就需要定义三个不同的数据结构去进行存储。当然，不是每个模块都会在这三个作用域都提供配置指令的。那么也就不一定每个模块都需要定义三个数据结构去存储这些配置信息了。视模块的实现而言，需要几个就定义几个。
有一点需要特别注意的就是，在模块的开发过程中，我们最好使用 Nginx 原有的命名习惯。这样跟原代码的契合度更高，看起来也更舒服。
对于模块配置信息的定义，命名习惯是ngx_http_&amp;lt;module name&amp;gt;_(main|srv|loc)_conf_t。这里有个例子，就是从我们后面将要展示给大家的 hello module 中截取的。
1typedef struct 2 ngx_str_t hello_string; 3 ngx_int_t hello_counter; 4}ngx_http_hello_loc_conf_t; 模块配置指令 一个模块的配置指令是定义在一个静态数组中的。同样地，我们来看一下从 hello module 中截取的模块配置指令的定义。
1static ngx_command_t ngx_http_hello_commands[] = { 2 { 3 ngx_string(&amp;#34;hello_string&amp;#34;), 4 NGX_HTTP_LOC_CONF|NGX_CONF_NOARGS|NGX_CONF_TAKE1, 5 ngx_http_hello_string, 6 NGX_HTTP_LOC_CONF_OFFSET, 7 offsetof(ngx_http_hello_loc_conf_t, hello_string), 8 NULL }, 9 { 10 ngx_string(&amp;#34;hello_counter&amp;#34;), 11 NGX_HTTP_LOC_CONF|NGX_CONF_FLAG, 12 ngx_http_hello_counter, 13 NGX_HTTP_LOC_CONF_OFFSET, 14 offsetof(ngx_http_hello_loc_conf_t, hello_counter), 15 NULL }, 16 ngx_null_command 17}; 其实看这个定义，就基本能看出来一些信息。例如，我们是定义了两个配置指令，一个是叫 hello_string，可以接受一个参数，或者是没有参数。另外一个命令是 hello_counter，接受一个 NGX_CONF_FLAG 类型的参数。除此之外，似乎看起来有点迷惑。没有关系，我们来详细看一下 ngx_command_t，一旦我们了解这个结构的详细信息，那么我相信上述这个定义所表达的所有信息就不言自明了。</description></item><item><title>四、初探 Nginx 架构</title><link>https://www.hotmindshare.com/docs/cloud-native/nginx/4/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.hotmindshare.com/docs/cloud-native/nginx/4/</guid><description>初探 Nginx 架构 众所周知，Nginx 性能高，而 Nginx 的高性能与其架构是分不开的。那么 Nginx 究竟是怎么样的呢？这一节我们先来初识一下 Nginx 框架吧。
Nginx 在启动后，在 unix 系统中会以 daemon 的方式在后台运行，后台进程包含一个 master 进程和多个 worker 进程。我们也可以手动地关掉后台模式，让 Nginx 在前台运行，并且通过配置让 Nginx 取消 master 进程，从而可以使 Nginx 以单进程方式运行。很显然，生产环境下我们肯定不会这么做，所以关闭后台模式，一般是用来调试用的，在后面的章节里面，我们会详细地讲解如何调试 Nginx。所以，我们可以看到，Nginx 是以多进程的方式来工作的，当然 Nginx 也是支持多线程的方式的，只是我们主流的方式还是多进程的方式，也是 Nginx 的默认方式。Nginx 采用多进程的方式有诸多好处，所以我就主要讲解 Nginx 的多进程模式吧。
刚才讲到，Nginx 在启动后，会有一个 master 进程和多个 worker 进程。master 进程主要用来管理 worker 进程，包含：接收来自外界的信号，向各 worker 进程发送信号，监控 worker 进程的运行状态，当 worker 进程退出后(异常情况下)，会自动重新启动新的 worker 进程。而基本的网络事件，则是放在 worker 进程中来处理了。多个 worker 进程之间是对等的，他们同等竞争来自客户端的请求，各进程互相之间是独立的。一个请求，只可能在一个 worker 进程中处理，一个 worker 进程，不可能处理其它进程的请求。worker 进程的个数是可以设置的，一般我们会设置与机器cpu核数一致，这里面的原因与 Nginx 的进程模型以及事件处理模型是分不开的。Nginx 的进程模型，可以由下图来表示：
在Nginx 启动后，如果我们要操作 Nginx，要怎么做呢？从上文中我们可以看到，master 来管理 worker 进程，所以我们只需要与 master 进程通信就行了。master 进程会接收来自外界发来的信号，再根据信号做不同的事情。所以我们要控制 Nginx，只需要通过 kill 向 master 进程发送信号就行了。比如kill -HUP pid，则是告诉 Nginx，从容地重启 Nginx，我们一般用这个信号来重启 Nginx，或重新加载配置，因为是从容地重启，因此服务是不中断的。master 进程在接收到 HUP 信号后是怎么做的呢？首先 master 进程在接到信号后，会先重新加载配置文件，然后再启动新的 worker 进程，并向所有老的 worker 进程发送信号，告诉他们可以光荣退休了。新的 worker 在启动后，就开始接收新的请求，而老的 worker 在收到来自 master 的信号后，就不再接收新的请求，并且在当前进程中的所有未处理完的请求处理完成后，再退出。当然，直接给 master 进程发送信号，这是比较老的操作方式，Nginx 在 0.</description></item><item><title>五、Nginx 基础概念</title><link>https://www.hotmindshare.com/docs/cloud-native/nginx/5/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.hotmindshare.com/docs/cloud-native/nginx/5/</guid><description>Nginx 基础概念 connection 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 在Nginx 中 connection 就是对 tcp 连接的封装，其中包括连接的 socket，读事件，写事件。利用 Nginx 封装的 connection，我们可以很方便的使用 Nginx 来处理与连接相关的事情，比如，建立连接，发送与接受数据等。而 Nginx 中的 http 请求的处理就是建立在 connection之上的，所以 Nginx 不仅可以作为一个web服务器，也可以作为邮件服务器。当然，利用 Nginx 提供的 connection，我们可以与任何后端服务打交道。
结合一个 tcp 连接的生命周期，我们看看 Nginx 是如何处理一个连接的。首先，Nginx 在启动时，会解析配置文件，得到需要监听的端口与 ip 地址，然后在 Nginx 的 master 进程里面，先初始化好这个监控的 socket(创建 socket，设置 addrreuse 等选项，绑定到指定的 ip 地址端口，再 listen)，然后再 fork 出多个子进程出来，然后子进程会竞争 accept 新的连接。此时，客户端就可以向 Nginx 发起连接了。当客户端与服务端通过三次握手建立好一个连接后，Nginx 的某一个子进程会 accept 成功，得到这个建立好的连接的 socket，然后创建 Nginx 对连接的封装，即 ngx_connection_t 结构体。接着，设置读写事件处理函数并添加读写事件来与客户端进行数据的交换。最后，Nginx 或客户端来主动关掉连接，到此，一个连接就寿终正寝了。
当然，Nginx 也是可以作为客户端来请求其它 server 的数据的（如 upstream 模块），此时，与其它 server 创建的连接，也封装在 ngx_connection_t 中。作为客户端，Nginx 先获取一个 ngx_connection_t 结构体，然后创建 socket，并设置 socket 的属性（ 比如非阻塞）。然后再通过添加读写事件，调用 connect/read/write 来调用连接，最后关掉连接，并释放 ngx_connection_t。</description></item><item><title>一、关于 Nginx</title><link>https://www.hotmindshare.com/docs/cloud-native/nginx/1/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.hotmindshare.com/docs/cloud-native/nginx/1/</guid><description>Nginx 入门指南 Nginx 是一款轻量级的 Web 服务器/反向代理服务器及电子邮件（IMAP/POP3）代理服务器，其特点是占有内存少，并发能力强。
本教程根据淘宝核心系统服务器平台组的成员的日常工作总结而成，主要介绍了 Nginx 平台的特点及模块开发，帮助读者更好的构建和维护 Nginx 服务器。
适用人群 高性能Web 服务器维护人员，对互联网服务器感兴趣的程序开发者。
学习前提 学习本教程前，我们假定您已经能够搭 Nginx 服务器，并能够进行简单常规的操作。
鸣谢：淘宝核心系统服务器平台组成员
版本信息 书中演示代码基于以下版本：
框架 版本信息 Nginx 1.3.13开发版本</description></item></channel></rss>