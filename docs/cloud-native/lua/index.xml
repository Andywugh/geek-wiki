<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Lua on 程序员安仔</title><link>https://www.hotmindshare.com/docs/cloud-native/lua/</link><description>Recent content in Lua on 程序员安仔</description><generator>Hugo -- gohugo.io</generator><language>zh-hans</language><copyright>粤ICP备2023148789号</copyright><atom:link href="https://www.hotmindshare.com/docs/cloud-native/lua/index.xml" rel="self" type="application/rss+xml"/><item><title>八、Lua 函数</title><link>https://www.hotmindshare.com/docs/cloud-native/lua/8/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.hotmindshare.com/docs/cloud-native/lua/8/</guid><description>Lua 函数 在Lua中，函数是对语句和表达式进行抽象的主要方法。既可以用来处理一些特殊的工作，也可以用来计算一些值。
Lua提供了许多的内建函数，你可以很方便的在程序中调用它们，如print()函数可以将传入的参数打印在控制台上。
Lua函数主要有两种用途：
1.完成指定的任务，这种情况下函数作为调用语句使用； 2.计算并返回值，这种情况下函数作为赋值语句的表达式使用。 函数定义 Lua编程语言函数定义格式如下：
1optional_function_scope function function_name( argument1, argument2, argument3..., argumentn) 2 function_body 3 return result_params_comma_separated 4end 解析：
optional_function_scope local function_name: argument1, argument2, argument3…, argumentn: function_body: result_params_comma_separated: 实例 以下实例定义了函数 max()，参数为 num1, num2，用于比较两值的大小，并返回最大值： \\start --[[ 函数返回两个值的最大值 –]] function max(num1, num2) if (num1 &amp;gt; num2) then result = num1; else result = num2; end return result; end — 调用函数 print(“两值比较最大值为 “,max(10,4)) print(“两值比较最大值为 “,max(5,6))
```end
以上代码执行结果为： \\start 两值比较最大值为 10 两值比较最大值为 6</description></item><item><title>二、Lua 环境安装</title><link>https://www.hotmindshare.com/docs/cloud-native/lua/2/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.hotmindshare.com/docs/cloud-native/lua/2/</guid><description>Lua 环境安装 Linux 系统上安装 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 Linux &amp;amp; Mac上安装 Lua 安装非常简单，只需要下载源码包并在终端解压编译即可，本文使用了5.3.0版本进行安装：
1curl -R -O http://www.lua.org/ftp/lua-5.3.0.tar.gz 2tar zxf lua-5.3.0.tar.gz 3cd lua-5.3.0 4make linux test 5make install Mac OS X 系统上安装 1curl -R -O http://www.lua.org/ftp/lua-5.3.0.tar.gz 2tar zxf lua-5.3.0.tar.gz 3cd lua-5.3.0 4make macosx test 5make install 接下来我们创建一个 helloWorld.lua:
1print(&amp;#34;Hello World!&amp;#34;) 执行以下命令:
1$ lua helloWorld 输出结果为：
1Hello World! Window 系统上安装 Lua window下你可以使用一个叫”SciTE”的IDE环境来执行lua程序，下载地址为：
Github 下载地址：https://github.com/rjpcomputing/luaforwindows/releases 双击安装后即可在该环境下编写 Lua 程序并运行。
你也可以使用 Lua 官方推荐的方法使用 LuaDist：http://luadist.org/
如果安装的时候报错: lua.c:80:31: fatal error: readline/readline.</description></item><item><title>二十、Lua 垃圾回收</title><link>https://www.hotmindshare.com/docs/cloud-native/lua/20/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.hotmindshare.com/docs/cloud-native/lua/20/</guid><description>Lua 垃圾回收 Lua采用了自动内存管理。 这意味着你不用操心新创建的对象需要的内存如何分配出来， 也不用考虑在对象不再被使用后怎样释放它们所占用的内存。
Lua运行了一个垃圾收集器来收集所有死对象 （即在 Lua 中不可能再访问到的对象）来完成自动内存管理的工作。 Lua 中所有用到的内存，如：字符串、表、用户数据、函数、线程、 内部结构等，都服从自动管理。
Lua实现了一个增量标记-扫描收集器。 它使用这两个数字来控制垃圾收集循环： 垃圾收集器间歇率和垃圾收集器步进倍率。 这两个数字都使用百分数为单位 （例如：值 100 在内部表示 1 ）。
垃圾收集器间歇率控制着收集器需要在开启新的循环前要等待多久。 增大这个值会减少收集器的积极性。 当这个值比 100 小的时候，收集器在开启新的循环前不会有等待。 设置这个值为 200 就会让收集器等到总内存使用量达到 之前的两倍时才开始新的循环。
垃圾收集器步进倍率控制着收集器运作速度相对于内存分配速度的倍率。 增大这个值不仅会让收集器更加积极，还会增加每个增量步骤的长度。 不要把这个值设得小于 100 ， 那样的话收集器就工作的太慢了以至于永远都干不完一个循环。 默认值是 200 ，这表示收集器以内存分配的”两倍”速工作。
如果你把步进倍率设为一个非常大的数字 （比你的程序可能用到的字节数还大 10% ）， 收集器的行为就像一个 stop-the-world 收集器。 接着你若把间歇率设为 200 ， 收集器的行为就和过去的 Lua 版本一样了： 每次 Lua 使用的内存翻倍时，就做一次完整的收集。
垃圾回收器函数 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 Lua提供了以下函数**collectgarbage ([opt [, arg]])**用来控制自动内存管理:
collectgarbage(“collect”): 做一次完整的垃圾收集循环。通过参数 opt 它提供了一组不同的功能： collectgarbage(“count”): 以 K 字节数为单位返回 Lua 使用的总内存数。 这个值有小数部分，所以只需要乘上 1024 就能得到 Lua 使用的准确字节数（除非溢出）。 collectgarbage(“restart”): 重启垃圾收集器的自动运行。 collectgarbage(“setpause”): 将 arg 设为收集器的 间歇率 （参见 §2.</description></item><item><title>二十八、Lua 如何输出树状结构的table？</title><link>https://www.hotmindshare.com/docs/cloud-native/lua/28/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.hotmindshare.com/docs/cloud-native/lua/28/</guid><description>为了让游戏前端数据输出更加条理，做了一个简单树状结构来打印数据。
ccmlog.lua
1local function __tostring(value, indent, vmap) 2 local str = &amp;#39;&amp;#39; 3 indent = indent or &amp;#39;&amp;#39; 4 vmap = vmap or {} 5 --递归结束条件 6 if (type(value) ~= &amp;#39;table&amp;#39;) then 7 if (type(value) == &amp;#39;string&amp;#39;) then 8 --字符串 9 str = string.format(&amp;#34;[[%s]]&amp;#34;, value) 10 else 11 --整数 12 str = tostring(value) 13 end 14 else 15 if type(vmap) == &amp;#39;table&amp;#39; then 16 if vmap[value] then return &amp;#39;(&amp;#39;..tostring(value)..&amp;#39;)&amp;#39; end 17 vmap[value] = true 18 end 19 local auxTable = {} --保存元表KEY(非整数) 20 local iauxTable = {} --保存元表value 21 local iiauxTable = {} --保存数组(key为0) 22 table.</description></item><item><title>二十二、Lua 数据库访问</title><link>https://www.hotmindshare.com/docs/cloud-native/lua/22/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.hotmindshare.com/docs/cloud-native/lua/22/</guid><description>Lua 数据库访问 本文主要为大家介绍 Lua 数据库的操作库：LuaSQL。他是开源的，支持的数据库有：ODBC, ADO, Oracle, MySQL, SQLite 和 PostgreSQL。
本文为大家介绍MySQL的数据库连接。
LuaSQL 可以使用 LuaRocks 来安装可以根据需要安装你需要的数据库驱动。
LuaRocks 安装方法：
1$ wget http://luarocks.org/releases/luarocks-2.2.1.tar.gz 2$ tar zxpf luarocks-2.2.1.tar.gz 3$ cd luarocks-2.2.1 4$ ./configure; sudo make bootstrap 5$ sudo luarocks install luasocket 6$ lua 7Lua 5.3.0 Copyright (C) 1994-2015 Lua.org, PUC-Rio 8&amp;gt; require &amp;#34;socket&amp;#34; Window 下安装 LuaRocks：https://github.com/keplerproject/luarocks/wiki/Installation-instructions-for-Windows 安装不同数据库驱动：
1luarocks install luasql-sqlite3 2luarocks install luasql-postgres 3luarocks install luasql-mysql 4luarocks install luasql-sqlite 5luarocks install luasql-odbc 你也可以使用源码安装方式，Lua Github 源码地址：https://github.</description></item><item><title>二十九、Lua中的元表与元方法</title><link>https://www.hotmindshare.com/docs/cloud-native/lua/29/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.hotmindshare.com/docs/cloud-native/lua/29/</guid><description>前言 Lua中每个值都可具有元表。 元表是普通的Lua表，定义了原始值在某些特定操作下的行为。你可通过在值的原表中设置特定的字段来改变作用于该值的操作的某些行为特征。
例如，当数字值作为加法的操作数时，Lua检查其元表中的”__add”字段是否有个函数。如果有，Lua调用它执行加法。
我们称元表中的键为事件（event），称值为元方法（metamethod）。前述例子中的事件是”add”，元方法是执行加法的函数。
可通过函数getmetatable查询任何值的元表。
在table中，我可以重新定义的元方法有以下几个：
1__add(a, b) --加法 2__sub(a, b) --减法 3__mul(a, b) --乘法 4__div(a, b) --除法 5__mod(a, b) --取模 6__pow(a, b) --乘幂 7__unm(a) --相反数 8__concat(a, b) --连接 9__len(a) --长度 10__eq(a, b) --相等 11__lt(a, b) --小于 12__le(a, b) --小于等于 13__index(a, b) --索引查询 14__newindex(a, b, c) --索引更新（PS：不懂的话，后面会有讲） 15__call(a, ...) --执行方法调用 16__tostring(a) --字符串输出 17__metatable --保护元表 Lua中的每一个表都有其Metatable。Lua默认创建一个不带metatable的新表
1t = {} 2print(getmetatable(t)) --&amp;gt; nil 可以使用setmetatable函数设置或者改变一个表的metatable
1t1 = {} 2setmetatable(t, t1) 3assert(getmetatable(t) == t1) 任何一个表都可以是其他一个表的metatable，一组相关的表可以共享一个metatable（描述他们共同的行为）。一个表也可以是自身的metatable（描述其私有行为）。</description></item><item><title>二十六、Lua 学习笔记之四(Lua中的基本函数库)</title><link>https://www.hotmindshare.com/docs/cloud-native/lua/26/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.hotmindshare.com/docs/cloud-native/lua/26/</guid><description>Lua中的基本函数库 表1
基本函数库
功能
参数
备注
assert(v[,mess age]) &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;
相当于C的断言
v：当表达式v为nil或false将触发错误,
message：发生错误时返回的信息，默认为”assertion failed!”
&amp;nbsp;
collectgarbage (opt [, arg])
是垃圾收集器的通用接口，用于操作垃圾收集器
opt：操作方法标志
“Stop”: 停止垃圾收集器 “Restart”: 重启垃圾收集器 “Collect”: 执行一次全垃圾收集循环
“Count”: 返回当前Lua中使用的内存量(以KB为单位)
“Step”: 单步执行一个垃圾收集. 步长 “Size” 由参数arg指定　(大型的值需要多步才能完成)，如果要准确指定步长，需要多次实验以达最优效果。如果步长完成一次收集循环，将返回True
“Setpause”: 设置 arg/100 的值作为暂定收集的时长 “Setstepmul”: 设置 arg/100 的值，作为步长的增幅(即新步长＝旧步长*arg/100)
&amp;nbsp;
dofile (filename)
打开并且执行一个lua块,当忽略参数filename时，将执行标准输入设备(stdin)的内容。返回所有块的返回值。当发生错误时，dofile将错误反射给调用者
注：dofile不能在保护模式下运行
&amp;nbsp;
error (message [, level])
终止正在执行的函数，并返回message的内容作为错误信息(error函数永远都不会返回)
通常情况下，error会附加一些错误位置的信息到message头部.
Level参数指示获得错误的位置,
Level=1[默认]：为调用error位置(文件+行号)
Level=2：指出哪个调用error的函数的函数
Level=0:不添加错误位置信息
&amp;nbsp;
_G全局环境表(全局变量)
记录全局环境的变量值的表 _G._G = _G</description></item><item><title>二十七、Lua 学习笔记之五(Lua中的数学库)</title><link>https://www.hotmindshare.com/docs/cloud-native/lua/27/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.hotmindshare.com/docs/cloud-native/lua/27/</guid><description>Lua中的数学库 Lua5.1中数学库的所有函数如下表：
math.pi 为圆周率常量 = 3.14159265358979323846
表1
数学库
说明
例子
方法
abs
取绝对值
math.abs(-15)
15
acos
反余弦函数
math.acos(0.5)
1.04719755
asin
反正弦函数
math.asin(0.5)
0.52359877
atan2
x&amp;nbsp;/&amp;nbsp;y的反正切值
math.atan2(90.0,&amp;nbsp;45.0)
1.10714871
atan
反正切函数
math.atan(0.5)
0.463647609
ceil
不小于x的最大整数
math.ceil(5.8)
6
cosh
双曲线余弦函数
math.cosh(0.5)
1.276259652
cos
余弦函数
math.cos(0.5)
0.87758256
deg
弧度转角度
math.deg(math.pi)
180
exp
计算以e为底x次方值
math.exp(2)
2.718281828
floor
不大于x的最大整数
math.floor(5.6)
5
fmod&amp;nbsp;（mod）
取模运算
math.mod(14,&amp;nbsp;5)
4
frexp
把双精度数val分解为数字部分（尾数）和以2为底的指数n，即val=x*2n
math.frexp(10.0)
0.625&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;4
ldexp
计算value&amp;nbsp;*&amp;nbsp;2的n次方
math.ldexp(10.0,&amp;nbsp;3)
80&amp;nbsp;=&amp;nbsp;10&amp;nbsp;*&amp;nbsp;(2&amp;nbsp;^3)
log10
计算以10为基数的对数
math.log10(100)</description></item><item><title>二十三、Lua 学习笔记之一(初阶话题)</title><link>https://www.hotmindshare.com/docs/cloud-native/lua/23/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.hotmindshare.com/docs/cloud-native/lua/23/</guid><description>前言 本文针对的读者是有经验的C/C++程序员,希望了解Lua或者迅速抓住Lua的关键概念和模式进行开发的。因此本文并不打算教给读者条件语句的语法或者函数定义的方式等等显而易见的东西,以及一些诸如变量、函数等编程语言的基本概念。本文只打算告诉读者Lua那些与C/C++显著不同的东西以及它们实际上带来了怎样不同于C/C++的思考方式。不要小看它们,它们即将颠覆你传统的C/C++的世界观!
本文一共分初阶、进阶和高阶三大部分,每个部分又有若干章节。读者应当从头至尾循序渐进的阅读,但是标有“*”号的章节(主要讨论OO在Lua中的实现方式)可以略去而不影响对后面内容的理解。读者只要把前两部分完成就可以胜任Lua开发的绝大部分任务。高阶部分可作为选择。
初阶话题 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 1.八种基本类型: 如下表 基本类型
描述
备注
数值(number)
内部以double表示
&amp;nbsp;
字符串(string)
&amp;nbsp;
总是以零结尾,但可以包含任意字符(包括零),因此并不等价于C字符串, 而是其超集
&amp;nbsp;
布尔(boolean)
只有“true”或者“false”两个值。
&amp;nbsp;
函数(function)
&amp;nbsp;
Lua的关键概念之一。不简单等同于C的函数或函数指针。
&amp;nbsp;
表(table)
异构的Hash表。Lua的关键概念之一。
&amp;nbsp;
userdata
&amp;nbsp;
用户(非脚本用户)定义的C数据结构。脚本用户只能使用它,不能定义。
&amp;nbsp;
线程(thread)
&amp;nbsp;
Lua协作线程(coroutine),与一般操作系统的抢占式线程不一样。
&amp;nbsp;
nil
&amp;nbsp;
代表什么也没有,可以与C的NULL作类比,但它不是空指针。
&amp;nbsp;
2.函数 2、 1实例代码；
1 function foo(a,b,c,...) local sum = a+b return sum,c --函数可以返回多个值 end r1,r2 = foo(1,&amp;#34;123&amp;#34;,&amp;#34;hello&amp;#34;)--平行赋值 print(r1,r2); 输出结果:
124hello
2、 2函数基本使用方法；
函数定义: 用关键字function定义函数,以关键字end结束
局部变量: 用关键字local定义。如果没有用local定义,即使在函数内部定义的变量也是全局变量!
函数可以返回多个值: return a, b, c, …</description></item><item><title>二十四、Lua 学习笔记之二(进阶话题)</title><link>https://www.hotmindshare.com/docs/cloud-native/lua/24/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.hotmindshare.com/docs/cloud-native/lua/24/</guid><description>进阶话题 1.函数闭包 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 1、1 实例代码
1 function createCountdownTimer(second) 2 local ms = second * 1000 --ms为countDown的Upvalue 3 local function countDown() 4 ms = ms -1 5 return ms 6 end 7 return countDown 8 end 9 local timer1 = createCountdownTimer(1) 10 for i = 1, 3 do 11 print(timer1()) 12 end 输出结果:
999
998
997
1、2 关于函数闭包描述
Upvalue 一个函数所使用的定义在它的函数体之外的局部变量(external local variable)称为这个函数的upvalue。 在前面的代码中,函数countDown使用的定义在函数createCountdownTimer 中的局部变量ms就是countDown的upvalue,但ms对createCountdownTimer而 言只是一个局部变量,不是upvalue。 Upvalue是Lua不同于C/C++的特有属性,需要结合代码仔细体会。
函数闭包 一个函数和它所使用的所有upvalue构成了一个函数闭包。
Lua函数闭包与C函数的比较 Lua函数闭包使函数具有保持它自己的状态的能力,从这个意义上说,可以 与带静态局部变量的C函数相类比。但二者有显著的不同:对Lua来说,函数 是一种基本数据类型——代表一种(可执行)对象,可以有自己的状态;但 是对带静态局部变量的C函数来说,它并不是C的一种数据类型,更不会产生 什么对象实例,它只是一个静态地址的符号名称。</description></item><item><title>二十五、Lua 学习笔记之三(高阶话题)</title><link>https://www.hotmindshare.com/docs/cloud-native/lua/25/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.hotmindshare.com/docs/cloud-native/lua/25/</guid><description>高阶话题 1.迭代 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 1、1 实例代码:
1 --迭代 2 local function enum(array) 3 local index = 1 4 return function() 5 local ret = array[index] 6 index = index + 1 7 return ret 8 end 9 end 10 local function foreach(array,action) 11 for element in enum(array)do 12 action(element) 13 end 14 end 15 foreach({1,2,3},print) 输出结果:
1
2
3
1、2 有关迭代的描述:
定义 迭代是for语句的一种特殊形式,可以通过for语句驱动迭代函数对一个给定集合进行遍历。正式、完备的语法说明较复杂,请参考Lua手册。
实现 如前面代码所示:enum函数返回一个匿名的迭代函数,for语句每次调用该迭代函数都得到一个值(通过element变量引用),若该值为nil,则for循环结束。
2.协作线程 2、1 实例代码
1 --线程 2 local function producer() 3 return coroutine.</description></item><item><title>二十一、Lua 面向对象</title><link>https://www.hotmindshare.com/docs/cloud-native/lua/21/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.hotmindshare.com/docs/cloud-native/lua/21/</guid><description>Lua 面向对象 面向对象编程（Object Oriented Programming，OOP）是一种非常流行的计算机编程架构。
以下几种编程语言都支持面向对象编程：
C++ Java Objective-C Smalltalk C# Ruby 面向对象特征 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 1） 封装：指能够把一个实体的信息、功能、响应都装入一个单独的对象中的特性。 2） 继承：继承的方法允许在不改动原程序的基础上对其进行扩充，这样使得原功能得以保存，而新功能也得以扩展。这有利于减少重复编码，提高软件的开发效率。 3） 多态：同一操作作用于不同的对象，可以有不同的解释，产生不同的执行结果。在运行时，可以通过指向基类的指针，来调用实现派生类中的方法。 4）抽象：抽象(Abstraction)是简化复杂的现实问题的途径，它可以为具体问题找到最恰当的类定义，并且可以在最恰当的继承级别解释问题。 Lua 中面向对象 我们知道，对象由属性和方法组成。LUA中最基本的结构是table，所以需要用table来描述对象的属性。
lua中的function可以用来表示方法。那么LUA中的类可以通过table + function模拟出来。
至于继承，可以通过metetable模拟出来（不推荐用，只模拟最基本的对象大部分时间够用了）。
Lua中的表不仅在某种意义上是一种对象。像对象一样，表也有状态（成员变量）；也有与对象的值独立的本性，特别是拥有两个不同值的对象（table）代表两个不同的对象；一个对象在不同的时候也可以有不同的值，但他始终是一个对象；与对象类似，表的生命周期与其由什么创建、在哪创建没有关系。对象有他们的成员函数，表也有：
1Account = {balance = 0} 2function Account.withdraw (v) 3 Account.balance = Account.balance - v 4end 这个定义创建了一个新的函数，并且保存在Account对象的withdraw域内，下面我们可以这样调用：
1Account.withdraw(100.00) 一个简单实例 以下简单的类包含了三个属性： area, length 和 breadth，printArea方法用于打印计算结果：
1-- Meta class 2Rectangle = {area = 0, length = 0, breadth = 0} 3-- 派生类的方法 new 4function Rectangle:new (o,length,breadth) 5 o = o or {} 6 setmetatable(o, self) 7 self.</description></item><item><title>九、Lua 运算符</title><link>https://www.hotmindshare.com/docs/cloud-native/lua/9/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.hotmindshare.com/docs/cloud-native/lua/9/</guid><description>Lua 运算符 运算符是一个特殊的符号，用于告诉解释器执行特定的数学或逻辑运算。Lua提供了以下几种运算符类型：
算术运算符 关系运算符 逻辑运算符 其他运算符 算术运算符 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 下表列出了 Lua 语言中的常用算术运算符，设定 A 的值为10，B 的值为 20：
操作符 描述 实例 + 加法 A + B 输出结果 30 – 减法 A – B 输出结果 -10 * 乘法 A * B 输出结果 200 / 除法 B / A w输出结果 2 % 取余 B % A 输出结果 0 ^ 乘幂 A^2 输出结果 100 – 负号 -A 输出结果v -10 实例 我们可以通过以下实例来更加透彻的理解算术运算符的应用：
1a = 21 2b = 10 3c = a + b 4print(&amp;#34;Line 1 - c 的值为 &amp;#34;, c ) 5c = a - b 6print(&amp;#34;Line 2 - c 的值为 &amp;#34;, c ) 7c = a * b 8print(&amp;#34;Line 3 - c 的值为 &amp;#34;, c ) 9c = a / b 10print(&amp;#34;Line 4 - c 的值为 &amp;#34;, c ) 11c = a % b 12print(&amp;#34;Line 5 - c 的值为 &amp;#34;, c ) 13c = a^2 14print(&amp;#34;Line 6 - c 的值为 &amp;#34;, c ) 15c = -a 16print(&amp;#34;Line 7 - c 的值为 &amp;#34;, c ) 以上程序执行结果为：</description></item><item><title>六、Lua 循环</title><link>https://www.hotmindshare.com/docs/cloud-native/lua/6/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.hotmindshare.com/docs/cloud-native/lua/6/</guid><description>Lua 循环 很多情况下我们需要做一些有规律性的重复操作，因此在程序中就需要重复执行某些语句。
一组被重复执行的语句称之为循环体，能否继续重复，决定循环的终止条件。
循环结构是在一定条件下反复执行某段程序的流程结构，被反复执行的程序被称为循环体。
循环语句是由循环体及循环的终止条件两部分组成的。
Lua语言提供了以下几种循环处理方式：
循环类型 描述 while 循环 在条件为 true 时，让程序重复地执行某些语句。执行语句前会先检查条件是否为 true。 for 循环 重复执行指定语句，重复次数可在 for 语句中控制。 Lua repeat…until 重复执行循环，直到 指定的条件为真时为止 循环嵌套 可以在循环内嵌套一个或多个循环语句（while、for、do..while） 循环控制语句 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 循环控制语句用于控制程序的流程， 以实现程序的各种结构方式。
Lua支持以下循环控制语句：
控制语句 描述 break 语句 退出当前循环或语句，并开始脚本执行紧接着的语句。 无限循环 在循环体中如果条件永远为 true 循环语句就会永远执行下去，以下以 while 循环为例：
1while( true ) 2do 3 print(&amp;#34;循环将永远执行下去&amp;#34;) 4end</description></item><item><title>七、Lua 流程控制</title><link>https://www.hotmindshare.com/docs/cloud-native/lua/7/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.hotmindshare.com/docs/cloud-native/lua/7/</guid><description>Lua 流程控制 Lua编程语言流程控制语句通过程序设定一个或多个条件语句来设定。在条件为 true 时执行指定程序代码，在条件为 false 时执行其他指定代码。
以下是典型的流程控制流程图：
控制结构的条件表达式结果可以是任何值，Lua认为false和nil为假，true 和非nil为真。
要注意的是Lua中 0 为 true：
1--[ 0 为true ] 2if(0) 3then 4 print(&amp;#34;0 为真&amp;#34;) 5end 以上代码输出结果为：
10 为真 Lua提供了以下控制结构语句：
语句 描述 if 语句 if 语句 由一个布尔表达式作为条件判断，其后紧跟其他语句组成。 if…else 语句 if 语句 可以与 else 语句搭配使用, 在 if 条件表达式为 false 时执行 else 语句代码。 if 嵌套语句 你可以在if 或 else if中使用一个或多个 if 或 else if 语句 。</description></item><item><title>三、Lua 基本语法</title><link>https://www.hotmindshare.com/docs/cloud-native/lua/3/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.hotmindshare.com/docs/cloud-native/lua/3/</guid><description>Lua 基本语法 Lua学习起来非常简单，我们可以创建第一个 Lua 程序！
第一个 Lua 程序 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 交互式编程 Lua提供了交互式编程模式。我们可以在命令行中输入程序并立即查看效果。
Lua交互式编程模式可以通过命令 lua -i 或 lua 来启用：
1$ lua -i 2$ Lua 5.3.0 Copyright (C) 1994-2015 Lua.org, PUC-Rio 3&amp;gt; 在命令行中，输入以下命令:
1&amp;gt; print(&amp;#34;Hello World！&amp;#34;) 接着我们按下回车键，输出结果如下：
1&amp;gt; print(&amp;#34;Hello World！&amp;#34;) 2Hello World！ 3&amp;gt; 脚本式编程 我们可以将 Lua 程序代码保持到一个以 lua 结尾的文件，并执行，该模式称为脚本式编程，如我们将如下代码存储在名为 hello.lua 的脚本文件中：
1print(&amp;#34;Hello World！&amp;#34;) 2print(&amp;#34;www.w3cschool.cn&amp;#34;) 使用lua 名执行以上脚本，输出结果为：
1$ lua test.lua 2Hello World！ 3www.w3cschool.cn 我们也可以将代码修改为如下形式来执行脚本（在开头添加：#!/usr/local/bin/lua）：
1#!/usr/local/bin/lua 2print(&amp;#34;Hello World！&amp;#34;) 3print(&amp;#34;www.w3cschool.cn&amp;#34;) 以上代码中，我们指定了 Lua 的解释器 /usr/local/bin directory。加上 # 号标记解释器会忽略它。接下来我们为脚本添加可执行权限，并执行：</description></item><item><title>三十、Lua中的table函数库</title><link>https://www.hotmindshare.com/docs/cloud-native/lua/30/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.hotmindshare.com/docs/cloud-native/lua/30/</guid><description>Lua中的table函数库 table库由一些操作table的辅助函数组成。他的主要作用之一是对Lua中array的大小给出一个合理的解释。另外还提供了一些从list中插入删除元素的函数，以及对array元素排序函数。
table.concat(table, sep, start, end) 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 concat是concatenate(连锁, 连接)的缩写. table.concat()函数列出参数中指定table的数组部分从start位置到end位置的所有元素, 元素间以指定的分隔符(sep)隔开。除了table外, 其他的参数都不是必须的, 分隔符的默认值是空字符, start的默认值是1, end的默认值是数组部分的总长.
sep, start, end这三个参数是顺序读入的, 所以虽然它们都不是必须参数, 但如果要指定靠后的参数, 必须同时指定前面的参数.
1test = {&amp;#34;Tom&amp;#34;, &amp;#34;Mary&amp;#34;, &amp;#34;Jam&amp;#34;,&amp;#34;Hey&amp;#34;} 2print(table.concat(test, &amp;#34;:&amp;#34;)) 3print(&amp;#34;*************&amp;#34;) 4print(table.concat(test, nil, 1, 2)) 5print(&amp;#34;*************&amp;#34;) 6print(table.concat(test, &amp;#34;\n&amp;#34;, 2, 3)) 7print(table.maxn(test))</description></item><item><title>三十八、Lua 代码编写规范</title><link>https://www.hotmindshare.com/docs/cloud-native/lua/38/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.hotmindshare.com/docs/cloud-native/lua/38/</guid><description>Lua代码编写规范 开发中，大量使用lua，暂时根据当前状况，总结相对而言较好的规范，在多人协作中可以更好的开发、交流。
介绍
该文档旨在为使用lua编写应用程序建立编码指南。
制订编码规范的目的：
统一编码标准，通用，提高开发效率； 使代码通俗易懂，易于维护。 切记：善用调试器。
一、 命名惯例 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 1．所有lua文件命名时使用小写字母、下划线
2．类名、变量名尽可能使用有意义的英文，类名使用帕斯卡命名法，变量名使用骆驼式命名法
3．常量、消息号定义时用大写，单词间 _ 分割 eg:KIND_PET_FOOD
4．枚举值定义时 加前缀 enum_
5、 函数名使用骆驼式命名法；
注：
骆驼式命名法：第一个单字以小写字母开始；第二个单字的首字母大写或每一个单字的首字母都采用大写字母
帕斯卡命名法：和骆驼命名法很像，只有一点区别，就是首字母要大写。(单字之间不以空格断开或连接号)
二、 文件组织 1、 文件开头加上此文件的功能、职责的简要描述；
如下：
--
--Author: Feng
--Date: XXXX-XX-XX
--功能描述
每个文件都加module 限定词； 导入的模块都加 local 限定词；或者使用(module(…, package.seeall))，这样便于进行热更新
2、 所有提供外部函数都加如下格式的注释；
例如：
--此函数检测是否可以从A(oldx, oldy)点走到B点（newx, newy）
--@param oldx 当前所在点x
--@param oldy 当前所在点y
--@param newx 目标点x
--@param newy 目标点y
--@return 若可以到达，返回true；否则返回false
function Object:checkBar(oldx, oldy, newx, newy)
…
end</description></item><item><title>三十二、Lua中的常用操作系统库</title><link>https://www.hotmindshare.com/docs/cloud-native/lua/32/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.hotmindshare.com/docs/cloud-native/lua/32/</guid><description>os.time ([table]) 功能：按table的内容返回一个时间值(数字),若不带参数则返回当前时间.（在许多系统中该数值是当前距离某个特定时间的秒数。）
说明：当为函数调用附加一个特殊的时间表时，该函数就是返回距该表描述的时间的数值。这样的时间表有如下的区间：
前三项是必需的，如果未定义后几项，默认时间为正午（12:00:00）。如果是在里约热内卢（格林威治向西三个时区）的一台Unix计算机上（相对时间为1970年1月1日，00:00:00），对于pc机（中国时区而言）有稍微更改，更改了为1970年1月1日，08:00:00，这是因我国与其它国家时间差导致。
例子：
1print(os.time{year=1970, month=1, day=1,hour=8}) 2print(os.time{year=1970, month=1, day=1}) --若未定义“时，分，秒”,默认时间为正午（04:00:00） 运行结果：
--&amp;gt;0
--&amp;gt;14400(14400 = 46060 )
os.date ([format [, time]]) 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 功能：返回一个按format格式化日期、时间的字串或表
说明：函数date，其实是time函数的一种“反函数”。它将一个表示日期和时间的数值，转换成更高级的表现形式。其第一个参数是一个格式化字符串，描述了要返回的时间形式。第二个参数就是时间的数字表示，默认为当前的时间。
参数：format：
*t”:将返一个带year(4位),month(1-12), day (1–31), hour (0-23), min (0-59), sec (0-61), wday (星期几, 星期天为1), yday (年内天数), and isdst (是否为日光节约时间true/false)的带键名的表;
若没有”*t”则返回一个按C的strftime函数格式化的字符串;
若不带参数，则按当前系统的设置返回格式化的字符串 os.date() &amp;lt;=&amp;gt; os.date(“%c”)
例子：我当前PC时间，如图：
代码：
1t = os.date(&amp;#34;*t&amp;#34;, os.time()); 2for i, v in pairs(t) do 3 print(i,&amp;#34;-&amp;gt;&amp;#34;,v); 4end 运行结果 ：
运行结果和以上时钟的秒，不一致，你想，截图也要时间的，呵呵。
如果使用带标记（见下表）的特殊字符串，os.data函数会将相应的标记位以时间信息进行填充，得到一个包含时间的字符串。
例子：</description></item><item><title>三十九、Lua中调用C函数(lua-5.2.3)</title><link>https://www.hotmindshare.com/docs/cloud-native/lua/39/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.hotmindshare.com/docs/cloud-native/lua/39/</guid><description>Lua可以调用C函数的能力将极大的提高Lua的可扩展性和可用性。
对于有些和操作系统相关的功能，或者是对效率要求较高的模块，我们完全可以通过C函数来实现，之后再通过Lua调用指定的C函数。
对于那些可被Lua调用的C函数而言，其接口必须遵循Lua要求的形式，即typedef int (lua_CFunction)(lua_State L)。
简单说明一下，该函数类型仅仅包含一个表示Lua环境的指针作为其唯一的参数，实现者可以通过该指针进一步获取Lua代码中实际传入的参数。返回值是整型，表示该C函数将返回给Lua代码的返回值数量，如果没有返回值，则return 0即可。需要说明的是，C函数无法直接将真正的返回值返回给Lua代码，而是通过虚拟栈来传递Lua代码和C函数之间的调用参数和返回值的。
实例代码：
1// testlua.cpp : 定义控制台应用程序的入口点。 2// 3#include &amp;#34;stdafx.h&amp;#34; 4#include &amp;lt;stdio.h&amp;gt; 5#include &amp;lt;string.h&amp;gt; 6#include &amp;lt;math.h&amp;gt; 7extern &amp;#34;C&amp;#34; 8#include &amp;lt;lua.h&amp;gt; 9#include &amp;lt;lualib.h&amp;gt; 10#include &amp;lt;lauxlib.h&amp;gt; 11//待Lua调用的C注册函数 12static int add2(lua_State* L) 13 //检查栈中的参数是否合法，1表示Lua调用时的第一个参数(从左到右)，依此类推。 14 //如果Lua代码在调用时传递的参数不为number，该函数将报错并终止程序的执行。 15 double op1 = luaL_checknumber(L,1); 16 double op2 = luaL_checknumber(L,2); 17 //将函数的结果压入栈中。如果有多个返回值，可以在这里多次压入栈中。 18 lua_pushnumber(L,op1 + op2); 19 //返回值用于提示该C函数的返回值数量，即压入栈中的返回值数量。 20 return 1; 21//待Lua调用的C注册函数。 22static int sub2(lua_State* L) 23 double op1 = luaL_checknumber(L,1); 24 double op2 = luaL_checknumber(L,2); 25 lua_pushnumber(L,op1 - op2); 26 return 1; 27//待Lua调用的C注册函数。 28static int l_sin (lua_State *L) { 29 double d = lua_tonumber(L, 1); /* get argument */ 30 lua_pushnumber(L, sin(d)); /* push result */ 31 return 1; /* number of results */ 32int _tmain(int argc, _TCHAR* argv[]) 33 lua_State *L = luaL_newstate(); 34 luaL_openlibs(L); 35 //将指定的函数注册为Lua的全局函数变量，其中第一个字符串参数为Lua代码 36 //在调用C函数时使用的全局函数名，第二个参数为实际C函数的指针。 37 lua_register(L, &amp;#34;add2&amp;#34;, add2); 38 lua_register(L, &amp;#34;sub2&amp;#34;, sub2); 39 lua_register(L, &amp;#34;l_sin&amp;#34;, l_sin); 40 //在注册完所有的C函数之后，即可在Lua的代码块中使用这些已经注册的C函数了。 41 luaL_dofile(L,&amp;#34;test.</description></item><item><title>三十六、Lua IO库</title><link>https://www.hotmindshare.com/docs/cloud-native/lua/36/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.hotmindshare.com/docs/cloud-native/lua/36/</guid><description>I/O库为文件操作提供两种模式。简单模式（simple model）拥有一个当前输入文件和一个当前输出文件，并且提供针对这些文件相关的操作。完全模式（complete model）使用外部的文件句柄来实现。
简单模式 I/O库将当前输入文件作为标准输入（stdin），将当前输出文件作为标准输出（stdout）。这样当我们执行io.read，就是在标准输入中读取一行。
写操作较读操作简单，我们先从写操作入手。
下面这个例子里函数io.write获取任意数目的字符串参数，接着将它们写到当前的输出文件。
1local t = io.write(&amp;#34;sin (3) = &amp;#34;, math.sin(3), &amp;#34;\n&amp;#34;) 2--&amp;gt; sin (3) = 0.1411200080598672 3print(&amp;#34;hello&amp;#34;, &amp;#34;Lua&amp;#34;); print(&amp;#34;Hi&amp;#34;) 4--&amp;gt;hello Lua 5--&amp;gt;Hi 注：Write函数与print函数不同在于，write不附加任何额外的字符到输出中去，例如制表符，换行符等等。还有write函数是使用当前输出文件，而print始终使用标准输出。另外print函数会自动调用参数的tostring方法，所以可以显示出表（tables）函数（functions）和nil。
read函数:从当前输入文件读取串，由它的参数控制读取的内容：
例子：
1--io.read 从标准输入流中获得，默认设置下，就是你的屏幕输入 2t = io.read(&amp;#34;*all&amp;#34;) 3t = string.gsub(t, ...) -- do the job 4io.write(t) -- write the 提示：若使用luaEditor编辑器,估计无法在屏幕输入。
完全模式 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 完全模式的核心在于文件句柄（file handle）。该结构类似于C语言中的文件流（FILE*），其呈现了一个打开的文件以及当前存取位置。打开一个文件的函数是io.open。它模仿C语言中的fopen函数，同样需要打开文件的文件名参数，打开模式的字符串参数：
例子：
1--读操作 2file = io.open(&amp;#34;testRead.txt&amp;#34;, &amp;#34;r&amp;#34;) 3for line in file:lines() do 4 print(line) 5end 6file:close() 7--写操作 8file = io.</description></item><item><title>三十七、理解Lua 语言中的点、冒号与self</title><link>https://www.hotmindshare.com/docs/cloud-native/lua/37/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.hotmindshare.com/docs/cloud-native/lua/37/</guid><description>lua编程中，经常遇到函数的定义和调用，有时候用点号调用，有时候用冒号调用，这里简单的说明一下原理。如：
点号调用： 1-- 点号定义和点号调用: 2girl = {money = 200} 3function girl.goToMarket(girl ,someMoney) 4 girl.money = girl.money - someMoney 5end 6girl.goToMarket(girl ,100) 7print(girl.money) 引用参数self： 1-- 参数self指向调用者自身(类似于c++里的this 指向当前类) 2girl = {money = 200} 3function girl.goToMarket(self ,someMoney) 4 self.money = self.money - someMoney 5end 6girl.goToMarket(girl, 100) 7print(girl.money) 冒号调用： 1-- 冒号定义和冒号调用: 2girl = {money = 200} 3function girl:goToMarket(someMoney) 4 self.money = self.money - someMoney 5end 6girl:goToMarket(100) 7print(girl.money) 冒号定义和冒号调用其实跟上面的效果一样，只是把第一个隐藏参数省略了，而该参数self指向调用者自身。
**总结：**冒号只是起了省略第一个参数self的作用，该self指向调用者本身，并没有其他特殊的地方。
引用博文：http://www.xuebuyuan.com/1613223.html</description></item><item><title>三十三、Cocos2d-x使用Luajit实现加密</title><link>https://www.hotmindshare.com/docs/cloud-native/lua/33/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.hotmindshare.com/docs/cloud-native/lua/33/</guid><description>项目要求对lua脚本进行加密，查了一下相关的资料 ，得知lua本身可以使用luac将脚本编译为字节码(bytecode)从而实现加密，试了一下，确实可行。下面是使用原生的lua解释器编译字节码：
1、 新建一个名为1.lua的文件，里面只有一句话print(“HelloLua”)，新建一个空的out.lua脚本文件；
2、 开始–运行–cmd3、luac-oout.lua1.lua；
注：luac -o [编译后脚本名] [脚本名]，必要时带上脚本路径，如：
[编译后脚本名] [脚本名]，必要时带上脚本路径
回车之后，再打开out.lua就可以看到编译好的字节码了，如：
然后实验一下，执行这个字节码脚本，可以看到lua原生的解释器可以直接解析luac编译出来的bytecode脚本，很方便！
**重点：**做完了以上的一系列之后，我照着这个方法编译项目中的脚本，然后在cocos2dx环境下使用，发现不行！于是又查了一下资料，发现2dx使用的是luajit，lua原生编译出来的bytecode和luajit是不兼容的，所以照着上面方法编译出来的bytecode脚本无法在2dx中使用。
解决这个问题其实很简单，就是用2dx自带的luajit编译lua脚本，下面附上luajit编译bytecode的方法：
1、 在cocos2d-x-2.2.3\scripting\lua\luajit\LuaJIT-2.0.1\src目录下有个msvcbuild.bat批处理文件，需要先把luajit.exe这个东西给编译出来；
2、 打开visualstudio的命令行工具，这个只要装了vs都会有，在安装目录里面可以找到；
3、 用vs的命令行工具cd到luajit的src目录；
4、 执行msvcbuild.bat批处理文件，编译出luajit.exe；
5、 将生成的luajit.exe、lua51.dll、jit复制到打包工具的相对目录下，这样在工具中就可以直接调用luajit–bsource_fileout_file(一般都是lua后缀，代码不用改动)；
至此，luajit编译bytecode加密已完成！
**严重注意：**例子中，我把编译前后的脚本名字取的不一样，是为了让大家看出差异化来，实际在项目中使用的时候，脚本的名字编译前后最好都一致，不然在脚本中相互require的时候可能会出现问题！一个一个转换脚太麻烦了，分享一个bat批处理，可以批量转换一个文件夹中的所有lua文件.
代码如下：
1@echo off 2if exist out rd /s /q out 3mkdir out 4:input 5cls 6set input=: 7set /p input= 拖入要编译的lua文件夹： 8set &amp;#34;input=%input:&amp;#34;=%&amp;#34; 9if &amp;#34;%input%&amp;#34;==&amp;#34;:&amp;#34; goto input 10if not exist &amp;#34;%input%&amp;#34; goto input 11for %%i in (&amp;#34;%input%&amp;#34;) do if /i &amp;#34;%%~di&amp;#34;==%%i goto input 12pushd %cd% 13cd /d &amp;#34;%input%&amp;#34;&amp;gt;nul 2&amp;gt;nul || exit 14set cur_dir=%cd% 15popd 16set /a num = 0 17for /f &amp;#34;delims=&amp;#34; %%i in (&amp;#39;dir /b /a-d /s &amp;#34;%input%&amp;#34;&amp;#39;) do (set /a num += 1 &amp;amp; luajit -b %%~fsi out/%%~nxi &amp;amp; echo %%~nxi) 18echo 编译脚本数量：%num% 19ATTRIB out/*.</description></item><item><title>三十四、Lua string库</title><link>https://www.hotmindshare.com/docs/cloud-native/lua/34/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.hotmindshare.com/docs/cloud-native/lua/34/</guid><description>Lua解释器对字符串的支持很有限。一个程序可以创建字符串并连接字符串，但不能截取子串，检查字符串的大小，检测字符串的内容。在Lua中操纵字符串的功能基本来自于string库。
一、String库的常用函数： 1--返回字符串s的长度 2local s = &amp;#34;HelloWorld&amp;#34; 3print(string.len(s)) --&amp;gt;10 4--重复n次字符串s的串 5print(string.rep(s,2)) --&amp;gt;HelloWorldHelloWorld 6--大写字母转换成小写 7print(string.lower(s)) --&amp;gt;helloworld 8--小写转换成大写 9print(string.upper(s)) --&amp;gt;HELLOWORLD 10--截取字符串 11local s = &amp;#34;[in brackets]&amp;#34; 12print(string.sub(s,2,-1)) --&amp;gt;in brackets] 13--将每一个数字转换成字符 14print(string.char(97)) --&amp;gt;a 15--将每一个字符转换成数字 16print(string.byte(&amp;#34;abc&amp;#34;)) 17print(string.byte(&amp;#34;abc&amp;#34;, 2)) --&amp;gt; 98 18print(string.byte(&amp;#34;abc&amp;#34;, -1)) --&amp;gt; 99 19--注：使用负数索引访问字符串的最后一个字符 20--对字符串进行格式化输出 21PI = 3.14165120 22print(string.format(&amp;#34;pi = %.4f&amp;#34;, PI)) --&amp;gt;pi = 3.1417 23--注释：使用和C语言的printf函数几乎一模一样，你完全可以照C语言的printf来使用这个函数. 注：
string库中所有的字符索引从前往后是1,2,…;从后往前是-1,-2,…
string库中所有的function都不会直接操作字符串，而是返回一个结果。
二、String库的模式匹配函数 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 在string库中功能最强大的函数是：string.find（字符串查找），string.gsub（全局字符串替换），and string.gfind（全局字符串查找）。这些函数都是基于模式匹配的。
1、string.find
说明：用来在目标串（subject string）内搜索匹配指定的模式的串。函数如果找到匹配的串返回他的位置，否则返回nil.最简单的模式就是一个单词，仅仅匹配单词本身。比如，模式’hello’仅仅匹配目标串中的”hello”。当查找到模式的时候，函数返回两个值：匹配串开始索引和结束索引。
1local s = &amp;#34;hello world&amp;#34; 2i,j = string.</description></item><item><title>三十五、Lua中的模块与module函数</title><link>https://www.hotmindshare.com/docs/cloud-native/lua/35/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.hotmindshare.com/docs/cloud-native/lua/35/</guid><description>这篇文章主要介绍了Lua中的模块(module)和包(package)详解,本文讲解了require函数、写一个模块、package.loaded、module函数等内容.
从Lua5.1版本开始，就对模块和包添加了新的支持，可是使用require和module来定义和使用模块和包。require用于使用模块，module用于创建模块。简单的说，一个模块就是一个程序库，可以通过require来加载。然后便得到了一个全局变量，表示一个table。这个table就像是一个命名空间，其内容就是模块中导出的所有东西，比如函数和常量，一个符合规范的模块还应使require返回这个table。现在就来具体的总结一下require和module这两个函数。如：
1require &amp;#34;mod&amp;#34; 2mod.foo() 3local m2 = require &amp;#34;mod2&amp;#34; 4local f = mod2.foo 5f() 1. require函数： require函数的调用形式为require “模块名”。该调用会返回一个由模块函数组成的table，并且还会定义一个包含该table的全局变量。在使用Lua中的标准库时可以不用显示的调用require，因为Lua已经预先加载了他们。
require函数在搜素加载模块时，有一套自定义的模式，如：
?;?.lua;c:/windows/?;/usr/local/lua/?/?.lua
在上面的模式中，只有问号(?)和分号(;)是模式字符，分别表示require函数的参数(模块名)和模式间的分隔符。如：调用require “sql”，将会打开以下的文件：
sql sql.lua
c:/windows/sql
/usr/local/lua/sql/sql.lua
Lua将require搜索的模式字符串放在变量package.path中。当Lua启动后，便以环境变量LUA_PATH的值来初始化这个变量。如果没有找到该环境变量，则使用一个编译时定义的默认路径来初始化。如果require无法找到与模块名相符的Lua文件，就会找C程序库。**C程序库的搜索模式存放在变量package.cpath中。**而这个变量则是通过环境变量LUA_CPATH来初始化的。
2. 编写模块的基本方法： 新建一个文件，命名为game.lua，代码如下：
1local M = {}; 2local modelName = ...; 3_G[modelName] = M; 4function M.play() 5 print(&amp;#34;那么，开始吧&amp;#34;); 6end 7function M.quit() 8 print(&amp;#34;你走吧，我保证你不会出事的，呵，呵呵&amp;#34;); 9end 10return M; 加载game.lua，代码如下：
1game = require &amp;#34;test&amp;#34; 2game.play() 运行：
lua -e “io.stdout:setvbuf ‘no&amp;rsquo;” “HelloWorld.lua”
那么，开始吧
Exit code: 0</description></item><item><title>三十一、Lua 函数回调技巧</title><link>https://www.hotmindshare.com/docs/cloud-native/lua/31/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.hotmindshare.com/docs/cloud-native/lua/31/</guid><description>技巧1： 1local a = {};function b() print(&amp;#34;Hello World&amp;#34;)enda[&amp;#34;sell&amp;#34;] = {callFunc =b}a[&amp;#34;sell&amp;#34;].callFunc() # 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 技巧2： 使用lua 自带的 unpack :
解释：把一直数组（只有连续数字下标的 table）展开成一串返回值，但是对用字符串或别的东西做 key 的 table 无能为力。
1function unpackex(tbl, args) local ret = {} for _,v in ipairs(args) do table.insert(ret, tbl[v]) end return unpack(ret)endprint(unpackex({one = {&amp;#34;one&amp;#34;, &amp;#34;two&amp;#34;, &amp;#34;three&amp;#34;}, two = &amp;#34;T&amp;#34; , three = &amp;#34;TH&amp;#34;},{&amp;#34;one&amp;#34;, &amp;#34;two&amp;#34;, &amp;#34;three&amp;#34;})) 输出：&amp;raquo; table: 00ABC2D0TTH</description></item><item><title>十、Lua 字符串</title><link>https://www.hotmindshare.com/docs/cloud-native/lua/10/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.hotmindshare.com/docs/cloud-native/lua/10/</guid><description>Lua 字符串 字符串或串(String)是由数字、字母、下划线组成的一串字符。
Lua语言中字符串可以使用以下三种方式来表示：
单引号间的一串字符。 双引号间的一串字符。 [[和]]间的一串字符。 以上三种方式的字符串实例如下：
1string1 = &amp;#34;Lua&amp;#34; 2print(&amp;#34;\&amp;#34;字符串 1 是\&amp;#34;&amp;#34;,string1) 3string2 = &amp;#39;w3cschool.cn&amp;#39; 4print(&amp;#34;字符串 2 是&amp;#34;,string2) 5 string3 = [[&amp;#34;Lua 教程&amp;#34;]] 6print(&amp;#34;字符串 3 是&amp;#34;,string3) 以上代码执行输出结果为：
1&amp;#34;字符串 1 是&amp;#34; Lua 2字符串 2 是 w3cschool.cn 3字符串 3 是 &amp;#34;Lua 教程&amp;#34; 转义字符用于表示不能直接显示的字符，比如后退键，回车键，等。如在字符串转换双引号可以使用 “\””。
所有的转义字符和所对应的意义：
转义字符 意义 ASCII码值（十进制） \a 响铃(BEL) 007 \b 退格(BS) ，将当前位置移到前一列 008 \f 换页(FF)，将当前位置移到下页开头 012 \n 换行(LF) ，将当前位置移到下一行开头 010 \r 回车(CR) ，将当前位置移到本行开头 013 \t 水平制表(HT) （跳到下一个TAB位置） 009 \v 垂直制表(VT) 011 \\ 代表一个反斜线字符”\’ 092 \’ 代表一个单引号（撇号）字符 039 \” 代表一个双引号字符 034 空字符(NULL) 000 \ddd 1到3位八进制数所代表的任意字符 三位八进制 \xhh 1到2位十六进制所代表的任意字符 二位十六进制 字符串操作 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 Lua提供了很多的方法来支持字符串的操作：</description></item><item><title>十八、Lua 错误处理</title><link>https://www.hotmindshare.com/docs/cloud-native/lua/18/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.hotmindshare.com/docs/cloud-native/lua/18/</guid><description>Lua 错误处理 程序运行中错误处理是必要的，在我们进行文件操作，数据转移及web service 调用过程中都会出现不可预期的错误。如果不注重错误信息的处理，就会造成信息泄露，程序无法运行等情况。
任何程序语言中，都需要错误处理。错误类型有：
语法错误 运行错误 语法错误 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 语法错误通常是由于对程序的组件（如运算符、表达式）使用不当引起的。一个简单的实例如下：
1-- test.lua 文件 2a == 2 以上代码执行结果为：
1lua: test.lua:2: syntax error near &amp;#39;==&amp;#39; 正如你所看到的，以上出现了语法错误，一个 “=” 号跟两个 “=” 号是有区别的。一个 “=” 是赋值表达式两个 “=” 是比较运算。
另外一个实例:
1for a= 1,10 2 print(a) 3end 执行以上程序会出现如下错误：
1lua: test2.lua:2: &amp;#39;do&amp;#39; expected near &amp;#39;print&amp;#39; 语法错误比程序运行错误更简单，运行错误无法定位具体错误，而语法错误我们可以很快的解决，如以上实例我们只要在for语句下添加 do 即可：
1for a= 1,10 2do 3 print(a) 4end 运行错误 运行错误是程序可以正常执行，但是会输出报错信息。如下实例由于参数输入错误，程序执行时报错：
1function add(a,b) 2 return a+b 3end 4add(10) 当我们编译运行以下代码时，编译是可以成功的，但在运行的时候会产生如下错误：
1lua: test2.lua:2: attempt to perform arithmetic on local &amp;#39;b&amp;#39; (a nil value) 2stack traceback: 3 test2.</description></item><item><title>十二、Lua 迭代器</title><link>https://www.hotmindshare.com/docs/cloud-native/lua/12/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.hotmindshare.com/docs/cloud-native/lua/12/</guid><description>Lua 迭代器 迭代器（iterator）是一种对象，它能够用来遍历标准模板库容器中的部分或全部元素，每个迭代器对象代表容器中的确定的地址
在Lua中迭代器是一种支持指针类型的结构，它可以遍历集合的每一个元素。
泛型 for 迭代器 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 泛型for 在自己内部保存迭代函数，实际上它保存三个值：迭代函数、状态常量、控制变量。
泛型for 迭代器提供了集合的 key/value 对，语法格式如下：
1for k, v in pairs(t) do 2 print(k, v) 3end 上面代码中，k, v为变量列表；pairs(t)为表达式列表。
查看以下实例:
1array = {&amp;#34;Lua&amp;#34;, &amp;#34;Tutorial&amp;#34;} 2for key,value in ipairs(array) 3do 4 print(key, value) 5end 以上代码执行输出结果为：
11 Lua 22 Tutorial 以上实例中我们使用了 Lua 默认提供的迭代函数 ipairs。
下面我们看看范性for的执行过程：
首先，初始化，计算in后面表达式的值，表达式应该返回范性for需要的三个值：迭代函数、状态常量、控制变量；与多值赋值一样，如果表达式返回的结果个数不足三个会自动用nil补足，多出部分会被忽略。 第二，将状态常量和控制变量作为参数调用迭代函数（注意：对于for结构来说，状态常量没有用处，仅仅在初始化时获取他的值并传递给迭代函数）。 第三，将迭代函数返回的值赋给变量列表。 第四，如果返回的第一个值为nil循环结束，否则执行循环体。 第五，回到第二步再次调用迭代函数 。在Lua中我们常常使用函数来描述迭代器，每次调用该函数就返回集合的下一个元素。Lua 的迭代器包含以下两种类型：
无状态的迭代器 多状态的迭代器 无状态的迭代器 无状态的迭代器是指不保留任何状态的迭代器，因此在循环中我们可以利用无状态迭代器避免创建闭包花费额外的代价。
每一次迭代，迭代函数都是用两个变量（状态常量和控制变量）的值作为参数被调用，一个无状态的迭代器只利用这两个值可以获取下一个元素。
这种无状态迭代器的典型的简单的例子是ipairs，他遍历数组的每一个元素。
以下实例我们使用了一个简单的函数来实现迭代器，实现 数字 n 的平方：
1function square(iteratorMaxCount,currentNumber) 2 if currentNumber&amp;lt;iteratorMaxCount 3 then 4 currentNumber = currentNumber+1 5 return currentNumber, currentNumber*currentNumber 6 end 7end 8for i,n in square,3,0 9do 10 print(i,n) 11end 以上实例输出结果为：</description></item><item><title>十九、Lua 调试(Debug)</title><link>https://www.hotmindshare.com/docs/cloud-native/lua/19/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.hotmindshare.com/docs/cloud-native/lua/19/</guid><description>Lua 调试(Debug) Lua提供了 debug 库用于提供创建我们自定义调速器的功能。Lua 本身并未有内置的调速器，但很多开发者共享了他们的 Lua 调速器代码。
Lua中 debug 库包含以下函数：
sethook ([thread,] hook, mask [, count]):
序号 方法 &amp;amp; 用途 1. debug(): 进入一个用户交互模式，运行用户输入的每个字符串。 使用简单的命令以及其它调试设置，用户可以检阅全局变量和局部变量， 改变变量的值，计算一些表达式，等等。 输入一行仅包含 cont 的字符串将结束这个函数， 这样调用者就可以继续向下运行。
2. getfenv(object): 返回对象的环境变量。
3. gethook(optional thread): 返回三个表示线程钩子设置的值： 当前钩子函数，当前钩子掩码，当前钩子计数
4. getinfo ([thread,] f [, what]): 返回关于一个函数信息的表。 你可以直接提供该函数， 也可以用一个数字 f 表示该函数。 数字 f 表示运行在指定线程的调用栈对应层次上的函数： 0 层表示当前函数（getinfo 自身）； 1 层表示调用 getinfo 的函数 （除非是尾调用，这种情况不计入栈）；等等。 如果 f 是一个比活动函数数量还大的数字， getinfo 返回 nil。 5. debug.getlocal ([thread,] f, local): 此函数返回在栈的 f 层处函数的索引为 local 的局部变量 的名字和值。 这个函数不仅用于访问显式定义的局部变量，也包括形参、临时变量等。 6.</description></item><item><title>十六、Lua 协同程序(coroutine)</title><link>https://www.hotmindshare.com/docs/cloud-native/lua/16/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.hotmindshare.com/docs/cloud-native/lua/16/</guid><description>Lua 协同程序(coroutine) 什么是协同(coroutine)？ 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 Lua协同程序(coroutine)与线程比较类似：拥有独立的堆栈，独立的局部变量，独立的指令指针，同时又与其它协同程序共享全局变量和其它大部分东西。
协同是非常强大的功能，但是用起来也很复杂。
线程和协同程序区别 线程与协同程序的主要区别在于，一个具有多个线程的程序可以同时运行几个线程，而协同程序却需要彼此协作的运行。
在任一指定时刻只有一个协同程序在运行，并且这个正在运行的协同程序只有在明确的被要求挂起的时候才会被挂起。
协同程序有点类似同步的多线程，在等待同一个线程锁的几个线程有点类似协同。
基本语法 方法 描述 coroutine.create() 创建coroutine，返回coroutine， 参数是一个函数，当和resume配合使用的时候就唤醒函数调用 coroutine.resume() 重启coroutine，和create配合使用 coroutine.yield() 挂起coroutine，将coroutine设置为挂起状态，这个和resume配合使用能有很多有用的效果 coroutine.status() 查看coroutine的状态
注：coroutine的状态有三种：dead，suspend，running，具体什么时候有这样的状态请参考下面的程序 coroutine.wrap（） 创建coroutine，返回一个函数，一旦你调用这个函数，就进入coroutine，和create功能重复 coroutine.running() 返回正在跑的coroutine，一个coroutine就是一个线程，当使用running的时候，就是返回一个corouting的线程号 以下实例演示了以上各个方法的用法： 1-- coroutine_test.lua 文件 2co = coroutine.create( 3 function(i) 4 print(i); 5 end 6coroutine.resume(co, 1) -- 1 7print(coroutine.status(co)) -- dead 8print(&amp;#34;----------&amp;#34;) 9co = coroutine.wrap( 10 function(i) 11 print(i); 12 end 13co(1) 14print(&amp;#34;----------&amp;#34;) 15co2 = coroutine.create( 16 function() 17 for i=1,10 do 18 print(i) 19 if i == 3 then 20 print(coroutine.</description></item><item><title>十七、Lua 文件 I-O</title><link>https://www.hotmindshare.com/docs/cloud-native/lua/17/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.hotmindshare.com/docs/cloud-native/lua/17/</guid><description>Lua 文件 I/O LuaI/O 库用于读取和处理文件。分为简单模式（和C一样）、完全模式。
简单模式（simple model）拥有一个当前输入文件和一个当前输出文件，并且提供针对这些文件相关的操作。 完全模式（complete model） 使用外部的文件句柄来实现。它以一种面对对象的形式，将所有的文件操作定义为文件句柄的方法 简单模式在做一些简单的文件操作时较为合适。但是在进行一些高级的文件操作的时候，简单模式就显得力不从心。例如同时读取多个文件这样的操作，使用完全模式则较为合适。
打开文件操作语句如下：
1file = io.open (filename [, mode]) mode 的值有：
模式 描述 r 以只读方式打开文件，该文件必须存在。 w 打开只写文件，若文件存在则文件长度清为0，即该文件内容会消失。若文件不存在则建立该文件。 a 以附加的方式打开只写文件。若文件不存在，则会建立该文件，如果文件存在，写入的数据会被加到文件尾，即文件原先的内容会被保留。（EOF符保留） r+ 以可读写方式打开文件，该文件必须存在。 w+ 打开可读写文件，若文件存在则文件长度清为零，即该文件内容会消失。若文件不存在则建立该文件。 a+ 与a类似，但此文件可读可写 b 二进制模式，如果文件是二进制文件，可以加上b + 号表示对文件既可以读也可以写 简单模式 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 简单模式使用标准的 I/O 或使用一个当前输入文件和一个当前输出文件。
以下为file.lua 文件代码，操作的文件为test.lua(如果没有你需要创建该文件)，代码如下：
1-- 以只读方式打开文件 2file = io.open(&amp;#34;test.lua&amp;#34;, &amp;#34;r&amp;#34;) 3-- 设置默认输入文件为 test.lua 4io.input(file) 5-- 输出文件第一行 6print(io.read()) 7-- 关闭打开的文件 8io.close(file) 9-- 以附加的方式打开只写文件 10file = io.open(&amp;#34;test.lua&amp;#34;, &amp;#34;a&amp;#34;) 11-- 设置默认输出文件为 test.</description></item><item><title>十三、Lua table(表)</title><link>https://www.hotmindshare.com/docs/cloud-native/lua/13/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.hotmindshare.com/docs/cloud-native/lua/13/</guid><description>Lua table(表) table 是 Lua 的一种数据结构用来帮助我们创建不同的数据类型，如：数字、字典等。
Luatable 使用关联型数组，你可以用任意类型的值来作数组的索引，但这个值不能是 nil。
Luatable 是不固定大小的，你可以根据自己需要进行扩容。
Lua也是通过table来解决模块（module）、包（package）和对象（Object）的。 例如string.format表示使用”format”来索引table string。
table(表)的构造 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 构造器是创建和初始化表的表达式。表是Lua特有的功能强大的东西。最简单的构造函数是{}，用来创建一个空表。可以直接初始化数组:
1-- 初始化表 2mytable = {} 3-- 指定值 4mytable[1]= &amp;#34;Lua&amp;#34; 5-- 移除引用 6mytable = nil 7-- lua 垃圾回收会释放内存 当我们为 table a 并设置元素，然后将 a 赋值给 b，则 a 与 b 都指向同一个内存。如果 a 设置为 nil ，则 b 同样能访问 table 的元素。如果没有指定的变量指向a，Lua的垃圾回收机制会清理相对应的内存。
以下实例演示了以上的描述情况：
1-- 简单的 table 2mytable = {} 3print(&amp;#34;mytable 的类型是 &amp;#34;,type(mytable)) 4mytable[1]= &amp;#34;Lua&amp;#34; 5mytable[&amp;#34;wow&amp;#34;] = &amp;#34;修改前&amp;#34; 6print(&amp;#34;mytable 索引为 1 的元素是 &amp;#34;, mytable[1]) 7print(&amp;#34;mytable 索引为 wow 的元素是 &amp;#34;, mytable[&amp;#34;wow&amp;#34;]) 8-- alternatetable和mytable的是指同一个 table 9alternatetable = mytable 10print(&amp;#34;alternatetable 索引为 1 的元素是 &amp;#34;, alternatetable[1]) 11print(&amp;#34;mytable 索引为 wow 的元素是 &amp;#34;, alternatetable[&amp;#34;wow&amp;#34;]) 12alternatetable[&amp;#34;wow&amp;#34;] = &amp;#34;修改后&amp;#34; 13print(&amp;#34;mytable 索引为 wow 的元素是 &amp;#34;, mytable[&amp;#34;wow&amp;#34;]) 14-- 释放变量 15alternatetable = nil 16print(&amp;#34;alternatetable 是 &amp;#34;, alternatetable) 17-- mytable 仍然可以访问 18print(&amp;#34;mytable 索引为 wow 的元素是 &amp;#34;, mytable[&amp;#34;wow&amp;#34;]) 19mytable = nil 20print(&amp;#34;mytable 是 &amp;#34;, mytable) 以上代码执行结果为：</description></item><item><title>十四、Lua 模块与包</title><link>https://www.hotmindshare.com/docs/cloud-native/lua/14/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.hotmindshare.com/docs/cloud-native/lua/14/</guid><description>Lua 模块与包 模块类似于一个封装库，从 Lua 5.1 开始，Lua 加入了标准的模块管理机制，可以把一些公用的代码放在一个文件里，以 API 接口的形式在其他地方调用，有利于代码的重用和降低代码耦合度。
Lua的模块是由变量、函数等已知元素组成的 table，因此创建一个模块很简单，就是创建一个 table，然后把需要导出的常量、函数放入其中，最后返回这个 table 就行。以下为创建自定义模块 module.lua，文件代码格式如下：
1-- 文件名为 module.lua 2-- 定义一个名为 module 的模块 3module = {} 4-- 定义一个常量 5module.constant = &amp;#34;这是一个常量&amp;#34; 6-- 定义一个函数 7function module.func1() 8 io.write(&amp;#34;这是一个公有函数！\n&amp;#34;) 9end 10local function func2() 11 print(&amp;#34;这是一个私有函数！&amp;#34;) 12end 13function module.func3() 14 func2() 15end 16return module 由上可知，模块的结构就是一个 table 的结构，因此可以像操作调用 table 里的元素那样来操作调用模块里的常量或函数。
上面的func2 声明为程序块的局部变量，即表示一个私有函数，因此是不能从外部访问模块里的这个私有函数，必须通过模块里的公有函数来调用.
require 函数 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 Lua提供了一个名为require的函数用来加载模块。要加载一个模块，只需要简单地调用就可以了。例如：
1require(&amp;#34;&amp;lt;模块名&amp;gt;&amp;#34;) 或者
1require &amp;#34;&amp;lt;模块名&amp;gt;&amp;#34; 执行require 后会返回一个由模块常量或函数组成的 table，并且还会定义一个包含该 table 的全局变量。</description></item><item><title>十五、Lua 元表(Metatable)</title><link>https://www.hotmindshare.com/docs/cloud-native/lua/15/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.hotmindshare.com/docs/cloud-native/lua/15/</guid><description>Lua 元表(Metatable) 在Lua table 中我们可以访问对应的key来得到value值，但是却无法对两个 table 进行操作。
因此Lua 提供了元表(Metatable)，允许我们改变table的行为，每个行为关联了对应的元方法。
例如，使用元表我们可以定义Lua如何计算两个table的相加操作a+b。
当Lua试图对两个表进行相加时，先检查两者之一是否有元表，之后检查是否有一个叫”__add”的字段，若找到，则调用对应的值。”__add”等即时字段，其对应的值（往往是一个函数或是table）就是”元方法”。
有两个很重要的函数来处理元表：
setmetatable(table,metatable): 对指定table设置元表(metatable)，如果元表(metatable)中存在__metatable键值，setmetatable会失败 。 getmetatable(table): 返回对象的元表(metatable)。 以下实例演示了如何对指定的表设置元表：
1mytable = {} -- 普通表 2mymetatable = {} -- 元表 3setmetatable(mytable,mymetatable) -- 把 mymetatable 设为 mytable 的元表 以上代码也可以直接写成一行：
1mytable = setmetatable({},{}) 以下为返回对象元表：
1getmetatable(mytable) -- 这回返回mymetatable __index 元方法 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 这是metatable 最常用的键。
当你通过键来访问 table 的时候，如果这个键没有值，那么Lua就会寻找该table的metatable（假定有metatable）中的__index 键。如果__index包含一个表格，Lua会在表格中查找相应的键。
我们可以在使用 lua 命令进入交互模式查看：
1$ lua 2Lua 5.3.0 Copyright (C) 1994-2015 Lua.org, PUC-Rio 3&amp;gt; other = { foo = 3 } 4&amp;gt; t = setmetatable({}, { __index = other }) 5&amp;gt; t.</description></item><item><title>十一、Lua 数组</title><link>https://www.hotmindshare.com/docs/cloud-native/lua/11/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.hotmindshare.com/docs/cloud-native/lua/11/</guid><description>Lua 数组 数组，就是相同数据类型的元素按一定顺序排列的集合，可以是一维数组和多维数组。
Lua数组的索引键值可以使用整数表示，数组的大小不是固定的。
一维数组 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 一维数组是最简单的数组，其逻辑结构是线性表。一维数组可以用for循环出数组中的元素，如下实例：
1array = {&amp;#34;Lua&amp;#34;, &amp;#34;Tutorial&amp;#34;} 2for i= 0, 2 do 3 print(array[i]) 4end 以上代码执行输出结果为：
1nil 2Lua 3Tutorial 正如你所看到的，我们可以使用整数索引来访问数组元素，如果知道的索引没有值则返回nil。
在Lua 索引值是以 1 为起始，但你也可以指定 0 开始。
除此外我们还可以以负数为数组索引值：
1array = {} 2for i= -2, 2 do 3 array[i] = i *2 4end 5for i = -2,2 do 6 print(array[i]) 7end 以上代码执行输出结果为：
1-4 2-2 多维数组 多维数组即数组中包含数组或一维数组的索引键对应一个数组。
以下是一个三行三列的阵列多维数组：
1-- 初始化数组 2array = {} 3for i=1,3 do 4 array[i] = {} 5 for j=1,3 do 6 array[i][j] = i*j 7 end 8end 9-- 访问数组 10for i=1,3 do 11 for j=1,3 do 12 print(array[i][j]) 13 end 14end 以上代码执行输出结果为：</description></item><item><title>四、Lua 数据类型</title><link>https://www.hotmindshare.com/docs/cloud-native/lua/4/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.hotmindshare.com/docs/cloud-native/lua/4/</guid><description>Lua 数据类型 Lua是动态类型语言，变量不要类型定义,只需要为变量赋值。 值可以存储在变量中，作为参数传递或结果返回。
Lua中有8个基本类型分别为：nil、boolean、number、string、userdata、function、thread和table。
数据类型 描述 nil 这个最简单，只有值nil属于该类，表示一个无效值（在条件表达式中相当于false）。 boolean 包含两个值：false和true。 number 表示双精度类型的实浮点数 string 字符串由一对双引号或单引号来表示 function 由 C 或 Lua 编写的函数 userdata 表示任意存储在变量中的C数据结构 thread 表示执行的独立线路，用于执行协同程序 table Lua 中的表（table）其实是一个”关联数组”（associative arrays），数组的索引可以是数字或者是字符串。在 Lua 里，table 的创建是通过”构造表达式”来完成，最简单构造表达式是{}，用来创建一个空表。 我们可以使用type函数测试给定变量或者值的类型：
1print(type(&amp;#34;Hello world&amp;#34;)) --&amp;gt; string 2print(type(10.4*3)) --&amp;gt; number 3print(type(print)) --&amp;gt; function 4print(type(type)) --&amp;gt; function 5print(type(true)) --&amp;gt; boolean 6print(type(nil)) --&amp;gt; nil 7print(type(type(X))) --&amp;gt; string nil（空） 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 nil类型表示一种没有任何有效值，它只有一个值 — nil，例如打印一个没有赋值的变量，便会输出一个 nil 值：
1&amp;gt; print(type(a)) 2nil 3&amp;gt; 对于全局变量和 table，nil 还有一个”删除”作用，给全局变量或者 table 表里的变量赋一个 nil 值，等同于把它们删掉，执行下面代码就知：</description></item><item><title>四十、Lua 常用数据结构</title><link>https://www.hotmindshare.com/docs/cloud-native/lua/40/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.hotmindshare.com/docs/cloud-native/lua/40/</guid><description>Lua中的table不是一种简单的数据结构，它可以作为其它数据结构的基础。如数组、记录、线性表、队列和集合等，在Lua中都可以通过table来表示。
一、数组 在lua中通过整数下标访问表中的元素即可简单的实现数组。并且数组不必事先指定大小，大小可以随需要动态的增长。
1a = {} 2for i = 1,100 do 3 a[i] = 0 4end 5print(&amp;#34;The length of array &amp;#39;a&amp;#39; is &amp;#34; ..a) 6squares = {1, 4, 9, 16, 25} 7print(&amp;#34;The length of array &amp;#39;a&amp;#39; is &amp;#34; ..squares) 在Lua中习惯上数组的下表从1开始，Lua的标准库与此习惯保持一致，因此如果你的数组下标也是从1开始你就可以直接使用标准库的函数，否则就无法直接使用。
二、二维数组 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 Lua中主要有两种表示矩阵的方法，第一种是用数组的数组表示。也就是说一个表的元素是另一个表。
1local N = 3 2local M = 3 3mt = {} 4for i = 1,N do 5 mt[i] = {} 6 for j = 1,M do 7 mt[i][j] = i * j 8 end 9end 10mt = {} 11for i = 1, N do 12 for j = 1, M do 13 mt[(i - 1) * M + j] = i * j 14 end 15end # 三、链表 Lua中用tables很容易实现链表，每一个节点是一个table，指针是这个表的一个域，并且指向另一个节点(table)。例如，要实现一个只有两个域：值和指针的基本链表，代码如下：</description></item><item><title>五、Lua 变量</title><link>https://www.hotmindshare.com/docs/cloud-native/lua/5/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.hotmindshare.com/docs/cloud-native/lua/5/</guid><description>Lua 变量 变量在使用前，必须在代码中进行声明，即创建该变量。编译程序执行代码之前编译器需要知道如何给语句变量开辟存储区，用于存储变量的值。
Lua变量有三种类型：全局变量、局部变量、表中的域。
函数外的变量默认为全局变量，除非用 local 显示声明。函数内变量与函数的参数默认为局部变量。
局部变量的作用域为从声明位置开始到所在语句块结束（或者是直到下一个同名局部变量的声明）。
变量的默认值均为 nil。
1-- test.lua 文件脚本 2a = 5 -- 全局变量 3local b = 5 -- 局部变量 4function joke() 5 c = 5 -- 全局变量 6 local d = 6 -- 局部变量 7end 8joke() 9print(c,d) --&amp;gt; 5 nil 10do 11 local a = 6 -- 局部变量 12 b = 6 -- 全局变量 13 print(a,b); --&amp;gt; 6 6 14end 15print(a,b) --&amp;gt; 5 6 执行以上实例输出结果为：</description></item><item><title>一、Lua 入门教程</title><link>https://www.hotmindshare.com/docs/cloud-native/lua/1/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.hotmindshare.com/docs/cloud-native/lua/1/</guid><description>Lua 入门教程 Lua是一种轻量小巧的脚本语言，用标准C语言编写并以源代码形式开放， 其设计目的是为了嵌入应用程序中，从而为应用程序提供灵活的扩展和定制功能。
Lua是巴西里约热内卢天主教大学（Pontifical Catholic University of Rio de Janeiro）里的一个研究小组，由Roberto Ierusalimschy、Waldemar Celes 和 Luiz Henrique de Figueiredo所组成并于1993年开发。
设计目的 其设计目的是为了嵌入应用程序中，从而为应用程序提供灵活的扩展和定制功能。
Lua 特性 轻量级: 它用标准C语言编写并以源代码形式开放，编译后仅仅一百余K，可以很方便的嵌入别的程序里。
可扩展: Lua提供了非常易于使用的扩展接口和机制：由宿主语言(通常是C或C++)提供这些功能，Lua可以使用它们，就像是本来就内置的功能一样。
其它特性:
支持面向过程(procedure-oriented)编程和函数式编程(functional programming)；
自动内存管理；只提供了一种通用类型的表（table），用它可以实现数组，哈希表，集合，对象；
语言内置模式匹配；闭包(closure)；函数也可以看做一个值；提供多线程（协同进程，并非操作系统所支持的线程）支持；
通过闭包和table可以很方便地支持面向对象编程所需要的一些关键机制，比如数据抽象，虚函数，继承和重载等。
Lua 应用场景 游戏开发 独立应用脚本 Web 应用脚本 扩展和数据库插件如：MySQL Proxy 和 MySQL WorkBench 安全系统，如入侵检测系统 第一个 Lua 程序 接下来我们使用 Lua 来输出”Hello World!”
实例(Lua 5.3) print(“Hello World!”)
尝试一下 »
运行后，会在屏幕上显示 Hello, world!。</description></item></channel></rss>