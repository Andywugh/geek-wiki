<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>RabbitMQ源码剖析 on 程序员安仔</title><link>https://www.shellio.cc/docs/mq/rabbitmq-advanced/</link><description>Recent content in RabbitMQ源码剖析 on 程序员安仔</description><generator>Hugo -- gohugo.io</generator><language>zh-hans</language><copyright>粤ICP备2023148789号</copyright><atom:link href="https://www.shellio.cc/docs/mq/rabbitmq-advanced/index.xml" rel="self" type="application/rss+xml"/><item><title>八、RabbitMQ-客户端源码之ChannelN</title><link>https://www.shellio.cc/docs/mq/rabbitmq-advanced/8/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/mq/rabbitmq-advanced/8/</guid><description>作者：朱小厮 | 出自：https://hiddenpps.blog.csdn.net/column/info/14800
ChannelN是整个RabbitMQ客户端最核心的一个类了，其包含的功能点甚多，这里需要分类阐述。
首先来看看ChannelN的成员变量：
1private final Map 2 3 4 5 _consumers = Collections.synchronizedMap(new HashMap 6 7 8 9 ()); 10private volatile Consumer defaultConsumer = null; 11private final ConsumerDispatcher dispatcher; 12private final Collection 13 14 15 16 returnListeners = new CopyOnWriteArrayList 17 18 19 20 (); 21private final Collection 22 23 24 flowListeners = new CopyOnWriteArrayList 25 26 (); private volatile CountDownLatch finishedShutdownFlag = null; private final Collection 27 28 confirmListeners = new CopyOnWriteArrayList 29 30 (); private long nextPublishSeqNo = 0L; private final SortedSet 31 32 unconfirmedSet = Collections.</description></item><item><title>二、RabbitMQ-客户端源码之AMQConnection</title><link>https://www.shellio.cc/docs/mq/rabbitmq-advanced/2/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/mq/rabbitmq-advanced/2/</guid><description>作者：朱小厮 | 出自：https://hiddenpps.blog.csdn.net/column/info/14800
上一篇文章（[一]RabbitMQ-客户端源码之ConnectionFactory）中阐述了conn.start()方法完成之后客户端就已经和broker建立了正常的连接，而这个Connection的关键就在于这个start()方法之内，下面我们来慢慢分析。
首先来看看start()方法的源码，这个方法有点长，这里拆开来一一分析，首先是注释：
1/** 2 * Start up the connection, including the MainLoop thread. 3 * Sends the protocol 4 * version negotiation header, and runs through 5 * Connection.Start/.StartOk, Connection.Tune/.TuneOk, and then 6 * calls Connection.Open and waits for the OpenOk. Sets heart-beat 7 * and frame max values after tuning has taken place. 8 * @throws IOException if an error is encountered 9 * either before, or during, protocol negotiation; 10 * sub-classes {@link ProtocolVersionMismatchException} and 11 * {@link PossibleAuthenticationFailureException} will be thrown in the 12 * corresponding circumstances.</description></item><item><title>九、RabbitMQ-客户端源码之Consumer</title><link>https://www.shellio.cc/docs/mq/rabbitmq-advanced/9/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/mq/rabbitmq-advanced/9/</guid><description>作者：朱小厮
出自：https://hiddenpps.blog.csdn.net/column/info/14800
在[八]RabbitMQ-客户端源码之ChannelN中讲述basicConsume的方法时设计到Consumer这个回调函数，Consumer其实是一个接口，真正实现它的是QueueingConsumer和DefaultConsumer，且DefaultConsumer是QueueingConsumer的父类，里面都是空方法。在用户使用时可以简单的采用QueueingConsumer或者采用DefaultConsumer来重写某些方法。
这里先来看下消费者客户端的关键代码：
1QueueingConsumer consumer = new QueueingConsumer(channel); 2channel.basicQos(32); 3channel.basicConsume(QUEUE_NAME, false, &amp;#34;consumer_zzh&amp;#34;,consumer) 4while (true) { 5 QueueingConsumer.Delivery delivery = consumer.nextDelivery(); 6 String message = new String(delivery.getBody()); 7 System.out.println(&amp;#34; [X] Received &amp;#39;&amp;#34; + message + &amp;#34;&amp;#39;&amp;#34;); 8 channel.basicAck(delivery.getEnvelope().getDeliveryTag(),false); 可以看到QueueingConsumer作为channel.basicConsume的回调函数，之后再进行处理。
在AMQConnection中有关MainLoop的主线程，专门用来”第一线”的处理Broker发送回客户端从帧。当Basic.Consume/.ConsumeOk开启消费模式之后，Broker主动的向客户端发送Basic.Delivery帧，MainLoop线程一步步的调用，最后到ChannelN的processAsync()方法中有：
1if (method instanceof Basic.Deliver) { 2 processDelivery(command, (Basic.Deliver) method); 3 return true; 4} 之后调用processDelivery方法：
1protected void processDelivery(Command command, Basic.Deliver method) { 2 Basic.Deliver m = method; 3 Consumer callback = _consumers.</description></item><item><title>六、RabbitMQ-客户端源码之AMQCommand</title><link>https://www.shellio.cc/docs/mq/rabbitmq-advanced/6/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/mq/rabbitmq-advanced/6/</guid><description>作者：朱小厮 | 出自：https://hiddenpps.blog.csdn.net/column/info/14800
AMQCommand是用来处理AMQ命令的，其包含了Method, Content Heaeder和Content Body.
下面是通过wireshark抓包的AMQP协议
上图中的Basic.Publish命令就包含Method, Content header以及Content body。
AMQCommand不是直接包含Method等成员变量的，而是通过CommandAssembler又做了一次封装。
接下来先看下CommandAssembler类。此类中有这些成员变量：
1/** Current state, used to decide how to handle each incoming frame. */ 2private enum CAState { 3 EXPECTING_METHOD, EXPECTING_CONTENT_HEADER, EXPECTING_CONTENT_BODY, COMPLETE 4private CAState state; 5/** The method for this command */ 6private Method method; 7/** The content header for this command */ 8private AMQContentHeader contentHeader; 9/** The fragments of this command&amp;#39;s content body - a list of byte[] */ 10private final List 11 12 13 14 bodyN; 15/** sum of the lengths of all fragments */ 16private int bodyLength; 17/** No bytes of content body not yet accumulated */ 18private long remainingBodyBytes; 19 20 CAState state标识这此Command目前的状态，是准备处理Method(EXPECTING_METHOD)，还是处理Content header(EXPECTING_CONTENT_HEADER),还是准备处理Content body（EXPECTING_CONTENT_BODY），还是以及完成了（COMPLETE）。 Method method代表type=Method的AMQP帧 AMQContentHeader contentHeader代表type=Content header的AMQP帧 final List bodyN代表type=Content body的AMQP帧，就是真正的消息体（Message body）。 bodyLength就是消息体大小 这个类中除了构造函数，getMethod, getContentHeader, getContentBody,isComplete这个几个方法，最关键的方法就是：</description></item><item><title>七、RabbitMQ-客户端源码之AMQPImpl+Method</title><link>https://www.shellio.cc/docs/mq/rabbitmq-advanced/7/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/mq/rabbitmq-advanced/7/</guid><description>作者：朱小厮 | 出自：https://hiddenpps.blog.csdn.net/column/info/14800
AMQPImpl类包括AMQP接口（public class AMQImpl implements AMQP）主要囊括了AMQP协议中的通信帧的类别。
这里以Connection.Start帧做一个例子。
1public static class Connection { 2 public static final int INDEX = 10; 3 public static class Start 4 extends Method 5 implements com.rabbitmq.client.AMQP.Connection.Start 6 { 7 public static final int INDEX = 10; 8 private final int versionMajor; 9 private final int versionMinor; 10 private final Map 11 12 13 14 serverProperties; 15 private final LongString mechanisms; 16 private final LongString locales; 17.</description></item><item><title>三、RabbitMQ-客户端源码之ChannelManager</title><link>https://www.shellio.cc/docs/mq/rabbitmq-advanced/3/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/mq/rabbitmq-advanced/3/</guid><description>作者：朱小厮 | 出自：https://hiddenpps.blog.csdn.net/column/info/14800
关于ChannelManager，官方注解：Manages a set of channels, indexed by channel number (1… _channelMax)。
ChannelManager类的代码量不是很多，主要用来管理Channel的，channelNumber=0的除外，应为channelNumber=0是留给Connection的特殊的channelNumber。
下面是ChannelManager的成员变量：
1/** Monitor for _channelMap and channelNumberAllocator */ 2private final Object monitor = new Object(); 3 /** Mapping from 1.._channelMax to {@link ChannelN} instance */ 4 private final Map 5 6 7 8 _channelMap = new HashMap 9 10 11 12 (); 13 private final IntAllocator channelNumberAllocator; 14private final ConsumerWorkService workService; 15private final Set 16 17 18 19 shutdownSet = new HashSet 20 21 22 23 (); 24/** Maximum channel number available on this connection.</description></item><item><title>四、RabbitMQ-客户端源码之Frame</title><link>https://www.shellio.cc/docs/mq/rabbitmq-advanced/4/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/mq/rabbitmq-advanced/4/</guid><description>作者：朱小厮 | 出自：https://hiddenpps.blog.csdn.net/column/info/14800
Frame是指AMQP协议层面的通信帧（一个正式定义的连接数据包）。
我们来看下Frame类中的成员变量有哪些：
1/** Frame type code */ 2public final int type; 3/** Frame channel number, 0-65535 */ 4public final int channel; 5/** Frame payload bytes (for inbound frames) */ 6private final byte[] payload; 7/** Frame payload (for outbound frames) */ 8private final ByteArrayOutputStream accumulator; Frame里的三个成员变量：type, channel, payload是真正和报文有关的。accumulator是为了方便内部编程的一个变量。Frame类就是对这个玩意儿捯饬捯饬，没有什么难度，好奇的同学可以自己翻看下，本文主要来阐述下AMQP中的Frame的一些信息。
一个通信帧的协议层面的结构如下：
序号 名称 占用字节 1 frame type 1B 2 channel number 2B 3 payload length 4B 4 payload [0-N]B 5 FRAME_END(结束帧) 1B(0xCE) 这样可以知道：一个通信帧的最小大小为：1B+2B+4B+0B+1B=8B.</description></item><item><title>五、RabbitMQ-客户端源码之AMQChannel</title><link>https://www.shellio.cc/docs/mq/rabbitmq-advanced/5/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/mq/rabbitmq-advanced/5/</guid><description>作者：朱小厮 | 出自：https://hiddenpps.blog.csdn.net/column/info/14800
AMQChannel是一个抽象类，是ChannelN的父类。其中包含唯一的抽象方法：
1/** 2 * Protected API - called by nextCommand to check possibly handle an incoming Command before it is returned to the caller of nextCommand. If this method 3 * returns true, the command is considered handled and is not passed back to nextCommand&amp;#39;s caller; if it returns false, nextCommand returns the command as 4 * usual. This is used in subclasses to implement handling of Basic.</description></item><item><title>一、RabbitMQ-客户端源码之ConnectionFactory</title><link>https://www.shellio.cc/docs/mq/rabbitmq-advanced/1/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/mq/rabbitmq-advanced/1/</guid><description>作者：朱小厮 | 出自：https://hiddenpps.blog.csdn.net/column/info/14800
1ConnectionFactory factory = new ConnectionFactory(); 2factory.setHost(ip); 3factory.setPort(5672); 4factory.setUsername(&amp;#34;root&amp;#34;); 5factory.setPassword(&amp;#34;root&amp;#34;); 6Connection connection = factory.newConnection(); 7Channel channel = connection.createChannel(); 8String message = &amp;#34;RabbitMQ Demo Test:&amp;#34; + System.currentTimeMillis(); 9channel.basicPublish(EXCHANGE_NAME, routingKey, MessageProperties.PERSISTENT_TEXT_PLAIN, message.getBytes()); 10channel.close(); 11connection.close(); 相信使用rabbitmq java客户端的同学来说，这段代码并不陌生，主要的作用是发送一条消息至broker然后关闭。通过wireshark抓包工具可以看到整个AMQP协议的流程，如下图：
（xx.xx.48.240是client的ip，xx.xx.197.73是broker的ip）
下面通过源码来分析下Connection有关的整个流程，对于上面AMQP流程中的Protocol-Header到Connection.Open-Ok的部分。
首先是ConnectionFactory类(文章开篇的demo中)，这里主要包含一些与broker连接的配置参数等,比如：username, password, virtualHost, host,port, requestedChannelMax, requestedFrameMax, requestedHeartbeat, connectionTimeout, shutdownTimeout（只列出部分）。
这个类中其余都是些Getter和Setter方法，但是有个newConnection方法是关键，文中开篇的demo代码下面列出详细内容：
1/** 2 * Create a new broker connection, picking the first available address from 3 * the list. 4 * 5 * If automatic connection recovery 6 * is enabled, the connection returned by this method will be {@link Recoverable}.</description></item></channel></rss>