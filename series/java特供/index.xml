<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Java特供 on 程序员安仔</title><link>https://www.shellio.cc/series/java%E7%89%B9%E4%BE%9B/</link><description>Recent content in Java特供 on 程序员安仔</description><generator>Hugo -- gohugo.io</generator><language>zh-hans</language><copyright>粤ICP备2023148789号</copyright><lastBuildDate>Sat, 21 Oct 2023 12:22:54 +0800</lastBuildDate><atom:link href="https://www.shellio.cc/series/java%E7%89%B9%E4%BE%9B/index.xml" rel="self" type="application/rss+xml"/><item><title>八、1.3 修改 web.xml</title><link>https://www.shellio.cc/docs/java/jfinal/8/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/jfinal/8/</guid><description>将如下内容添加至 web.xml
jfinal
com.jfinal.core.JFinalFilter
configClass demo.DemoConfig
jfinal
/*</description></item><item><title>八、Gradle Groovy 快速入门</title><link>https://www.shellio.cc/docs/java/gradle/8/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/gradle/8/</guid><description>Groovy 快速入门 要构建一个 Groovy 项目，你需要使用 Groovy 插件。该插件扩展了 Java 插件，对你的项目增加了 Groovy 的编译功能. 你的项目可以包含 Groovy 源码，Java 源码，或者两者都包含。在其他各方面，Groovy 项目与我们在第七章 Java 快速入门中所看到的Java 项目几乎相同。
一个基本的 Groovy 项目 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 让我们来看一个例子。要使用 Groovy 插件，你需要在构建脚本文件当中添加以下内容：
例子Groovy plugin
build.gradle
1apply plugin: &amp;#39;groovy&amp;#39; 注意：此例子的代码可以在 Gradle 的二进制文件或源码中的 samples/groovy/quickstart 里看到。
这段代码同时会将 Java 插件应用到 project 中，如果 Java 插件还没被应用的话。Groovy 插件继承了 compile 任务 ，在 src/main/groovy 目录中查找源文件；且继承了 compileTest 任务，在 src/test/groovy 目录中查找测试的源文件。这些编译任务对这些目录使用了联合编译，这意味着它们可以同时包含 java 和 groovy 源文件。
要使用groovy 编译任务，还必须声明要使用的 Groovy 版本以及从哪里获取 Groovy 库。你可以通过在 groovy 配置中添加依赖来完成。compile 配置继承了这个依赖,从而在编译 Groovy和 Java 源代码时，groovy 库也会被包含在类路径中。下面例子中，我们会使用 Maven 中央仓库中的 Groovy 2.</description></item><item><title>八、Groovy 条件语句</title><link>https://www.shellio.cc/docs/java/groovy/8/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/groovy/8/</guid><description>条件声明需要程序指定一个或者多个条件进行判断，如果条件被确定为真，则要执行一个或多个语句；如果条件被确定为假，则要执行其他语句。
序号 语句和描述 1 if语句 这个语句的一般工作是首先在if语句中计算一个条件。如果条件为真，它然后执行语句。
2 if / else语句 这个语句的一般工作是首先在if语句中计算一个条件。如果条件为真，则其后执行语句，并在else条件之前停止并退出循环。如果条件为假，则执行else语句块中的语句，然后退出循环。
3 嵌套if语句 i有时需要有多个if语句嵌入在彼此内部。
4 Switch语句 有时，嵌套的if-else语句是如此常见，并且经常使用，因此设计了一个更容易的语句，称为switch语句。
5 嵌套switch语句 switch也可以多层嵌套。</description></item><item><title>八、Hibernate 持久化类</title><link>https://www.shellio.cc/docs/java/hibernate/8/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/hibernate/8/</guid><description>持久化类 Hibernate 的完整概念是提取 Java 类属性中的值，并且将它们保存到数据库表单中。映射文件能够帮助 Hibernate 确定如何从该类中提取值，并将它们映射在表格和相关域中。
在Hibernate 中，其对象或实例将会被存储在数据库表单中的 Java 类被称为持久化类。若该类遵循一些简单的规则或者被大家所熟知的 Plain Old Java Object (POJO) 编程模型，Hibernate 将会处于其最佳运行状态。以下所列就是持久化类的主要规则，然而，在这些规则中，没有一条是硬性要求。
所有将被持久化的 Java 类都需要一个默认的构造函数。 为了使对象能够在 Hibernate 和数据库中容易识别，所有类都需要包含一个 ID。此属性映射到数据库表的主键列。 所有将被持久化的属性都应该声明为 private，并具有由 JavaBean 风格定义的 getXXX 和 setXXX 方法。 Hibernate 的一个重要特征为代理，它取决于该持久化类是处于非 final 的，还是处于一个所有方法都声明为 public 的接口。 所有的类是不可扩展或按 EJB 要求实现的一些特殊的类和接口。 POJO 的名称用于强调一个给定的对象是普通的 Java 对象，而不是特殊的对象，尤其不是一个 Enterprise JavaBean。
一个简单的 POJO 的例子 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 基于以上所述规则，我们能够定义如下 POJO 类：
1public class Employee { 2 private int id; 3 private String firstName; 4 private String lastName; 5 private int salary; 6 public Employee() {} 7 public Employee(String fname, String lname, int salary) { 8 this.</description></item><item><title>八、Java 8 Lambda 表达式 （ 下 ）范例</title><link>https://www.shellio.cc/docs/java/java8/8/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/java8/8/</guid><description>经过Java 8 Lambda 表达式 （ 上 ）- 简介 和 Java 8 Lambda 表达式 （ 中 ）- 外部参数 两个章节的学习，想必你已经对 Java 8 中的 Lambda 表达式已经非常熟悉了。
本章节我们就来回顾下上面两章节的所学知识，然后写一些范例巩固下。
回顾 lambda 表达式是 java 8 引入的最重要的功能之一。 lambda 表达式为那些只包含一个方法的接口提供了简洁代码，例如函数接口 ( function interface )。 lambda 表达式还为集合的迭代提供了一种更为简单的方式。 对于那些使用匿名类或内部类实现的单个方法接口，在 Java 8 中，可以使用 lambda 表达式来实现。不仅功能相同，而且代码更简洁。 lambda 表达式真正的原理，是 「 为那些函数接口定义了它们包含的唯一方法，而且返回函数接口的实例 」
lambda 表达式语法 lambda 表达式语法非常易于阅读和理解
lambda 表达式语法看起来像
1(Argument part) -&amp;gt; Body part 例如
1、 如果某个方法没有参数，并打印信息，则可能像下面这样；
1 () -&amp;gt; System.out.println(&amp;#34;Your message&amp;#34;); 2、 如果某个方法接受两个参数，执行一些业务逻辑并返回值，则看起来可能像下面这样；</description></item><item><title>八、Java 9 新特性 – 集合不可变实例工厂方法</title><link>https://www.shellio.cc/docs/java/java9/8/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/java9/8/</guid><description>Java 9 为集合接口 ( List 、Set 、Map ) 提供了创建 不可变实例 的工厂方法。这些工厂方法为便利而生，以简介简单的方式创建这些集合
老式的创建集合的方法 我们先来看看默认的老式的创建集合的方法，创建一个文件 CollectionFactoryMethodTester.java ，并输入以下内容
1import java.util.ArrayList; 2import java.util.Collections; 3import java.util.HashMap; 4import java.util.HashSet; 5import java.util.List; 6import java.util.Map; 7import java.util.Set; 8public class CollectionFactoryMethodTester { 9 public static void main(String []args) { 10 Set&amp;lt;String&amp;gt; set = new HashSet&amp;lt;&amp;gt;(); 11 set.add(&amp;#34;A&amp;#34;); 12 set.add(&amp;#34;B&amp;#34;); 13 set.add(&amp;#34;C&amp;#34;); 14 set = Collections.unmodifiableSet(set); 15 System.out.println(set); 16 List&amp;lt;String&amp;gt; list = new ArrayList&amp;lt;&amp;gt;(); 17 list.add(&amp;#34;A&amp;#34;); 18 list.add(&amp;#34;B&amp;#34;); 19 list.add(&amp;#34;C&amp;#34;); 20 list = Collections.</description></item><item><title>八、JSP 动作元素</title><link>https://www.shellio.cc/docs/java/jsp/8/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/jsp/8/</guid><description>JSP 动作元素 与JSP指令元素不同的是，JSP动作元素在请求处理阶段起作用。JSP动作元素是用XML语法写成的。
利用JSP动作可以动态地插入文件、重用JavaBean组件、把用户重定向到另外的页面、为Java插件生成HTML代码。
动作元素只有一种语法，它符合XML标准：
1&amp;lt;jsp:action_name attribute=&amp;#34;value&amp;#34; /&amp;gt; 动作元素基本上都是预定义的函数，JSP规范定义了一系列的标准动作，它用JSP作为前缀，可用的标准动作元素如下：
语法 描述 jsp:include 在页面被请求的时候引入一个文件。 jsp:useBean 寻找或者实例化一个JavaBean。 jsp:setProperty 设置JavaBean的属性。 jsp:getProperty 输出某个JavaBean的属性。 jsp:forward 把请求转到一个新的页面。 jsp:plugin 根据浏览器类型为Java插件生成OBJECT或EMBED标记。 jsp:element 定义动态XML元素 jsp:attribute 设置动态定义的XML元素属性。 jsp:body 设置动态定义的XML元素内容。 jsp:text 在JSP页面和文档中使用写入文本的模板 常见的属性 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 所有的动作要素都有两个属性：id属性和scope属性。
id属性： id属性是动作元素的唯一标识，可以在JSP页面中引用。动作元素创建的id值可以通过PageContext来调用。
scope属性： 该属性用于识别动作元素的生命周期。 id属性和scope属性有直接关系，scope属性定义了相关联id对象的寿命。 scope属性有四个可能的值： (a) page, (b)request, (c)session, 和 (d) application。
动作元素 动作元素用来包含静态和动态的文件。该动作把指定文件插入正在生成的页面。语法格式如下：
1&amp;lt;jsp:include page=&amp;#34;relative URL&amp;#34; flush=&amp;#34;true&amp;#34; /&amp;gt; 前面已经介绍过include指令，它是在JSP文件被转换成Servlet的时候引入文件，而这里的jsp:include动作不同，插入文件的时间是在页面被请求的时候。
以下是include动作相关的属性列表。
属性 描述 page 包含在页面中的相对URL地址。 flush 布尔属性，定义在包含资源前是否刷新缓存区。 实例 以下我们定义了两个文件date.jsp和main.jsp，代码如下所示：
date.jsp文件代码：
1&amp;lt;p&amp;gt; 2 Today&amp;#39;s date: &amp;lt;%= (new java.</description></item><item><title>八、JUnit – 执行过程</title><link>https://www.shellio.cc/docs/java/junit/8/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/junit/8/</guid><description>JUnit – 执行过程 本教程阐明了 JUnit 中的方法执行过程，即哪一个方法首先被调用，哪一个方法在一个方法之后调用。以下为 JUnit 测试方法的 API，并且会用例子来说明。
在目录C:\ &amp;gt; JUNIT_WORKSPACE 创建一个 java 类文件命名为 JunitAnnotation.java 来测试注释程序。
1import org.junit.After; 2import org.junit.AfterClass; 3import org.junit.Before; 4import org.junit.BeforeClass; 5import org.junit.Ignore; 6import org.junit.Test; 7public class ExecutionProcedureJunit { 8 //execute only once, in the starting 9 @BeforeClass 10 public static void beforeClass() { 11 System.out.println(&amp;#34;in before class&amp;#34;); 12 } 13 //execute only once, in the end 14 @AfterClass 15 public static void afterClass() { 16 System.</description></item><item><title>八、Maven 创建工程</title><link>https://www.shellio.cc/docs/java/maven/8/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/maven/8/</guid><description>Maven – 创建工程 Maven 使用**原型（archetype）**插件创建工程。要创建一个简单的 Java 应用，我们将使用 maven-archetype-quickstart 插件。在下面的例子中，我们将在 C:\MVN 文件夹下创建一个基于 maven 的 java 应用工程。
我们打开命令控制台，跳转到 C:\MVN 目录，并执行下面的 mvn 命令。
1C:\MVN&amp;gt;mvn archetype:generate 2-DgroupId=com.companyname.bank 3-DartifactId=consumerBanking 4-DarchetypeArtifactId=maven-archetype-quickstart 5-DinteractiveMode=false Maven 将开始处理，并将创建完成的 java 应用工程结构。
1INFO] Scanning for projects... 2[INFO] Searching repository for plugin with prefix: &amp;#39;archetype&amp;#39;. 3[INFO] ------------------------------------------------------------------- 4[INFO] Building Maven Default Project 5[INFO] task-segment: [archetype:generate] (aggregator-style) 6[INFO] ------------------------------------------------------------------- 7[INFO] Preparing archetype:generate 8[INFO] No goals needed for project - skipping 9[INFO] [archetype:generate {execution: default-cli}] 10[INFO] Generating project in Batch mode 11[INFO] ------------------------------------------------------------------- 12[INFO] Using following parameters for creating project 13 from Old (1.</description></item><item><title>八、Memcached replace 命令</title><link>https://www.shellio.cc/docs/java/memcached/8/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/memcached/8/</guid><description>Memcached replace 命令用于替换已存在的 key(键) 的 value(数据值)
语法 1replace key flags exptime bytes [noreply] 2value 参数说明 key : 键值 key-value 结构中的 key，用于查找缓存值。 flags ：可以包括键值对的整型参数，客户机使用它存储关于键值对的额外信息 exptime ：在缓存中保存键值对的时间长度（以秒为单位，0 表示永远） bytes ：在缓存中存储的字节数 noreply ：可选, 该参数告知服务器不需要返回数据 value ：存储的值（始终位于第二行）（可直接理解为key-value结构中的value） 返回值说明 如果数据替换成功，返回 STORED 如果键不存在，返回 NOT_STORED 如果执行错误，返回 CLIENT_ERROR 范例 1. 数据替换成功，返回 STORED 1flush_all 2OK 3set greeting 0 1000 11 4hello,world 5STORED 6replace greeting 0 1000 17 7hello,ddkk.com 8STORED 2. 如果键不存在，返回 NOT_STORED 1flush_all 2OK 3replace greeting 0 1000 17 4hello,ddkk.</description></item><item><title>二、0.1 极速 体验 Generator</title><link>https://www.shellio.cc/docs/java/jfinal/2/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/jfinal/2/</guid><description>JFinal 2.1 新增了 Generator 用来极速生成 Model、BaseModel、MappingKit、DataDictionary文件 。 使 用 时 通 常 只 需 配 置 Generator 的 四 个 参 数 即 可 ： baseModelPackageName 、 baseModelOutputDir、modelPackageName、modelOutputDir。四个参数分别表示 baseMode 的包 名，baseModel 的输出路径，modle 的包名，model 的输出路径，以下是示例代码：
1// base model 所使用的包名 2String baseModelPkg = &amp;#34;model.base&amp;#34;; 3// base model 文件保存路径 4String baseModelDir = PathKit.getWebRootPath() + &amp;#34;/../src/model/base&amp;#34;; 5// model 所使用的包名 6String modelPkg = &amp;#34;model&amp;#34;; 7// model 文件保存路径 8String modelDir = baseModelDir+ &amp;#34;/..&amp;#34;; 9Generator gernerator = new Generator(dataSource, baseModelPkg, baseModelDir,modelPkg, modelDir); 10gernerator.</description></item><item><title>二、Gradle 概述</title><link>https://www.shellio.cc/docs/java/gradle/2/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/gradle/2/</guid><description>概述 特性说明 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 下面是一些 Gradle 特性的列表。
基于声明的构建和基于约定的构建 Gradle 的核心在于基于 Groovy 的丰富而可扩展的域描述语言(DSL)。 Groovy 通过声明性的语言元素将基于声明的构建推向下层，你可以按你想要的方式进行组合。 这些元素同样也为支持 Java， Groovy，OSGi，Web 和 Scala 项目提供了基于约定的构建。 并且，这种声明性的语言是可以扩展的。你可以添加新的或增强现有的语言元素。 因此，它提供了简明、可维护和易理解的构建。
为以依赖为基础的编程方式提供语言支持 声明性语言优点在于通用任务图，你可以将其充分利用在构建中. 它提供了最大限度的灵活性，以让 Gradle 适应你的特殊需求。
构建结构化 Gradle 的灵活和丰富性最终能够支持在你的构建中应用通用的设计模式。 例如，它可以很容易地将你的构建拆分为多个可重用的模块，最后再进行组装，但不要强制地进行模块的拆分。 不要把原本在一起的东西强行分开（比如在你的项目结构里），从而避免让你的构建变成一场噩梦。 最后，你可以创建一个结构良好，易于维护，易于理解的构建。
深度 API Gradle 允许你在构建执行的整个生命周期，对它的核心配置及执行行为进行监视并自定义。
Gradle 的扩展 Gradle 有非常良好的扩展性。 从简单的单项目构建，到庞大的多项目构建，它都能显著地提升你的效率。 这才是真正的结构化构建。通过最先进的增量构建功能，它可以解决许多大型企业所面临的性能瓶颈问题。
多项目构建 Gradle 对多项目构建的支持非常出色。项目依赖是首先需要考虑的问题。 我们允许你在多项目构建当中对项目依赖关系进行建模，因为它们才是你真正的问题域。 Gradle 遵守你的布局。
Gradle 提供了局部构建的功能。 如果你在构建一个单独的子项目，Gradle 也会帮你构建它所依赖的所有子项目。 你也可以选择重新构建依赖于特定子项目的子项目。 这种增量构建将使得在大型构建任务中省下大量时间。
多种方式管理依赖 不同的团队喜欢用不同的方式来管理他们的外部依赖。 从 Maven 和 Ivy 的远程仓库的传递依赖管理，到本地文件系统的 jar 包或目录，Gradle 对所有的管理策略都提供了方便的支持。
Gradle 是第一个构建集成工具 Anttasks 是最重要的。而更有趣的是，Ant projects 也是最重要的。 Gradle 对任意的 Ant 项目提供了深度导入，并在运行时将 Ant 目标(target)转换为原生的 Gradle 任务(task)。 你可以从 Gradle 上依赖它们(Ant targets)，增强它们，甚至在你的 build.</description></item><item><title>二、Groovy 环境</title><link>https://www.shellio.cc/docs/java/groovy/2/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/groovy/2/</guid><description>有多种方式来获得的Groovy环境设置。
下载和安装 -进入该链接www.groovy-lang.org/download.html获得Windows安装程序部分。
启动Groovy安装程序，然后请执行以下完成安装步骤。
第1步 -选择语言安装程序。
第2步 -点击下一步按钮。
第3步 -点击“我同意”按钮。
第4步 -接受默认组件，然后单击下一步按钮。
第5步 -选择适当的目标文件夹，然后单击下一步按钮。
第6步 -点击安装按钮开始安装。
第7步 -一旦安装完成后，单击下一步按钮开始配置。
第8步 -选择默认选项，并单击下一步按钮。
第9步 -接受默认的文件关联，然后单击下一步按钮。
第10步 -单击Finish按钮完成安装。
一旦上述步骤之后，你就可以开始使用Groovy shell，有助于测试我们的Groovy，而不需要为Groovy提供一个完整的集成开发环境。可以通过在命令提示符下命令groovysh来完成。
如果你想包含groovy二进制文件作为maven或gradle构建的一部分，你可以添加以下行
# Gradle 1&amp;#39;org.codehaus.groovy:groovy:2.4.5&amp;#39; Maven 1&amp;lt;groupId&amp;gt;org.codehaus.groovy&amp;lt;/groupId&amp;gt; 2&amp;lt;artifactId&amp;gt;groovy&amp;lt;/artifactId&amp;gt; 3&amp;lt;version&amp;gt;2.4.5&amp;lt;/version&amp;gt;</description></item><item><title>二、Hibernate ORM 概览</title><link>https://www.shellio.cc/docs/java/hibernate/2/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/hibernate/2/</guid><description>ORM 概览 什么是 JDBC？ 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 JDBC 代表 Java Database Connectivity ，它是提供了一组 Java API 来访问关系数据库的 Java 程序。这些 Java APIs 可以使 Java 应用程序执行 SQL 语句，能够与任何符合 SQL 规范的数据库进行交互。
JDBC 提供了一个灵活的框架来编写操作数据库的独立的应用程序，该程序能够运行在不同的平台上且不需修改，能够与不同的 DBMS 进行交互。
JDBC 的优点和缺点 JDBC 的优点 JDBC 的缺点 干净整洁的 SQL 处理 大项目中使用很复杂 大数据下有良好的性能 很大的编程成本 对于小应用非常好 没有封装 易学的简易语法 难以实现 MVC 的概念 &amp;nbsp; 查询需要指定 DBMS 为什么是对象关系映射（ORM）？ 当我们工作在一个面向对象的系统中时，存在一个对象模型和关系数据库不匹配的问题。RDBMSs 用表格的形式存储数据，然而像 Java 或者 C# 这样的面向对象的语言它表示一个对象关联图。考虑下面的带有构造方法和公有方法的 Java 类：
1public class Employee { 2 private int id; 3 private String first_name; 4 private String last_name; 5 private int salary; 6 public Employee() {} 7 public Employee(String fname, String lname, int salary) { 8 this.</description></item><item><title>二、Java 9 新特性 – 特性简介</title><link>https://www.shellio.cc/docs/java/java9/2/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/java9/2/</guid><description>Java 9 ( 又称为 jdk 1.9 ) 是 Java 编程语言开发的主要版本。它的初始版本于 2017 年 9 月21 日发布
按照今天的日期，也就是差不多一年前吧，但是，要知道，Java 10 都已经出来了…. 残废的 Java 9 ，大家还没用上，就开始过时了。
Java 9 的目标 Java 9 版本的主要目标是
1、 模块化JDK和Java标准版(JavaStandardEdition)，使得Java可以用在小型计算设备中；
今天，我才牢牢记住了 Java SE 的全称，竟然是 Java Standard Edition
2、 提高JDK和Java实现的整体安全性；
3、 简化JAVASE和JavaEE平台上的Java代码库和大型应用程序的构建和维护过程；
4、 设计和实现能够应用于JavaPlatform和JavaJDK上的标准模块系统；
其实看这几个主要目标，Java 9 的最大的变更应该就是开始模块化…，
这也导致了 Java 9 不突出的原因吧。毕竟 Java 开发人员日常使用 Java 9 的过程中，对模块化并没有明显的感知
Java 9 新特性 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 Java 9 在以上 4 个目标的基础上做了大量的工作，可以对外称道的应该有 90+ 个，但是，大部分都是小修小改，不足道也。
我们就介绍几个比较大一点的特性吧
1、 模块化(Module)；</description></item><item><title>二、Java8 IntStream,LongStream,DoubleStream</title><link>https://www.shellio.cc/docs/java/java8/2/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/java8/2/</guid><description>本章节我们提供一些 Java 8 中的 IntStream、LongStream 和 DoubleStream 使用范例。IntStream、LongStream 和 DoubleStream 分别表示原始 int 流、 原始 long 流 和 原始 double 流。
这三个原始流类提供了大量的方法用于操作流中的数据，同时提供了相应的静态方法来初始化它们自己。
这三个原始流类都在 java.util.stream 命名空间下。
java.util.stream.IntStream java.util.stream.IntStream 是一个原始整数值序列 ( sequence ) 。该流提供了许多方法可以对该流中的元素顺序执行或并行执行一些聚合操作，比如 max() 或 average()
聚合方法 方法 说明 rangeClosed(a,b) 返回子序列 [a,b]，包含起始值，增长步值为 1 range(a,b) 返回子序列 [a,b)，左闭右开，意味着不包括 b sum 计算所有元素的总和 sorted 排序元素 这些方法使用示例如下
IntStreamDemo.java 1package com.ddkk.util.stream; 2import java.util.stream.IntStream; 3public class IntStreamDemo { 4 public static void main(String[] args) { 5 System.out.println(&amp;#34;--Using IntStream.rangeClosed--&amp;#34;); 6 IntStream.</description></item><item><title>二、JSP 开发环境搭建</title><link>https://www.shellio.cc/docs/java/jsp/2/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/jsp/2/</guid><description>JSP 开发环境搭建 JSP开发环境是您用来开发、测试和运行JSP程序的地方。
本节将会带您搭建JSP开发环境，具体包括以下几个步骤。
配置Java开发工具（JDK） 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 这一步涉及Java SDK的下载和PATH环境变量的配置。
您可以从Oracle公司的Java页面中下载SDK：Java SE Downloads
Java SDK下载完后，请按照给定的指示来安装和配置SDK。最后，通过设置PATH和JAVA_HOME环境变量来指明包括java和javac的文件夹路径，通常是java_install_dir/bin和java_install_dir。
假如您用的是Windows系统并且SDK的安装目录为C::\jdk1.5.0_20，那么您就需要在 C:\autoexec.bat 文件中添加以下两行：
1set PATH=C:\jdk1.5.0_20\bin;%PATH% 2set JAVA_HOME=C:\jdk1.5.0_20 或者，在Windows NT/2000/XP下，您可以直接右击我的电脑图标，选择属性，然后高级，然后环境变量，接下来您就可以很方便地设置PATH变量并且确定退出就行了。
在Linux/Unix系统下，如果SDK的安装目录为/usr/local/jdk1.5.0_20并且使用的是C shell，那么您就需要在.cshrc文件中添加以下两行：
1setenv PATH /usr/local/jdk1.5.0_20/bin:$PATH 2setenv JAVA_HOME /usr/local/jdk1.5.0_20 或者，假如您正在使用类似于Borland JBuilder、Eclipse、IntelliJ IDEA和Sun ONE Studio这样的集成开发环境，可以试着编译并运行一个简单的程序来确定IDE（集成开发环境）是否已经知道 SDK的安装目录。
本步骤你也可以参考本站Java开发环境配置章节的教程。
设置Web服务器：Tomcat 目前，市场上有很多支持JSP和Servlets开发的Web服务器。他们中的一些可以免费下载和使用，Tomcat就是其中之一。
Apache Tomcat是一个开源软件，可作为独立的服务器来运行JSP和Servlets，也可以集成在 Apache Web Server中。以下是Tomcat的配置方法：
下载最新版本的Tomcat：http://tomcat.apache.org/。 下载完安装文件后，将压缩文件解压到一个方便的地方，比如Windows下的C:\apache-tomcat-5.5.29目录或者Linux/Unix下的/usr/local/apache-tomcat-5.5.29目录，然后创建CATALINA_HOME环境变量指向这些目录。 在Windows机器下，Tomcat可以通过执行以下命令来启动：
1%CATALINA_HOME%\bin\startup.bat 2或者 3C:\apache-tomcat-5.5.29\bin\startup.bat 在Linux/Unix机器下，Tomcat可以通过执行以下命令来启动：
1$CATALINA_HOME/bin/startup.sh 2或者 3/usr/local/apache-tomcat-5.5.29/bin/startup.sh 成功启动Tomcat后，通过访问http://localhost:8080/便可以使用Tomcat自带的一些web应用了。假如一切顺利的话，您应该能够看到以下的页面：
更多关于配置和运行Tomcat的信息可以在Tomcat提供的文档中找到，或者去Tomcat官网查阅：http://tomcat.apache.org。
在Windows机器下，Tomcat可以通过执行以下命令来停止：
1%CATALINA_HOME%\bin\shutdown 2或者 3C:\apache-tomcat-5.5.29\bin\shutdown 在Linux/Unix机器下，Tomcat可以通过执行以下命令来停止：
1$CATALINA_HOME/bin/shutdown.sh 2或者 3/usr/local/apache-tomcat-5.5.29/bin/shutdown.sh 设置CLASSPATH环境变量 由于servlets不是Java SE的一部分，所以您必须标示出servlet类的编译器。
假如您用的是Windows机器，您需要在C:\autoexec.bat文件中添加以下两行：
1set CATALINA=C:\apache-tomcat-5.</description></item><item><title>二、JUnit – 环境设置</title><link>https://www.shellio.cc/docs/java/junit/2/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/junit/2/</guid><description>Junit – 环境设置 本地环境设置 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 JUnit 是 Java 的一个框架，所以最根本的需要是在你的机器里装有 JDK。
系统要求 JDK 1.5或1.5以上 内存 没有最小要求 磁盘空间 没有最小要求 操作系统 没有最小要求 步骤1：在你的机器里验证 Java 装置 现在打开控制台，执行以下 java 要求。
操作系统 任务 命令 Windows 打开命令操作台 c:&amp;gt;java -version Linux 打开命令终端 $ java -version Mac 打开终端 machine:~ joseph$ java -version 我们来验证一下所有操作系统的输出：
操作系统 输出 Windows java 版本 “1.6.0_21” Java（TM）SE 运行环境（build 1.6.0_21-b07）
Java 热点（TM）客户端虚拟机（build 17.0-b17，混合模式，共享）
Linux java 版本“1.6.0_21” Java（TM）SE 运行环境（build 1.6.0_21-b07）
Java 热点（TM）客户端虚拟机（build 17.0-b17，混合模式，共享）
Mac java 版本“1.6.0_21”
Java（TM）SE 运行环境（build 1.</description></item><item><title>二、Linux(CentosUbuntu) Memcached 安装</title><link>https://www.shellio.cc/docs/java/memcached/2/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/memcached/2/</guid><description>Memcached 支持许多平台：Linux、FreeBSD、Centos、Ubuntu 、Solaris、Mac OS
当然也支持安装在 Windows 上
Linux 系统安装 Memcached，首先要先安装 libevent 库
安装 libevent Ubuntu / Debian 系统 1sudo apt-get install libevent libevent-devel Redhat / Fedora / Centos 系统 1yum install libevent libevent-devel FreeBSD 系统 1portmaster databases/libevent databases/libevent-devel MacOS 系统 1brew install libevent 安装 Memcached 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 使用软件管理器自动安装 Ubuntu / Debian 自动安装 1sudo apt-get install memcached Redhat / Fedora / Centos 自动安装 1yum install memcached FreeBSD 自动安装 1portmaster databases/memcached MacOS 使用 brew 安装 1brew install libmemcached memcached Linux 源代码安装 从[官方网站 (http://memcached.</description></item><item><title>二、Maven 环境配置</title><link>https://www.shellio.cc/docs/java/maven/2/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/maven/2/</guid><description>Maven – 环境配置 Maven 是一个基于 Java 的工具，所以要做的第一件事情就是安装 JDK。
系统要求 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 项目 要求 JDK Maven 3.3 要求 JDK 1.7 或以上
Maven 3.2 要求 JDK 1.6 或以上
Maven 3.0/3.1 要求 JDK 1.5 或以上 内存 没有最低要求 磁盘 Maven 自身安装需要大约 10 MB 空间。除此之外，额外的磁盘空间将用于你的本地 Maven 仓库。你本地仓库的大小取决于使用情况，但预期至少 500 MB 操作系统 没有最低要求 步骤 1：检查 Java 安装 现在打开控制台，执行下面的 java 命令。
操作系统 任务 命令 Windows 打开命令控制台 c:\&amp;gt; java -version Linux 打开命令终端 $ java -version Mac 打开终端 machine:~ joseph$ java -version 我们来验证一下所有平台上的输出：</description></item><item><title>二十、2.8 PropKit</title><link>https://www.shellio.cc/docs/java/jfinal/20/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/jfinal/20/</guid><description>PropKit 工具类用来操作外部配置文件。PropKit 可以极度方便地在系统任意时空使用，如 下是示例代码：
public class AppConfigextends JFinalConfig{
public void configConstant(Constantsme) {
// 第一次使用use加载的配置将成为主配置，可以通过PropKit.get(…)直接取值 PropKit.use(“a_little_config.txt”);
me.setDevMode(PropKit.getBoolean(“devMode”));
}
public void configPlugin(Pluginsme) {
// 非第一次使用use加载的配置，需要通过每次使用use来指定配置文件名再来取值 String redisHost= PropKit.use(“redis_config.txt”).get(“host”); int redisPort= PropKit.use(“redis_config.txt”).getInt(“port”); RedisPlugin rp =new RedisPlugin(“myRedis”, redisHost, redisPort);me.add(rp);
// 非第一次使用 use加载的配置，也可以先得到一个Prop对象，再通过该对象来获取值 Prop p =PropKit.use(“db_config.txt”);
DruidPlugin dp = new DruidPlugin(p.get(“jdbcUrl”), p.get(“user”)…); me.add(dp);
}
}
如上代码所示，PropKit 可同时加载多个配置文件，第一个被加载的配置文件可以使用 PorpKit.get(…)方法直接操作，非第一个被加载的配置文件则需要使用 PropKit.use(…).get(…) 来操作。PropKit 的使用并不限于在 YourJFinalConfig 中，可以在项目的任何地方使用， JFinalConfig 的 getProperty 方法其底层依赖于 PropKit 实现。</description></item><item><title>二十、Gradle Gradle 插件</title><link>https://www.shellio.cc/docs/java/gradle/20/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/gradle/20/</guid><description>Gradle 插件 Gradle 在它的核心中有意地提供了一些小但有用的功能，用于在真实世界中的自动化。所有有用的功能，例如以能够编译 Java 代码为例，都是通过插件进行添加的。插件添加了新任务 （例如JavaCompile），域对象 （例如SourceSet），约定（例如主要的 Java 源代码是位于 src/main/java），以及扩展的核心对象和其他插件的对象。
在这一章中，我们将讨论如何使用插件以及术语和插件相关的概念。
应用插件 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 插件都认为是被应用，通过 Project.apply() 方法来完成。
应用插件
build.gradle
1apply plugin: &amp;#39;java&amp;#39; 插件都有表示它们自己的一个短名称。. 在上述例子中，我们使用短名称 java 去应用 JavaPlugin。
我们还可以使用下面的语法：
通过类型应用插件
build.gradle
1apply plugin: org.gradle.api.plugins.JavaPlugin 由于Gradle 的默认导入，您还可以这样写：
通过类型应用插件
build.gradle
1apply plugin: JavaPlugin 插件的应用是幂等的。也就是说，一个插件可以被应用多次。如果以前已应用了该插件，任何进一步的应用都不会再有任何效果。
一个插件是任何实现了 Plugin 接口的简单的类。Gradle 提供了核心插件作为其发行包的一部分，所以简单地应用如上插件是你所需要做的。然而，对于第三方插件，你需要进行配置以使插件在构建类路径中可用。有关如何进行此操作的详细信息。
插件都做了什么 把插件应用到项目中可以让插件来扩展项目的功能。它可以做的事情如：
将任务添加到项目 （如编译、 测试） 使用有用的默认设置对已添加的任务进行预配置。 向项目中添加依赖配置 （见“依赖管理基础”）。 通过扩展对现有类型添加新的属性和方法。 让我们来看看：
通过插件添加任务
build.gradle
1apply plugin: &amp;#39;java&amp;#39; 2task show &amp;lt;&amp;lt; { 3 println relativePath(compileJava.destinationDir) 4 println relativePath(processResources.</description></item><item><title>二十、Groovy 面向对象</title><link>https://www.shellio.cc/docs/java/groovy/20/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/groovy/20/</guid><description>在Groovy中，如在任何其他面向对象语言中一样，存在类和对象的概念以表示编程语言的对象定向性质。Groovy类是数据的集合和对该数据进行操作的方法。在一起，类的数据和方法用于表示问题域中的一些现实世界对象。
Groovy中的类声明了该类定义的对象的状态（数据）和行为。因此，Groovy类描述了该类的实例字段和方法。
以下是Groovy中的一个类的示例。类的名称是Student，它有两个字段 – StudentID和StudentName。在main函数中，我们创建一个这个类的对象，并将值分配给对象的StudentID和StudentName。
1class Student { 2 int StudentID; 3 String StudentName; 4 static void main(String[] args) { 5 Student st = new Student(); 6 st.StudentID = 1; 7 st.StudentName = &amp;#34;Joe&amp;#34; 8 } getter和setter方法 在任何编程语言中，总是使用private关键字隐藏实例成员，而是提供getter和setter方法来相应地设置和获取实例变量的值。以下示例显示如何完成此操作。
1class Student { 2 private int StudentID; 3 private String StudentName; 4 void setStudentID(int pID) { 5 StudentID = pID; 6 } 7 void setStudentName(String pName) { 8 StudentName = pName; 9 } 10 int getStudentID() { 11 return this.</description></item><item><title>二十、Java 8 函数接口 （ Functional interface ）</title><link>https://www.shellio.cc/docs/java/java8/20/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/java8/20/</guid><description>Java 8 引入了 「 函数接口 」 ( funtional interface ) 的概念，「 函数接口 」就是那些有且只有显式定义一个方法的接口。
例如，具有单个方法 compareTo() 的接口 Comparable 接口，它只有一个功能，就是用于比较。
这种函数接口一般用于 Java 8 中的 Lambda 表达式 。 而且 Java 8 为了支持 Lambda 表达式，更是定义了许多函数接口。这些接口基本都在 java.util.function 包中。
函数接口 函数接口为 Java 8 Lambda 表达式和方法引用提供目标类型。每个函数接口都有一个 虚 ( abstract ) 方法，成为该函数接口的函数方法。用于适配该类型的 Lambda 表达式的参数类型和返回值类型。
函数接口可以在多个上下文中提供目标类型，例如赋值上下文，方法调用或强制转换上下文。
我们写一小段代码演示下
1// Assignment context 2Predicate&amp;lt;String&amp;gt; p = String::isEmpty; 3// Method invocation context 4stream.filter(e -&amp;gt; e.getSize() &amp;gt; 10)... 5// Cast context 6stream.map((ToIntFunction) e -&amp;gt; e.</description></item><item><title>二十、Java 9 新特性 – 其它特性</title><link>https://www.shellio.cc/docs/java/java9/20/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/java9/20/</guid><description>除了上面介绍的这些比较大的特性，Java 9 还存在着一些比较小的特性，我们就不一一展开了，只将它们罗列再此
1、 对GC（垃圾收集器）改进；
2、 堆遍历(Stack-Walking)API；
3、 过滤输入的序列化数据；
4、 废弃了AppletAPI；
5、 IndifyStringConcatenation；
6、 EnhancedMethodHandles；
7、 Java平台日志记录API和服务器(Service)；
8、 紧凑的字符串(CompactStrings)；
9、 Nashorn的解析API；
结束语 从这短短的十几篇讲解，我们可以看到 Java 9 的新特性并没有 Java 8 那么多
大多数都是对 Java 8 的增强而已。所以，是一个被忽略的改版。
因为在语法在没有大的更新，所以，其实，学习与不学习，都无关紧要了
重要的是，用的时候会查询就可以了</description></item><item><title>二十、JSP 点击量统计</title><link>https://www.shellio.cc/docs/java/jsp/20/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/jsp/20/</guid><description>JSP 点击量统计 有时候我们需要知道某个页面被访问的次数，这时我们就需要在页面上添加页面统计器，页面访问的统计一般在用户第一次载入时累加该页面的访问数上。
要实现一个计数器，您可以利用应用程序隐式对象和相关方法getAttribute()和setAttribute()来实现。
这个对象表示JSP页面的整个生命周期中。当JSP页面初始化时创建此对象，当JSP页面调用jspDestroy()时删除该对象。
以下是在应用中创建变量的语法：
1application.setAttribute(String Key, Object Value); 您可以使用上述方法来设置一个计数器变量及更新该变量的值。读取该变量的方法如下：
1application.getAttribute(String Key); 在页面每次被访问时，你可以读取计数器的当前值，并递增1，然后重新设置，在下一个用户访问时就将新的值显示在页面上。
实例演示 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 该实例将介绍如何使用JSP来计算特定页面访问的总人数。如果你要计算你网站使用页面的总点击量，那么你就必须将该代码放在所有的JSP页面上。
1&amp;lt;%@ page import=&amp;#34;java.io.*,java.util.*&amp;#34; %&amp;gt; 2&amp;lt;html&amp;gt; 3&amp;lt;head&amp;gt; 4&amp;lt;title&amp;gt;Applcation object in JSP&amp;lt;/title&amp;gt; 5&amp;lt;/head&amp;gt; 6&amp;lt;body&amp;gt; 7&amp;lt;% 8Integer hitsCount = (Integer)application.getAttribute(&amp;#34;hitCounter&amp;#34;); 9if( hitsCount ==null || hitsCount == 0 ){ 10 /* 第一次访问 */ 11 out.println(&amp;#34;Welcome to my website!&amp;#34;); 12 hitsCount = 1; 13}else{ 14 /* 返回访问值 */ 15 out.println(&amp;#34;Welcome back to my website!&amp;#34;); 16 hitsCount += 1; 17} 18 application.</description></item><item><title>二十、Maven IntelliJ IDEA</title><link>https://www.shellio.cc/docs/java/maven/20/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/maven/20/</guid><description>Maven – IntelliJ IDEA IntelliJ IDEA 针对 Maven 支持内部构建功能。 在本例中，我们使用 IntelliJ IDEA Community Edition 11.1 的版本。
关于IntelliJ IDEA 的一些特性如下：
可以通过 IntelliJ IDEA 来运行 Maven 目标。 可以在 IntelliJ IDEA 自己的终端里查看 Maven 命令的输出结果。 可以在 IDE 里更新 Maven 的依赖关系。 可以在 IntelliJ IDEA 中启动 Maven 的构建。 IntelliJ IDEA 基于 Maven 的 pom.xml 来实现自动化管理依赖关系。 IntelliJ IDEA 可以通过自己的工作区解决 Maven 的依赖问题，而无需安装到本地的 Maven 仓库，虽然需要依赖的工程在同一个工作区。 IntelliJ IDEA 可以自动从远程 Moven 仓库上下载需要的依赖和源码。 IntelliJ IDEA 提供了创建 Maven 工程，pom.xml 文件的向导。 下面的例子将会帮助你更加充分的认识集成的 IntelliJ IDEA 和 Maven 的优势。</description></item><item><title>二十、Memcached stats sizes 命令</title><link>https://www.shellio.cc/docs/java/memcached/20/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/memcached/20/</guid><description>Memcached stats sizes 命令用于显示所有 item 的 大小 和 个数
语法 1stats sizes 该命令返回两列，第一列是 item 的大小，第二列是 item 的个数
Memcached 1.4.27 及以后的版本自动开启了 stats sizes 功能 这之前的版本需要在 Memcached 启动时带上 -o track_sizes 则来开启
范例 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 1flush_all 2OK 3set site 0 1000 11 4ddkk.com 5STORED 6set age 0 1000 2 728 8STORED 9stats sizes 10STAT 96 2 item 大小 96, 总共有2个key 11END 1、4.27 之前的版本，如果启动 memcached 时没有设置 -o track_sizes 选项会是如下结果
1flush_all 2OK 3set site 0 1000 11 4ddkk.</description></item><item><title>二十八、3.8 session 操作方法</title><link>https://www.shellio.cc/docs/java/jfinal/28/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/jfinal/28/</guid><description>通过setSessionAttr(key, value)可以向 session 中存放数据，getSessionAttr(key)可以从 session中读取数据。还可以通过 getSession()得到 session 对象从而使用全面的 session API。</description></item><item><title>二十八、Gradle Checkstyle 插件</title><link>https://www.shellio.cc/docs/java/gradle/28/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/gradle/28/</guid><description>Checkstyle 插件 Checkstyle 插件使用 Checkstyle 对你的项目的 Java 源文件执行质量检查，并从检查结果中生成报告。
用法 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 要使用Checkstyle 插件，请在构建脚本中包含以下语句：
使用 Checkstyle 插件
build.gradle
1apply plugin: &amp;#39;checkstyle&amp;#39; 该插件向你的项目添加了大量的执行质量检查的任务。你可以通过运行 gradle check 执行检查。
Tasks Checkstyle 插件向 project 中添加了以下 tasks：
表29.1. Checkstyle 插件 – tasks
任务名称 依赖于 类型 描述 checkstyleMain classes checkstyle 针对生产Java 源文件运行 Checkstyle。 checkstyleTest testClasses checkstyle 针对测试 Java 源文件运行 Checkstyle。 SourceSet sourceSetClasses checkstyle 针对source set 的 Java 源文件运行 Checkstyle。 Checkstyle 插件向 Java 插件所加入的 tasks 添加了以下的依赖。
表29.2. Checkstyle 插件 – 额外的 task 依赖</description></item><item><title>二十八、Groovy DSLS</title><link>https://www.shellio.cc/docs/java/groovy/28/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/groovy/28/</guid><description>Groovy允许在顶层语句的方法调用的参数周围省略括号。这被称为“命令链”功能。这个扩展的工作原理是允许一个人链接这种无括号的方法调用，在参数周围不需要括号，也不需要链接调用之间的点。
如果一个调用被执行为bcd，这将实际上等价于a（b）.c（d）。
DSL或域特定语言旨在简化以Groovy编写的代码，使得它对于普通用户变得容易理解。以下示例显示了具有域特定语言的确切含义。
1def lst = [1,2,3,4] 2print lst 上面的代码显示了使用println语句打印到控制台的数字列表。在域特定语言中，命令将是 –
1Given the numbers 1,2,3,4 2Display all the numbers 所以上面的例子显示了编程语言的转换，以满足领域特定语言的需要。
让我们来看一个简单的例子，我们如何在Groovy中实现DSL –
1class EmailDsl { 2 String toText 3 String fromText 4 String body 5 /** 6 * This method accepts a closure which is essentially the DSL. Delegate the 7 * closure methods to 8 * the DSL class so the calls can be processed 9 */ 10 def static make(closure) { 11 EmailDsl emailDsl = new EmailDsl() 12 // any method called in closure will be delegated to the EmailDsl class 13 closure.</description></item><item><title>二十八、JSP 表达式语言</title><link>https://www.shellio.cc/docs/java/jsp/28/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/jsp/28/</guid><description>JSP 表达式语言 JSP表达式语言（EL）使得访问存储在JavaBean中的数据变得非常简单。JSP EL既可以用来创建算术表达式也可以用来创建逻辑表达式。在JSP EL表达式内可以使用整型数，浮点数，字符串，常量true、false，还有null。
一个简单的语法 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 典型的，当您需要在JSP标签中指定一个属性值时，只需要简单地使用字符串即可：
1&amp;lt;jsp:setProperty name=&amp;#34;box&amp;#34; property=&amp;#34;perimeter&amp;#34; value=&amp;#34;100&amp;#34;/&amp;gt; JSPEL允许您指定一个表达式来表示属性值。一个简单的表达式语法如下：
1${expr} 其中，expr指的是表达式。在JSP EL中通用的操作符是”.”和”[]”。这两个操作符允许您通过内嵌的JSP对象访问各种各样的JavaBean属性。
举例来说，上面的 标签可以使用表达式语言改写成如下形式：
1&amp;lt;jsp:setProperty name=&amp;#34;box&amp;#34; property=&amp;#34;perimeter&amp;#34; value=&amp;#34;${2*box.width+2*box.height}&amp;#34;/&amp;gt; 当JSP编译器在属性中见到”${}”格式后，它会产生代码来计算这个表达式，并且产生一个替代品来代替表达式的值。
您也可以在标签的模板文本中使用表达式语言。比如 标签简单地将其主体中的文本插入到JSP输出中：
1&amp;lt;jsp:text&amp;gt; 2&amp;lt;h1&amp;gt;Hello JSP!&amp;lt;/h1&amp;gt; 3&amp;lt;/jsp:text&amp;gt; 现在，在 标签主体中使用表达式，就像这样：
1&amp;lt;jsp:text&amp;gt; 2Box Perimeter is: ${2*box.width + 2*box.height} 3&amp;lt;/jsp:text&amp;gt; 在EL表达式中可以使用圆括号来组织子表达式。比如${(1 + 2) * 3}等于9，但是${1 + (2 * 3)} 等于7。
想要停用对EL表达式的评估的话，需要使用page指令将isELIgnored属性值设为true：
1&amp;lt;%@ page isELIgnored =&amp;#34;true|false&amp;#34; %&amp;gt; 这样，EL表达式就会被忽略。若设为false，则容器将会计算EL表达式。
EL中的基础操作符 EL表达式支持大部分Java所提供的算术和逻辑操作符：
操作符 描述 . 访问一个Bean属性或者一个映射条目 [] 访问一个数组或者链表的元素 ( ) 组织一个子表达式以改变优先级 + 加 – 减或负 * 乘 / or div 除 % or mod 取模 == or eq 测试是否相等 !</description></item><item><title>二十二、3.2 Action</title><link>https://www.shellio.cc/docs/java/jfinal/22/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/jfinal/22/</guid><description>Controller 以及在其中定义的 public 无参方法称为一个 Action。Action 是请求的最小单位。
Action 方法必须在 Controller 中声明，该方法必须是 public 可见性且没有形参。
ublic class HelloController extends Controller {
public void index() { renderText(“此方法是一个action”);
}
public void test() { renderText(“此方法是一个action”);
}
}
以上代码中定义了两个 Action：HelloController.index()、HelloController.test()。在 Controller
中提供了 getPara、getModel 系列方法 setAttr 方法以及 render 系列方法供 Action 使用。</description></item><item><title>二十二、Gradle Java 插件</title><link>https://www.shellio.cc/docs/java/gradle/22/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/gradle/22/</guid><description>Java 插件 Java 插件向一个项目添加了 Java 编译、 测试和 bundling 的能力。它是很多其他 Gradle 插件的基础服务。
用法 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 要使用Java 插件，请在构建脚本中加入：
使用 Java 插件
build.gradle
1apply plugin: &amp;#39;java&amp;#39; 源集 Java 插件引入了一个源集的概念。一个源集只是一组用于编译并一起执行的源文件。这些源文件可能包括 Java 源代码文件和资源文件。其他有一些插件添加了在源集里包含 Groovy 和 Scala 的源代码文件的能力。一个源集有一个相关联的编译类路径和运行时类路径。
源集的一个用途是，把源文件进行逻辑上的分组，以描述它们的目的。例如，你可能会使用一个源集来定义一个集成测试套件，或者你可能会使用单独的源集来定义你的项目的 API 和实现类。
Java 插件定义了两个标准的源集，分别是 main 和 test。main 源集包含你产品的源代码，它们将被编译并组装成一个 JAR 文件。test 源集包含你的单元测试的源代码，它们将被编译并使用 JUnit 或 TestNG 来执行。
任务 Java 插件向你的项目添加了大量的任务，如下所示。
表23.1. Java 插件-任务
任务名称 依赖于 类型 描述 compileJava 产生编译类路径中的所有任务。这包括了用于jar任务。 JavaCompile 使用 javac 编译产品中的 Java 源文件。 processResources – Copy 把生产资源文件拷贝到生产的类目录中。 classes processResources。一些插件添加了额外的编译任务。 Task 组装生产的类目录。 compileTestJava compile，再加上所有能产生测试编译类路径的任务。 JavaCompile 使用 javac 编译 Java 的测试源文件。 processTestResources – Copy 把测试的资源文件拷贝到测试的类目录中。 testClasses processTestResources。一些插件添加了额外的测试编译任务。 Task 组装测试的类目录。 jar compile Jar 组装 JAR 文件 javadoc compile Javadoc 使用 Javadoc 生成生产的 Java 源代码的API文档 test compileTest，再加上所有产生测试运行时类路径的任务。 Test 使用 JUnit 或 TestNG运行单元测试。 uploadArchives 使用jar。 Upload 使用archives配置上传包括 JAR 文件的构件。 clean – Delete 删除项目的 build 目录。 TaskName – Delete 删除由指定的任务所产生的输出文件。例如，&amp;nbsp;jar任务中所创建的 JAR 文件，test任务所创建的测试结果。 对于每个你添加到该项目中的源集，Java 插件将添加以下的编译任务：</description></item><item><title>二十二、Groovy 特征</title><link>https://www.shellio.cc/docs/java/groovy/22/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/groovy/22/</guid><description>特征是语言的结构构造，允许 –
行为的组成。 接口的运行时实现。 与静态类型检查/编译的兼容性 它们可以被看作是承载默认实现和状态的接口。使用trait关键字定义trait。
下面给出了一个特征的例子：
1trait Marks { 2 void DisplayMarks() { 3 println(&amp;#34;Display Marks&amp;#34;); 4 } 然后可以使用implement关键字以类似于接口的方式实现trait。
1class Example { 2 static void main(String[] args) { 3 Student st = new Student(); 4 st.StudentID = 1; 5 st.Marks1 = 10; 6 println(st.DisplayMarks()); 7 } 8} 9trait Marks { 10 void DisplayMarks() { 11 println(&amp;#34;Display Marks&amp;#34;); 12 } 13} 14class Student implements Marks { 15 int StudentID 16 int Marks1; 实现接口 Traits可以实现接口，在这种情况下，使用implements关键字声明接口。</description></item><item><title>二十二、Java 连接 Memcached 服务</title><link>https://www.shellio.cc/docs/java/memcached/22/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/memcached/22/</guid><description>Memcached 是简单的 key-value 内存缓存系统
JAVA 操作 Memcached 有两大类库:
Spymemcached Spymemcached是 Memcached 的一个流行的Java client库 XMemcached 原淘宝的伯岩/庄晓丹开发的XMemcached，性能表现出色，广泛应用于 Java + Memcached 项目中 我们接下来的范例使用 2.0.13 版本的 Spymemcached 包
把 Spymemcached 添加 classpath 中 1. 先下载 Spymemcached 本站下载地址
https://ddkk.com/static/download/spymemcached-2.10.3.jar
Google Code jar 包下载地址
https://storage.googleapis.com/google-code-archive-downloads/v2/code.google.com/spymemcached/spymemcached-2.10.3.jar
可能无法下载，原因你懂得
2. 然后将 spymemcached-2.10.3.jar 拖到 classpath 环境变量中 Memcached 服务 假设你已经安装了 Memcached，如果你没有安装，可以到 Linux(Centos/Ubuntu) Memcached 安装 学习如何安装 Memcached
我们的范例的 Memcached 服务的主机为 127.0.0.1 端口为 11211
Java 连接 Memcached 范例 1package com.ddkk.demo; 2import net.spy.memcached.MemcachedClient; 3import java.</description></item><item><title>二十二、JSP 发送邮件</title><link>https://www.shellio.cc/docs/java/jsp/22/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/jsp/22/</guid><description>JSP 发送邮件 虽然使用JSP实现邮件发送功能很简单，但是需要有JavaMail API，并且需要安装JavaBean Activation Framework。
在这里下载最新版本的 JavaMail。 在这里下载最新版本的 JavaBeans Activation Framework(JAF)。 下载并解压这些文件，在根目录下，您将会看到一系列jar包。将mail.jar包和activation.jar包加入CLASSPATH变量中。
发送一封简单的邮件 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 这个例子展示了如何从您的机器发送一封简单的邮件。它假定localhost已经连接至网络并且有能力发送一封邮件。与此同时，请再一次确认mail.jar包和activation.jar包已经添加进CLASSPATH变量中。
1&amp;lt;%@ page import=&amp;#34;java.io.*,java.util.*,javax.mail.*&amp;#34;%&amp;gt; 2&amp;lt;%@ page import=&amp;#34;javax.mail.internet.*,javax.activation.*&amp;#34;%&amp;gt; 3&amp;lt;%@ page import=&amp;#34;javax.servlet.http.*,javax.servlet.*&amp;#34; %&amp;gt; 4&amp;lt;% 5String result; 6// 收件人的电子邮件 7String to = &amp;#34;abcd@gmail.com&amp;#34;; 8// 发件人的电子邮件 9String from = &amp;#34;mcmohd@gmail.com&amp;#34;; 10// 假设你是从本地主机发送电子邮件 11String host = &amp;#34;localhost&amp;#34;; 12// 获取系统属性对象 13Properties properties = System.getProperties(); 14// 设置邮件服务器 15properties.setProperty(&amp;#34;mail.smtp.host&amp;#34;, host); 16// 获取默认的Session对象。 17Session mailSession = Session.getDefaultInstance(properties); 18try{ 19// 创建一个默认的MimeMessage对象。 20MimeMessage message = new MimeMessage(mailSession); 21// 设置 From: 头部的header字段 22message.</description></item><item><title>二十九、3.9 render 系列方法</title><link>https://www.shellio.cc/docs/java/jfinal/29/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/jfinal/29/</guid><description>render 系列方法将渲染不同类型的视图并返回给客户端。JFinal 目前支持的视图类型有：
FreeMarker、JSP、Velocity、JSON、File、Text、Html 等等。除了 JFinal 支持的视图型以外，还可以通过继承 Render 抽象类来无限扩展视图类型。
通常情况下使用 Controller.render(String)方法来渲染视图，使用 Controller.render(String)时 的 视 图 类 型 由JFinalConfig.configConstant(Constantsconstants) 配 置 中 的constants. setViewType(ViewType)来决定，该设置方法支持的 ViewType 有：FreeMarker、JSP、Velocity， 不进行配置时的缺省配置为 FreeMarker。
此外，还可以通过constants.setMainRenderFactory(IMainRenderFactory) 来设置 Controller.render(String)所使用的视图，IMainRenderFactory 专门用来对 Controller.render(String) 方法扩展除了 FreeMarker、JSP、Velocity 之外的视图。
假设在 JFinalConfig.configRoute(Routes routes) 中有 如下 Controller 映射配置 ：routes.add(“/user”, UserController.class, “/path”)， render(String view)使用例子：
方法调用
描述
render(”test.html”)
渲染名为 test.html 的视图，该视图的全路&amp;nbsp;径 为”/path/test.html”
render(”/other_path/test.html”)
渲染名为 test.html 的视图，该视图的全路&amp;nbsp;径 为”/other_path/test.html”，即当参数以”/”开头时将 采用绝对路径。
其它render 方法使用例子：
方法调用
描述
renderFreeMarker(”test.html”)
渲染&amp;nbsp;名为 test.html &amp;nbsp;的视图&amp;nbsp;，&amp;nbsp;且&amp;nbsp;视图类型为&amp;nbsp;
FreeMarker。
renderJsp(”test.html”)</description></item><item><title>二十九、Gradle CodeNarc 插件</title><link>https://www.shellio.cc/docs/java/gradle/29/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/gradle/29/</guid><description>CodeNarc 插件 CodeNarc 插件使用 CodeNarc 对项目的 Groovy 源文件执行质量检查并生成报告。
用法 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 要使用CodeNarc 插件，请在构建脚本中包含以下语句：
使用 CodeNarc 插件
build.gradle
1apply plugin: &amp;#39;codenarc&amp;#39; 该插件向你的项目添加了大量的执行质量检查的任务。你可以通过运行 gradle check 执行检查。
任务 CodeNarc 插件向project 中添加了以下任务：
表30.1. CodeNarc 插件 – 任务
任务名称 依赖于 类型 描述 codenarcMain – codenarc 针对生产 Groovy 源文件运行 CodeNarc。 codenarcTest – codenarc 针对测试 Groovy 源文件运行 CodeNarc。 SourceSet – codenarc 针对给定的source set 的 Groovy 源文件运行 CodeNarc。 CodeNarc 插件向 Groovy 插件所加入的任务添加了以下的依赖。
表30.2. CodeNarc 插件 – 附加的任务依赖
任务名称 依赖于 check 所有的 CodeNarc 任务，包括codenarcTest。 项目布局 CodeNarc 插件预计是以下的项目布局：</description></item><item><title>二十九、Groovy 数据库</title><link>https://www.shellio.cc/docs/java/groovy/29/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/groovy/29/</guid><description>Groovy的groovy-sql模块提供了比当前Java的JDBC技术更高级的抽象。Groovy sql API支持各种各样的数据库，其中一些如下所示。
HSQLDB Oracle SQL Server MySQL MongoDB 在我们的示例中，我们将使用MySQL DB作为示例。为了使用MySQL与Groovy，首先要做的是从mysql站点下载MySQL jdbc jar文件。 MySQL的格式如下所示。
1mysql-connector-java-5.1.38-bin 然后，确保将上述jar文件添加到工作站中的类路径。
数据库连接 在连接到MySQL数据库之前，请确保以下内容 –
你已经创建了一个数据库TESTDB。 您在TESTDB中创建了一个表EMPLOYEE。 此表格包含FIRST_NAME，LAST_NAME，AGE，SEX和INCOME。 用户ID“testuser”和密码“test123”设置为访问TESTDB。 确保已下载mysql jar文件并将该文件添加到类路径。 你已经通过MySQL教程来了解MySQL基础 下面的示例显示如何连接MySQL数据库“TESTDB”。
1import java.sql.*; 2import groovy.sql.Sql 3class Example { 4 static void main(String[] args) { 5 // Creating a connection to the database 6 def sql = Sql.newInstance(&amp;#39;jdbc:mysql://localhost:3306/TESTDB&amp;#39;, 7 &amp;#39;testuser&amp;#39;, &amp;#39;test123&amp;#39;, &amp;#39;com.mysql.jdbc.Driver&amp;#39;) 8 // Executing the query SELECT VERSION which gets the version of the database 9 // Also using the eachROW method to fetch the result from the database 10 sql.</description></item><item><title>二十九、JSP 异常处理</title><link>https://www.shellio.cc/docs/java/jsp/29/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/jsp/29/</guid><description>JSP 异常处理 当编写JSP程序的时候，程序员可能会遗漏一些BUG，这些BUG可能会出现在程序的任何地方。JSP代码中通常有以下几类异常:
检查型异常:检查型异常就是一个典型的用户错误或者一个程序员无法预见的错误。举例来说，如果一个文件将要被打开，但是无法找到这个文件，则一个异常被抛出。这些异常不能再编译期被简单地忽略。 运行时异常:一个运行时异常可能已经被程序员避免，这种异常在编译期将会被忽略。 错误:这里没有异常，但问题是它超出了用户或者程序员的控制范围。错误通常会在代码中被忽略，您几乎不能拿它怎么样。举例来或，栈溢出错误。这些错误都会在编译期被忽略。 本节将会给出几个简单而优雅的方式来处理运行时异常和错误。
使用Exception对象 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 exception对象是Throwable子类的一个实例，只在错误页面中可用。下表列出了Throwable类中一些重要的方法:
序号 方法&amp;amp;描述 1 public String getMessage()
返回异常的信息。这个信息在Throwable构造函数中被初始化
2 public ThrowablegetCause()
返回引起异常的原因，类型为Throwable对象
3 public String toString()
返回类名
4 public void printStackTrace()
将异常栈轨迹输出至System.err
5 public StackTraceElement [] getStackTrace()
以栈轨迹元素数组的形式返回异常栈轨迹
6 public ThrowablefillInStackTrace()
使用当前栈轨迹填充Throwable对象
JSP提供了可选项来为每个JSP页面指定错误页面。无论何时页面抛出了异常，JSP容器都会自动地调用错误页面。
接下来的例子为main.jsp指定了一个错误页面。使用&amp;lt;%@page errorPage=&amp;ldquo;XXXXX&amp;rdquo;%&amp;gt;指令指定一个错误页面。
1&amp;lt;%@ page errorPage=&amp;#34;ShowError.jsp&amp;#34; %&amp;gt; 2&amp;lt;html&amp;gt; 3&amp;lt;head&amp;gt; 4 &amp;lt;title&amp;gt;Error Handling Example&amp;lt;/title&amp;gt; 5&amp;lt;/head&amp;gt; 6&amp;lt;body&amp;gt; 7&amp;lt;% // Throw an exception to invoke the error page int x = 1; if (x == 1) { throw new RuntimeException(&amp;#34;Error condition!</description></item><item><title>二十六、3.6 getFile 文件上传</title><link>https://www.shellio.cc/docs/java/jfinal/26/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/jfinal/26/</guid><description>Controller 提供了 getFile 系列方法支持文件上传。**特别注意：**如果客户端请求为 multipart request（form 表单使用了 enctype=”multipart/form-data”），那么必须先调用 getFile 系列方法才 能使 getPara 系列方法正常工作，因为 multipart request 需要通过 getFile 系列方法解析请求体中 的数据，包括参数。
文件默认上传至项目根路径下的 upload 子路径之下，该路径称为文件上传基础路径。可以 在 JFinalConfig.configConstant(Constants me)方法中通过 me.setBaseUploadPath(baseUploadPath) 设置文件上传基础路径，该路径参数接受以”/”打头或者以 windows 磁盘盘符打头的绝对路径， 即可将基础路径指向项目根径之外，方便单机多实例部署。当该路径参数设置为相对路径时， 则是以项目根为基础的相对路径。</description></item><item><title>二十六、Gradle Ear 插件</title><link>https://www.shellio.cc/docs/java/gradle/26/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/gradle/26/</guid><description>Ear 插件 Ear插件添加了用于组装 web 应用程序的 EAR 文件的支持。它添加了一个默认的 EAR archive task。它不需要 Java 插件，但是对于使用了 Java 插件的项目，它将禁用默认的 JAR archive 的生成。
用法 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 要使用Ear 的插件，请在构建脚本中包含以下语句：
使用 Ear 插件
build.gradle
1apply plugin: &amp;#39;ear&amp;#39; Tasks Ear插件向 project 中添加了以下任务。
表27.1. Ear 插件 – tasks
任务名称 依赖于 类型 描述 ear compile（仅在也配置了使用 Java 插件的时候） ear 组装应用程序 EAR 文件。 Ear插件向基础插件所加入的 tasks 添加了以下的依赖。
表27.2. Ear 插件 – 额外的 task 依赖
任务名称 依赖于 assemble ear 项目布局 表27.3. Ear 插件 – 项目布局</description></item><item><title>二十六、Groovy JMX</title><link>https://www.shellio.cc/docs/java/groovy/26/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/groovy/26/</guid><description>JMX是defacto标准，用于监控与Java虚拟环境有任何关系的所有应用程序。鉴于Groovy直接位于Java之上，Groovy可以利用已经为Java实现的大量工作。
监视JVM 可以使用java.lang.management中提供的标准类来执行JVM的监视。以下代码示例说明如何完成此操作。
1import java.lang.management.* 2def os = ManagementFactory.operatingSystemMXBean 3println &amp;#34;&amp;#34;&amp;#34;OPERATING SYSTEM: 4 OS architecture = $os.arch 5 OS name = $os.name 6 OS version = $os.version 7 OS processors = $os.availableProcessors 8&amp;#34;&amp;#34;&amp;#34; 9def rt = ManagementFactory.runtimeMXBean 10println &amp;#34;&amp;#34;&amp;#34;RUNTIME: 11 Runtime name = $rt.name 12 Runtime spec name = $rt.specName 13 Runtime vendor = $rt.specVendor 14 Runtime spec version = $rt.specVersion 15 Runtime management spec version = $rt.managementSpecVersion 16 &amp;#34;&amp;#34;&amp;#34; 17def mem = ManagementFactory.</description></item><item><title>二十六、JSP JavaBean</title><link>https://www.shellio.cc/docs/java/jsp/26/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/jsp/26/</guid><description>JSP JavaBean JavaBean是特殊的Java类，是用Java语言写成的可重用组件，并且遵守JavaBeans API规范。
接下来给出的是JavaBean与其它Java类相比而言独一无二的特征：
提供一个默认的无参构造函数。 需要被序列化并且实现了Serializable接口。 可能有一系列可读写属性。 可能有一系列的”getter”或”setter”方法。 JavaBeans属性 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 一个JavaBean对象的属性应该是可访问的。这个属性可以是任意合法的Java数据类型，包括自定义Java类。
一个JavaBean对象的属性可以是可读写，或只读，或只写。JavaBean对象的属性通过JavaBean实现类中提供的两个方法来访问：
方法 描述 getPropertyName() 举例来说，如果属性的名称为myName，那么这个方法的名字就要写成getMyName()来读取这个属性。这个方法也称为访问器。 setPropertyName() 举例来说，如果属性的名称为myName，那么这个方法的名字就要写成setMyName()来写入这个属性。这个方法也称为写入器。 一个只读的属性只提供getPropertyName()方法，一个只写的属性只提供setPropertyName()方法。
JavaBeans程序示例 这是StudentBean.java文件：
1package com.tutorialspoint; 2public class StudentsBean implements java.io.Serializable 3 private String firstName = null; 4 private String lastName = null; 5 private int age = 0; 6 public StudentsBean() { 7 } 8 public String getFirstName(){ 9 return firstName; 10 } 11 public String getLastName(){ 12 return lastName; 13 } 14 public int getAge(){ 15 return age; 16 } 17 public void setFirstName(String firstName){ 18 this.</description></item><item><title>二十七、3.7 renderFile 文件下载</title><link>https://www.shellio.cc/docs/java/jfinal/27/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/jfinal/27/</guid><description>Controller 提供了 renderFile 系列方法支持文件下载。 文件默认下载路径为项目根路径下的 download 子路径之下，该路径称为文件下载基础路径。可以在 JFinalConfig.configConstant(Constants me) 方 法 中 通 过 me.setBaseDownloadPath(baseDownloadPath) 设置文件下载基础路径，该路径参数接受以”/”打 头或者以 windows 磁盘盘符打头的绝对路径，即可将基础路径指向项目根径之外，方便单机 多实例部署。当该路径参数设置为相对路径时，则是以项目根为基础的相对路径</description></item><item><title>二十七、Gradle Jetty 插件</title><link>https://www.shellio.cc/docs/java/gradle/27/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/gradle/27/</guid><description>Jetty 插件 Jetty 插件继承自 War 插件，并添加一些任务，这些任务可以让你在构建时部署你的 web 应用程序到一个 Jetty 的 web 嵌入式容器中。
用法 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 要使用Jetty 的插件，请在构建脚本中包含以下语句：
使用 Jetty 插件
build.gradle
1apply plugin: &amp;#39;jetty&amp;#39; 任务 Jetty 插件定义了以下任务：
表28.1. Jetty 插件 – 任务
任务名称 依赖于 类型 描述 jettyRun compile jettyRun 启动 Jetty 实例并将部署上 exploded web 应用程序。 jettyRunWar war jettyRunWar 启动 Jetty 实例并将部署上 WAR 包。 jettyStop – jettyStop 停止 Jetty 实例。 图28.1. Jetty 插件 – tasks
项目布局 Jetty 插件使用 和 War 插件相同的布局。</description></item><item><title>二十七、Groovy JSON</title><link>https://www.shellio.cc/docs/java/groovy/27/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/groovy/27/</guid><description>本章介绍了如何使用Groovy语言来解析和生成JSON对象。
JSON功能 功能 库 JsonSlurper JsonSlurper是一个将JSON文本或阅读器内容解析为Groovy数据的类
结构，例如地图，列表和原始类型，如整数，双精度，布尔和字符串。
JsonOutput 此方法负责将Groovy对象序列化为JSON字符串。 使用JsonSlurper解析数据 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 JsonSlurper是一个将JSON文本或阅读器内容解析为Groovy数据结构的类，如地图，列表和原始类型，如Integer，Double，Boolean和String。
句法 1def slurper = new JsonSlurper() JSON slurper将文本或阅读器内容解析为列表和地图的数据结构。
JsonSlurper类自带了一些用于解析器实现的变体。有时，在解析某些字符串时，您可能有不同的要求。让我们举一个例子，其中需要读取从Web服务器的响应返回的JSON。在这种情况下，使用解析器JsonParserLax变量是有益的。此parsee允许在JSON文本中的注释以及没有引号字符串等。要指定此类型的解析器，您需要在定义JsonSlurper的对象时使用JsonParserType.LAX解析器类型。
让我们看下面这个例子。示例是使用http模块从Web服务器获取JSON数据。对于这种类型的遍历，最好的选择是将解析器类型设置为JsonParserLax变体。
1http.request( GET, TEXT ) { 2 headers.Accept = &amp;#39;application/json&amp;#39; 3 headers.&amp;#39;User-Agent&amp;#39; = USER_AGENT 4 response.success = { 5 res, rd -&amp;gt; 6 def jsonText = rd.text 7 //Setting the parser type to JsonParserLax 8 def parser = new JsonSlurper().setType(JsonParserType.LAX) 9 def jsonResp = parser.parseText(jsonText) 10 } 类似地，以下附加的解析器类型在Groovy中可用 –</description></item><item><title>二十七、JSP 自定义标签</title><link>https://www.shellio.cc/docs/java/jsp/27/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/jsp/27/</guid><description>JSP 自定义标签 自定义标签是用户定义的JSP语言元素。当JSP页面包含一个自定义标签时将被转化为servlet，标签转化为对被 称为tag handler的对象的操作，即当servlet执行时Web container调用那些操作。
JSP标签扩展可以让你创建新的标签并且可以直接插入到一个JSP页面。 JSP 2.0规范中引入Simple Tag Handlers来编写这些自定义标记。
你可以继承SimpleTagSupport类并重写的doTag()方法来开发一个最简单的自定义标签。
创建”Hello”标签 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 接下来，我们想创建一个自定义标签叫作 ，标签格式为：
1&amp;lt;ex:Hello /&amp;gt; 要创建自定义的JSP标签，你首先必须创建处理标签的Java类。所以，让我们创建一个HelloTag类，如下所示：
1package com.tutorialspoint; 2import javax.servlet.jsp.tagext.*; 3import javax.servlet.jsp.*; 4import java.io.*; 5public class HelloTag extends SimpleTagSupport { 6 public void doTag() throws JspException, IOException { 7 JspWriter out = getJspContext().getOut(); 8 out.println(&amp;#34;Hello Custom Tag!&amp;#34;); 9 } 以下代码重写了doTag()方法，方法中使用了getJspContext()方法来获取当前的JspContext对象，并将”Hello Custom Tag!”传递给JspWriter对象。
编译以上类，并将其复制到环境变量CLASSPATH目录中。最后创建如下标签库：&amp;lt;Tomcat安装目录&amp;gt;webapps\ROOT\WEB-INF\custom.tld。
1&amp;lt;taglib&amp;gt; 2 &amp;lt;tlib-version&amp;gt;1.0&amp;lt;/tlib-version&amp;gt; 3 &amp;lt;jsp-version&amp;gt;2.0&amp;lt;/jsp-version&amp;gt; 4 &amp;lt;short-name&amp;gt;Example TLD&amp;lt;/short-name&amp;gt; 5 &amp;lt;tag&amp;gt; 6 &amp;lt;name&amp;gt;Hello&amp;lt;/name&amp;gt; 7 &amp;lt;tag-class&amp;gt;com.</description></item><item><title>二十三、3.3 getPara 系列方法</title><link>https://www.shellio.cc/docs/java/jfinal/23/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/jfinal/23/</guid><description>Controller 提供了 getPara 系列方法用来从请求中获取参数。getPara 系列方法分为两种类型。 第 一 种 类 型 为 第 一 个 形 参 为 String 的 getPara 系列 方法 。 该 系 列 方法 是对 HttpServletRequest.getParameter(String name) 的 封 装 ， 这 类 方 法 都 是 转 调 了 HttpServletRequest.getParameter(String name)。第二种类型为第一个形参为 int 或无形参的 getPara 系列方法。该系列方法是去获取 urlPara 中所带的参数值。getParaMap 与 getParaNames 分别对应 HttpServletRequest 的 getParameterMap 与 getParameterNames。
记忆技巧：第一个参数为 String 类型的将获取表单或者 url 中问号挂参的域值。第一个参数为int 或无参数的将获取 urlPara 中的参数值。
getPara 使用例子：
方法调用</description></item><item><title>二十三、Gradle Groovy 插件</title><link>https://www.shellio.cc/docs/java/gradle/23/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/gradle/23/</guid><description>Groovy 插件 Groovy 的插件继承自 Java 插件并添加了对 Groovy 项目的支持。它可以处理 Groovy 代码，以及混合的 Groovy 和 Java 代码，甚至是纯 Java 代码（尽管我们不一定推荐使用）。该插件支持联合编译，可以任意地混合及匹配 Groovy 和 Java 代码各自的依赖。例如，一个 Groovy 类可以继承自一个 Java 类，而这个 Java 类也可以继承自一个 Groovy 类。这样一来，我们就能够在项目中使用最适合的语言，并且在有需要的情况下用其他的语言重写其中的任何类。
用法 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 要使用Groovy 的插件，请在构建脚本中包含以下语句：
使用 Groovy 插件
build.gradle
1apply plugin: &amp;#39;groovy&amp;#39; 任务 Groovy 的插件向 project 中添加了以下任务。
表24.1. Groovy 插件 – 任务
任务名称 依赖于 类型 描述 compileGroovy compileJava GroovyCompile 编译production 的 Groovy 源文件。 compileTestGroovy compileTestJava GroovyCompile 编译test 的 Groovy 的源文件。 SourceSetGroovy SourceSetJava GroovyCompile 编译给定的 source set 里的 Groovy 源文件。 groovydoc – Groovydoc 为 production 里的 Groovy 源文件生成 API 文档。 Groovy 的插件向 Java 插件所加入的 tasks 添加了以下的依赖。</description></item><item><title>二十三、Groovy 闭包</title><link>https://www.shellio.cc/docs/java/groovy/23/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/groovy/23/</guid><description>闭包是一个短的匿名代码块。它通常跨越几行代码。一个方法甚至可以将代码块作为参数。它们是匿名的。
下面是一个简单闭包的例子，它是什么样子。
1class Example { 2 static void main(String[] args) { 3 def clos = {println &amp;#34;Hello World&amp;#34;}; 4 clos.call(); 5 } 在上面的例子中，代码行 – {println“Hello World”}被称为闭包。此标识符引用的代码块可以使用call语句执行。
当我们运行上面的程序，我们将得到以下结果 –
1Hello World 闭包中的形式参数 闭包也可以包含形式参数，以使它们更有用，就像Groovy中的方法一样。
1class Example { 2 static void main(String[] args) { 3 def clos = {param-&amp;gt;println &amp;#34;Hello ${param}&amp;#34;}; 4 clos.call(&amp;#34;World&amp;#34;); 5 } 在上面的代码示例中，注意使用$ {param}，这导致closure接受一个参数。当通过clos.call语句调用闭包时，我们现在可以选择将一个参数传递给闭包。
当我们运行上面的程序，我们将得到以下结果 –
1Hello World 下一个图重复了前面的例子并产生相同的结果，但显示可以使用被称为它的隐式单个参数。这里的’it’是Groovy中的关键字。
1class Example { 2 static void main(String[] args) { 3 def clos = {println &amp;#34;Hello ${it}&amp;#34;}; 4 clos.</description></item><item><title>二十三、JSP 标准标签库（JSTL）</title><link>https://www.shellio.cc/docs/java/jsp/23/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/jsp/23/</guid><description>JSP 标准标签库（JSTL） JSP标准标签库（JSTL）是一个JSP标签集合，它封装了JSP应用的通用核心功能。
JSTL支持通用的、结构化的任务，比如迭代，条件判断，XML文档操作，国际化标签，SQL标签。 除了这些，它还提供了一个框架来使用集成JSTL的自定义标签。
根据JSTL标签所提供的功能，可以将其分为5个类别。
核心标签 格式化标签 SQL 标签 XML 标签 JSTL 函数 JSTL 库安装 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 Apache Tomcat安装JSTL 库步骤如下：
从Apache的标准标签库中下载的二进包(jakarta-taglibs-standard-current.zip)。下载地址：http://archive.apache.org/dist/jakarta/taglibs/standard/binaries/ 下载jakarta-taglibs-standard-1.1.1.zip 包并解压，将jakarta-taglibs-standard-1.1.1/lib/下的两个jar文件：standard.jar和jstl.jar文件拷贝到/WEB-INF/lib/下。 接下来我们在 web.xml 文件中添加以下配置： 1 …… 2 &amp;lt;jsp-config&amp;gt; 3 &amp;lt;taglib&amp;gt; 4 &amp;lt;taglib-uri&amp;gt;http://java.sun.com/jstl/fmt&amp;lt;/taglib-uri&amp;gt; 5 &amp;lt;taglib-location&amp;gt;/WEB-INF/fmt.tld&amp;lt;/taglib-location&amp;gt; 6 &amp;lt;/taglib&amp;gt; 7 &amp;lt;taglib&amp;gt; 8 &amp;lt;taglib-uri&amp;gt;http://java.sun.com/jstl/fmt-rt&amp;lt;/taglib-uri&amp;gt; 9 &amp;lt;taglib-location&amp;gt;/WEB-INF/fmt-rt.tld&amp;lt;/taglib-location&amp;gt; 10 &amp;lt;/taglib&amp;gt; 11 &amp;lt;taglib&amp;gt; 12 &amp;lt;taglib-uri&amp;gt;http://java.sun.com/jstl/core&amp;lt;/taglib-uri&amp;gt; 13 &amp;lt;taglib-location&amp;gt;/WEB-INF/c.tld&amp;lt;/taglib-location&amp;gt; 14 &amp;lt;/taglib&amp;gt; 15 &amp;lt;taglib&amp;gt; 16 &amp;lt;taglib-uri&amp;gt;http://java.sun.com/jstl/core-rt&amp;lt;/taglib-uri&amp;gt; 17 &amp;lt;taglib-location&amp;gt;/WEB-INF/c-rt.tld&amp;lt;/taglib-location&amp;gt; 18 &amp;lt;/taglib&amp;gt; 19 &amp;lt;taglib&amp;gt; 20 &amp;lt;taglib-uri&amp;gt;http://java.sun.com/jstl/sql&amp;lt;/taglib-uri&amp;gt; 21 &amp;lt;taglib-location&amp;gt;/WEB-INF/sql.tld&amp;lt;/taglib-location&amp;gt; 22 &amp;lt;/taglib&amp;gt; 23 &amp;lt;taglib&amp;gt; 24 &amp;lt;taglib-uri&amp;gt;http://java.</description></item><item><title>二十三、PHP 连接 Memcached 服务</title><link>https://www.shellio.cc/docs/java/memcached/23/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/memcached/23/</guid><description>在前面章节中我们已经介绍了如何安装 Memcached 服务,也介绍了 Memcached 的各种命令
现在我们为大家介绍 PHP 如何使用 Memcached 服务。
PHP Memcached 客户端 PHPMemcached 的客户端有两个：
1、 PHP-Memcache；
2、 PHP-Memcached推荐；
我们推荐大家使用 PHP-Memcached
PHP Memcached 扩展安装 PHPMemcached 扩展包下载地址： http://pecl.php.net/package/memcached ，你可以下载最新稳定包(stable)
1#下载 2wget http://pecl.php.net/get/memcached-3.0.3.tgz 3# 解压 4tar -zxvf memcached-3.0.3.tgz 5cd memcached-3.0.3 6# 生成编译配置文件 7/usr/local/php/bin/phpize 8./configure --with-php-config=/usr/local/php/bin/php-config 9# 编译安装 10make &amp;amp;&amp;amp; make install 注意： /usr/local/php/ 为php的安装路径，需要根据你安装的实际目录调整
如果你使用的是 PHP7 如果你是 PHP7 版本，则需要下载指定分支：
1git clone -b php7 https://github.com/php-memcached-dev/php-memcached.git 如果你的系统还未编译 libmemcached，则下载编译它：
https://launchpad.net/libmemcached/+download
配置 php.ini 安装成功后会显示你的 memcache.so 扩展的位置，例如：</description></item><item><title>二十四、3.4 getModel 与 getBean 系列方法</title><link>https://www.shellio.cc/docs/java/jfinal/24/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/jfinal/24/</guid><description>getModel 用来接收页面表单域传递过来的 model 对象，表单域名称以”modelName.attrName” 方式命名。除了 getModel 以外，还提供了一个 getBean 方法用于支持传统的 Java Bean。以下 是一个简单的示例：
1// 定义Model，在此为Blog 2public class Blog extends Model&amp;lt;Blog&amp;gt; { 3 public static final Blog me = new Blog(); 4// 在页面表单中采用modelName.attrName形式为作为表单域的name 5&amp;lt;form action=&amp;#34;/blog/save&amp;#34; method=&amp;#34;post&amp;#34;&amp;gt; 6 &amp;lt;input name=&amp;#34;blog.title&amp;#34; type=&amp;#34;text&amp;#34;&amp;gt; 7 &amp;lt;input name=&amp;#34;blog.content&amp;#34; type=&amp;#34;text&amp;#34;&amp;gt; 8 &amp;lt;input value=&amp;#34;提交&amp;#34; type=&amp;#34;submit&amp;#34;&amp;gt; 9&amp;lt;/form&amp;gt; 10public class BlogController extends Controller { 11 public void save() { 12 // 页面的modelName正好是Blog类名的首字母小写 13 Blog blog = getModel(Blog.class); 14 // 如果表单域的名称为 &amp;#34;otherName.title&amp;#34;可加上一个参数来获取 blog = getModel(Blog.</description></item><item><title>二十四、Gradle Scala 插件</title><link>https://www.shellio.cc/docs/java/gradle/24/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/gradle/24/</guid><description>Scala 插件 Scala 的插件继承自 Java 插件并添加了对 Scala 项目的支持。它可以处理 Scala 代码，以及混合的 Scala 和 Java 代码，甚至是纯 Java 代码（尽管我们不一定推荐使用）。该插件支持联合编译，联合编译可以通过 Scala 及 Java 的各自的依赖任意地混合及匹配它们的代码。例如，一个 Scala 类可以继承自一个 Java 类，而这个 Java 类也可以继承自一个 Scala 类。这样一来，我们就能够在项目中使用最适合的语言，并且在有需要的情况下用其他的语言重写其中的任何类。
用法 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 要使用Scala 插件，请在构建脚本中包含以下语句：
使用 Scala 插件
build.gradle
1apply plugin: &amp;#39;scala&amp;#39; 任务 Scala 的插件向 project 中添加了以下任务。
表25.1. Scala 插件 – 任务
任务名称 依赖于 类型 描述 compileScala compileJava ScalaCompile 编译production 的 Scala 源文件。 compileTestScala compileTestJava ScalaCompile 编译test 的 Scala 的源文件。 SourceSetScala SourceSetJava ScalaCompile 编译给定的source set 里的 Scala 源文件。 scaladoc – scaladoc 为production 里的 Scala 源文件生成 API 文档。 Scala 插件向 Java 插件所加入的 tasks 添加了以下的依赖。</description></item><item><title>二十四、Groovy 注释</title><link>https://www.shellio.cc/docs/java/groovy/24/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/groovy/24/</guid><description>注释是元数据的形式，其中它们提供关于不是程序本身的一部分的程序的数据。注释对它们注释的代码的操作没有直接影响。
注释主要用于以下原因 –
编译器信息 -编译器可以使用注释来检测错误或抑制警告。 编译时和部署时处理 -软件工具可以处理注释信息以生成代码，XML文件等。 运行时处理 -一些注释可以在运行时检查。 在Groovy中，基本注释如下所示：
@interface – at符号字符（@）向编译器指示以下是注释。
注释可以以没有主体的方法的形式和可选的默认值来定义成员。
注释可以应用于以下类型 –
字符串类型 下面给出了字符串注释的一个例子 –
1@interface Simple { 2 String str1() default &amp;#34;HelloWorld&amp;#34;; 枚举类型 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 1enum DayOfWeek { mon, tue, wed, thu, fri, sat, sun } 2@interface Scheduled { 3 DayOfWeek dayOfWeek() 4} 类类型 1@interface Simple {} 2@Simple 3class User { 4 String username 5 int age 6def user = new User(username: &amp;#34;Joe&amp;#34;,age:1); 7println(user.age); 8println(user.username); 注释成员值 使用注释时，需要至少设置所有没有默认值的成员。下面给出一个例子。当定义后使用注释示例时，需要为其分配一个值。</description></item><item><title>二十四、JSP 连接数据库</title><link>https://www.shellio.cc/docs/java/jsp/24/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/jsp/24/</guid><description>JSP 连接数据库 本章节假设您已经对JDBC有一定的了解。在开始学习JSP数据库访问前，请确保JDBC环境已经正确配置。
首先，让我们按照下面的步骤来创建一个简单的表并插入几条简单的记录：
创建表 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 在数据库中创建一个Employees表，步骤如下：
步骤1： 打开CMD，然后进入数据库安装目录：
1C:\&amp;gt; 2C:\&amp;gt;cd Program Files\MySQL\bin 3C:\Program Files\MySQL\bin&amp;gt; 步骤2： 1C:\Program Files\MySQL\bin&amp;gt;mysql -u root -p 2Enter password: ******** 3mysql&amp;gt; 步骤3： 用create database语句建立一个新的数据库TEST：
1mysql&amp;gt; create database TEST 步骤4： 在TEST数据库中创建Employee表：
1mysql&amp;gt; use TEST; 2mysql&amp;gt; create table Employees 3 ( 4 id int not null, 5 age int not null, 6 first varchar (255), 7 last varchar (255) 8 ); 9Query OK, 0 rows affected (0.08 sec) 10mysql&amp;gt; 插入数据记录 创建好Employee表后，往表中插入几条记录：</description></item><item><title>二十五、3.5 setAttr 方法</title><link>https://www.shellio.cc/docs/java/jfinal/25/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/jfinal/25/</guid><description>setAttr(String, Object)转调了 HttpServletRequest.setAttribute(String, Object)，该方法可以将 各种数据传递给 View 并在 View 中显示出来。</description></item><item><title>二十五、Gradle War 插件</title><link>https://www.shellio.cc/docs/java/gradle/25/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/gradle/25/</guid><description>War 插件 War的插件继承自 Java 插件并添加了对组装 web 应用程序的 WAR 文件的支持。它禁用了 Java 插件生成默认的 JAR archive，并添加了一个默认的 WAR archive 任务。
用法 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 要使用War 的插件，请在构建脚本中包含以下语句：
使用 War 插件
build.gradle
1apply plugin: &amp;#39;war&amp;#39; 任务 War插件向 project 中添加了以下任务。
表26.1. War 插件 – 任务
任务名称 依赖于 类型 描述 war compile War 组装应用程序 WAR 文件。 War插件向 Java 插件所加入的 tasks 添加了以下的依赖。
表26.2. War 插件 – 额外的 task 依赖
任务名称 依赖于 assemble war 图26.1. War 插件 – tasks
项目布局 表26.3. War 插件 – 项目布局</description></item><item><title>二十五、Groovy XML</title><link>https://www.shellio.cc/docs/java/groovy/25/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/groovy/25/</guid><description>XML是一种便携的开放源代码语言，允许程序员开发可以被其他应用程序读取的应用程序，而不管操作系统和/或开发语言。这是用于在应用程序之间交换数据的最常用的语言之一。
XML是什么？ 可扩展标记语言XML是一种非常类似于HTML或SGML的标记语言。这是万维网联盟推荐的，可作为开放标准。XML对于跟踪少量到中等数据量而不需要基于SQL的骨干非常有用。
Groovy中的XML支持 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 Groovy语言还提供了对XML语言的丰富支持。使用的两个最基本的XML类是 –
XML标记构建器 - Groovy支持基于树的标记生成器BuilderSupport，它可以被子类化以生成各种树结构对象表示。通常，这些构建器用于表示XML标记，HTML标记。 Groovy的标记生成器捕获对伪方法的调用，并将它们转换为树结构的元素或节点。这些伪方法的参数被视为节点的属性。作为方法调用一部分的闭包被视为生成的树节点的嵌套子内容。 XML解析器 - Groovy XmlParser类使用一个简单的模型来将XML文档解析为Node实例的树。每个节点都有XML元素的名称，元素的属性和对任何子节点的引用。这个模型足够用于大多数简单的XML处理。 对于所有的XML代码示例，让我们使用以下简单的XML文件movies.xml来构建XML文件并随后读取该文件。
1&amp;lt;collection shelf = &amp;#34;New Arrivals&amp;#34;&amp;gt; 2 &amp;lt;movie title = &amp;#34;Enemy Behind&amp;#34;&amp;gt; 3 &amp;lt;type&amp;gt;War, Thriller&amp;lt;/type&amp;gt; 4 &amp;lt;format&amp;gt;DVD&amp;lt;/format&amp;gt; 5 &amp;lt;year&amp;gt;2003&amp;lt;/year&amp;gt; 6 &amp;lt;rating&amp;gt;PG&amp;lt;/rating&amp;gt; 7 &amp;lt;stars&amp;gt;10&amp;lt;/stars&amp;gt; 8 &amp;lt;description&amp;gt;Talk about a US-Japan war&amp;lt;/description&amp;gt; 9 &amp;lt;/movie&amp;gt; 10 &amp;lt;movie title = &amp;#34;Transformers&amp;#34;&amp;gt; 11 &amp;lt;type&amp;gt;Anime, Science Fiction&amp;lt;/type&amp;gt; 12 &amp;lt;format&amp;gt;DVD&amp;lt;/format&amp;gt; 13 &amp;lt;year&amp;gt;1989&amp;lt;/year&amp;gt; 14 &amp;lt;rating&amp;gt;R&amp;lt;/rating&amp;gt; 15 &amp;lt;stars&amp;gt;8&amp;lt;/stars&amp;gt; 16 &amp;lt;description&amp;gt;A schientific fiction&amp;lt;/description&amp;gt; 17 &amp;lt;/movie&amp;gt; 18 &amp;lt;movie title = &amp;#34;Trigun&amp;#34;&amp;gt; 19 &amp;lt;type&amp;gt;Anime, Action&amp;lt;/type&amp;gt; 20 &amp;lt;format&amp;gt;DVD&amp;lt;/format&amp;gt; 21 &amp;lt;year&amp;gt;1986&amp;lt;/year&amp;gt; 22 &amp;lt;rating&amp;gt;PG&amp;lt;/rating&amp;gt; 23 &amp;lt;stars&amp;gt;10&amp;lt;/stars&amp;gt; 24 &amp;lt;description&amp;gt;Vash the Stam pede!</description></item><item><title>二十五、JSP XML 数据处理</title><link>https://www.shellio.cc/docs/java/jsp/25/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/jsp/25/</guid><description>JSP XML 数据处理 当通过HTTP发送XML数据时，就有必要使用JSP来处理传入和流出的XML文档了，比如RSS文档。作为一个XML文档，它仅仅只是一堆文本而已，使用JSP创建XML文档并不比创建一个HTML文档难。
使用JSP发送XML 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 使用JSP发送XML内容就和发送HTML内容一样。唯一的不同就是您需要把页面的context属性设置为text/xml。要设置context属性，使用&amp;lt;%@page % &amp;gt;命令，就像这样：
1&amp;lt;%@ page contentType=&amp;#34;text/xml&amp;#34; %&amp;gt; 接下来这个例子向浏览器发送XML内容：
1&amp;lt;%@ page contentType=&amp;#34;text/xml&amp;#34; %&amp;gt; 2&amp;lt;books&amp;gt; 3 &amp;lt;book&amp;gt; 4 &amp;lt;name&amp;gt;Padam History&amp;lt;/name&amp;gt; 5 &amp;lt;author&amp;gt;ZARA&amp;lt;/author&amp;gt; 6 &amp;lt;price&amp;gt;100&amp;lt;/price&amp;gt; 7 &amp;lt;/book&amp;gt; 8&amp;lt;/books&amp;gt; 使用不同的浏览器来访问这个例子，看看这个例子所呈现的文档树。
在JSP中处理XML 在使用JSP处理XML之前，您需要将与XML 和XPath相关的两个库文件放在 \lib目录下：
XercesImpl.jar：在这下载http://www.apache.org/dist/xerces/j/ xalan.jar：在这下载http://xml.apache.org/xalan-j/index.html books.xml文件:
1&amp;lt;books&amp;gt; 2&amp;lt;book&amp;gt; 3 &amp;lt;name&amp;gt;Padam History&amp;lt;/name&amp;gt; 4 &amp;lt;author&amp;gt;ZARA&amp;lt;/author&amp;gt; 5 &amp;lt;price&amp;gt;100&amp;lt;/price&amp;gt; 6&amp;lt;/book&amp;gt; 7&amp;lt;book&amp;gt; 8 &amp;lt;name&amp;gt;Great Mistry&amp;lt;/name&amp;gt; 9 &amp;lt;author&amp;gt;NUHA&amp;lt;/author&amp;gt; 10 &amp;lt;price&amp;gt;2000&amp;lt;/price&amp;gt; 11&amp;lt;/book&amp;gt; 12&amp;lt;/books&amp;gt; main.jsp文件：
1&amp;lt;%@ page language=&amp;#34;java&amp;#34; contentType=&amp;#34;text/html; charset=UTF-8&amp;#34; 2 pageEncoding=&amp;#34;UTF-8&amp;#34;%&amp;gt; 3&amp;lt;%@ taglib prefix=&amp;#34;c&amp;#34; uri=&amp;#34;http://java.</description></item><item><title>二十一、3.1 概述</title><link>https://www.shellio.cc/docs/java/jfinal/21/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/jfinal/21/</guid><description>Controller 是 JFinal 核心类之一，该类作为 MVC 模式中的控制器。基于 JFinal 的 Web 应 用的控制器需要继承该类。Controller 是定义 Action 方法的地点，是组织 Action 的一种方式， 一个 Controller 可以包含多个 Action。Controller 是线程安全的。</description></item><item><title>二十一、Gradle 标准的 Gradle 插件</title><link>https://www.shellio.cc/docs/java/gradle/21/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/gradle/21/</guid><description>标准的 Gradle 插件 Gradle 的发行包中有大量的插件。如下列所示：
语言插件 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 这些插件添加了让各种语言可以被编译和在 JVM 执行的支持。
语言插件
插件 Id 自动应用 与什么插件一起使用 描述 java java-base – 向一个项目添加 Java 编译、 测试和捆绑的能力。它是很多其他 Gradle 插件的基础服务。 groovy groovy-base – 添加对 Groovy 项目构建的支持。 scala scala-base – 添加对 Scala 项目构建的支持。
antlr java – 添加对使用Antlr作为生成解析器的支持。 正在孵化的语言插件 这些插件添加了对多种语言的支持：
语言插件
插件 Id 自动应用 与什么插件一起使用 描述 assembler – – 向项目添加本机汇编语言的功能。
c – – 向项目添加 C语言源代码编译功能。
cpp – – 向项目添加 c++ 源代码编译功能。
objective-c – – 向项目中添加 Objective-C 源代码编译功能。</description></item><item><title>二十一、Groovy 泛型</title><link>https://www.shellio.cc/docs/java/groovy/21/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/groovy/21/</guid><description>在定义类，接口和方法时，泛型使能类型（类和接口）作为参数。与在方法声明中使用的更熟悉的形式参数非常类似，类型参数提供了一种方法，可以为不同的输入重复使用相同的代码。区别在于形式参数的输入是值，而类型参数的输入是类型。
集合的通用 可以对集合类（如List类）进行一般化，以便只有该类型的集合在应用程序中被接受。下面显示了一般化ArrayList的示例。以下语句的作用是它只接受类型为string的列表项 –
1List&amp;lt;String&amp;gt; list = new ArrayList&amp;lt;String&amp;gt;(); 在下面的代码示例中，我们将执行以下操作：
创建一个只包含字符串的通用ArrayList集合。 向列表中添加3个字符串。 对于列表中的每个项目，打印字符串的值。 1class Example { 2 static void main(String[] args) { 3 // Creating a generic List collection 4 List&amp;lt;String&amp;gt; list = new ArrayList&amp;lt;String&amp;gt;(); 5 list.add(&amp;#34;First String&amp;#34;); 6 list.add(&amp;#34;Second String&amp;#34;); 7 list.add(&amp;#34;Third String&amp;#34;); 8 for(String str : list) { 9 println(str); 10 } 11 } 上述程序的输出将是 –
1First String 2Second String 3Third String 泛型类 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 整个类也可以泛化。这使得类更灵活地接受任何类型，并相应地与这些类型工作。让我们来看一个例子，说明我们如何做到这一点。
在以下程序中，我们执行以下步骤 –</description></item><item><title>二十一、JSP 自动刷新</title><link>https://www.shellio.cc/docs/java/jsp/21/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/jsp/21/</guid><description>JSP 自动刷新 想象一下，如果要直播比赛的比分，或股票市场的实时状态，或当前的外汇配给，该怎么实现呢？显然，要实现这种实时功能，您就不得不规律性地刷新页面。
JSP提供了一种机制来使这种工作变得简单，它能够定时地自动刷新页面。
刷新一个页面最简单的方式就是使用response对象的setIntHeader()方法。这个方法的签名如下：
1public void setIntHeader(String header, int headerValue) 这个方法通知浏览器在给定的时间后刷新，时间以秒为单位。
页面自动刷新程序示例 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 这个例子使用了setIntHeader()方法来设置刷新头，模拟一个数字时钟：
1&amp;lt;%@ page import=&amp;#34;java.io.*,java.util.*&amp;#34; %&amp;gt; 2&amp;lt;html&amp;gt; 3&amp;lt;head&amp;gt; 4&amp;lt;title&amp;gt;Auto Refresh Header Example&amp;lt;/title&amp;gt; 5&amp;lt;/head&amp;gt; 6&amp;lt;body&amp;gt; 7&amp;lt;center&amp;gt; 8&amp;lt;h2&amp;gt;Auto Refresh Header Example&amp;lt;/h2&amp;gt; 9&amp;lt;% 10// Set refresh, autoload time as 5 seconds 11response.setIntHeader(&amp;#34;Refresh&amp;#34;, 5); 12// Get current time 13Calendar calendar = new GregorianCalendar(); 14String am_pm; 15int hour = calendar.get(Calendar.HOUR); 16int minute = calendar.get(Calendar.MINUTE); 17int second = calendar.get(Calendar.SECOND); 18if(calendar.get(Calendar.AM_PM) == 0) 19am_pm = &amp;#34;AM&amp;#34;; 20else 21am_pm = &amp;#34;PM&amp;#34;; 22String CT = hour+&amp;#34;:&amp;#34;+ minute +&amp;#34;:&amp;#34;+ second +&amp;#34; &amp;#34;+ am_pm; 23out.</description></item><item><title>二十一、Memcached flush_all 命令</title><link>https://www.shellio.cc/docs/java/memcached/21/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/memcached/21/</guid><description>Memcached flush_all 命令用于清空缓存。
也就是删除缓存中的所有 key=&amp;gt;value(键=&amp;gt;值) 对
语法 1flush_all [time] [noreply] time 参数是可选的，单位秒。 如果设置了值，则表示 Memcached 将在这个时间后才执行清空操作 noreply 参数是可选的，如果设置了值，则表示 Memcached 服务不用返回信息 flush_all noreply 命令没有任何效果的,因为它本来就没数据返回
范例 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 1 . 不带任何参数 1set site 0 1000 11 2ddkk.com 3STORED 4get site 5VALUE site 0 11 6ddkk.com 7END 8flush_all 9OK 10get site 11END 2. 10s 后清空缓存 1set site 0 1000 11 2ddkk.com 3STORED 4get site 5VALUE site 0 11 6ddkk.com 7END 8flush_all 10 设置 10秒后清空缓存 9OK 10get site 立刻获取有返回 11VALUE site 0 11 12ddkk.</description></item><item><title>九、1.4 添加 java 文件</title><link>https://www.shellio.cc/docs/java/jfinal/9/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/jfinal/9/</guid><description>在项目src 目录下创建 demo 包，并在 demo 包下创建 DemoConfig 文件， 内容如下：
package demo;
import com.jfinal.config.*;
public class DemoConfig extends JFinalConfig {
public void configConstant(Constants me)
{ me.setDevMode(true);
}
public void configRoute(Routes me)
{ me.add(“/hello”,
HelloController.class);
}
public void configPlugin(Plugins me) {}
public void configInterceptor(Interceptors me) {}
public void configHandler(Handlers me) {}
注意：DemoConfig.java 文件所在的包以及自身文件名必须与 web.xml 中的 param-value 标 签内的配置相一致(在本例中该配置为 demo.DemoConfig)。
在demo 包下创建 HelloController 类文件， 内容如下：
package demo;
import com.jfinal.core.Controller;
public class HelloController extends Controller {</description></item><item><title>九、Gradle Web 工程构建</title><link>https://www.shellio.cc/docs/java/gradle/9/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/gradle/9/</guid><description>Web 工程构建 本章介绍了 Gradle 对 Web 工程的相关支持。Gradle 为 Web 开发提供了两个主要插件，War plugin 和 Jetty plugin。 其中 War plugin 继承自 Java plugin，可以用来打 war 包。jetty plugin 继承自 War plugin 作为工程部署的容器。
打 War 包 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 需要打包 War 文件，需要在脚本中使用 War plugin：
War plugin build.gradle
1apply plugin: &amp;#39;war&amp;#39; 备注：本示例代码可以在 Gradle 发行包中的 samples/webApplication/quickstart 路径下找到。
由于继承自 Java 插件，当你执行 gradle build 时，将会编译、测试、打包你的工程。Gradle 会在 src/main/webapp 下寻找 Web 工程文件。编译后的 classes 文件以及运行时依赖也都会被包含在 War 包中。
Groovy web构建
在一个工程中你可以采用多个插件。比如你可以在 web 工程中同时使用 War plugin 和 Groovy plugin。插件会将 Gradle 依赖添加到你的 War 包中。</description></item><item><title>九、Groovy 方法</title><link>https://www.shellio.cc/docs/java/groovy/9/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/groovy/9/</guid><description>Groovy中的方法是使用返回类型或使用def关键字定义的。方法可以接收任意数量的参数。定义参数时，不必显式定义类型。可以添加修饰符，如public，private和protected。默认情况下，如果未提供可见性修饰符，则该方法为public。
最简单的方法是没有参数的方法，如下所示：
1def methodName() { 2 //Method code 下面是一个简单方法的例子
1class Example { 2 static def DisplayName() { 3 println(&amp;#34;This is how methods work in groovy&amp;#34;); 4 println(&amp;#34;This is an example of a simple method&amp;#34;); 5 } 6 static void main(String[] args) { 7 DisplayName(); 8 } 在上面的例子中，DisplayName是一个简单的方法，它由两个println语句组成，用于向控制台输出一些文本。在我们的静态main方法中，我们只是调用DisplayName方法。上述方法的输出将是 –
1This is how methods work in groovy 2This is an example of a simple method 方法参数 如果一个方法的行为由一个或多个参数的值确定，则它通常是有用的。我们可以使用方法参数将值传递给被调用的方法。请注意，参数名称必须彼此不同。
使用参数的最简单的方法类型，如下所示 −
1def methodName(parameter1, parameter2, parameter3) { 2 // Method code goes here 以下是使用参数的简单方法的示例</description></item><item><title>九、Hibernate 映射文件</title><link>https://www.shellio.cc/docs/java/hibernate/9/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/hibernate/9/</guid><description>映射文件 一个对象/关系型映射一般定义在 XML 文件中。映射文件指示 Hibernate 如何将已经定义的类或类组与数据库中的表对应起来。
尽管有些 Hibernate 用户选择手写 XML 文件，但是有很多工具可以用来给先进的 Hibernate 用户生成映射文件。这样的工具包括 XDoclet, Middlegen 和 AndroMDA。
让我们来考虑我们之前定义的 POJO 类，它的对象将延续到下一部分定义的表中。
1public class Employee { 2 private int id; 3 private String firstName; 4 private String lastName; 5 private int salary; 6 public Employee() {} 7 public Employee(String fname, String lname, int salary) { 8 this.firstName = fname; 9 this.lastName = lname; 10 this.salary = salary; 11 } 12 public int getId() { 13 return id; 14 } 15 public void setId( int id ) { 16 this.</description></item><item><title>九、Java 8 方法引用</title><link>https://www.shellio.cc/docs/java/java8/9/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/java8/9/</guid><description>Java 8 中新增加了 方法引用 这个概念。 但，什么是方法引用呢 ？
我们先来看一个例子，下面这个范例演示了如何遍历字符串列表并进行一些操作
LambdaTester.java 1import java.util.Arrays; 2import java.util.List; 3import java.util.function.Function; 4public class LambdaTester { 5 public static void main(String[] args) 6 { 7 LambdaTester tester = new LambdaTester(); 8 tester.run(); 9 } 10 public void run() 11 { 12 List&amp;lt;String&amp;gt; list = Arrays.asList(&amp;#34;Ram&amp;#34;,&amp;#34;Shyam&amp;#34;,&amp;#34;Kabir&amp;#34;); 13 // 输出 14 for(String st: list){ 15 System.out.println(st); 16 } 17 // 转换为大写 18 for(String st: list){ 19 upperAndPrint(st); 20 } 21 } 22 public static void upperAndPrint(String s) 23 { 24 System.</description></item><item><title>九、Java 9 新特性 – 接口 ( interface ) 的私有方法</title><link>https://www.shellio.cc/docs/java/java9/9/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/java9/9/</guid><description>在我的印象中，好像，从来没有，想过在 interface 中定义私有的方法。一来各种文档中的确没有这么介绍过，二来，好像从来没有谁这么做过，三来，好像定义了也不知道要怎么使用，毕竟，接口 interface 中的方法都会被具体的类重写一次，所以，似乎，私有方法都没啥大作用了。
比如说，很简单的，我们的 Java 基础教程: Java 接口 中，就没有论述私有方法这回事。
既然Java 9 添加了这项特性，那么，应该就有它的用途，我们一起来看看 Java 9 中的接口的私有方法是什么样的吧。
JDK 7 / JDK 6 回忆一下，Java 8 之前 ，接口好像就只允许两种类型的数据，一个是常量、另一个就是公开 ( public ) 的虚方法 ( abstract )，而且是虚方法哦，就是没有任何实现的方法，因为这些方法要被类来实现。
也就是说，Java 8 之前的版本不存在有着默认实现的方法
我们来看看一个示例，在我们的工作区创建一个文件 InterfacePrivateMethodTester.java ，并输入一下内容
1public class InterfacePrivateMethodTester { 2 public static void main(String []args) { 3 LogOracle log = new LogOracle(); 4 log.logInfo(&amp;#34;&amp;#34;); 5 log.logWarn(&amp;#34;&amp;#34;); 6 log.logError(&amp;#34;&amp;#34;); 7 log.logFatal(&amp;#34;&amp;#34;); 8 LogMySql log1 = new LogMySql(); 9 log1.</description></item><item><title>九、JSP 隐式对象</title><link>https://www.shellio.cc/docs/java/jsp/9/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/jsp/9/</guid><description>JSP 隐式对象 JSP隐式对象是JSP容器为每个页面提供的Java对象，开发者可以直接使用它们而不用显式声明。JSP隐式对象也被称为预定义变量。
JSP所支持的九大隐式对象：
对象 描述 request HttpServletRequest类的实例 response HttpServletResponse类的实例 out PrintWriter类的实例，用于把结果输出至网页上 session HttpSession类的实例 application ServletContext类的实例，与应用上下文有关 config ServletConfig类的实例 pageContext PageContext类的实例，提供对JSP页面所有对象以及命名空间的访问 page 类似于Java类中的this关键字 Exception Exception类的对象，代表发生错误的JSP页面中对应的异常对象 request对象 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 request对象是javax.servlet.http.HttpServletRequest 类的实例。每当客户端请求一个JSP页面时，JSP引擎就会制造一个新的request对象来代表这个请求。
request对象提供了一系列方法来获取HTTP头信息，cookies，HTTP方法等等。
response对象 response对象是javax.servlet.http.HttpServletResponse类的实例。当服务器创建request对象时会同时创建用于响应这个客户端的response对象。
response对象也定义了处理HTTP头模块的接口。通过这个对象，开发者们可以添加新的cookies，时间戳，HTTP状态码等等。
out对象 out对象是 javax.servlet.jsp.JspWriter 类的实例，用来在response对象中写入内容。
最初的JspWriter类对象根据页面是否有缓存来进行不同的实例化操作。可以在page指令中使用buffered=’false’属性来轻松关闭缓存。
JspWriter类包含了大部分java.io.PrintWriter类中的方法。不过，JspWriter新增了一些专为处理缓存而设计的方法。还有就是，JspWriter类会抛出IOExceptions异常，而PrintWriter不会。
下表列出了我们将会用来输出boolean，char，int，double，Srtring，object等类型数据的重要方法：
方法 描述 out.print(dataType dt) 输出Type类型的值 out.println(dataType dt) 输出Type类型的值然后换行 out.flush() 刷新输出流 session对象 session对象是 javax.servlet.http.HttpSession 类的实例。和Java Servlets中的session对象有一样的行为。
session对象用来跟踪在各个客户端请求间的会话。
application对象 application对象直接包装了servlet的ServletContext类的对象，是javax.servlet.ServletContext 类的实例。
这个对象在JSP页面的整个生命周期中都代表着这个JSP页面。这个对象在JSP页面初始化时被创建，随着jspDestroy()方法的调用而被移除。
通过向application中添加属性，则所有组成您web应用的JSP文件都能访问到这些属性。
config对象 config对象是 javax.servlet.ServletConfig 类的实例，直接包装了servlet的ServletConfig类的对象。
这个对象允许开发者访问Servlet或者JSP引擎的初始化参数，比如文件路径等。
以下是config对象的使用方法，不是很重要，所以不常用：
1config.getServletName(); 它返回包含在 元素中的servlet名字，注意， 元素在 WEB-INF\web.</description></item><item><title>九、JUnit – 执行测试</title><link>https://www.shellio.cc/docs/java/junit/9/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/junit/9/</guid><description>JUnit – 执行测试 测试用例是使用 JUnitCore 类来执行的。JUnitCore 是运行测试的外观类。它支持运行 JUnit 4 测试, JUnit 3.8.x 测试,或者他们的混合。 要从命令行运行测试，可以运行 java org.junit.runner.JUnitCore 。对于只有一次的测试运行，可以使用静态方法 runClasses(Class[])。
下面是org.junit.runner.JUnitCore 类的声明：
1public class JUnitCore extends java.lang.Object 创建一个类 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 在目录 C:\ &amp;gt; JUNIT_WORKSPACE 中创建一个被测试的 Java 类命名为 MessageUtil.java。 1/* 2* This class prints the given message on console. 3*/ 4public class MessageUtil { 5 private String message; 6 //Constructor 7 //@param message to be printed 8 public MessageUtil(String message){ 9 this.message = message; 10 } 11 // prints the message 12 public String printMessage(){ 13 System.</description></item><item><title>九、Maven 构建 &amp;amp; 测试工程</title><link>https://www.shellio.cc/docs/java/maven/9/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/maven/9/</guid><description>Maven – 构建 &amp;amp; 测试工程 我们在创建工程章节中学到的是如何使用 Maven 创建 Java 应用。现在我们将看到如何构建和测试这个应用。
跳转到C:/MVN 目录下，既你的 java 应用目录下。打开 consumerBanking 文件夹。你将看到 POM.xml 文件中有下面的内容。
1&amp;lt;project xmlns=&amp;#34;http://maven.apache.org/POM/4.0.0&amp;#34; 2 xmlns:xsi=&amp;#34;http://www.w3.org/2001/XMLSchema-instance&amp;#34; 3 xsi:schemaLocation=&amp;#34;http://maven.apache.org/POM/4.0.0 4 http://maven.apache.org/xsd/maven-4.0.0.xsd&amp;#34;&amp;gt; 5 &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt; 6 &amp;lt;groupId&amp;gt;com.companyname.projectgroup&amp;lt;/groupId&amp;gt; 7 &amp;lt;artifactId&amp;gt;project&amp;lt;/artifactId&amp;gt; 8 &amp;lt;version&amp;gt;1.0&amp;lt;/version&amp;gt; 9 &amp;lt;dependencies&amp;gt; 10 &amp;lt;dependency&amp;gt; 11 &amp;lt;groupId&amp;gt;junit&amp;lt;/groupId&amp;gt; 12 &amp;lt;artifactId&amp;gt;junit&amp;lt;/artifactId&amp;gt; 13 &amp;lt;version&amp;gt;3.8.1&amp;lt;/version&amp;gt; 14 &amp;lt;/dependency&amp;gt; 15 &amp;lt;/dependencies&amp;gt; 16&amp;lt;/project&amp;gt; 可以看到，Maven 已经添加了 JUnit 作为测试框架。默认 Maven 添加了一个源码文件 App.java 和一个测试文件 AppTest.java 到上个章节中我们提到的默认目录结构中。
打开命令控制台，跳转到 C:\MVN\consumerBanking 目录下，并执行以下 mvn 命令。
1C:\MVN\consumerBanking&amp;gt;mvn clean package Maven 将开始构建工程。
1[INFO] Scanning for projects.</description></item><item><title>九、Memcached append 命令</title><link>https://www.shellio.cc/docs/java/memcached/9/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/memcached/9/</guid><description>Memcached append 命令用于向已存在 key(键) 的 value(数据值) 后面追加数据
语法 1append key flags exptime bytes [noreply] 2value 参数说明 key： 键值 key-value 结构中的 key flags ：可以包括键值对的整型参数，客户机使用它存储关于键值对的额外信息 exptime ：在缓存中保存键值对的时间长度（以秒为单位，0 表示永远） bytes ：在缓存中存储的字节数 noreply ：可选， 该参数告知服务器不需要返回数据 value ：存储的值（始终位于第二行）（可直接理解为key-value结构中的value） 返回值说明 如果数据添加成功，返回 STORED 如果键不存在，返回 NOT_STORED 如果执行错误，返回 CLIENT_ERROR 范例 1. 如果数据添加成功，返回 STORED 1flush_all 2OK 3set greeting 0 1000 6 4hello, 5STORED 6append greeting 0 1000 11 7ddkk.com 8STORED 9get greeting 10VALUE greeting 0 17 11hello,ddkk.com 12END 2. 如果键不存在，返回 NOT_STORED 1flush_all 2OK 3append greeting 0 1000 11 4ddkk.</description></item><item><title>六、1.1 JFinal创建项目</title><link>https://www.shellio.cc/docs/java/jfinal/6/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/jfinal/6/</guid><description>JFinal 推荐使用 Eclipse IDE for Java EE Developers 做 为 开 发 环 境 。 点此下载
IDEA 用户快速上手参见这里：http://my.oschina.net/chixn/blog/471755
1）创建 Dynamic Web Project
2）填入项目基本信息
注意：Target runtime 一定要选择
3）修改 Default Output Folder，推荐输入 WebRoot\WEB-INF\classes
特别注意：此处的 Default out folder 必须要与 WebRoot\WEB-INF\classes 目录完全一致才可 以使用 JFinal 集成的 Jetty 来启动项目。
4）修改 Content directory，推荐输入 WebRoot
注意：此处也可以使用默认值 WebContent， 但上一步中的 WebRoot\WEB-INF\classes 则需要 改成 WebContent\WEB-INF\classes 才能对应上。</description></item><item><title>六、Gradle Java 构建入门</title><link>https://www.shellio.cc/docs/java/gradle/6/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/gradle/6/</guid><description>Java 构建入门 Java 插件 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 如你所见，Gradle 是一个通用工具。它可以通过脚本构建任何你想要实现的东西，真正实现开箱即用。但前提是你需要在脚本中编写好代码才行。
大部分Java 项目基本流程都是相似的：编译源文件，进行单元测试，创建 jar 包。使用 Gradle 做这些工作不必为每个工程都编写代码。Gradle 已经提供了完美的插件来解决这些问题。插件就是 Gradle 的扩展，简而言之就是为你添加一些非常有用的默认配置。Gradle 自带了很多插件，并且你也可以很容易的编写和分享自己的插件。Java plugin 作为其中之一，为你提供了诸如编译，测试，打包等一些功能。
Java 插件为工程定义了许多默认值，如Java源文件位置。如果你遵循这些默认规则，那么你无需在你的脚本文件中书写太多代码。当然，Gradle 也允许你自定义项目中的一些规则，实际上，由于对 Java 工程的构建是基于插件的，那么你也可以完全不用插件自己编写代码来进行构建。
后面的章节我们通过许多深入的例子介绍了如何使用 Java 插件来进行以来管理和多项目构建等。但在这个章节我们需要先了解 Java 插件的基本用法。
一个基本 Java 项目 来看一下下面这个小例子，想用 Java 插件，只需增加如下代码到你的脚本里。
采用 Java 插件 1build.gradle 1apply plugin: &amp;#39;java&amp;#39; 备注:示例代码可以在 Gralde 发行包中的 samples/java/quickstart 下找到。
定义一个 Java 项目只需如此而已。这将会为你添加 Java 插件及其一些内置任务。
添加了哪些任务?
你可以运行 gradle tasks 列出任务列表。这样便可以看到 Java 插件为你添加了哪些任务。
标准目录结构如下:
1project 2 +build 3 +src/main/java 4 +src/main/resources 5 +src/test/java 6 +src/test/resources Gradle 默认会从 src/main/java 搜寻打包源码，在 src/test/java 下搜寻测试源码。并且 src/main/resources 下的所有文件按都会被打包，所有 src/test/resources 下的文件 都会被添加到类路径用以执行测试。所有文件都输出到 build 下，打包的文件输出到 build/libs 下。</description></item><item><title>六、Groovy 运算符</title><link>https://www.shellio.cc/docs/java/groovy/6/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/groovy/6/</guid><description>运算符是一个符号，通知编译器执行特定的数学或逻辑操作。
Groovy中有以下类型的运算符 –
算术运算符 关系运算符 逻辑运算符 位运算符 赋值运算符 算术运算符 Groovy语言支持正常的算术运算符任何语言。以下是在Groovy中可用的算术运算符 –
显示示例
运算符 描述 例子 + 两个操作数的加法 1 + 2 将得到 3 – 第一第二操作数相减
2 – 1 将得到 1 * 两个操作数的乘法 2 * 2 将得到4&amp;nbsp; / 两个操作数的除法 3/2 将得到&amp;nbsp;1.5 ％ 取模运算 3％2 将得到&amp;nbsp;1 ++ 自增运算，在自身值的基础上加1 INT X = 5;
X ++;
X 将得到 6
— 自减运算,在自身值的基础上减1
INT X = 5;
X – -;
X 将得到 4
# 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 关系运算符 关系运算符允许对象的比较。以下是在Groovy中可用的关系运算符 –</description></item><item><title>六、Hibernate 配置</title><link>https://www.shellio.cc/docs/java/hibernate/6/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/hibernate/6/</guid><description>配置 Hibernate 需要事先知道在哪里找到映射信息，这些映射信息定义了 Java 类怎样关联到数据库表。Hibernate 也需要一套相关数据库和其它相关参数的配置设置。所有这些信息通常是作为一个标准的 Java 属性文件提供的，名叫 hibernate.properties。又或者是作为 XML 文件提供的，名叫 hibernate.cfg.xml。
我们将考虑 hibernate.cfg.xml 这个 XML 格式文件，来决定在我的例子里指定需要的 Hibernate 应用属性。这个 XML 文件中大多数的属性是不需要修改的。这个文件保存在应用程序的类路径的根目录里。
Hibernate 属性 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 下面是一个重要的属性列表，你可能需要表中的属性来在单独的情况下配置数据库。
S.N. 属性和描述 1 hibernate.dialect 这个属性使 Hibernate 应用为被选择的数据库生成适当的 SQL。 2 hibernate.connection.driver_class JDBC 驱动程序类。 3 hibernate.connection.url 数据库实例的 JDBC URL。 4 hibernate.connection.username 数据库用户名。 5 hibernate.connection.password 数据库密码。 6 hibernate.connection.pool_size 限制在 Hibernate 应用数据库连接池中连接的数量。 7 hibernate.connection.autocommit 允许在 JDBC 连接中使用自动提交模式。 如果您正在使用 JNDI 和数据库应用程序服务器然后您必须配置以下属性:
S.N. 属性和描述 1 hibernate.connection.datasource 在应用程序服务器环境中您正在使用的应用程序 JNDI 名。 2 hibernate.</description></item><item><title>六、Java 8 Lambda 表达式 （ 上 ）- 简介</title><link>https://www.shellio.cc/docs/java/java8/6/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/java8/6/</guid><description>Lambda 表达式在 Java 8 中引入，并且被吹捧为 Java 8 最大的特性。
Lambda 表达式是函数式编程的的一个重要特性，标志者 Java 向函数式编程迈出了重要的第一步。
Java Lambda 表达式语法 Java Lambda 表达式的语法结构如下
1parameter -&amp;gt; expression body 实际代码可能如下
有参数且只有一条语句时 1(a,b) -&amp;gt; a + b 只有一个参数时 1a -&amp;gt; a 没有参数时 1() -&amp;gt; System.out.println(&amp;#34;DDKK.COM 弟弟快看，程序员编程资料站&amp;#34;) 有多条语句时 1(a,b) -&amp;gt; { 2 int c = a + b; 3 System.out.println(&amp;#34;DDKK.COM 弟弟快看，程序员编程资料站&amp;#34;) 针对这个 Java Lambda 表达式语法，有几个重要的特征需要说明
可选的参数类型声明 ： 无需声明参数的类型。编译器可以从参数的值推断出相同的值。 可选的参数周围的小括号 () ： 如果只有一个参数，可以忽略参数周围的小括号。但如果有多个参数，则必须添加小括号。 可选的大括号 {} : 如果 Lambda 表达式只包含一条语句，那么可以省略大括号。但如果有多条语句，则必须添加大括号。 可选的 return 关键字 ： 如果 Lambda 表达式只有一条语句，那么编译器会自动 return 该语句最后的结果。但如果显式使用了 return 语句，则必须添加大括号 {} ，哪怕只有一条语句。 Java Lambda 表达式的原理 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 后面我们会讲到，Java 8 中的 Lambda 表达式其实是一个特殊的只有一个方法的类的实例。</description></item><item><title>六、Java 9 新特性 – 改进 JavaDocs</title><link>https://www.shellio.cc/docs/java/java9/6/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/java9/6/</guid><description>一直以来，Java 生成的文档 JavaDoc 一直使用的都是 HTML 4 格式，这次 Java 9 良心大大的发现，使用了 HTML 5 ，但还不是默认的，如果要输出 HTML 5 格式，还必须在命令行程序中添加 -html5 选项。
旧的 JavaDoc 文档格式 我们先在当前工作区，例如我的是 D:\devops\java9 的 src 目录下创建一个文件 JavaDocTester.java ，内容如下
1/** 2 * @author MahKumar 3 * @version 0.1 4*/ 5public class JavaDocTester { 6 /** 7 * 默认的方法用于输出 Hello World 8 * &amp;lt;p&amp;gt;Hello world&amp;lt;/p&amp;gt; 9 * @param args 命令行参数 10 */ 11 public static void main(String []args) { 12 System.out.println(&amp;#34;Hello World&amp;#34;); 13 } 然后我们就可以使用 javadoc 命令输出该类的文档</description></item><item><title>六、JSP 语法</title><link>https://www.shellio.cc/docs/java/jsp/6/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/jsp/6/</guid><description>JSP 语法 本小节将会简单地介绍一下JSP开发中的基础语法。
脚本程序 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 脚本程序可以包含任意量的Java语句、变量、方法或表达式，只要它们在脚本语言中是有效的。
脚本程序的语法格式：
1&amp;lt;% 代码片段 %&amp;gt; 或者，您也可以编写与其等价的XML语句，就像下面这样：
1&amp;lt;jsp:scriptlet&amp;gt; 2 代码片段 3&amp;lt;/jsp:scriptlet&amp;gt; 任何文本、HTML标签、JSP元素必须写在脚本程序的外面。
下面给出一个示例，同时也是本教程的第一个JSP示例：
1&amp;lt;html&amp;gt; 2&amp;lt;head&amp;gt; 3&amp;lt;title&amp;gt;Hello World&amp;lt;/title&amp;gt; 4&amp;lt;/head&amp;gt; 5&amp;lt;body&amp;gt; 6Hello World!&amp;lt;br/&amp;gt; 7&amp;lt;% 8out.println(&amp;#34;Your IP address is &amp;#34; + request.getRemoteAddr()); 9%&amp;gt; 10&amp;lt;/body&amp;gt; 11&amp;lt;/html&amp;gt; **注意：**请确保Apache Tomcat已经安装在C:\apache-tomcat-7.0.2目录下并且运行环境已经正确设置。
将以上代码保存在hello.jsp中，然后将它放置在 C:\apache-tomcat-7.0.2\webapps\ROOT目录下，打开浏览器并在地址栏中输入http://localhost:8080/hello.jsp。运行后得到以下结果：
JSP声明 一个声明语句可以声明一个或多个变量、方法，供后面的Java代码使用。在JSP文件中，您必须先声明这些变量和方法然后才能使用它们。
JSP声明的语法格式：
1&amp;lt;%! declaration; [ declaration; ]+ ... %&amp;gt; 或者，您也可以编写与其等价的XML语句，就像下面这样：
1&amp;lt;jsp:declaration&amp;gt; 2 代码片段 3&amp;lt;/jsp:declaration&amp;gt; 程序示例：
1&amp;lt;%! int i = 0; %&amp;gt; 2&amp;lt;%! int a, b, c; %&amp;gt; 3&amp;lt;%! Circle a = new Circle(2.</description></item><item><title>六、JUnit – 编写测试</title><link>https://www.shellio.cc/docs/java/junit/6/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/junit/6/</guid><description>JUnit – 编写测试 在这里你将会看到一个应用 POJO 类，Business logic 类和在 test runner 中运行的 test 类的 JUnit 测试的例子。
在 C:\ &amp;gt; JUNIT_WORKSPACE 路径下创建一个名为 EmployeeDetails.java 的 POJO 类。
1public class EmployeeDetails { 2 private String name; 3 private double monthlySalary; 4 private int age; 5 /** 6 * @return the name 7 */ 8 public String getName() { 9 return name; 10 } 11 /** 12 * @param name the name to set 13 */ 14 public void setName(String name) { 15 this.</description></item><item><title>六、Maven 仓库</title><link>https://www.shellio.cc/docs/java/maven/6/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/maven/6/</guid><description>Maven – 仓库 什么是 Maven 仓库？ 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 在Maven 的术语中，仓库是一个位置（place），例如目录，可以存储所有的工程 jar 文件、library jar 文件、插件或任何其他的工程指定的文件。
Maven 仓库有三种类型：
本地（local） 中央（central） 远程（remote） 本地仓库 Maven 本地仓库是机器上的一个文件夹。它在你第一次运行任何 maven 命令的时候创建。
Maven 本地仓库保存你的工程的所有依赖（library jar、plugin jar 等）。当你运行一次 Maven 构建，Maven 会自动下载所有依赖的 jar 文件到本地仓库中。它避免了每次构建时都引用存放在远程机器上的依赖文件。
Maven 本地仓库默认被创建在 %USER_HOME% 目录下。要修改默认位置，在 %M2_HOME%\conf 目录中的 Maven 的 settings.xml 文件中定义另一个路径。
1&amp;lt;settings xmlns=&amp;#34;http://maven.apache.org/SETTINGS/1.0.0&amp;#34; 2 xmlns:xsi=&amp;#34;http://www.w3.org/2001/XMLSchema-instance&amp;#34; 3 xsi:schemaLocation=&amp;#34;http://maven.apache.org/SETTINGS/1.0.0 4 http://maven.apache.org/xsd/settings-1.0.0.xsd&amp;#34;&amp;gt; 5 &amp;lt;localRepository&amp;gt;C:/MyLocalRepository&amp;lt;/localRepository&amp;gt; 6&amp;lt;/settings&amp;gt; 当你运行 Maven 命令，Maven 将下载依赖的文件到你指定的路径中。
中央仓库 Maven 中央仓库是由 Maven 社区提供的仓库，其中包含了大量常用的库。
中央仓库的关键概念：
这个仓库由 Maven 社区管理。 不需要配置。 需要通过网络才能访问。 要浏览中央仓库的内容，maven 社区提供了一个 URL：http://search.</description></item><item><title>六、Memcached set 命令</title><link>https://www.shellio.cc/docs/java/memcached/6/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/memcached/6/</guid><description>Memcached set 命令用于将 value(数据值) 存储在指定的 key(键) 中
语法： 1set key flags exptime bytes [noreply] 2value 范例 如果我们设置一个 key 为 site ,值为 ddkk.com, 过期时间为 1000 秒的键值对，那么命令一般如下
1set site 0 1000 11 2ddkk.com 参数说明
key ： 键值 key-value 结构中的 key，用于查找缓存值。 flags ：可以包括键值对的整型参数，客户机使用它存储关于键值对的额外信息 exptime ：在缓存中保存键值对的时间长度（以秒为单位，0 表示永远） bytes ：在缓存中存储的字节数 noreply ：可选， 该参数告知服务器不需要返回数据 value ：存储的值（始终位于第二行）（可直接理解为key-value结构中的value） 返回值说明 如果数据设置成功，返回 STORED 如果 key 已经存在，不管有没有过期都会更新数据，返回值为 STORED 如果执行错误，返回 CLIENT_ERROR 范例 1. 如果数据设置成功，返回 STORED 1flush_all 2OK 3set site 0 1000 11 4ddkk.</description></item><item><title>六十、8.1 概述</title><link>https://www.shellio.cc/docs/java/jfinal/60/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/jfinal/60/</guid><description>Validator 是 JFinal 校验组件，在 Validator 类中提供了非常方便的校验方法，学习简单，使用方便。</description></item><item><title>六十八、10.3 在 JFinal 中扩展</title><link>https://www.shellio.cc/docs/java/jfinal/68/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/jfinal/68/</guid><description>可以通过 FreeMarkerRender.getConfiguration().setSharedVariable(“myKit”, new MyKit()) 为FreeMarker 设置共享工具类，在 view 中使用 ${myKit.method(para)}。</description></item><item><title>六十二、8.3 Validator 配置</title><link>https://www.shellio.cc/docs/java/jfinal/62/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/jfinal/62/</guid><description>Validator 配置方式与拦截器完全一样，见如下代码：
public class UserController extends Controller {
@Before(LoginValidator. class) // 配置方式与拦截器完全一样
public void login() {
}
}</description></item><item><title>六十九、11.1 概述</title><link>https://www.shellio.cc/docs/java/jfinal/69/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/jfinal/69/</guid><description>JFinal 采用微内核全方位扩展架构，全方位是指其扩展方式在空间上的表现形式。JFinal 由 Handler、Interceptor、Controller、Render、Plugin 五大部分组成。本章将简单介绍此架构以 及基于此架构所做的一些较为常用的扩展。</description></item><item><title>六十六、10.1 概述</title><link>https://www.shellio.cc/docs/java/jfinal/66/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/jfinal/66/</guid><description>JFinal 默认使用 FreeMarker 作为 View，为了使 eclipse jee 能正确识别 html，所以默认使 用”.html”作为 FreeMarker 视图文件的扩展名(原为”.ftl”)。
如果需要使用 JSP 作为默认视图需要在 configConstant(Constants me)方法中进行配置，见 如下配置：
public void configConstant(Constants me) { me.setDevMode( true); me.setViewType(ViewType. JSP);
}</description></item><item><title>六十七、10.2 FreeMarker 示例</title><link>https://www.shellio.cc/docs/java/jfinal/67/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/jfinal/67/</guid><description>以下代码为 FreeMarker 经常使用的指令与插值:
&amp;gt; &amp;lt;\#list userList as user&amp;gt; &amp;gt; &amp;gt; $\{user.name\} $\{user.age\} $\{user.email\} 以上代码将 userList 中的 user 对象循环输出。</description></item><item><title>六十三、9.1 概述</title><link>https://www.shellio.cc/docs/java/jfinal/63/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/jfinal/63/</guid><description>JFinal 为国际化提供了极速化的支持，国际化模块仅三个类文件，使用方式要比 spring 这 类框架容易得多。</description></item><item><title>六十四、9.2 I18n 与 Res</title><link>https://www.shellio.cc/docs/java/jfinal/64/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/jfinal/64/</guid><description>I18n 对象可通过资源文件的 baseName 与 locale 参数获取到与之相对应的 Res 对象，Res 对象提供了 API 用来获取国际化数据。
以下给出具体使用步骤：
l创建 i18n_en_US.properties、 i18n_zh_CN.properties 资源文件， i18n 即为资源文件的baseName，可以是任意名称，在此示例中使用”i18n”作为 baseName i18n_en_US.properties 文件中添加如下内容：msg=Hello {0}, today is{1}. i18n_zh_CN.properties 文件中添加如下内容：msg=你好{0}, 今天是{1}. 在 YourJFinalConfig 中使用 me.setI18nDefaultBaseName(“i18n”)配置资源文件默认 baseName 特别注意，java 国际化规范要求 properties 文件的编辑需要使用专用的编辑器，否则会出 乱码，常用的有 Properties Editor，在此可以下载：http://www.oschina.net/p/properties+editor 以下是基于以上步骤以后的代码示例：
// 通过locale参数en_US得到对应的Res对象
Res resEn = I18n. use(“en_US”);
// 直接获取数据
String msgEn = resEn.get(“msg”);
// 获取数据并使用参数格式化
String msgEnFormat = resEn.format(“msg”, “james”, new Date());
// 通过locale参数zh_CN得到对应的Res对象
Res resZh = I18n. use(“zh_CN”);
// 直接获取数据</description></item><item><title>六十五、9.3 I18nInterceptor</title><link>https://www.shellio.cc/docs/java/jfinal/65/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/jfinal/65/</guid><description>I18nInterceptor 拦截器是针对于 web 应用提供的一个国际化组件，以下是在 freemarker 模板 中使用的例子：
//先将I18nInterceptor配置成全局拦截器
public void configInterceptor(Interceptors me) { me.add( new I18nInterceptor());
}
// 然后在 freemarker中即可通过_res对象来获取国际化数据
${_res.get(“msg”)}
以上代码通过配置了 I18nInterceptor 拦截 action 请求，然后即可在 freemarker 模板文件中 通过名为_res 对象来获取国际化数据，I18nInterceptor 的具体工作流程如下：
l试图从请求中通过 controller.getPara(“_locale”)获取 locale 参数，如果获取到则将其保存到cookie 之中 如 果 controller.getPara(“_locale”) 没 有 获 取 到 参 数 值 ， 则试图通过controller.getCookie(“_locale”)得到 locale 参数 如果以上两步仍然没有获取到 locale 参数值，则使用 I18n. defaultLocale 的值做为 locale 值 来使用 使用 前 面 三 步 中 得 到 的 locale 值 ， 通过 I18n.</description></item><item><title>六十一、8.2 Validator</title><link>https://www.shellio.cc/docs/java/jfinal/61/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/jfinal/61/</guid><description>Validator 自身实现了 Interceptor 接口，所以它也是一个拦截器，配置方式与拦截器完全一 样。以下是 Validator 示例：
public class LoginValidator extends Validator {
protected void validate(Controller c) { validateRequiredString(“name”, “nameMsg”, “请输入用户名”); validateRequiredString(“pass”, “passMsg”, “请输入密码”);
}
protected void handleError(Controller c) { c.keepPara(“name”);
c.render(“login.html”);
}
}
protected void validator(Controller c)方法中可以调用 validateXxx(…)系列方法进行后端校 验，protected void handleError(Controller c)方法中可以调用 c.keepPara(…)方法将提交的值再传 回页面以便保持原先输入的值，还可以调用 c.render(…) 方法来返回相应的页面。 注意 handleError(Controller c)只有在校验失败时才会调用。
以上代码 handleError 方法中的 keepXxx 方法用于将页面表单中的数据保持住并传递回页， 以便于用户无需再重复输入已经通过验证的表单域，如果传递过来的是 model 对象，可以使用 keepModel 方法来保持住用户输入过的数据。</description></item><item><title>七、1.2 放入 JFinal 库文件</title><link>https://www.shellio.cc/docs/java/jfinal/7/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/jfinal/7/</guid><description>将jfinal-xxx.jar 与jetty-server-8.1.8.jar 拷贝至项目 WEB-INF\lib 下即可。
注意：jetty-server-8.1.8.jar是开发时使用的运行环境，生产环境不需要此文件。</description></item><item><title>七、Gradle 依赖管理基础</title><link>https://www.shellio.cc/docs/java/gradle/7/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/gradle/7/</guid><description>依赖管理基础 本章节介绍如何使用 Gradle 进行基本的依赖管理.
什么是依赖管理? 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 通俗来讲，依赖管理由如下两部分组成。首先，Gradle 需要知道项目构建或运行所需要的一些文件，以便于找到这些需要的文件。我们称这些输入的文件为项目的依赖。其次，你可能需要构建完成后自动上传到某个地方。我们称这些输出为发布。下面来仔细介绍一下这两部分：
大部分工程都不太可能完全自给自足，一般你都会用到其他工程的文件。比如我工程需要 Hibernate 就得把它的类库加进来，比如测试的时候可能需要某些额外 jar 包，例如 JDBC 驱动或 Ehcache 之类的 Jar 包。
这些文件就是工程的依赖。Gradle 需要你告诉它工程的依赖是什么，它们在哪，然后帮你加入构建中。依赖可能需要去远程库下载，比如 Maven 或者 Ivy 库。也可以是本地库，甚至可能是另一个工程。我们称这个过程叫依赖解决。
通常，依赖的自身也有依赖。例如，Hibernate 核心类库就依赖于一些其他的类库。所以，当 Gradle 构建你的工程时，会去找到这些依赖。我们称之为依赖传递。
大部分工程构建的主要目的是脱离工程使用。例如，生成 jar 包，包括源代码、文档等，然后发布出去。
这些输出的文件构成了项目的发布内容。Gralde 也会为你分担这些工作。你声明了发布到到哪，Gradle 就会发布到哪。“发布”的意思就是你想做什么。比如，复制到某个目录，上传到 Maven 或 Ivy 仓库。或者在其它项目里使用，这些都可以称之为发行。
依赖声明 来看一下这个脚本里声明依赖的部分：
声明依赖 build.gradle
1apply plugin: &amp;#39;java&amp;#39; 2repositories { 3 mavenCentral() 4dependencies { 5 compile group: &amp;#39;org.hibernate&amp;#39;, name: &amp;#39;hibernate-core&amp;#39;, version: &amp;#39;3.6.7.Final&amp;#39; 6 testCompile group: &amp;#39;junit&amp;#39;, name: &amp;#39;junit&amp;#39;, version: &amp;#39;4.+&amp;#39; 这是什么意思呢？这段脚本是这么个意思。首先，Hibernate-core.3.6.7.final.jar 这货是编译期必需的依赖。并且这货相关的依赖也会一并被加载进来，该段脚本同时还声明项目测试阶段需要 4.</description></item><item><title>七、Groovy 循环</title><link>https://www.shellio.cc/docs/java/groovy/7/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/groovy/7/</guid><description>到目前为止，我们已经看到已经按顺序方式一个接一个执行的语句。此外，在Groovy中提供了语句来改变程序逻辑中的控制流。然后将它们分类为我们将详细看到的控制语句的流程。
序号 语句和描述 1 while语句 while语句首先通过计算条件表达式（布尔值）来执行，如果结果为真，则执行while循环中的语句。
2 for语句 for语句用于遍历一组值。
3 for-in语句 for-in语句用于遍历一组值。
循环控制语句 序号 语句和描述 1 break语句 break语句用于改变循环和switch语句内的控制流。
2 continue语句 continue语句补充了break语句。它的使用仅限于while和for循环。</description></item><item><title>七、Hibernate 会话</title><link>https://www.shellio.cc/docs/java/hibernate/7/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/hibernate/7/</guid><description>会话 Session 用于获取与数据库的物理连接。 Session 对象是轻量级的，并且设计为在每次需要与数据库进行交互时被实例化。持久态对象被保存，并通过 Session 对象检索找回。
该Session 对象不应该长时间保持开放状态，因为它们通常不能保证线程安全，而应该根据需求被创建和销毁。Session 的主要功能是为映射实体类的实例提供创建，读取和删除操作。这些实例可能在给定时间点时存在于以下三种状态之一：
瞬时状态: 一种新的持久性实例，被 Hibernate 认为是瞬时的，它不与 Session 相关联，在数据库中没有与之关联的记录且无标识符值。 持久状态：可以将一个瞬时状态实例通过与一个 Session 关联的方式将其转化为持久状态实例。持久状态实例在数据库中没有与之关联的记录，有标识符值，并与一个 Session 关联。 脱管状态：一旦关闭 Hibernate Session，持久状态实例将会成为脱管状态实例。 若Session 实例的持久态类别是序列化的，则该 Session 实例是序列化的。一个典型的事务应该使用以下语法：
1Session session = factory.openSession(); 2Transaction tx = null; 3try { 4 tx = session.beginTransaction(); 5 // do some work 6 ... 7 tx.commit(); 8catch (Exception e) { 9 if (tx!=null) tx.rollback(); 10 e.printStackTrace(); 11}finally { 12 session.close(); 如果Session 引发异常，则事务必须被回滚，该 session 必须被丢弃。
Session 接口方法 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 Session 接口提供了很多方法，但在以下讲解中我将仅列出几个我们会在本教程中应用的重要方法。您可以查看 Hibernate 文件，查询与 Session 及 SessionFactory 相关的完整方法目录。</description></item><item><title>七、Java 8 Lambda 表达式 （ 中 ）- 外部参数</title><link>https://www.shellio.cc/docs/java/java8/7/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/java8/7/</guid><description>在Java 8 Lambda 表达式 （ 上 ）- 简介 章节中我们讲解了 Java 8 Lambda 表达式的一些基础知识。我们也了解 Java 8 Lambda 表达式的一些使用场景：
Java Lambda 表达式主要用于定义函数接口的内联实现。而函数接口，就是只包含了一个方法的接口。在前一章节中，我们使用了各种类型的 lambda 表达式来定义 MathOperation 接口的 operation 方法。 Java Lambda 表达式消除了对 匿名类 的需求，并为 Java 提供了非常简单但功能强大的函数编程功能。 Java 8 Lambda 表达式作用域 ( scope ) 因为Java 8 的 lambda 表达式其实是函数接口的内联实现，也就是匿名内部类，因此，可以引用任何外部的变量或者常量。
但是，lambda 对这些外部的变量是有要求的： 它们必须使用 final 修饰符修饰。
如果一个变量允许被第二次赋值，则 Lambda 表达式会抛出编译错误。
注意： 其实这条规则并不是非常严格执行的，普通变量也是可以的，只要，只要不进行第二次赋值就可以。
注意： 刚刚测试了下，其实只要不是当前作用域声明的变量，可以随意第二次赋值，也不会报错
范例一 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 Java 8 lambda 表达式使用外部 final 变量
LambdaTester.java 1public class LambdaTester 2 final static String salutation = &amp;#34;你好，&amp;#34;; 3 public static void main(String args[]) 4 { 5 GreetingService greetService1 = message -&amp;gt; 6 System.</description></item><item><title>七、Java 9 新特性 – 多版本共存 JAR</title><link>https://www.shellio.cc/docs/java/java9/7/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/java9/7/</guid><description>Java 9 之前的 JAR 格式中只能包含一个 Java 版本，显然，这是不符合 Java 这种开启了版本帝的发展线路了，想想，现在大多数 Java 还停留在 Java 6 7 8 的年代，Java 10 已经发布，如果要发布一个 JAR 格式的类库，意味着要编译多个版本的 JAR， 6 7 8 9 10 五个版本，看起来也太恐怖了。
Java 9 突然间良心发现，开始支持多版本共存的 JAR 了。
Java 9 引入了一个新的功能，其实也不算吧，就是增强了 JAR 格式，可以在同一个 JAR 中维护和使用不同版本的 java 类或资源
JAR 多版本共存原理 首先在JAR 中，文件 MANIFEST.MF 文件的 main 节中有一个条目 Multi-Release:true ， 用于指定该 JAR 包是多 Java 版本共存的
同时，JAR 目录下的子目录 META-INF 还包含一个 versions 子目录，其子目录 ( 从 9 开始，用于 Java 9 ) 存储特定于版本的类和资源文件</description></item><item><title>七、JSP 指令</title><link>https://www.shellio.cc/docs/java/jsp/7/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/jsp/7/</guid><description>JSP 指令 JSP指令用来设置整个JSP页面相关的属性，如网页的编码方式和脚本语言。
语法格式如下：
1&amp;lt;%@ directive attribute=&amp;#34;value&amp;#34; %&amp;gt; 指令可以有很多个属性，它们以键值对的形式存在，并用逗号隔开。
JSP中的三种指令标签：
指令 描述 &amp;lt;%@ page … %&amp;gt; 定义网页依赖属性，比如脚本语言、error页面、缓存需求等等 &amp;lt;%@ include … %&amp;gt; 包含其他文件 &amp;lt;%@ taglib … %&amp;gt; 引入标签库的定义 Page指令 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 Page指令为容器提供当前页面的使用说明。一个JSP页面可以包含多个page指令。
Page指令的语法格式：
1&amp;lt;%@ page attribute=&amp;#34;value&amp;#34; %&amp;gt; 等价的XML格式：
1&amp;lt;jsp:directive.page attribute=&amp;#34;value&amp;#34; /&amp;gt; 属性 下表列出与Page指令相关的属性：
属性 描述 buffer 指定out对象使用缓冲区的大小 autoFlush 控制out对象的&amp;nbsp;缓存区 contentType 指定当前JSP页面的MIME类型和字符编码 errorPage 指定当JSP页面发生异常时需要转向的错误处理页面 isErrorPage 指定当前页面是否可以作为另一个JSP页面的错误处理页面 extends 指定servlet从哪一个类继承 import 导入要使用的Java类 info 定义JSP页面的描述信息 isThreadSafe 指定对JSP页面的访问是否为线程安全 language 定义JSP页面所用的脚本语言，默认是Java session 指定JSP页面是否使用session isELIgnored 指定是否执行EL表达式 isScriptingEnabled 确定脚本元素能否被使用 Include指令 JSP可以通过include指令来包含其他文件。被包含的文件可以是JSP文件、HTML文件或文本文件。包含的文件就好像是该JSP文件的一部分，会被同时编译执行。</description></item><item><title>七、JUnit – 使用断言</title><link>https://www.shellio.cc/docs/java/junit/7/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/junit/7/</guid><description>JUnit – 使用断言 断言 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 所有的断言都包含在 Assert 类中
1public class Assert extends java.lang.Object 这个类提供了很多有用的断言方法来编写测试用例。只有失败的断言才会被记录。Assert 类中的一些有用的方法列式如下：
序号 方法和描述 1 void assertEquals(boolean expected, boolean actual)
检查两个变量或者等式是否平衡 2 void assertTrue(boolean expected, boolean actual)
检查条件为真 3 void assertFalse(boolean condition)
检查条件为假 4 void assertNotNull(Object object)
检查对象不为空 5 void assertNull(Object object)
检查对象为空 6 void assertSame(boolean condition)
assertSame() 方法检查两个相关对象是否指向同一个对象 7 void assertNotSame(boolean condition)
assertNotSame() 方法检查两个相关对象是否不指向同一个对象 8 void assertArrayEquals(expectedArray, resultArray)
assertArrayEquals() 方法检查两个数组是否相等 下面我们在例子中试验一下上面提到的各种方法。在 C:\ &amp;gt; JUNIT_WORKSPACE 路径下创建一个文件名为 TestAssertions.</description></item><item><title>七、Maven 插件</title><link>https://www.shellio.cc/docs/java/maven/7/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/maven/7/</guid><description>Maven – 插件 什么是 Maven 插件？ 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 Maven 实际上是一个依赖插件执行的框架，每个任务实际上是由插件完成。Maven 插件通常被用来：
创建 jar 文件 创建 war 文件 编译代码文件 代码单元测试 创建工程文档 创建工程报告 插件通常提供了一个目标的集合，并且可以使用下面的语法执行：
1mvn [plugin-name]:[goal-name] 例如，一个 Java 工程可以使用 maven-compiler-plugin 的 compile-goal 编译，使用以下命令：
1mvn compiler:compile 插件类型 Maven 提供了下面两种类型的插件：
类型 描述 Build plugins 在构建时执行，并在 pom.xml 的 元素中配置。 Reporting plugins 在网站生成过程中执行，并在 pom.xml 的 元素中配置。 下面是一些常用插件的列表：
插件 描述 clean 构建之后清理目标文件。删除目标目录。 compiler 编译 Java 源文件。 surefile 运行 JUnit 单元测试。创建测试报告。 jar 从当前工程中构建 JAR 文件。 war 从当前工程中构建 WAR 文件。 javadoc 为工程生成 Javadoc。 antrun 从构建过程的任意一个阶段中运行一个 ant 任务的集合。 例子 我们已经在我们的例子中大量使用了 maven-antrun-plugin 来输出数据到控制台上。请查看 Maven – 构建配置文件 章节。让我们用一种更好的方式理解这部分内容，在 C:\MVN\project 目录下创建一个 pom.</description></item><item><title>七、Memcached add 命令</title><link>https://www.shellio.cc/docs/java/memcached/7/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/memcached/7/</guid><description>Memcached add 命令用于将 value(数据值) 存储在指定的 key(键) 中
语法 1add key flags exptime bytes [noreply] 2value 参数说明 key ： 键值 key-value 结构中的 key flags ：可以包括键值对的整型参数，客户机使用它存储关于键值对的额外信息 exptime ：在缓存中保存键值对的时间长度（以秒为单位，0 表示永远） bytes ：在缓存中存储的字节数 noreply ：可选，该参数告知服务器不需要返回数据 value ：存储的值（始终位于第二行）（可直接理解为key-value结构中的value） 返回值说明 如果数据添加成功，返回 STORED 如果 key 已经存在，且没过期，则不会更新数据，返回值为 NOT_STORED 如果 key 已经存在，但已经过期，那么替换成功，返回值为 STORED 如果执行错误，返回 CLIENT_ERROR 范例 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 1. 如果数据添加成功，返回 STORED 1add site 0 1000 11 2ddkk.com 3STORED 2. 如果 key 已经存在，且没过期 如果key 已经存在，且没过期，则不会更新数据，返回值为 NOT_STORED
1flush_all 2OK 3add site 0 1000 11 4ddkk.</description></item><item><title>七十、11.2 架构</title><link>https://www.shellio.cc/docs/java/jfinal/70/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/jfinal/70/</guid><description>JFinal 顶层架构图如下：
未完待续 ……
JFinal 官方网站：http://www.jfinal.com JFinal 官方 QQ 群: 322076903、432462639</description></item><item><title>三、0.2 JFinal相关生成文件</title><link>https://www.shellio.cc/docs/java/jfinal/3/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/jfinal/3/</guid><description>BaseModel是用于被最终的 Model 继承的基类，所有的 getter、setter方法都将生成在此文 件内，这样就保障了最终 Model 的清爽与干净，BaseModel不需要人工维护，在数据库有任何 变化时重新生成一次即可。
MappingKit用于生成table 到 Model 的映射关系，并且会生成主键/复合主键的配置，也即 在 JFinal 2.1 中无需在 configPlugin(Plugins me)方法中书写任何样板式的映射代码。
DataDictionary 是指生成的数据字典，会生成数据表所有字段的名称、类型、长度、备注、是否主键等信息。</description></item><item><title>三、Eclipse JSP-Servlet 环境搭建</title><link>https://www.shellio.cc/docs/java/jsp/3/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/jsp/3/</guid><description>Eclipse JSP/Servlet 环境搭建 本文假定你已安装了 JDK 环境，如未安装，可参阅 Java 开发环境配置 。
我们可以使用 Eclipse 来搭建 JSP 开发环境，首先我们分别下载一下软件包：
Eclipse J2EE：http://www.eclipse.org/downloads/ Tomcat：http://tomcat.apache.org/download-70.cgi Tomcat 下载安装 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 你可以根据你的系统下载对应的包(以下以Window系统为例)：
下载之后，将压缩包解压到D盘（你可以自己选择）：
注意目录名不能有中文和空格。目录介绍如下：
bin：二进制执行文件。里面最常用的文件是startup.bat，如果是 Linux 或 Mac 系统启动文件为 startup.sh。 conf:配置目录。里面最核心的文件是server.xml。可以在里面改端口号等。默认端口号是8080，也就是说，此端口号不能被其他应用程序占用。 lib：库文件。tomcat运行时需要的jar包所在的目录 logs：日志 temp：临时产生的文件，即缓存 webapps：web的应用程序。web应用放置到此目录下浏览器可以直接访问 work：编译以后的class文件。 接着我们可以双击 startup.bat 启动 Tomcat，弹出如下界面：
这个时候，本地的服务器就已经搭建起来了。如果想关闭服务器，可以直接关闭上面的窗口，或者在里面输入Ctrl+C禁止服务。
接着我们在浏览器中输入 http://localhost:8080/，如果弹出如下界面，表示tomcat安装成功并且启动起来了：
我们现在在浏览器上测试一下它吧：
首先在D:\apache-tomcat-8.0.14\webapps\ROOT目录中新建一个jsp文件：
test.jsp 文件代码如下：
1&amp;lt;%@ page contentType=&amp;#34;text/html;charset=UTF-8&amp;#34; %&amp;gt; 2&amp;lt;% 3out.print(&amp;#34;w3cschool教程 : http://www.w3cschool.cn&amp;#34;); 4%&amp;gt; 接着在浏览器中访问地址 http://localhost:8080/test.jsp, 输出结果如下：
将 Tomcat 和 Eclipse 相关联 Eclipse J2EE下载后，解压即可使用，我们打开Java EE ，选择菜单栏Windows–&amp;gt;preferences（Mac 系统为 Eclipse–&amp;gt;偏好设置），弹出如下界面：</description></item><item><title>三、Gradle 安装</title><link>https://www.shellio.cc/docs/java/gradle/3/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/gradle/3/</guid><description>安装 先决条件 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 Gradle 需要 1.5 或更高版本的 JDK.Gradle 自带了 Groovy 库，所以不需要安装 Groovy。Gradle 会忽略已经安装的 Groovy。Gradle 会使用 ptah (这里的”path”应该是指 PATH 环境变量。[Rover12421]译注) 中的 JDK(可以使用 java -version 检查)。当然，你可以配置 JAVA_HOME 环境变量来指向 JDK 的安装目录。
下载 从Gralde 官方网站下载 Gradle 的最新发行包。
解压 Gradle 发行包是一个 ZIP 文件。完整的发行包包括以下内容(官方发行包有 full 完整版，也有不带源码和文档的版本，可根据需求下载。[Rover12421]译注):
Gradle 可执行文件 用户手册 (有 PDF 和 HTML 两种版本) DSL 参考指南 API 手册(Javadoc 和 Groovydoc) 样例，包括用户手册中的例子，一些完整的构建样例和更加复杂的构建脚本 源代码。仅供参考使用,如果你想要自己来编译 Gradle 你需要从源代码仓库中检出发行版本源码，具体请查看 Gradle 官方主页。 配置环境变量 运行gradle 必须将 GRADLE_HOME/bin 加入到你的 PATH 环境变量中。
测试安装 运行如下命令来检查是否安装成功.该命令会显示当前的 JVM 版本和 Gradle 版本。</description></item><item><title>三、Groovy 基本语法</title><link>https://www.shellio.cc/docs/java/groovy/3/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/groovy/3/</guid><description>为了了解Groovy的基本语法，让我们先看看一个简单的Hello World程序。
创建你的第一个Hello World程序 创建Hello World程序，你只要输入以下几行简单的代码就可实现 –
1class Example { 2 static void main(String[] args) { 3 // Using a simple println statement to print output to the console 4 println(&amp;#39;Hello World&amp;#39;); 5 } 当我们运行上面的程序，我们会得到以下结果 –
1Hello World 在Groovy中导入语句 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 import语句可以用来导入，可以在你的代码可以使用其他库的功能。这是通过使用在 Import 关键字完成。
下面的示例演示了如何使用MarkupBuilder的类，它可能是最常用的创建HTML或XML标记的类之一。
1import groovy.xml.MarkupBuilder 2def xml = new MarkupBuilder() 默认情况下，Groovy在代码中包括以下库，因此您不需要显式导入它们。
1import java.lang.* 2import java.util.* 3import java.io.* 4import java.net.* 5import groovy.lang.* 6import groovy.util.* 7import java.math.BigInteger 8import java.math.BigDecimal Groovy令牌 令牌可以是一个关键字，一个标识符，常量，字符串文字或符号。</description></item><item><title>三、Hibernate 简介</title><link>https://www.shellio.cc/docs/java/hibernate/3/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/hibernate/3/</guid><description>简介 Hibernate 是由 Gavin King 于 2001 年创建的开放源代码的对象关系框架。它强大且高效的构建具有关系对象持久性和查询服务的 Java 应用程序。
Hibernate 将 Java 类映射到数据库表中，从 Java 数据类型中映射到 SQL 数据类型中，并把开发人员从 95% 的公共数据持续性编程工作中解放出来。
Hibernate 是传统 Java 对象和数据库服务器之间的桥梁，用来处理基于 O/R 映射机制和模式的那些对象。
Hibernate 优势 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 Hibernate 使用 XML 文件来处理映射 Java 类别到数据库表格中，并且不用编写任何代码。 为在数据库中直接储存和检索 Java 对象提供简单的 APIs。 如果在数据库中或任何其它表格中出现变化，那么仅需要改变 XML 文件属性。 抽象不熟悉的 SQL 类型，并为我们提供工作中所熟悉的 Java 对象。 Hibernate 不需要应用程序服务器来操作。 操控你数据库中对象复杂的关联。 最小化与访问数据库的智能提取策略。 提供简单的数据询问。 支持的数据库 Hibernate 支持几乎所有的主要 RDBMS。以下是一些由 Hibernate 所支持的数据库引擎。
HSQL Database Engine DB2/NT MySQL PostgreSQL FrontBase Oracle Microsoft SQL Server Database Sybase SQL Server Informix Dynamic Server 支持的技术 Hibernate 支持多种多样的其它技术，包括以下：</description></item><item><title>三、Java 9 新特性 – 环境配置</title><link>https://www.shellio.cc/docs/java/java9/3/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/java9/3/</guid><description>Java 9 的环境安装和配置其实很简单，因为跟 Java 7 / Java 8 的安装差不多，我们就不做过多的介绍了。
相关的安装教程，可以参考我们的 Java 基础教程：Java 开发环境配置
因为Java 当前的最新大版本为 Java 10 ，所以，我们建议你安装 Java 10 ，它同时也包含了 Java 9 的新特性
编辑器 顺便说一下，我们接下来的教程不会使用大型的 IDE ，比如 Idea 和 Netbeans 和 Eclipse 等，而只会使用一些较小的文本编辑器，比如 Sublime Text 3 和 Visual Studio Code
关于这些文本编辑器，网上的使用教程很多，其实，下载安装就好，没啥大的配置。
项目 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 既然不使用大型的、功能齐全的 IDE ，那么我们也不会建立大型的项目工程，一般情况下，我们直接单个文件解决所有问题，这样方便大家理解，也不会造成部分文件或代码缺失的问题。</description></item><item><title>三、Java8 Collectors.joining() 详解</title><link>https://www.shellio.cc/docs/java/java8/3/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/java8/3/</guid><description>本章节我们来详细讲讲 Java 8 流 ( stream ) 收集器 ( Collectors ) 中的 joining() 方法。该方法会返回一个 Collectors 实例，方便在流收集器上的链式操作。
Collectors.joining() 方法以遭遇元素的顺序拼接元素。我们可以传递可选的拼接字符串、前缀和后缀
joinning() 方法定义 假设我们的流中有四个元素 [&amp;quot;A&amp;quot;,&amp;quot;B&amp;quot;,&amp;quot;C&amp;quot;,&amp;quot;D&amp;quot;]，那么我们就可以按照以下方式来收集它们
joining() joinning() 无参数方法会返回一个 Collectors 实例，并且以空字符串 ( &amp;quot;&amp;quot; ) 来拼接收集到的所有元素
JoiningExample.java 1package com.ddkk.util.stream; 2import java.util.Arrays; 3import java.util.List; 4import java.util.stream.Collectors; 5public class JoiningExample { 6 public static void main(String[] args) { 7 List&amp;lt;String&amp;gt; list = Arrays.asList(&amp;#34;A&amp;#34;,&amp;#34;B&amp;#34;,&amp;#34;C&amp;#34;,&amp;#34;D&amp;#34;); 8 String result= list.stream().collect(Collectors.joining()); 9 System.out.println(result); 10 } 输出结果为 ABCD
joining(CharSequence delimiter) 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 joining(CharSequence delimiter) 接受一个参数字符串序列作为拼接符，并返回一个 Collectors 实例。假如我们传递的拼接符为 &amp;quot;-&amp;quot; 。那么输出结果为 A-B-C-D</description></item><item><title>三、JUnit – 测试框架</title><link>https://www.shellio.cc/docs/java/junit/3/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/junit/3/</guid><description>JUnit – 测试框架 什么是 Junit 测试框架？ 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 JUnit 是一个回归测试框架，被开发者用于实施对应用程序的单元测试，加快程序编制速度，同时提高编码的质量。JUnit 测试框架能够轻松完成以下任意两种结合：
Eclipse 集成开发环境 Ant 打包工具 Maven 项目构建管理 特性 JUnit 测试框架具有以下重要特性：
测试工具 测试套件 测试运行器 测试分类 测试工具 测试工具是一整套固定的工具用于基线测试。测试工具的目的是为了确保测试能够在共享且固定的环境中运行，因此保证测试结果的可重复性。它包括：
在所有测试调用指令发起前的 setUp() 方法。 在测试方法运行后的 tearDown() 方法。 让我们来看一个例子：
1import junit.framework.*; 2public class JavaTest extends TestCase { 3 protected int value1, value2; 4 // assigning the values 5 protected void setUp(){ 6 value1=3; 7 value2=3; 8 } 9 // test method to add two values 10 public void testAdd(){ 11 double result= value1 + value2; 12 assertTrue(result == 6); 13 } 测试套件 测试套件意味捆绑几个测试案例并且同时运行。在 JUnit 中，@RunWith 和 @Suite 都被用作运行测试套件。以下为使用 TestJunit1 和 TestJunit2 的测试分类：</description></item><item><title>三、Maven POM</title><link>https://www.shellio.cc/docs/java/maven/3/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/maven/3/</guid><description>Maven – POM POM代表工程对象模型。它是使用 Maven 工作时的基本组建，是一个 xml 文件。它被放在工程根目录下，文件命名为 pom.xml。
POM包含了关于工程和各种配置细节的信息，Maven 使用这些信息构建工程。
POM也包含了目标和插件。当执行一个任务或者目标时，Maven 会查找当前目录下的 POM，从其中读取所需要的配置信息，然后执行目标。能够在 POM 中设置的一些配置如下：
project dependencies plugins goals build profiles project version developers mailing list 在创建POM 之前，我们首先确定工程组（groupId），及其名称（artifactId）和版本，在仓库中这些属性是工程的唯一标识。
POM 举例 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 1&amp;lt;project xmlns=&amp;#34;http://maven.apache.org/POM/4.0.0&amp;#34; 2 xmlns:xsi=&amp;#34;http://www.w3.org/2001/XMLSchema-instance&amp;#34; 3 xsi:schemaLocation=&amp;#34;http://maven.apache.org/POM/4.0.0 4 http://maven.apache.org/xsd/maven-4.0.0.xsd&amp;#34;&amp;gt; 5 &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt; 6 &amp;lt;groupId&amp;gt;com.companyname.project-group&amp;lt;/groupId&amp;gt; 7 &amp;lt;artifactId&amp;gt;project&amp;lt;/artifactId&amp;gt; 8 &amp;lt;version&amp;gt;1.0&amp;lt;/version&amp;gt; 9&amp;lt;/project&amp;gt; 需要说明的是每个工程应该只有一个 POM 文件。
所有的 POM 文件需要 project 元素和三个必须的字段：groupId, artifactId,version。 在仓库中的工程标识为 groupId:artifactId:version POM.xml 的根元素是 project，它有三个主要的子节点： 节点 描述 groupId 这是工程组的标识。它在一个组织或者项目中通常是唯一的。例如，一个银行组织 com.company.bank 拥有所有的和银行相关的项目。 artifactId 这是工程的标识。它通常是工程的名称。例如，消费者银行。groupId 和 artifactId 一起定义了 artifact 在仓库中的位置。 version 这是工程的版本号。在 artifact 的仓库中，它用来区分不同的版本。例如：</description></item><item><title>三、Window 下安装 Memcached</title><link>https://www.shellio.cc/docs/java/memcached/3/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/memcached/3/</guid><description>Memcached 官网上并未提供 Memcached 的 Window 平台安装包
但已经有热心的网友自己编译了一些 Window 平台的包供大家使用
本站再此列出了大部分版本的下载连接，你需要根据自己的系统平台及需要的版本号点击对应的链接下载即可：
再此感谢下载连接的网站和贡献这些 window 安装包的朋友
在 1.4.5 版本以前 memcached 可以作为一个服务安装 推荐 32位系统 1.4.4版本
http://downloads.northscale.com/memcached-win32-1.4.4-14.zip
64位系统 1.4.4版本：
http://downloads.northscale.com/memcached-win64-1.4.4-14.zip
1.4.5 及之后的版本删除了作为一个服务安装的功能 32位系统 1.4.5版本
http://downloads.northscale.com/memcached-1.4.5-x86.zip
64位系统 1.4.5版本
http://downloads.northscale.com/memcached-1.4.5-amd64.zip
重要1.4.4 和 1.4.5 版本功能上没有多大的区别，如果你为了省事方便，可以下载 1.4.4 的版本
Memcached &amp;lt;1.4.5 版本安装步骤 1、 解压下载的安装包到指定目录，比如d:\dev\memcached；
2、 在1.4.5版本以前memcached可以作为一个服务安装，使用管理员权限运行以下命令：；
1d:\dev\memcached\memcached.exe -d install 注意： 你需要使用真实的 memcached.exe 路径 替代 d:\dev\memcached\memcached.exe
3、 然后我们用以下命令来启动和关闭memcached服务：；
开启Memcached 服务
1d:\dev\memcached\memcached.exe -d start 关闭Memcached 服务
1d:\dev\memcached\memcached.exe -d stop 4、 如果要修改Memcached的配置项,可以在命令行中执行；
1regedit.exe 命令打开注册表并找到 HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\memcached 来进行修改</description></item><item><title>三十、4.1 概述</title><link>https://www.shellio.cc/docs/java/jfinal/30/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/jfinal/30/</guid><description>传统AOP 实现需要引入大量繁杂而多余的概念，例如：Aspect、Advice、Joinpoint、Poincut、 Introduction、Weaving、Around 等等，并且需要引入 IOC 容器并配合大量的 XML 或者 annotation 来进行组件装配。
传统AOP 不但学习成本极高，开发效率极低，开发体验极差，而且还影响系统性能，尤 其是在开发阶段造成项目启动缓慢，极大影响开发效率。
JFinal 采用极速化的 AOP 设计，专注 AOP 最核心的目标，将概念减少到极致，仅有三个 概念：Interceptor、Before、Clear，并且无需引入 IOC 也无需使用繁杂的 XML。</description></item><item><title>三十、Gradle FindBugs 插件</title><link>https://www.shellio.cc/docs/java/gradle/30/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/gradle/30/</guid><description>FindBugs 插件 FindBugs 插件使用 FindBugs 对项目的 Java 源文件执行质量检查，并从检查结果中生成报告。
用法 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 要使用FindBugs 插件，请在构建脚本中包含以下语句：
使用 FindBugs 插件
build.gradle
1apply plugin: &amp;#39;findbugs&amp;#39; 该插件向你的项目添加了大量的执行质量检查的任务。你可以通过运行 gradle check 执行检查。
任务 FindBugs 插件向 project 中添加了以下任务：
表31.1. FindBugs 插件 – 任务
任务名称 依赖于 类型 描述 findbugsMain classes findbugs 针对生产Java 源文件运行 FindBugs。 findbugsTest testClasses findbugs 针对测试 Java 源文件运行 FindBugs。 SourceSet sourceSetClasses findbugs 针对source set 的 Java 源文件运行 FindBugs。 FindBugs 插件向 Java 插件所加入的任务添加了以下的依赖。
表31.2. FindBugs 插件 – 附加的任务依赖
任务名称 依赖于 check 所有 FindBugs 任务，包括findbugsTest。 依赖管理 FindBugs 插件增加了下列的依赖配置：</description></item><item><title>三十、Groovy 构建器</title><link>https://www.shellio.cc/docs/java/groovy/30/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/groovy/30/</guid><description>在软件开发过程中，有时开发人员花费大量时间来创建数据结构，域类，XML，GUI布局，输出流等。有时用于创建这些特定需求的代码导致在许多地方重复相同的代码片段。这是Groovy的建设者发挥作用。Groovy有可以用来创建标准对象和结构的构建器。这些构建器节省了时间，因为开发人员不需要编写自己的代码来创建这些构建器。在本章的教程中，我们将看看groovy中可用的不同构建器。
# Swing 构建器 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 ##
在groovy中，还可以使用groovy中提供的swing构建器创建图形用户界面。开发swing组件的主要类是SwingBuilder类。这个类有许多方法创建图形组件，如 –
JFrame - 这是用于创建框架元素。 JTextField - 这用于创建textfield组件。 让我们看一个简单的例子，如何使用SwingBuilder类创建一个Swing应用程序。在以下示例中，您可以看到以下几点 –
您需要导入groovy.swing.SwingBuilder和javax.swing.*类。 在Swing应用程序中显示的所有组件都是SwingBuilder类的一部分。 对于框架本身，您可以指定框架的初始位置和大小。您还可以指定框架的标题。 您需要将Visibility属性设置为true才能显示框架。 1import groovy.swing.SwingBuilder 2import javax.swing.* 3// Create a builder 4def myapp = new SwingBuilder() 5// Compose the builder 6def myframe = myapp.frame(title : &amp;#39;Tutorials Point&amp;#39;, location : [200, 200], 7 size : [400, 300], defaultCloseOperation : WindowConstants.EXIT_ON_CLOSE { 8 label(text : &amp;#39;Hello world&amp;#39;) 9 } 10// The following statement is used for displaying the form 11frame.</description></item><item><title>三十、JSP 调试</title><link>https://www.shellio.cc/docs/java/jsp/30/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/jsp/30/</guid><description>JSP 调试 要测试/调试一个JSP或servlet程序总是那么的难。JSP和Servlets程序趋向于牵涉到大量客户端/服务器之间的交互，这很有可能会产生错误，并且很难重现出错的环境。
接下来将会给出一些小技巧和小建议，来帮助您调试程序。
使用System.out.println() 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 System.out.println()可以很方便地标记一段代码是否被执行。当然，我们也可以打印出各种各样的值。此外：
自从System对象成为Java核心对象后，它便可以使用在任何地方而不用引入额外的类。使用范围包括Servlets，JSP，RMI，EJB’s，Beans，类和独立应用。 与在断点处停止运行相比，用System.out进行输出不会对应用程序的运行流程造成重大的影响，这个特点在定时机制非常重要的应用程序中就显得非常有用了。 接下来给出了使用System.out.println()的语法：
1System.out.println(&amp;#34;Debugging message&amp;#34;); 这是一个使用System.out.print()的简单例子：
1&amp;lt;%@taglib prefix=&amp;#34;c&amp;#34; uri=&amp;#34;http://java.sun.com/jsp/jstl/core&amp;#34; %&amp;gt; 2&amp;lt;html&amp;gt; 3&amp;lt;head&amp;gt;&amp;lt;title&amp;gt;System.out.println&amp;lt;/title&amp;gt;&amp;lt;/head&amp;gt; 4&amp;lt;body&amp;gt; 5&amp;lt;c:forEach var=&amp;#34;counter&amp;#34; begin=&amp;#34;1&amp;#34; end=&amp;#34;10&amp;#34; step=&amp;#34;1&amp;#34; &amp;gt; 6 &amp;lt;c:out value=&amp;#34;${counter-5}&amp;#34;/&amp;gt;&amp;lt;/br&amp;gt; 7 &amp;lt;% System.out.println( &amp;#34;counter= &amp;#34; + pageContext.findAttribute(&amp;#34;counter&amp;#34;) ); %&amp;gt; 8&amp;lt;/c:forEach&amp;gt; 9&amp;lt;/body&amp;gt; 10&amp;lt;/html&amp;gt; 现在，如果运行上面的例子的话，它将会产生如下的结果：
1-4 2-3 3-2 4-1 如果使用的是Tomcat服务器，您就能够在logs目录下的stdout.log文件中发现多出了如下内容：
1counter=1 2counter=2 3counter=3 4counter=4 5counter=5 6counter=6 7counter=7 8counter=8 9counter=9 10counter=10 使用这种方法可以将变量和其它的信息输出至系统日志中，用来分析并找出造成问题的深层次原因。
使用JDB Logger J2SE日志框架可为任何运行在JVM中的类提供日志记录服务。因此我们可以利用这个框架来记录任何信息。
让我们来重写以上代码，使用JDK中的 logger API：
1&amp;lt;%@taglib prefix=&amp;#34;c&amp;#34; uri=&amp;#34;http://java.sun.com/jsp/jstl/core&amp;#34; %&amp;gt; 2&amp;lt;%@page import=&amp;#34;java.</description></item><item><title>三十八、5.2 ActiveRecordPlugin</title><link>https://www.shellio.cc/docs/java/jfinal/38/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/jfinal/38/</guid><description>ActiveRecord 是作为 JFinal 的 Plugin 而存在的，所以使用时需要在 JFinalConfig 中配置ActiveRecordPlugin。
以下是Plugin 配置示例代码：
public class DemoConfig extends JFinalConfig {
public void configPlugin(Plugins me) {
C3p0Plugin cp = new C3p0Plugin(“jdbc:mysql://localhost/db_name”, “userName”, “password”);
me.add(cp);
ActiveRecordPlugin arp = new ActiveRecordPlugin(cp); me.add(arp);
arp.addMapping(“user”, User. class); arp. addMapping(“article”, “article_id”, Article. class);
}
}
以上代码配置了两个插件：C3p0Plugin 与 ActiveRecordPlugin，前者是 c3p0 数据源插件， 后者是 ActiveRecrod 支持插件。ActiveReceord 中定义了 addMapping(String tableName, Class&amp;lt;? extends Model&amp;gt; modelClass&amp;gt;)方法，该方法建立了数据库表名到 Model 的映射关系。
另外，以上代码中 arp.addMapping(“user”, User.class)，表的主键名为默认为“id”，如果主 键名称为 “user_id”则需要手动指定，如：arp.addMapping(“user”, “user_id”, User.class)。</description></item><item><title>三十二、4.3 Before</title><link>https://www.shellio.cc/docs/java/jfinal/32/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/jfinal/32/</guid><description>Before 注解用来对拦截器进行配置，该注解可配置 Class、Method 级别的拦截器，以下是 代码示例：
如上代码所示，Before 可以将拦截器配置为 Class 级别与 Method 级别，前者将拦截本类 中所有方法，后者仅拦截本方法。此外 Before 可以同时配置多个拦截器，只需用在大括号内 用逗号将多个拦截器进行分隔即可。
除了Class 与 Method 级别的拦截器以外，JFinal 还支持全局拦截器以及 Inject 拦截器（Inject
拦截将在后面介绍），全局拦截器分为控制层全局拦截器与业务层全局拦截器，前者拦截控制 层所有 Action 方法，后者拦截业务层所有方法。
全局拦截器需要在 YourJFinalConfig 进行配置，以下是配置示例：
1public class AppConfig extends JFinalConfig { 2 public void configInterceptor(Interceptors me) { 3 // 添加控制层全局拦截器 4 me.addGlobalActionInterceptor(new GlobalActionInterceptor()); 5 // 添加业务层全局拦截器 6 me.addGlobalServiceInterceptor(new GlobalServiceInterceptor()); 7 // 为兼容老版本保留的方法，功能与addGlobalActionInterceptor完全一样 8 me.add(new GlobalActionInterceptor()); 9 } 当某个Method 被多个级别的拦截器所拦截，拦截器各级别执行的次序依次为：Global、 Inject、Class、Method，如果同级中有多个拦截器，那么同级中的执行次序是：配置在前面的 先执行。</description></item><item><title>三十二、Gradle PMD 插件</title><link>https://www.shellio.cc/docs/java/gradle/32/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/gradle/32/</guid><description>PMD 插件 PMD插件使用 PMD 对项目的 Java 源文件执行质量检查，并从检查结果中生成报告。
用法 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 要使用PMD 插件，请在构建脚本中包含以下语句：
使用 PMD 插件
build.gradle
1apply plugin: &amp;#39;pmd&amp;#39; 该插件向你的项目添加了大量的执行质量检查的任务。你可以通过运行 gradle check 执行检查。
任务 PMD插件向 project 中添加了以下任务：
表33.1. PMD 插件 – 任务
任务名称 依赖于 类型 描述 pmdMain – pmd 针对生产Java 源文件运行 PMD。 pmdTest – pmd 针对测试 Java 源文件运行 PMD。 SourceSet – pmd 针对source set 的 Java 源文件运行 PMD。 PMD插件向 Java 插件所加入的任务添加了以下的依赖。
表33.2. PMD 插件 – 附加的任务依赖
任务名称 依赖于 check 所有的 PMD 任务，包括pmdTest。 依赖管理 PMD插件添加了下列的依赖配置：</description></item><item><title>三十二、Groovy 单元测试</title><link>https://www.shellio.cc/docs/java/groovy/32/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/groovy/32/</guid><description>面向对象系统的基本单元是类。因此单元测试由一个类中的testig组成。所采用的方法是创建被测试类的对象，并使用它来检查所选方法是否按预期执行。不是每个方法都可以测试，因为并不总是测试每一件事情。但是应该对关键和关键方法进行单元测试。
JUnit是一个开源测试框架，是Java代码自动化单元测试的公认行业标准。幸运的是，JUnit框架可以很容易地用于测试Groovy类。所需要的只是扩展作为标准Groovy环境一部分的GroovyTestCase类。 Groovy测试用例类基于Junit测试用例。
编写一个简单的Junit测试用例 假设我们在应用程序类文件中定义了以下类：
1class Example { 2 static void main(String[] args) { 3 Student mst = new Student(); 4 mst.name = &amp;#34;Joe&amp;#34;; 5 mst.ID = 1; 6 println(mst.Display()) 7 } 8} 9public class Student { 10 String name; 11 int ID; 12 String Display() { 13 return name +ID; 14 } 低于上述程序的输出中给出。
1Joe1 现在假设我们想为Student类写一个测试用例。典型的测试用例如下所示。以下几点需要注意以下代码 –
测试用例类扩展了GroovyTestCase类 我们使用assert语句来确保Display方法返回正确的字符串。 1class StudentTest extends GroovyTestCase { 2 void testDisplay() { 3 def stud = new Student(name : &amp;#39;Joe&amp;#39;, ID : &amp;#39;1&amp;#39;) 4 def expected = &amp;#39;Joe1&amp;#39; 5 assertToString(stud.</description></item><item><title>三十九、5.3 Model</title><link>https://www.shellio.cc/docs/java/jfinal/39/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/jfinal/39/</guid><description>Model 是 ActiveRecord 中最重要的组件之一，它充当 MVC 模式中的 Model 部分。以下是
Model 定义示例代码：
public class User extends Model {
public static final User dao = new User();
}
以上代码中的 User 通过继承 Model，便立即拥有的众多方便的操作数据库的方法。在 User 中声明的 dao 静态对象是为了方便查询操作而定义的，该对象并不是必须的。基于 ActiveRecord 的 Model 无需定义属性，无需定义 getter、setter 方法，无需 XML 配置，无需 Annotation 配置， 极大降低了代码量。
以下为Model 的一些常见用法：
// 创建name属性为James,age属性为25的User对象并添加到数据库
new User().set(“name”, “James”).set(“age”, 25).save();
// 删除id值为25的User User. dao.deleteById(25);
// 查询id值为25的User将其name属性改为James并更新到数据库
User. dao.findByIdLoadColumns (25).set(“name”, “James”).update();
// 查询id值为25的user, 且仅仅取name与age两个字段的值
User user = User. dao.findByIdLoadColumns (25, “name, age”);</description></item><item><title>三十六、4.7 Inject 拦截器</title><link>https://www.shellio.cc/docs/java/jfinal/36/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/jfinal/36/</guid><description>Inject 拦截器是指在使用 enhance 或 duang 方法增强时使用参数传入的拦截器。Inject 可以 对目标完全无侵入地应用 AOP。
假如需要增强的目标在 jar 包之中，无法使用 Before 注解对其配置拦截器，此时使用 Inject拦截器可以对 jar 包中的目标进行增强。如下是 Inject 拦截器示例：
1public void injectDemo() { 2 // 为enhance方法传入的拦截器称为Inject拦截器，下面代码中的Tx称为Inject拦截器 OrderService service = Enhancer.enhance(OrderService.class, Tx.class); service.payment(…); 如上代码中 Enhance.enhance()方法的第二个参数 Tx.class 被称之为 Inject 拦截器，使用此方法便可完全无侵入地对目标进行 AOP 增强。
Inject 拦截器与前面谈到的 Global、Class、Method 级别拦截器是同一层次上的概念。与 Class 级拦截器一样，Inject 拦截器将拦截被增强目标中的所有方法。Inject 拦截器可以被认为 就是 Class 级拦截器，只不过执行次序在 Class 级拦截器之前而已。</description></item><item><title>三十六、Gradle OSGi 插件</title><link>https://www.shellio.cc/docs/java/gradle/36/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/gradle/36/</guid><description>OSGi 插件 OSGi 插件提供了工厂方法来创建一个 OsgiManifest 对象。OsgiManifest 继承自 Manifest。如果应用了 Java 插件，OSGi 插件将把默认 jar 的 manifest 对象替换为一个 OsgiManifest 对象。被替换的 manifest 会被合并到新的对象单中。
OSGi 插件使 Peter Kriens BND tool 大量使用。
用法 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 要使用OSGi 插件，请在构建脚本中包含以下语句：
使用 OSGi 插件
build.gradle
1apply plugin: &amp;#39;osgi&amp;#39; 隐式应用插件 适用于Java 基础插件。
任务 此插件不会添加任何任务。
依赖管理 待决定
约定对象 OSGi 插件添加了下列约定对象： OsgiPluginConvention
约定属性 OSGi 插件没有向 project 添加任何的公约属性。
约定方法 OSGi 插件添加了以下方法。有关更多详细信息，请参见约定对象的 API 文档。
表37.1. OSGi 方法
方法 返回类型 描述 osgiManifest() OsgiManifest 返回一个 OsgiManifest 对象。 osgiManifest(Closure cl) OsgiManifest 返回一个通过闭包配置的 OsgiManifest 对象。 在classes 目录下的类文件会被分析出关于它们的包的依赖，以及它们所公布的包名。并基于此计算 OSGi Manifest 中 Import-Package 和 Export-Package 的值。如果 classpath 中包含了 jar 包和 OSGi bundle，bundle 信息会被用来指定 Import-Package 的值的版本信息。在 OsgiManifest 对象的显式属性旁边，你可以添加 instructions。</description></item><item><title>三十七、5.1 概述</title><link>https://www.shellio.cc/docs/java/jfinal/37/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/jfinal/37/</guid><description>ActiveRecord 是 JFinal 最核心的组成部分之一，通过 ActiveRecord 来操作数据库，将极大 地减少代码量，极大地提升开发效率。</description></item><item><title>三十三、4.4 Clear</title><link>https://www.shellio.cc/docs/java/jfinal/33/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/jfinal/33/</guid><description>拦截器从上到下依次分为 Global、Inject、Class、Method 四个层次，Clear 用于清除自身 所处层次以上层的拦截器。
Clear 声明在 Method 层时将针对 Global、Inject、Class 进行清除。Clear 声明在 Class 层时 将针对 Global、Inject 进行清除。Clear 注解携带参数时清除目标层中指定的拦截器。
Clear 用法记忆技巧： l共有 Global、Inject、Class、Method 四层拦截器
l清除只针对 Clear 本身所处层的向上所有层，本层与下层不清除
l不带参数时清除所有拦截器，带参时清除参数指定的拦截器
在某些应用场景之下，需要移除 Global 或 Class 拦截器。例如某个后台管理系统，配置了 一个全局的权限拦截器，但是其登录 action 就必须清除掉她，否则无法完成登录操作，以下是 代码示例：
1// login方法需要移除该权限拦截器才能正常登录 2@Before(AuthInterceptor.class) 3public class UserController extends Controller { 4 // AuthInterceptor 已被Clear清除掉，不会被其拦截 5 @Clear 6 public void login() { 7 } 8 // 此方法将被AuthInterceptor拦截 9 public void show() { 10 } Clear 注解带有参数时，能清除指定的拦截器，以下是一个更加全面的示例：</description></item><item><title>三十三、Gradle JaCoCo 插件</title><link>https://www.shellio.cc/docs/java/gradle/33/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/gradle/33/</guid><description>JaCoCo 插件 JaCoCo 插件目前还是孵化中状态。请务必注意，在以后的 Gradle 版本中，DSL 和其他配置可能会有所改变。
JaCoCo 插件通过集成 JaCoCo为 Java 代码提供了代码覆盖率指标。
入门 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 要想开始，请将 JaCoCo 插件应用于你想要计算代码覆盖率的项目中。
应用 JaCoCo 插件
build.gradle
1apply plugin: &amp;#34;jacoco&amp;#34; 如果Java 插件也被应用于你的项目，那么会创建一个名为 jacocoTestReport 的新任务，该新任务依赖于 test 任务。该报告可以在 $buildDir/reports/jacoco/test 中看到。默认情况下，会生成一个 HTML 报告。
配置 JaCoCo 插件 JaCoCo 插件添加一个名为 jacoco 类型为 JacocoPluginExtension 的 project 扩展，这个扩展允许在你的构建中配置 JaCoCo 所使用的默认值。
配置 JaCoCo 插件设置
build.gradle
1jacoco 2 toolVersion = &amp;#34;0.6.2.201302030002&amp;#34; 3 reportsDir = file(&amp;#34;$buildDir/customJacocoReportDir&amp;#34;) 4} 表34.1. JaCoCo 属性的 Gradle 默认值
Property Gradle 默认值 reportsDir “$buildDir/reports/jacoco” JaCoCo 报告配置 JacocoReport 任务可以用于生成不同格式的代码覆盖率报告。它实现了标准的 Gradle 类型 Reporting，并呈现了一个 JacocoReportsContainer 类型的报告容器。</description></item><item><title>三十三、Groovy 模板引擎</title><link>https://www.shellio.cc/docs/java/groovy/33/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/groovy/33/</guid><description>Groovy的模板引擎的操作方式类似于邮件合并（从数据库自动添加名称和地址到字母和信封，以便于将邮件，特别是广告发送到许多地址），但是它更加通用。
字符串中的简单模板 如果你采用下面的简单例子，我们首先定义一个名称变量来保存字符串“Groovy”。在println语句中，我们使用$符号来定义可以插入值的参数或模板。
1def name = &amp;#34;Groovy&amp;#34; 2println &amp;#34;This Tutorial is about ${name}&amp;#34; 如果上面的代码在groovy中执行，将显示以下输出。输出清楚地显示$名称被由def语句分配的值替换。
简单模板引擎 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 以下是SimpleTemplateEngine的示例，它允许您在模板中使用类似于JSP的scriptlet和EL表达式，以生成参数化文本。模板引擎允许绑定参数列表及其值，以便可以在具有定义的占位符的字符串中替换它们。
1def text =&amp;#39;This Tutorial focuses on $TutorialName. In this tutorial you will learn 2about $Topic&amp;#39; 3def binding = [&amp;#34;TutorialName&amp;#34;:&amp;#34;Groovy&amp;#34;, &amp;#34;Topic&amp;#34;:&amp;#34;Templates&amp;#34;] 4def engine = new groovy.text.SimpleTemplateEngine() 5def template = engine.createTemplate(text).make(binding) 6println template 如果上面的代码在groovy中执行，将显示以下输出。
现在让我们使用XML文件的模板功能。作为第一步，让我们将下面的代码添加到一个名为Student.template的文件中。在以下文件中，您将注意到，我们尚未添加元素的实际值，而是添加占位符。所以$ name，$ is和$ subject都被放置为占位符，需要在运行时替换。
1&amp;lt;Student&amp;gt; 2 &amp;lt;name&amp;gt;${name}&amp;lt;/name&amp;gt; 3 &amp;lt;ID&amp;gt;${id}&amp;lt;/ID&amp;gt; 4 &amp;lt;subject&amp;gt;${subject}&amp;lt;/subject&amp;gt; 5&amp;lt;/Student&amp;gt; 现在，让我们添加我们的Groovy脚本代码来添加功能，可以使用实际值替换上面的模板。应该注意以下事项关于以下代码。
占位符到实际值的映射通过绑定和SimpleTemplateEngine完成。绑定是一个映射，占位符作为键，替换值作为值。 1import groovy.text.* 2import java.io.* 3def file = new File(&amp;#34;D:/Student.</description></item><item><title>三十四、4.5 Interceptor 的触发</title><link>https://www.shellio.cc/docs/java/jfinal/34/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/jfinal/34/</guid><description>JFinal 中的 AOP 被划分为控制层 AOP 以及业务层 AOP，严格来说业务层 AOP 并非仅限 于在业务层使用，因为 JFinal AOP 可以应用于其它任何地方。
控制层拦截器的触发，只需发起 action 请求即可。业务层拦截器的触发需要先使用 enhance方法对目标对象进行增强，然后调用目标方法即可。以下是业务层 AOP 使用的例子：
1// 定义需要使用AOP的业务层类 2public class OrderService { 3 // 配置事务拦截器 4 @Before(Tx.class) 5 public void payment(int orderId, int userId) { 6 // service code here 7 } 8// 定义控制器，控制器提供了enhance系列方法可对目标进行AOP增强 9public class OrderController extends Controller { 10 public void payment() { 11 // 使用 enhance方法对业务层进行增强，使其具有AOP能力 OrderService service = enhance(OrderService.class); 12 // 调用payment方法时将会触发拦截器 13 service.</description></item><item><title>三十四、Gradle Sonar 插件</title><link>https://www.shellio.cc/docs/java/gradle/34/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/gradle/34/</guid><description>Sonar 插件 你可能会想使用新的 Sonar Runner 插件来代替现在这个插件。尤其是因为只有 Sonar Runner 插件支持 Sonar 3.4 及更高的版本。
Sonar 插件提供了对 Sonar，一个基于 web 的代码质量监测平台的集成。该插件添加了sonarAnalyze task ，用来分析一个 project 及子 project 都应用了哪个插件。分析结果存储于 Sonar 数据库中。该插件基于 Sonar Runner，并要求是 Sonar 2.11 或更高的版本。
SonarAnalyze task 是一项需要显式执行的独立任务，不依赖于任何其他 task。除了源代码之外，该 task 还分析了类文件和测试结果文件（如果有）。为获得最佳结果，建议在分析前运行一次完整的构建。在典型的设置中，会每天在构建服务器上运行一次分析。
用法 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 最低要求是必须配置 Sonar 插件应用于该 project。
配置使用 Sonar 插件
build.gradle
1apply plugin: &amp;#34;sonar&amp;#34; 除非Sonar 是在本地上运行，并且有默认的配置，否则有必要配置 Sonar 服务器及数据库的连接设置。
配置 Sonar 连接设置
build.gradle
1sonar 2 server { 3 url = &amp;#34;http://my.server.com&amp;#34; 4 } 5 database { 6 url = &amp;#34;jdbc:mysql://my.</description></item><item><title>三十四、Groovy 元对象编程</title><link>https://www.shellio.cc/docs/java/groovy/34/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/groovy/34/</guid><description>元对象编程或MOP可以用于动态调用方法，并且可以即时创建类和方法。
那么这是什么意思呢？让我们考虑一个叫Student的类，它是一个没有成员变量或方法的空类。假设你必须在这个类上调用以下语句。
1Def myStudent = new Student() 2myStudent.Name = ”Joe”; 3myStudent.Display() 现在在元对象编程中，即使类没有成员变量Name或方法Display（），上面的代码仍然可以工作。
这如何工作？那么，为了这个工作，一个人必须实现GroovyInterceptable接口挂钩到Groovy的执行过程。以下是该接口的可用方法。
1Public interface GroovyInterceptable { 2 Public object invokeMethod(String methodName, Object args) 3 Public object getproperty(String propertyName) 4 Public object setProperty(String propertyName, Object newValue) 5 Public MetaClass getMetaClass() 6 Public void setMetaClass(MetaClass metaClass) 所以在上面的接口描述中，假设你必须实现invokeMethod（），它会被调用的每个方法，要么存在或不存在。
缺失属性 所以，让我们看一个例子，我们如何为缺失的属性实现元对象编程。以下键应该注意以下代码。
类Student没有定义名为Name或ID的成员变量。 类Student实现GroovyInterceptable接口。 有一个称为dynamicProps的参数，将用于保存即时创建的成员变量的值。 方法getproperty和setproperty已被实现以在运行时获取和设置类的属性的值。 1class Example { 2 static void main(String[] args) { 3 Student mst = new Student(); 4 mst.Name = &amp;#34;Joe&amp;#34;; 5 mst.</description></item><item><title>三十五、4.6 Duang、Enhancer</title><link>https://www.shellio.cc/docs/java/jfinal/35/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/jfinal/35/</guid><description>Duang、Enhancer 用来对目标进行增强，让其拥有 AOP 的能力。以下是代码示例：
1public class TestMain{ 2 public void main(String[] args) { 3 // 使用Duang.duang方法在任何地方对目标进行增强 4 OrderService service = Duang.duang(OrderService.class); 5 // 调用payment方法时将会触发拦截器 6 service.payment(…); 7 // 使用Enhancer.enhance方法在任何地方对目标进行增强 8 OrderService service = Enhancer.enhance(OrderService.class); 9 } Duang.duang()、Enhancer.enhance()与 Controller.enhance()系方法在功能上完全一样，她们 除了支持类增强以外，还支持对象增强，例如 duang(new OrderService())以对象为参数的用法， 功能本质上是一样的，在此不再赘述。
使用Duang、Enhancer 类可以对任意目标在任何地方增强，所以 JFinal 的 AOP 可以应用 于非 web 项目，只需要引入 jfinal.jar 包，然后使用 Enhancer.enhance()或 Duang.duang()即可极 速使用 JFinal 的 AOP 功能。</description></item><item><title>三十五、Gradle Sonar Runner 插件</title><link>https://www.shellio.cc/docs/java/gradle/35/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/gradle/35/</guid><description>Sonar Runner 插件 Sonar runner 插件是目前仍是孵化状态。请务必注意，在以后的 Gradle 版本中，DSL 和其他配置可能会有所改变。
Sonar Runner 插件提供了对 Sonar，一个基于 web 的代码质量监测平台的集成。它基于 Sonar Runner，一个分析源代码及构建输出，并将所有收集的信息储存在 Sonar 数据库的 Sonar 客户端组件。相比单独使用 Sonar Runner，Sonar Runner 插件提供了以下便利：
自动配置 Sonar Runner
可以通过一个正规的 Gradle 任务来执行 Sonar Runner，这使得在任何 Gradle 可用的地方，它都可以用（开发人员构建，CI 服务器等），而无需下载，安装，和维护 Sonar Runner 的安装。
通过 Gradle 构建脚本动态配置
根据需要，可以利用 Gradle 脚本的所有特性去配置 Sonar Runner。
提供了广泛范围的默认配置
Gradle 已经有很多 Sonar Runner 成功分析一个项目所需的信息。基于这些信息对 Sonar Runner 进行预配置，减少了许多手动配置的需要。
插件状态和兼容性 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 Sonar Runner 插件是 Sonar 插件的继任者。目前它还在孵化中的状态。该插件基于 Sonar Runner 2.0，这使它与 Sonar 2.11 或更高的版本相兼容。不同于 Sonar 插件，Sonar Runner 插件与 Sonar 3.</description></item><item><title>三十一、4.2 Interceptor</title><link>https://www.shellio.cc/docs/java/jfinal/31/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/jfinal/31/</guid><description>Interceptor 可以对方法进行拦截，并提供机会在方法的前后添加切面代码，实现 AOP 的 核心目标。Interceptor 接口仅仅定了一个方法 void intercept(Invocation inv)。以下是简单的示例：
1public class DemoInterceptor implements Interceptor { 2 public void intercept(Invocation inv) { System.out.println(&amp;#34;Before method invoking&amp;#34;); inv.invoke(); 3 System.out.println(&amp;#34;After method invoking&amp;#34;); 4 } 以上代码中的 DemoInterceptor 将拦截目标方法，并且在目标方法调用前后向控制台输出 文本。inv.invoke()这一行代码是对目标方法的调用，在这一行代码的前后插入切面代码可以很 方便地实现 AOP。
nvocation 作为 Interceptor 接口 intercept 方法中的唯一参数，提供了很多便利的方法在拦 截器中使用。以下为 Invocation 中的方法：
方法
描述
void invoke()
传递本次调用，调用剩下的拦截器与目标方法
Controller getController()
获取&amp;nbsp;Action 调用的&amp;nbsp;Controller 对象（仅用于控制层拦截）
String getActionKey()
获取&amp;nbsp;Action 调用的&amp;nbsp;action key 值（仅用于控制层拦截）
String getControllerKey()
获取&amp;nbsp;Action 调用的&amp;nbsp;controller key 值（仅用于控制层拦截）
String getViewPath()</description></item><item><title>三十一、Gradle JDepend 插件</title><link>https://www.shellio.cc/docs/java/gradle/31/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/gradle/31/</guid><description>JDepend 插件 JDepend 插件使用 JDepend 对项目的源文件执行质量检查，并从检查结果中生成报告。
用法 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 要使用JDepend 插件，请在构建脚本中包含以下语句：
使用 JDepend 插件
build.gradle
1apply plugin: &amp;#39;jdepend&amp;#39; 该插件向你的项目添加了大量的执行质量检查的任务。你可以通过运行 gradle check 执行检查。
任务 JDepend 插件向 project 中添加了以下任务：
表32.1. JDepend 插件 – 任务
任务名称 依赖于 类型 描述 jdependMain classes jdepend 针对生产Java 源文件运行 JDepend。 jdependTest testClasses jdepend 针对测试Java 源文件运行 JDepend。 SourceSet sourceSetClasses jdepend 针对source set 的 Java 源文件运行 JDepend。 JDepend 插件向 Java 插件所加入的任务添加了以下的依赖。
表32.2. JDepend 插件 – 附加的任务依赖
任务名称 依赖于 check 所有 JDepend 任务，包括jdependTest。 依赖管理 JDepend 插件添加了下列的依赖配置：</description></item><item><title>三十一、Groovy 命令行</title><link>https://www.shellio.cc/docs/java/groovy/31/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/groovy/31/</guid><description>被称为groovysh的Groovy shell可以很容易地用于评估groovy表达式，定义类和运行简单的程序。当安装Groovy时，将安装命令行shell。
以下是Groovy中提供的命令行选项：
命令行参数 全名 描述 -C –color [= FLAG] 启用或禁用使用ANSI颜色 -D –define = NAME = VALUE 定义系统属性 -T –terminal = TYPE 指定要使用的终端TYPE -V –version 显示版本 -classpath &amp;nbsp; 指定在哪里找到类文件 – 必须是第一个参数 -cp –classpath 别名“-classpath” -d –debug –debug启用调试输出 -e –evaluate=arg 启动交互式会话时，评估选项指标 -H –help 显示此帮助消息 -q –quiet 禁止多余的输出 -v –verbose 启用详细输出 以下快照显示了在Groovy shell中执行的表达式的一个简单示例。在下面的例子中，我们只是在groovy shell中打印“Hello World”。
类和函数 在命令提示符下定义一个类是很容易的，创建一个新对象并调用类上的方法。下面的示例显示如何实现。在下面的示例中，我们使用简单的方法创建一个简单的Student类。在命令提示符本身中，我们正在创建一个类的对象并调用Display方法。
很容易在命令提示符中定义一个方法并调用该方法。注意，该方法是使用def类型定义的。还要注意，我们已经包括一个称为名称的参数，然后在调用Display方法时将其替换为实际值。下面的示例显示如何实现。
命令 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 shell有许多不同的命令，提供对shell环境的丰富访问。以下是他们的名单和他们做什么。
命令 命令说明 :help （：h）显示此帮助消息 ? （：？）别名为：：帮助 :exit （：x）退出shell :quit （：q）别名为：：exit import （：i）将一个类导入命名空间 :display （：d）显示当前缓冲区 :clear （：c）清除缓冲区并复位提示计数器 :show （：S）显示变量，类或导入 :inspect （：n）使用GUI对象浏览器检查变量或最后一个结果 :purge （：p）清除变量，类，导入或首选项 :edit （：e）编辑当前缓冲区 :load （：l）将文件或URL装入缓冲区 .</description></item><item><title>三十一、JSP 国际化</title><link>https://www.shellio.cc/docs/java/jsp/31/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/jsp/31/</guid><description>JSP 国际化 在开始前，需要解释几个重要的概念：
国际化（i18n）：表明一个页面根据访问者的语言或国家来呈现不同的翻译版本。 本地化（l10n）：向网站添加资源，以使它适应不同的地区和文化。比如网站的印度语版本。 区域：这是一个特定的区域或文化，通常认为是一个语言标志和国家标志通过下划线连接起来。比如”en_US”代表美国英语地区。 如果想要建立一个全球化的网站，就需要关心一系列项目。本章将会详细告诉您如何处理国际化问题，并给出了一些例子来加深理解。
JSP容器能够根据request的locale属性来提供正确地页面版本。接下来给出了如何通过request对象来获得Locale对象的语法：
1java.util.Locale request.getLocale() 检测Locale 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 下表列举出了Locale对象中比较重要的方法，用于检测request对象的地区，语言，和区域。所有这些方法都会在浏览器中显示国家名称和语言名称：
序号 方法 &amp;amp; 描述 1 String getCountry()
返回国家/地区码的英文大写，或 ISO 3166 2-letter 格式的区域
2 String getDisplayCountry()
返回要显示给用户的国家名称
3 String getLanguage()
返回语言码的英文小写，或ISO 639 格式的区域
4 String getDisplayLanguage()
返回要给用户看的语言名称
5 String getISO3Country()
返回国家名称的3字母缩写
6 String getISO3Language()
返回语言名称的3字母缩写
实例演示 这个例子告诉我们如何在JSP中显示语言和国家：
1&amp;lt;%@ page import=&amp;#34;java.io.*,java.util.Locale&amp;#34; %&amp;gt; 2&amp;lt;%@ page import=&amp;#34;javax.servlet.*,javax.servlet.http.* &amp;#34;%&amp;gt; 3&amp;lt;% //获取客户端本地化信息 Locale locale = request.getLocale(); String language = locale.getLanguage(); String country = locale.</description></item><item><title>十、1.5 JFinal启动项目</title><link>https://www.shellio.cc/docs/java/jfinal/10/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/jfinal/10/</guid><description>创建启动项如下图所示：
鼠标右键点击 Java Application 并选择 New 菜单项，新建 Java Application 启动项，如下图 所示：
在右侧窗口中的 Main class 输入框中填入: com.jfinal.core.JFinal 并点击 Debug 按钮启动项 目，如下图所示：</description></item><item><title>十、Gradle Gradle 命令行的基本使用</title><link>https://www.shellio.cc/docs/java/gradle/10/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/gradle/10/</guid><description>Gradle 命令行的基本使用 本章介绍了命令行的基本使用。正如在前面的章节里你所见到的调用 gradle 命令来完成一些功能。
多任务调用 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 你可以以列表的形式在命令行中一次调用多个任务。例如 gradle compile test 命令会依次调用，并且每个任务仅会被调用一次。compile 和 test 任务以及它们的依赖任务。无论它们是否被包含在脚本中：即无论是以命令行的形式定义的任务还是依赖于其它任务都会被调用执行。来看下面的例子。
下面定义了四个任务。dist 和 test 都依赖于 compile，只用当 compile 被调用之后才会调用 gradle dist test 任务。
任务依赖 多任务调用 build.gradle
1task compile &amp;lt;&amp;lt; { 2 println &amp;#39;compiling source&amp;#39; 3task compileTest(dependsOn: compile) &amp;lt;&amp;lt; { 4 println &amp;#39;compiling unit tests&amp;#39; 5task test(dependsOn: [compile, compileTest]) &amp;lt;&amp;lt; { 6 println &amp;#39;running unit tests&amp;#39; 7task dist(dependsOn: [compile, test]) &amp;lt;&amp;lt; { 8 println &amp;#39;building the distribution&amp;#39; gradle dist test 的输出结果。</description></item><item><title>十、Groovy 文件I-O</title><link>https://www.shellio.cc/docs/java/groovy/10/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/groovy/10/</guid><description>Groovy在使用I / O时提供了许多辅助方法，Groovy提供了更简单的类来为文件提供以下功能。
读取文件 写入文件 遍历文件树 读取和写入数据对象到文件 除此之外，您始终可以使用下面列出的用于文件I / O操作的标准Java类。
java.io.File java.io.InputStream java.io.OutputStream java.io.Reader java.io.Writer 读取文件 以下示例将输出Groovy中的文本文件的所有行。方法eachLine内置在Groovy中的File类中，目的是确保文本文件的每一行都被读取。
1import java.io.File 2class Example { 3 static void main(String[] args) { 4 new File(&amp;#34;E:/Example.txt&amp;#34;).eachLine { 5 line -&amp;gt; println &amp;#34;line : $line&amp;#34;; 6 } 7 } File类用于实例化以文件名作为参数的新对象。 然后它接受eachLine的函数，将它放到一个line的变量并相应地打印它。
如果文件包含以下行，它们将被打印。
1line : Example1 2line : Example2 读取文件的内容到字符串 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 如果要将文件的整个内容作为字符串获取，可以使用文件类的text属性。以下示例显示如何完成此操作。
1class Example { 2 static void main(String[] args) { 3 File file = new File(&amp;#34;E:/Example.</description></item><item><title>十、Hibernate 映射类型</title><link>https://www.shellio.cc/docs/java/hibernate/10/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/hibernate/10/</guid><description>映射类型 当你准备一个 Hibernate 映射文件时，我们已经看到你把 Java 数据类型映射到了 RDBMS 数据格式。在映射文件中已经声明被使用的 types 不是 Java 数据类型；它们也不是 SQL 数据库类型。这种类型被称为 Hibernate 映射类型，可以从 Java 翻译成 SQL，反之亦然。
在这一章中列举出所有的基础，日期和时间，大型数据对象，和其它内嵌的映射数据类型。
原始类型 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 映射类型 Java 类型 ANSI SQL 类型 integer int 或 java.lang.Integer INTEGER long long 或 java.lang.Long BIGINT short short 或 java.lang.Short SMALLINT float float 或 java.lang.Float FLOAT double double 或 java.lang.Double DOUBLE big_decimal java.math.BigDecimal NUMERIC character java.lang.String CHAR(1) string java.lang.String VARCHAR byte byte 或 java.lang.Byte TINYINT boolean boolean 或 java.</description></item><item><title>十、Java 8 接口 ( interface ) 默认方法</title><link>https://www.shellio.cc/docs/java/java8/10/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/java8/10/</guid><description>总所周知，在 Java 7 和之前的版本中，接口 interface 是不能包含具体的方法实现的。
比如，下面的代码，是会报错的。
1public class InterfaceDefaultMethodTester 2 public static void main(String[] args) 3 { 4 } 5 interface Greeter { 6 public void greeter(String name) 7 { 8 Syste.out.println(&amp;#34;你好，&amp;#34; + name ); 9 } 10 } 运行结果如下
1[penglei@ddkk.com helloworld]$ javac InterfaceDefaultMethodTester.java &amp;amp;&amp;amp; java InterfaceDefaultMethodTester 2InterfaceDefaultMethodTester.java:10: 错误: 接口抽象方法不能带有主体 3 { 4 ^ 51 个错误 如果一个接口有多个实现，那么每个实现都要重复的一遍一遍的实现接口中的所有方法，岂不是很痛苦。
在Java 7 及以前的版本，对于一个接口有多个实现的时候，我们通常的做法就是让所有的实现继承另一个基础类，然后在这个基础类中实现这个方法。
这就是，为什么 Java 中的 I/O 那么多类的原因，一个庞大的家族体系，每次看到我都头疼。
但是Java 8 中，我想应该是 Java 8 核心开发者们也厌倦了这种不断的重复实现接口方法和庞大的类家族体系。竟然在 Java 8 中为接口提供了一个新的功能，允许某个接口方法有个默认实现。</description></item><item><title>十、Java 9 新特性 – 改进进程管理 API</title><link>https://www.shellio.cc/docs/java/java9/10/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/java9/10/</guid><description>Java 9 这个版本对进程管理方面的改进也是相当大的。在为数不多的几次 Java 项目中，有偶尔用到多线程，但对多进程和进程方面的了解还真是太少。
我想，大部分人应该跟我一样，在编程之外知道有进程的东西的存在，在 Java 中反而会忽视，因为多线程和并发 ( Concurrency ) 的存在感更强吧。
这次Java 9 对进程管理的改进主要是提供了 ProcessHandle 类
ProcessHandle 类 该类在java.lang 包中，且处于 java.base 模块中。
ProcessHandle 可以用于获取进程信息，监听和检查进程的状态，并且可以监听进程的退出
主要提供了以下几个方法
方法 说明 static allProcesses() 返回当前进程可见的所有进程的快照 static current() 返回当前进程的 ProcessHandle 实例 static of(long pid) 返回现有本机进程的 Optional &amp;lt;ProcessHandle&amp;gt; children() 返回进程的当前直接子进程的快照 compareTo(ProcessHandle other) 比较两个进程 descendants() 返回当前进程后代的快照 destroy() 请求杀死当前进程 destroyForcibly() 强制杀死该进程 equals(Object other) 如果 other 对象为非 null，且具有相同的实现，并且表示相同的系统进程，则返回 true; 否则返回 false hashCode() 返回此 ProcessHandle 的哈希值 info() 返回有关该进程的信息的快照 isAlive() 测试此 ProcessHandle 表示的进程是否处于活动状态 onExit() 当进程终止时返回 CompletableFuture &amp;lt;ProcessHandle&amp;gt; parent() 返回当前进程的父进程 Optional&amp;lt;ProcessHandle&amp;gt; ，因为当前进程可能是初始进程，所以父进程不一定存在 pid() 返回当前进程的系统进程的 id supportsNormalTermination() 如果 destroy() 正常终止进程，则返回 true ProcessHandle 类用于标识并提供对 native 进程的控制，可以监控每个单独的进程的活跃度，列出其子进程 ( 线程 ) ，获取有关进程的信息或将其销毁。</description></item><item><title>十、JSP 客户端请求</title><link>https://www.shellio.cc/docs/java/jsp/10/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/jsp/10/</guid><description>JSP 客户端请求 当浏览器请求一个网页时，它会向网络服务器发送一系列不能被直接读取的信息，因为这些信息是作为HTTP信息头的一部分来传送的。您可以查阅HTTP协议来获得更多的信息。
下表列出了浏览器端信息头的一些重要内容，在以后的网络编程中将会经常见到这些信息：
信息 描述 Accept 指定浏览器或其他客户端可以处理的MIME类型。它的值通常为&amp;nbsp;image/png&amp;nbsp;或&amp;nbsp;image/jpeg Accept-Charset 指定浏览器要使用的字符集。比如 ISO-8859-1 Accept-Encoding 指定编码类型。它的值通常为&amp;nbsp;gzip&amp;nbsp;或compress Accept-Language 指定客户端首选语言，servlet会优先返回以当前语言构成的结果集，如果servlet支持这种语言的话。比如 en，en-us，ru等等 Authorization 在访问受密码保护的网页时识别不同的用户 Connection 表明客户端是否可以处理HTTP持久连接。持久连接允许客户端或浏览器在一个请求中获取多个文件。Keep-Alive&amp;nbsp;表示启用持久连接 Content-Length 仅适用于POST请求，表示 POST 数据的字节数 Cookie 返回先前发送给浏览器的cookies至服务器 Host 指出原始URL中的主机名和端口号 If-Modified-Since 表明只有当网页在指定的日期被修改后客户端才需要这个网页。 服务器发送304码给客户端，表示没有更新的资源 If-Unmodified-Since 与If-Modified-Since相反， 只有文档在指定日期后仍未被修改过，操作才会成功 Referer 标志着所引用页面的URL。比如，如果你在页面1，然后点了个链接至页面2，那么页面1的URL就会包含在浏览器请求页面2的信息头中 User-Agent 用来区分不同浏览器或客户端发送的请求，并对不同类型的浏览器返回不同的内容 HttpServletRequest类 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 request对象是javax.servlet.http.HttpServletRequest类的实例。每当客户端请求一个页面时，JSP引擎就会产生一个新的对象来代表这个请求。
request对象提供了一系列方法来获取HTTP信息头，包括表单数据，cookies，HTTP方法等等。
接下来将会介绍一些在JSP编程中常用的获取HTTP信息头的方法。详细内容请见下表：
序号 方法&amp;amp; 描述 1 Cookie[] getCookies() 返回客户端所有的Cookie的数组
2 Enumeration getAttributeNames() 返回request对象的所有属性名称的集合
3 Enumeration getHeaderNames() 返回所有HTTP头的名称集合
4 Enumeration getParameterNames() 返回请求中所有参数的集合
5 HttpSession getSession() 返回request对应的session对象，如果没有，则创建一个
6 HttpSession getSession(boolean create) 返回request对应的session对象，如果没有并且参数create为true，则返回一个新的session对象</description></item><item><title>十、JUnit – 套件测试</title><link>https://www.shellio.cc/docs/java/junit/10/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/junit/10/</guid><description>JUnit – 套件测试 测试套件 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 测试套件意味着捆绑几个单元测试用例并且一起执行他们。在 JUnit 中，@RunWith 和 @Suite 注释用来运行套件测试。这个教程将向您展示一个例子，其中含有两个测试样例 TestJunit1 &amp;amp; TestJunit2 类，我们将使用测试套件一起运行他们。
创建一个类 在目录C:\ &amp;gt; JUNIT_WORKSPACE 中创建一个被测试的 java 类命名为 MessageUtil.java
1/* 2* This class prints the given message on console. 3*/ 4public class MessageUtil { 5 private String message; 6 //Constructor 7 //@param message to be printed 8 public MessageUtil(String message){ 9 this.message = message; 10 } 11 // prints the message 12 public String printMessage(){ 13 System.</description></item><item><title>十、Maven 外部依赖</title><link>https://www.shellio.cc/docs/java/maven/10/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/maven/10/</guid><description>Maven – 外部依赖 现在，如你所知道的，Maven的依赖管理使用的是 Maven – 仓库 的概念。但是如果在远程仓库和中央仓库中，依赖不能被满足，如何解决呢? Maven 使用外部依赖的概念来解决这个问题。
例如，让我们对在 Maven – 创建工程 部分创建的项目做以下修改：
在 src 文件夹下添加 lib 文件夹 复制任何 jar 文件到 lib 文件夹下。我们使用的是 ldapjdk.jar ，它是为 LDAP 操作的一个帮助库 现在，我们的工程结构应该像下图一样：
现在你有了自己的工程库（library），通常情况下它会包含一些任何仓库无法使用，并且 maven 也无法下载的 jar 文件。如果你的代码正在使用这个库，那么 Maven 的构建过程将会失败，因为在编译阶段它不能下载或者引用这个库。
为了处理这种情况，让我们用以下方式，将这个外部依赖添加到 maven pom.xml 中。
1 &amp;lt;project xmlns=&amp;#34;http://maven.apache.org/POM/4.0.0&amp;#34; 2 xmlns:xsi=&amp;#34;http://www.w3.org/2001/XMLSchema-instance&amp;#34; 3 xsi:schemaLocation=&amp;#34;http://maven.apache.org/POM/4.0.0 4 http://maven.apache.org/maven-v4_0_0.xsd&amp;#34;&amp;gt; 5 &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt; 6 &amp;lt;groupId&amp;gt;com.companyname.bank&amp;lt;/groupId&amp;gt; 7 &amp;lt;artifactId&amp;gt;consumerBanking&amp;lt;/artifactId&amp;gt; 8 &amp;lt;packaging&amp;gt;jar&amp;lt;/packaging&amp;gt; 9 &amp;lt;version&amp;gt;1.0-SNAPSHOT&amp;lt;/version&amp;gt; 10 &amp;lt;name&amp;gt;consumerBanking&amp;lt;/name&amp;gt; 11 &amp;lt;url&amp;gt;http://maven.apache.org&amp;lt;/url&amp;gt; 12 &amp;lt;dependencies&amp;gt; 13 &amp;lt;dependency&amp;gt; 14 &amp;lt;groupId&amp;gt;junit&amp;lt;/groupId&amp;gt; 15 &amp;lt;artifactId&amp;gt;junit&amp;lt;/artifactId&amp;gt; 16 &amp;lt;version&amp;gt;3.</description></item><item><title>十、Memcached prepend 命令</title><link>https://www.shellio.cc/docs/java/memcached/10/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/memcached/10/</guid><description>Memcached prepend 命令用于向已存在 key(键) 的 value(数据值) 前面追加数据
语法 1prepend key flags exptime bytes [noreply] 2value 参数说明 key： 键值 key-value 结构中的 key flags ：可以包括键值对的整型参数，客户机使用它存储关于键值对的额外信息 exptime ：在缓存中保存键值对的时间长度（以秒为单位，0 表示永远） bytes ：在缓存中存储的字节数 noreply: 可选，该参数告知服务器不需要返回数据 value ：存储的值（始终位于第二行）（可直接理解为key-value结构中的value） 返回值说明 如果数据添加成功，返回 STORED 如果键不存在，返回 NOT_STORED 如果执行错误，返回 CLIENT_ERROR 范例 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 1. 如果数据添加成功返回 STORED 1flush_all 2OK 3set site 0 1000 7 4souyunku.cn 5STORED 6get site 7VALUE site 0 7 8souyunku.cn 9END 10prepend site 0 1000 4 11www. 12STORED 添加成功 13get site 14VALUE site 0 11 15ddkk.</description></item><item><title>十八、2.6 configHandler (Handlers me)</title><link>https://www.shellio.cc/docs/java/jfinal/18/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/jfinal/18/</guid><description>此方法用来配置 JFinal 的 Handler，如下代码配置了名为 ResourceHandler 的处理器，Handler 可以接管所有 web 请求，并对应用拥有完全的控制权，可以很方便地实现更高层的功能性扩 展。
1public void configHandler(Handlers me) { 2 me.add(new ResourceHandler());</description></item><item><title>十八、Gradle Gradle 守护进程</title><link>https://www.shellio.cc/docs/java/gradle/18/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/gradle/18/</guid><description>Gradle 守护进程 走进守护进程 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 Gradle 守护进程（有时也称为构建守护进程） 的目的是改善 Gradle 的启动和执行时间。
我们准备了几个守护进程非常有用的用例。对于一些工作流，用户会多次调用 Gradle，以执行少量的相对快速的任务。举个例子：
当使用测试驱动开发时，单元测试会被执行多次。 当开发一个 web 应用程序中，应用程序会被组装多次。 当发现构建能做什么，在 gradle tasks 在哪里会执行多次。 对以上各种工作流来说，让调用 Gradle 的启动成本尽可能小会很重要。
此外，如果可以相对较快地建立 Gradle 模型，用户界面可以提供一些有趣的功能。例如，该守护进程可能用于以下情形：
在 IDE 中的内容帮助 在 GUI 中的实时可视化构建 在 CLI 中的 tab 键完成 一般情况下，构建工具的敏捷行为总是可以派上用场。如果你尝试在你的本地构建中使用守护进程的话，它会变得让你很难回到正常的 Gradle 使用。
Tooling API 在整个过程当中都使用守护进程。如，你无法在没有守护进程时正式地使用 Tooling API。这意味着当您在 Eclipse 中使用 STS Gradle 或在 Intellij IDEA 中使用 Gradle 支持时，您已经在使用 Gradle 守护进程。
未来，该守护进程还会提供更多的功能：
敏捷的 up-to-date 检查：使用本地文件系统修改通知（例如，通过 jdk7 nio.2）预先执行 up-to-date 分析。 更快的构建： 预评估项目，这样当用户接下来调用 Gradle 时，模型就准备好了。 我们提到了更快的构建吗？守护进程可以预先下载依赖项或进行快照依赖的新版本检查。 使用可用于编译和测试的一个可复用线程池。例如，Groovy 和 Scala 的编译器启动开销都很大。构建守护进程可以维持一个已下载的 Groovy 和 （或） Scala 进程。 预先执行某些任务，比如编译。更快的反馈。 快速、 准确的 bash 的 tab 键完成。 Gradle 缓存的定期垃圾收集。 重用和失效的守护程序 基本的思想是， gradle 命令会 fork 一个守护进程，用于执行实际的构建。Gradle 命令的后续调用将重用该守护进程，以避免启动开销。有时我们不能使用现有的守护进程，是因为它正忙或其 java 版本或 jvm 参数不同。关于 fork 一个完全新的守护进程的具体细节，请阅读下面的专题。守护进程将在空闲3小时后自动失效。</description></item><item><title>十八、Groovy 正则表达式</title><link>https://www.shellio.cc/docs/java/groovy/18/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/groovy/18/</guid><description>正则表达式是用于在文本中查找子字符串的模式。 Groovy使用〜“regex”表达式本地支持正则表达式。引号中包含的文本表示用于比较的表达式。
例如，我们可以创建一个正则表达式对象，如下所示 –
1def regex = ~&amp;#39;Groovy&amp;#39; 当Groovy运算符=〜在if和while语句（见第8章）中作为谓词（返回布尔值的表达式）出现时，左侧的String操作数与右侧的正则表达式操作数匹配。因此，以下每个都传递值true。
当定义正则表达式时，可以使用以下特殊字符
有两个特殊的位置字符用于表示一行的开始和结束：caret（∧）和美元符号（$）。 正则表达式也可以包括量词。加号（+）表示一次或多次，应用于表达式的前一个元素。星号（*）用于表示零个或多个出现。问号（？）表示零或一次。 元字符{和}用于匹配前一个字符的特定数量的实例。 在正则表达式中，句点符号（。）可以表示任何字符。这被描述为通配符。 正则表达式可以包括字符类。一组字符可以作为简单的字符序列，包含在元字符[和]中，如[aeiou]中。对于字母或数字范围，可以使用[a-z]或[a-mA-M]中的短划线分隔符。字符类的补码由方括号内的前导插入符号表示，如[∧a-z]中所示，并表示除指定的字符以外的所有字符。下面给出了正则表达式的一些示例。 1&amp;#39;Groovy&amp;#39; =~ &amp;#39;Groovy&amp;#39; 2&amp;#39;Groovy&amp;#39; =~ &amp;#39;oo&amp;#39; 3&amp;#39;Groovy&amp;#39; ==~ &amp;#39;Groovy&amp;#39; 4&amp;#39;Groovy&amp;#39; ==~ &amp;#39;oo&amp;#39; 5&amp;#39;Groovy&amp;#39; =~ &amp;#39;∧G&amp;#39; 6‘Groovy&amp;#39; =~ &amp;#39;G$&amp;#39; 7‘Groovy&amp;#39; =~ &amp;#39;Gro*vy&amp;#39; &amp;#39;Groovy&amp;#39; =~ &amp;#39;Gro{2}vy&amp;#39;</description></item><item><title>十八、Hibernate 批处理</title><link>https://www.shellio.cc/docs/java/hibernate/18/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/hibernate/18/</guid><description>批处理 考虑一种情况，你需要使用 Hibernate 将大量的数据上传到你的数据库中。以下是使用 Hibernate 来达到这个的代码片段：
1Session session = SessionFactory.openSession(); 2Transaction tx = session.beginTransaction(); 3for ( int i=0; i&amp;lt;100000; i++ ) { 4 Employee employee = new Employee(.....); 5 session.save(employee); 6tx.commit(); 7session.close(); 因为默认下，Hibernate 将缓存所有的在会话层缓存中的持久的对象并且最终你的应用程序将和 OutOfMemoryException 在第 50000 行的某处相遇。你可以解决这个问题，如果你在 Hibernate 使用批处理。
为了使用批处理这个特性，首先设置 hibernate.jdbc.batch_size 作为批处理的尺寸，取一个依赖于对象尺寸的值 20 或 50。这将告诉 hibernate 容器每 X 行为一批插入。为了在你的代码中实现这个我们将需要像以下这样做一些修改：
1Session session = SessionFactory.openSession(); 2Transaction tx = session.beginTransaction(); 3for ( int i=0; i&amp;lt;100000; i++ ) { 4 Employee employee = new Employee(.</description></item><item><title>十八、Java 8 流 Stream ( 上 )</title><link>https://www.shellio.cc/docs/java/java8/18/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/java8/18/</guid><description>流(Stream ) 是 Java 8 新增加的一个重磅级的功能。流是一个抽象层。有了流，我们就可以使用类似于 SQL 语句的声明方式来处理数据。
比如，下面的 SQL 语句
1SELECT max(grade), student_id, student_name FROM Students; 上面这条 SQL 会自动返回最高学习绩点的学生的信息，而全程，开发人员却不用直接面对任何计算和比较。
在流（ Stream ) 出现之前，对于Java 中的集合框架的使用。开发人员不得不一次次的写一个循环，一次次的重复检查。当然了，这也什么，毕竟大家都是这样过来的。
更大的问题在于开发效率。面对当前的多核 CPU 计算机，面对并发编程。我们开发者常常会写出非常容易出错的并发执行的代码。
为了解决这些问题，Java 8 引入了流 ( Stream ) 这个概念，允许开发人员以声明的方式处理数据的同时，还能利用多核构架，而无需编写任何特殊的代码。
流是什么 ? Java 中的 流 ( Stream ) 表示来自 源 ( source ) 的一系列对象，它支持统计、求和、求平均值等聚合操作。
流具有以下特征：
元素序列 : 流以顺序方式提供特定类型的一组元素。流只会按需获取/计算元素。但它从不存储元素。 源 ( Source )：流可以将集合，数组或 I/O 资源作为输入源。 聚合操作： 流支持聚合操作，如 filter、map、limit、reduce、find、match 等 管道 ( pipelining )：大多数流操作都返回流本身，以便可以对其结果进行流水线操作。这些操作称为 中间 操作，它们的功能是获取输入，处理它们并将输出返回到目标。collect() 方法是一个终端操作，通常在流水线操作结束时出现，以标记流的结尾。 原子性迭代 ( Automatic iterations ) ： 与需要显式迭代的集合相比，流操作在内部对所提供的源元素进行迭代。 流的创建 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 Java 8 在推出流的同时，对集合框架也进行了一些比较大变更。主要是在 Collection 接口上提供了两种生成 Stream 的方法:</description></item><item><title>十八、Java 9 新特性 – CompletableFuture API ( 中 )</title><link>https://www.shellio.cc/docs/java/java9/18/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/java9/18/</guid><description>上一章节中我们提到，Java 9 添加了 CompletableFuture 类的子类化的支持。其实呢 ？ Java 9 对 CompletableFuture 类的子类化的支持也是新增了两个方法。
一个是defaultExecutor() 方法，返回默认的执行器 ( Executor )，一个是 newIncompleteFuture() 返回一个 CompletableFuture 的新实例。下面，我们就一一介绍这两个方法吧。
注意： 这个两个方法都是由 CompletableFuture 类提供的。
defaultExecutor() 方法 defaultExecutor() 方法的原型如下
1public Executor defaultExecutor() 这个方法没有任何参数，但可以返回一个默认的执行器 ( Executor )，这个执行器可以作为那些没有指定执行器的异步方法的执行器
简单的说，就是为异步方法提供一个执行器
子类中可以重写此方法，以返回一个最小化的独立线程作为执行器
newIncompleteFuture() 方法 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 newIncompleteFuture() 方法的原型如下
1public &amp;lt;U&amp;gt; CompletableFuture&amp;lt;U&amp;gt; newIncompleteFuture() 返回CompletionStage方法返回的的新的不完整 CompletableFuture，默认实现是返回 CompletableFuture 类的实例
CompletableFuture 类的子类应覆盖此方法，以返回与此 CompletableFuture 相同的类的实例</description></item><item><title>十八、JSP 日期处理</title><link>https://www.shellio.cc/docs/java/jsp/18/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/jsp/18/</guid><description>JSP 日期处理 使用JSP最重要的优势之一，就是可以使用所有Java API。本章将会详细地讲述Java中的Date类，它在java.util包下，封装了当前日期和时间。
Date类有两个构造函数。第一个构造函数使用当前日期和时间来初始化对象。
1Date( ) 第二个构造函数接受一个参数，这个参数表示从1970年1月1日凌晨至所要表示时间的毫秒数。
1Date(long millisec) 获取Date对象后，您就能够使用下表列出的所有方法：
序号 方法 &amp;amp; 描述 1 boolean after(Date date)
如果比给定的日期晚，则返回true，否则返回false
2 boolean before(Date date)
如果比给定的日期早，则返回true，否则返回false
3 Object clone( )
获取当前对象的一个副本
4 int compareTo(Date date)
如果与给定日期相等，则返回0，如果比给定日期早，则返回一个负数，如果比给定日期晚，则返回一个正数
5 int compareTo(Object obj)
与 compareTo(Date) 方法相同，如果 obj 不是Date类或其子类的对象，抛出ClassCastException异常
6 boolean equals(Object date)
如果与给定日期相同，则返回true，否则返回false
7 long getTime( )
返回从1970年1月1日凌晨至此对象所表示时间的毫秒数
8 int hashCode( )
返回此对象的哈希码
9 void setTime(long time)
使用给定参数设置时间和日期，参数time表示从1970年1月1日凌晨至time所经过的毫秒数
10 String toString( )
将此对象转换为字符串并返回这个字符串
获取当前日期和时间 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 使用JSP编程可以很容易的获取当前日期和时间，只要使用Date对象的toString()方法就行了，就像下面这样：</description></item><item><title>十八、Maven Elipse IDE</title><link>https://www.shellio.cc/docs/java/maven/18/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/maven/18/</guid><description>Maven – Elipse IDE Eclipse 提供一种卓越的插件 m2eclipse，该插件使得 Maven 和 Eclipse 能够无缝集成。
下面列出 m2eclipse 的一些特点：
可以在 Eclipse 环境上运行 Maven 的目标文件。 可以使用其自带的控制台在 Eclipse 中直接查看 Maven 命令的输出。 可以在 IDE 下更新 Maven 的依赖关系。 可以使用 Eclipse 开展 Maven 工程的构建。 Eclipse 基于 Maven 的 pom.xml 来实现自动化管理依赖关系。 它解决了 Maven 与 Eclipse 的工作空间之间的依赖，而不需要安装到本地 Maven 的存储库（需要依赖项目在同一个工作区）。 它可以自动地从远端的 Maven 库中下载所需要的依赖以及源码。 它提供了向导，为建立新 Maven 工程，pom.xml 以及在已有的工程上开启 Maven 支持。 它提供了远端的 Maven 存储库的依赖的快速搜索。 安装 m2eclipse 插件 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 使用以下任意一个链接来安装 m2eclipse:
Eclipse URL Eclipse 3.5 (Gallileo) Installing m2eclipse in Eclipse 3.</description></item><item><title>十八、Memcached stats items 命令</title><link>https://www.shellio.cc/docs/java/memcached/18/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/memcached/18/</guid><description>Memcached stats items 命令用于显示各个 slab 中 item 的数目和存储时长(最后一次访问距离现在的秒数)
语法 1stats items 范例 1flush_all 2OK 3set site 0 1000 11 4ddkk.com 5STORED 6set age 0 1000 2 728 8STORED 9stats items 10STAT items:1:number 2 11STAT items:1:age 477 12STAT items:1:evicted 0 13STAT items:1:evicted_nonzero 0 14STAT items:1:evicted_time 0 15STAT items:1:outofmemory 0 16STAT items:1:tailrepairs 0 17STAT items:1:reclaimed 0 18STAT items:1:expired_unfetched 0 19STAT items:1:evicted_unfetched 0 20STAT items:1:crawler_reclaimed 0 21STAT items:1:crawler_items_checked 0 22STAT items:1:lrutail_reflocked 0 23END</description></item><item><title>十二、1.7 Maven 下开发</title><link>https://www.shellio.cc/docs/java/jfinal/12/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/jfinal/12/</guid><description>如果使用 Maven 管理 jar 包依赖，只需要引入如下 dependency：
com.jfinal
jfinal
2.2
Manve 下启动 JFinal 与前面介绍的非 maven 方式基本相同，唯一的区别是在创建 Java Application 启动项时，在 Arguments 标签中的 Program arguments 中输入：src/main/webapp 80 / 5 参数用来指定 web 项目的根目录。如下示例代码是 main 方法启动方式：
public static void main(String[]args)
{ JFinal.start(“src/main/webapp”,80, “/”,
5);</description></item><item><title>十二、Gradle 编写构建脚本</title><link>https://www.shellio.cc/docs/java/gradle/12/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/gradle/12/</guid><description>编写构建脚本 这一章着眼于一些编写构建脚本的详细信息。
Gradle 构建语言 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 Gradle 提供一种领域特定语言或者说是 DSL，来描述构建。这种构建语言基于 Groovy 中，并进行了一些补充，使其易于描述构建。
Project API 在Java 构建入门的教程中，我们使用了 apply ()方法。这方法从何而来？我们之前说在 Gradle 中构建脚本定义了一个项目（project）。在构建的每一个项目中，Gradle 创建了一个 Project 类型的实例，并在构建脚本中关联此 Project 对象。当构建脚本执行时，它会配置此 Project 对象：
在构建脚本中，你所调用的任何一个方法，如果在构建脚本中未定义，它将被委托给 Project 对象。 在构建脚本中，你所访问的任何一个属性，如果在构建脚本里未定义，它也会被委托给 Project 对象。 下面我们来试试这个，试试访问 Project 对象的 name 属性。
访问 Project 对象的属性
build.gradle
1println name 2println project.name gradle -q check 的输出结果
1&amp;gt; gradle -q check 2projectApi 3projectApi 这两个println 语句打印出相同的属性。在生成脚本中未定义的属性，第一次使用时自动委托到 Project 对象。其他语句使用了在任何构建脚本中可以访问的 project 属性，则返回关联的 Project 对象。只有当您定义的属性或方法 Project 对象的一个成员相同名字时，你才需要使用 project 属性。
标准 project 属性 Project对象提供了一些在构建脚本中可用的标准的属性。下表列出了常用的几个属性。</description></item><item><title>十二、Groovy 数字</title><link>https://www.shellio.cc/docs/java/groovy/12/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/groovy/12/</guid><description>在Groovy中，数字实际上表示为对象，它们都是类Integer的一个实例。要使对象做某事，我们需要调用在其类中声明的一个方法。
Groovy支持整数和浮点数。
整数是不包含分数的值。 浮点数是包含小数部分的十进制值。 Groovy中的数字示例如下所示 –
1Integer x = 5; 2Float y = 1.25; 其中x是整数类型，y是浮点数。
groovy中的数字被定义为对象的原因通常是因为存在对数字执行操作的要求。在原始类型上提供类的概念被称为包装类。
默认情况下，Groovy中提供了以下包装程序类。
包装类的对象包含或包装其各自的基本数据类型。将原始数据类型转换为对象的过程称为装箱，这由编译器负责。将对象转换回其对应的基本类型的过程称为取消装箱。
例子 以下是装箱和拆箱的例子 –
1class Example { 2 static void main(String[] args) { 3 Integer x = 5,y = 10,z = 0; 4 // The the values of 5,10 and 0 are boxed into Integer types 5 // The values of x and y are unboxed and the addition is performed 6 z = x+y; 7 println(z); 8 } 上述程序的输出将为5.</description></item><item><title>十二、Hibernate O-R 映射</title><link>https://www.shellio.cc/docs/java/hibernate/12/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/hibernate/12/</guid><description>O/R 映射 目前为止我们已经通过应用 Hibernate 见识过十分基础的 O/R 映射了，但是还有三个更加重要的有关映射的话题需要我们更详细的探讨。这三个话题是集合的映射，实体类之间的关联映射以及组件映射。
集合映射 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 如果一个实例或者类中有特定变量的值的集合，那么我们可以应用 Java 中的任何的可用的接口来映射这些值。Hibernate 可以保存 java.util.Map, java.util.Set, java.util.SortedMap, java.util.SortedSet, java.util.List 和其它持续的实例或者值的任何数组的实例。
集合类型 映射和描述 java.util.Set 它和 \&amp;lt;set&amp;gt; 元素匹配并且用 java.util.HashSet 初始化。 java.util.SortedSet 它和 \&amp;lt;set&amp;gt; 元素匹配并且用 java.util.TreeSet 初始化。sort 属性可以设置成比较器或者自然排序。 java.util.List 它和 \&amp;lt;list&amp;gt; 元素匹配并且用 java.util.ArrayList 初始化。 java.util.Collection 它和 \&amp;lt;bag&amp;gt; 或者 \&amp;lt;ibag&amp;gt; 元素匹配以及用 java.util.ArrayList 初始化。 java.util.Map 它和 \&amp;lt;map&amp;gt; 元素匹配并且用 java.util.HashMap 初始化。 java.util.SortedMap“) 它和 \&amp;lt;map&amp;gt; 元素匹配并且用 java.util.TreeMap 初始化。sort 属性可以设置成比较器或者 自然排序。 对于Java 的原始数值 Hibernate 采用&amp;lt;primitive-array&amp;gt;支持数组，对于 Java 的其它数值 Hibernate 采用&amp;lt;array&amp;gt;支持数组。然而它们很少被应用，因此我也就不在本指导中讨论它们。</description></item><item><title>十二、Java 8 集合遍历 forEach() 方法</title><link>https://www.shellio.cc/docs/java/java8/12/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/java8/12/</guid><description>本文中，我们将介绍一个 java.util.concurrent 包提供的用于解决并发生产者 – 消费者问题的最有用的类 – BlockQueue。我们将介绍BlockingQueue 接口的 API 以及如何使用该接口的方法使编写并发程序更容易。
在本文的后面，我们将展示一个具有多个生产者线程和多个消费者线程的简单程序的示例。
BlockingQueue 的队列类型 java.util.concurrent 提供了两种类型的 BlockingQueue：
1、 无限队列（unboundedqueue）–几乎可以无限增长；
2、 有限队列（boundedqueue）–定义了最大容量；
无限队列 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 创建一个无限队列的方法很简单
1BlockingQueue&amp;lt;String&amp;gt; blockingQueue = new LinkedBlockingDeque&amp;lt;&amp;gt;(); 上面这段代码中，blockingQueue 的容量将设置为 Integer.MAX_VALUE 。
向无限队列添加元素的所有操作都将永远不会阻塞，因此它可以增长到非常大的容量。
使用无限 BlockingQueue 设计生产者 – 消费者模型时最重要的是 消费者应该能够像生产者向队列添加消息一样快地消费消息 。否则，内存可能会填满，然后就会得到一个 OutOfMemory 异常。
有限队列 第二种类型的队列是有限队列。我们可以通过将容量作为参数传递给构造函数来创建这样的队列
1BlockingQueue&amp;lt;String&amp;gt; blockingQueue = new LinkedBlockingDeque&amp;lt;&amp;gt;(10); 上面这句代码中，我们设置了 blockingQueue 的容量为 10 。这意味着当消费者尝试将元素添加到已经满了的队列时，结果取决于添加元素的方法（ offer() 、add() 、put() ) ，它将阻塞，直到有足够的空间可以插入元素。否则，添加操作将会失败。
使用有限队列是设计并发程序的好方法，因为当我们将元素插入到已经满了的队列时，这些操作需要等到消费者赶上并在队列中提供一些空间。这种机制可以让那个我们不做任何其它更改就可以实现节流。
BlockingQueue API BlockingQueue 接口的所有方法可以分为两大类：负责向队列添加元素的方法和检索这些元素的方法。
在队列满/空的情况下，来自这两个组的每个方法的行为都不同。
添加元素 BlockingQueue 提供了以下方法用于添加元素
方法 说明 add() 如果插入成功则返回 true，否则抛出 IllegalStateException 异常 put() 将指定的元素插入队列，如果队列满了，那么会阻塞直到有空间插入 offer() 如果插入成功则返回 true，否则返回 false offer(E e, long timeout, TimeUnit unit) 尝试将元素插入队列，如果队列已满，那么会阻塞直到有空间插入 检索元素 BlockingQueue 提供了以下方法用于检索元素</description></item><item><title>十二、Java 9 新特性 – try-with-resources 语句</title><link>https://www.shellio.cc/docs/java/java9/12/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/java9/12/</guid><description>如果你使用过 Python ，应该对 with 语句不陌生，with 语句会创建一个独立的上下文，当执行流程离开该上下文时，就会立刻释放该上下文中的所有资源
这样的机制，我们都可以不用手动去关闭已经打开的资源，比如文件等，例如
1with open(&amp;#39;hello.txt&amp;#39;) as f: 2 print(f.read() 在执行流程离开 with 语句块之后，f 这个文件资源就会自动销毁
Java 9 为 java 也引入了这种机制，Java 9 称之为 「 try-with-resources 」
其实应该说 Java 9 之前也能实现这样的机制，只不过有点复杂
try-with-resources try-with-resources 首先是一个 try 语句，其次，该语句包含一个或多个正式声明的资源。这些资源是一个对象，当不再需要时就应该关闭它。
try-with-resources 语句可以确保在需求完成后关闭每个资源，当然了，这些可以自动关闭的资源也是有条件的，那就是必须实现java.lang.AutoCloseable 或 java.io.Closeable 接口
Java 9 之前，资源可以在 try 之前或 try 语句内部声明，正如下面的代码所示的那样。
我们将使用 BufferedReader 作为资源来读取字符串，然后关闭 BufferedReader
TryResourceTester.java 1import java.io.BufferedReader; 2import java.io.IOException; 3import java.io.Reader; 4import java.io.StringReader; 5public class TryResourceTester { 6 public static void main(String[] args) throws IOException { 7 System.</description></item><item><title>十二、JSP HTTP 状态码</title><link>https://www.shellio.cc/docs/java/jsp/12/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/jsp/12/</guid><description>JSP HTTP 状态码 HTTP请求与HTTP响应的格式相近，都有着如下结构：
以状态行+CRLF（回车换行）开始 零行或多行头模块+CRLF 一个空行，比如CRLF 可选的消息体比如文件，查询数据，查询输出 举例来说，一个服务器响应头看起来就像下面这样：
1HTTP/1.1 200 OK 2Content-Type: text/html 3Header2: ... 4... 5HeaderN: ... 6 (Blank Line) 7&amp;lt;!doctype ...&amp;gt; 8&amp;lt;html&amp;gt; 9&amp;lt;head&amp;gt;...&amp;lt;/head&amp;gt; 10&amp;lt;body&amp;gt; 11... 12&amp;lt;/body&amp;gt; 13&amp;lt;/html&amp;gt; 状态行包含HTTP版本，一个状态码，和状态码相对应的短消息。
下表列出了可能会从服务器返回的HTTP状态码和与之关联的消息：
状态码 消息 描述 100 Continue 只有一部分请求被服务器接收，但只要没被服务器拒绝，客户端就会延续这个请求 101 Switching Protocols 服务器交换机协议 200 OK 请求被确认 201 Created 请求已完成，新的资源被创建 202 Accepted 请求被接受，但未处理完 203 Non-authoritative Information &amp;nbsp; 204 No Content &amp;nbsp; 205 Reset Content &amp;nbsp; 206 Partial Content &amp;nbsp; 300 Multiple Choices 一个超链接表，用户可以选择一个超链接并访问，最大支持5个超链接 301 Moved Permanently 被请求的页面已经移动到了新的URL下 302 Found 被请求的页面暂时性地移动到了新的URL下 303 See Other 被请求的页面可以在一个不同的URL下找到 304 Not Modified &amp;nbsp; 305 Use Proxy &amp;nbsp; 306 Unused 已经不再使用此状态码，但状态码被保留 307 Temporary Redirect 被请求的页面暂时性地移动到了新的URL下 400 Bad Request 服务器无法识别请求 401 Unauthorized 被请求的页面需要用户名和密码 402 Payment Required 目前还不能使用此状态码 403 Forbidden 禁止访问所请求的页面 404 Not Found 服务器无法找到所请求的页面 405 Method Not Allowed 请求中所指定的方法不被允许 406 Not Acceptable 服务器只能创建一个客户端无法接受的响应 407 Proxy Authentication Required 在请求被服务前必须认证一个代理服务器 408 Request Timeout 请求时间超过了服务器所能等待的时间，连接被断开 409 Conflict 请求有矛盾的地方 410 Gone 被请求的页面不再可用 411 Length Required “Content-Length”没有被定义，服务器拒绝接受请求 412 Precondition Failed 请求的前提条件被服务器评估为false 413 Request Entity Too Large 因为请求的实体太大，服务器拒绝接受请求 414 Request-url Too Long 服务器拒绝接受请求，因为URL太长。多出现在把”POST”请求转换为”GET”请求时所附带的大量查询信息 415 Unsupported Media Type 服务器拒绝接受请求，因为媒体类型不被支持 417 Expectation Failed &amp;nbsp; 500 Internal Server Error 请求不完整，服务器遇见了出乎意料的状况 501 Not Implemented 请求不完整，服务器不提供所需要的功能 502 Bad Gateway 请求不完整，服务器从上游服务器接受了一个无效的响应 503 Service Unavailable 请求不完整，服务器暂时重启或关闭 504 Gateway Timeout 网关超时 505 HTTP Version Not Supported 服务器不支持所指定的HTTP版本 设置HTTP状态码的方法 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 下表列出了HttpServletResponse 类中用来设置状态码的方法：</description></item><item><title>十二、JUnit – 时间测试</title><link>https://www.shellio.cc/docs/java/junit/12/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/junit/12/</guid><description>JUnit – 时间测试 Junit 提供了一个暂停的方便选项。如果一个测试用例比起指定的毫秒数花费了更多的时间，那么 Junit 将自动将它标记为失败。timeout 参数和 @Test 注释一起使用。现在让我们看看活动中的 @test(timeout)。
创建一个类 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 创建一个在 C:\JUNIT_WORKSPACE 中叫做 MessageUtil.java 的 java 类来测试。 在 printMessage() 方法内添加一个无限 while 循环。 1/* 2* This class prints the given message on console. 3*/ 4public class MessageUtil { 5 private String message; 6 //Constructor 7 //@param message to be printed 8 public MessageUtil(String message){ 9 this.message = message; 10 } 11 // prints the message 12 public void printMessage(){ 13 System.</description></item><item><title>十二、Maven 工程模版</title><link>https://www.shellio.cc/docs/java/maven/12/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/maven/12/</guid><description>Maven – 工程模板 Maven 使用原型（Archetype）概念为用户提供了大量不同类型的工程模版（614 个）。Maven 使用下面的命令帮助用户快速创建 java 项目。
1mvn archetype:generate 什么是原型？ 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 原型是一个 Maven 插件，它的任务是根据模板创建一个项目结构。我们将使用 quickstart 原型插件创建一个简单的 java 应用程序。
使用工程模板 让我们打开命令控制台，跳转到 C:\ &amp;gt; MVN 目录并执行以下 mvn 命令
1C:\MVN&amp;gt;mvn archetype:generate Maven 将开始处理，并要求选择所需的原型
1INFO] Scanning for projects... 2[INFO] Searching repository for plugin with prefix: &amp;#39;archetype&amp;#39;. 3[INFO] ------------------------------------------------------------------- 4[INFO] Building Maven Default Project 5[INFO]task-segment: [archetype:generate] (aggregator-style) 6[INFO] ------------------------------------------------------------------- 7[INFO] Preparing archetype:generate 8... 9600: remote -&amp;gt; org.trailsframework:trails-archetype (-) 10601: remote -&amp;gt; org.trailsframework:trails-secure-archetype (-) 11602: remote -&amp;gt; org.</description></item><item><title>十二、Memcached get 命令</title><link>https://www.shellio.cc/docs/java/memcached/12/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/memcached/12/</guid><description>Memcached get 命令获取存储在 键(key) 中的 数据值(value)
语法 1get key 多个key 使用空格隔开
1get key1 key2 key3 key ： 键值对 key-value 结构中的 key，用于查找缓存值 如果key 不存在，则返回空
范例 1. get 单个 key 这个范例中，我们设置键 site 的值为 ddkk.com 存活时间设置为 1000 秒
1flush_all 2OK 3set site 0 1000 11 4ddkk.com 5STORED 6get site 7VALUE site 0 11 8ddkk.com 9END 2. get 多个 key 1flush_all 2OK 3set site 0 1000 11 4ddkk.com 5STORED 6set age 0 1000 2 728 8STORED 9get site age 10VALUE site 0 11 11ddkk.</description></item><item><title>十九、2.7 afterJFinalStart()与 beforeJFinalStop()</title><link>https://www.shellio.cc/docs/java/jfinal/19/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/jfinal/19/</guid><description>JFinalConfig 中的 afterJFinalStart()与 beforeJFinalStop()方法供开发者在 JFinalConfig 继承类中 覆盖 。 JFinal 会在系统启动完成后回调 afterJFinalStart() 方 法 ， 会 在 系 统 关 闭 前 回 调 beforeJFinalStop()方法。这两个方法可以很方便地在项目启动后与关闭前让开发者有机会进行 额外操作，如在系统启动后创建调度线程或在系统关闭前写回缓存。</description></item><item><title>十九、Gradle 构建环境</title><link>https://www.shellio.cc/docs/java/gradle/19/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/gradle/19/</guid><description>构建环境 通过 gradle.properties 配置构建环境 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 Gradle 提供了几个选项，可以很容易地配置将用于执行您的构建的 Java 进程。当可以通过 GRADLE_OPTS 或 JAVA_OPTS 在你的本地环境中配置这些选项时，如果某些设置如 JVM 内存设置，Java home，守护进程的开/关，它们可以和你的项目在你的版本控制系统中被版本化的话，将会更有用，这样整个团队就可以使用一致的环境了。在你的构建当中，建立一致的环境，就和把这些配置放进 gradle.properties 文件一样简单。这些配置将会按以下顺序被应用（以防在多个地方都有配置时只有最后一个 生效）：
位于项目构建目录的gradle.properties。 位于gradle 用户主目录的gradle.properties。 系统属性，例如当在命令行中使用 -Dsome.property 时。 下面的属性可以用于配置 Gradle 构建环境：
org.gradle.daemon
当设置为 true 时，Gradle 守护进程会运行构建。对于本地开发者的构建而言，这是我们最喜欢的属性。开发人员的环境在速度和反馈上会优化，所以我们几乎总是使用守护进程运行 Gradle 作业。由于 CI 环境在一致性和可靠性上的优化，我们不通过守护进程运行 CI 构建（即长时间运行进程）。
org.gradle.java.home 为 Gradle 构建进程指定 java home 目录。这个值可以设置为 jdk 或 jre 的位置，不过，根据你的构建所做的，选择 jdk 会更安全。如果该设置未指定，将使用合理的默认值。
org.gradle.jvmargs 指定用于该守护进程的 jvmargs。该设置对调整内存设置特别有用。目前的内存上的默认设置很大方。
org.gradle.configureondemand
启用新的孵化模式，可以在配置项目时使得 Gradle 具有选择性。只适用于相关的项目被配置为在大型多项目中更快地构建。
org.gradle.parallel
如果配置了这一个，Gradle 将在孵化的并行模式下运行。
Forked java 进程 许多设置（如 java 版本和最大堆大小）可以在启动一个新的 JVM 构建进程时指定。这意味着 Gradle 在分析了各种 gradle.</description></item><item><title>十九、Groovy 异常处理</title><link>https://www.shellio.cc/docs/java/groovy/19/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/groovy/19/</guid><description>任何编程语言都需要异常处理来处理运行时错误，从而可以保持应用程序的正常流程。
异常通常会破坏应用程序的正常流程，这就是为什么我们需要在我们的应用程序中使用异常处理的原因。
例外大致分为以下类别 –
检测异常 -扩展Throwable类（除了RuntimeException和Error）的类称为检查异常egIOException，SQLException等。检查的异常在编译时检查。 一个典型的情况是FileNotFoundException。假设您的应用程序中有以下代码，它从E盘中的文件读取。
1class Example { 2 static void main(String[] args) { 3 File file = new File(&amp;#34;E://file.txt&amp;#34;); 4 FileReader fr = new FileReader(file); 5 } 如果文件（file.txt）不在E盘中，那么将引发以下异常。
抓取：java.io.FileNotFoundException：E：\ file.txt（系统找不到指定的文件）。
java.io.FileNotFoundException：E：\ file.txt（系统找不到指定的文件）。
未经检查的异常 -扩展RuntimeException的类称为未检查异常，例如，ArithmeticException，NullPointerException，ArrayIndexOutOfBoundsException等。未检查的异常在编译期不检查，而是在运行时检查。 一个典型的情况是ArrayIndexOutOfBoundsException，当您尝试访问大于数组长度的数组的索引时，会发生这种情况。以下是这种错误的典型例子。
1class Example { 2 static void main(String[] args) { 3 def arr = new int[3]; 4 arr[5] = 5; 5 } 当上面的代码执行时，将引发以下异常。
抓取：java.lang.ArrayIndexOutOfBoundsException：5
java.lang.ArrayIndexOutOfBoundsException：5
错误 -错误无法恢复。 OutOfMemoryError，VirtualMachineError，AssertionError等。 这些是程序永远不能恢复的错误，将导致程序崩溃。
下图显示了如何组织Groovy中的异常层次结构。它都基于Java中定义的层次结构。
捕捉异常 方法使用try和catch关键字的组合捕获异常。 try / catch块放置在可能生成异常的代码周围。</description></item><item><title>十九、Hibernate 拦截器</title><link>https://www.shellio.cc/docs/java/hibernate/19/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/hibernate/19/</guid><description>拦截器 你已经学到，在 Hibernate 中，一个对象将被创建和保持。一旦对象已经被修改，它必须被保存到数据库里。这个过程持续直到下一次对象被需要，它将被从持久的存储中加载。
因此一个对象通过它生命周期中的不同阶段，并且 Interceptor 接口提供了在不同阶段能被调用来进行一些所需要的任务的方法。这些方法是从会话到应用程序的回调函数，允许应用程序检查或操作一个持续对象的属性，在它被保存，更新，删除或上传之前。以下是在 Interceptor 接口中可用的所有方法的列表。
S.N. 方法和描述 1 findDirty()
这个方法在当 flush() 方法在一个 Session 对象上被调用时被调用。 2 instantiate()
这个方法在一个持续的类被实例化时被调用。 3 isUnsaved()
这个方法在当一个对象被传到 saveOrUpdate() 方法时被调用。 4 onDelete()
这个方法在一个对象被删除前被调用。 5 onFlushDirty()
这个方法在当 Hibernate 探测到一个对象在一次 flush（例如，更新操作）中是脏的（例如，被修改）时被调用。 6 onLoad()
这个方法在一个对象被初始化之前被调用。 7 onSave()
这个方法在一个对象被保存前被调用。 8 postFlush()
这个方法在一次 flush 已经发生并且一个对象已经在内存中被更新后被调用。 9 preFlush()
这个方法在一次 flush 前被调用。 Hibernate 拦截器给予了我们一个对象如何应用到应用程序和数据库的总控制。
如何使用拦截器？ 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 为了创建一个拦截器你可以直接实现 Interceptor 类或者继承 EmptyInterceptor 类。以下是简单的使用 Hibernate 拦截器功能的步骤。
创建拦截器 我们将在例子中继承 EmptyInterceptor，当 Employee 对象被创建和更新时拦截器的方法将自动被调用。你可以根据你的需求实现更多的方法。
1import java.io.Serializable; 2import java.</description></item><item><title>十九、Java 8 流 Stream ( 下 )</title><link>https://www.shellio.cc/docs/java/java8/19/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/java8/19/</guid><description>上一章节 Java 8 流 Stream ( 上 ) 因为时间关系，我们介绍到一半半就停止了。本章节我们继续。
limit() 方法 limit() 方法用于减少( 限制 ) 流中的元素数量。
例如下面的代码段演示了如何使用 limit() 方法只输出 10 个随机数
1Random random = new Random(); 2random.ints().limit(10).forEach(System.out::println); sorted() 方法 sorted() 方法用于给流中的元素进行排序。
下面的范例演示了如何按照排序顺序打印 10 个随机数
1Random random = new Random(); 2random.ints().limit(10).sorted().forEach(System.out::println); 并发处理 parallelStream() 是需要并发处理的流的替代方案。stream() 方法产生的流只能是串行处理，可以理解为只在一个线程中，按照流中元素的顺序一个接一个的处理。
而并发处理，就是传说中的 map-reduce 方法，可以充分利用多核优势。
需要注意的是，parallelStream() 会打乱流的顺序，也就是返回的序列顺序不一定是输入的序列顺序。
例如下面的代码用于打印序列中的空字符串的数量
1List&amp;lt;String&amp;gt; strings = Arrays.asList(&amp;#34;abc&amp;#34;, &amp;#34;&amp;#34;, &amp;#34;bc&amp;#34;, &amp;#34;efg&amp;#34;, &amp;#34;abcd&amp;#34;,&amp;#34;&amp;#34;, &amp;#34;jkl&amp;#34;); 2//get count of empty string 3int count = strings.parallelStream().filter(string -&amp;gt; string.isEmpty()).count(); 因为stream() 返回是串行流，而 parallelStream() 返回的是并行流。因此在串行和并行之间切换是非常简单的。</description></item><item><title>十九、Java 9 新特性 – CompletableFuture API ( 下 )</title><link>https://www.shellio.cc/docs/java/java9/19/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/java9/19/</guid><description>Java 9 同时为 CompletableFuture 类添加了一些工厂方法
completedFuture(U value) 工厂方法 completedFuture(U value) 工厂方法的原型如下
1public static &amp;lt;U&amp;gt; CompletableFuture&amp;lt;U&amp;gt; completedFuture(U value) 此工厂方法返回一个已完成的、使用给定值的新 CompletableFuture 。
completedStage(U value) 工厂方法 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 completedStage(U value) 工厂方法的原型如下
1public static &amp;lt;U&amp;gt; CompletionStage&amp;lt;U&amp;gt; completedStage(U value) 此工厂方法返回一个新的使用给定值 value 的已完成的 CompletionStage，且仅支持接口 CompletionStage 中定义的那些方法
failedStage(Throwable ex) 工厂方法 failedStage(Throwable ex) 工厂方法的原型如下
1public static &amp;lt;U&amp;gt; CompletionStage&amp;lt;U&amp;gt; failedStage(Throwable ex) 此工厂方法返回一个新的 CompletionStage，使用给定异常的情况下异常完成，且仅支持接口 CompletionStage 中存在的那些方法</description></item><item><title>十九、JSP 页面重定向</title><link>https://www.shellio.cc/docs/java/jsp/19/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/jsp/19/</guid><description>JSP 页面重定向 当需要将文档移动到一个新的位置时，就需要使用JSP重定向了。
最简单的重定向方式就是使用response对象的sendRedirect()方法。这个方法的签名如下：
1public void response.sendRedirect(String location) 2throws IOException 这个方法将状态码和新的页面位置作为响应发回给浏览器。您也可以使用setStatus()和setHeader()方法来得到同样的效果：
1.... 2String site = &amp;#34;http://www.w3cschool.cn&amp;#34; ; 3response.setStatus(response.SC_MOVED_TEMPORARILY); 4response.setHeader(&amp;#34;Location&amp;#34;, site); 5.... 实例演示 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 这个例子表明了JSP如何进行页面重定向：
1&amp;lt;%@ page import=&amp;#34;java.io.*,java.util.*&amp;#34; %&amp;gt; 2&amp;lt;html&amp;gt; 3&amp;lt;head&amp;gt; 4&amp;lt;title&amp;gt;Page Redirection&amp;lt;/title&amp;gt; 5&amp;lt;/head&amp;gt; 6&amp;lt;body&amp;gt; 7&amp;lt;center&amp;gt; 8&amp;lt;h1&amp;gt;Page Redirection&amp;lt;/h1&amp;gt; 9&amp;lt;/center&amp;gt; 10&amp;lt;% 11// 重定向到新地址 12String site = new String(&amp;#34;http://www.w3cschool.cn&amp;#34;); 13response.setStatus(response.SC_MOVED_TEMPORARILY); 14response.setHeader(&amp;#34;Location&amp;#34;, site); %&amp;gt; 15&amp;lt;/body&amp;gt; 16&amp;lt;/html&amp;gt; 将以上代码保存在PageRedirecting.jsp文件中，然后访问http://localhost:8080/PageRedirect.jsp，它将会把您带至//www.w3cschool.cn/。</description></item><item><title>十九、Maven NetBeans</title><link>https://www.shellio.cc/docs/java/maven/19/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/maven/19/</guid><description>Maven – NetBeans NetBeans 6.7 版本或者更新的版本针对 Maven 支持内部构建功能。 针对之前的版本，可以在插件管理器中找到 Maven 插件。在本例中，我们使用 NetBeans 6.9 版本。
关于NetBeans 的一些特性如下：
可以通过 NetBeans 来运行 Maven 目标。 可以在 NetBeans 自己的终端里查看 Maven 命令的输出结果。 可以更新 Maven 与 IDE 的依赖。 可以在 NetBeans 中启动 Maven 的构建。 NetBeans 基于 Maven 的 pom.xml 来实现自动化管理依赖关系。 NetBeans 可以通过自己的工作区解决 Maven 的依赖问题，而无需安装到本地的 Maven 仓库，虽然需要依赖的工程在同一个工作区。 NetBeans 可以自动从远程 Moven 库上下载需要的依赖和源码。 NetBeans 提供了创建 Maven 工程，pom.xml 文件的向导。 NetBeans 提供了 关于Maven 仓库的浏览器，使您可以查看本地存储库和注册在外部的 Maven 仓库。 下面的例子将会帮助你更加充分的认识集成的 NetBeans 和 Maven 的优势。
在 NetBeans 里打开一个 Maven 工程 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 打开 NetBeans.</description></item><item><title>十九、Memcached stats slabs 命令</title><link>https://www.shellio.cc/docs/java/memcached/19/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/memcached/19/</guid><description>Memcached stats slabs 命令用于显示各个 slab 的信息，包括chunk的大小、数目、使用情况等
语法 1stats slabs 范例 1flush_all 2OK 3set site 0 1000 11 4ddkk.com 5STORED 6set age 0 1000 2 728 8STORED 9stats sizes 10STAT 96 2 11END 12stats slabs stats slabs 命令 13STAT 1:chunk_size 96 只用到了 slab 1 14STAT 1:chunks_per_page 10922 15STAT 1:total_pages 1 16STAT 1:total_chunks 10922 17STAT 1:used_chunks 2 18STAT 1:free_chunks 10920 19STAT 1:free_chunks_end 0 20STAT 1:mem_requested 151 21STAT 1:get_hits 0 22STAT 1:cmd_set 2 23STAT 1:delete_hits 0 24STAT 1:incr_hits 0 25STAT 1:decr_hits 0 26STAT 1:cas_hits 0 27STAT 1:cas_badval 0 28STAT 1:touch_hits 0 29STAT active_slabs 1 30STAT total_malloced 1048512 31END</description></item><item><title>十六、2.4 configPlugin (Plugins me)</title><link>https://www.shellio.cc/docs/java/jfinal/16/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/jfinal/16/</guid><description>此方法用来配置 JFinal 的 Plugin，如下代码配置了 C3p0 数据库连接池插件与 ActiveRecord数据库访问插件。通过以下的配置，可以在应用中使用 ActiveRecord 非常方便地操作数据库。
public void configPlugin(Pluginsme)
{ loadPropertyFile(“your_app_config.txt”);
C3p0Plugin c3p0Plugin = new C3p0Plugin(getProperty(“jdbcUrl”), getProperty(“user”), getProperty(“password”));
me.add(c3p0Plugin);
ActiveRecordPlugin arp = new ActiveRecordPlugin(c3p0Plugin);me.add(arp);
arp.addMapping(“user”,User.class);
JFinal 插件架构是其主要扩展方式之一，可以方便地创建插件并应用到项目中去。</description></item><item><title>十六、Gradle 从 Gradle 中调用 Ant</title><link>https://www.shellio.cc/docs/java/gradle/16/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/gradle/16/</guid><description>从 Gradle 中调用 Ant Gradle 提供了对 Ant 的优秀集成您可以在你的 Gradle 构建中，使用单独的 Ant 任务或整个 Ant 构建。事实上，你会发现在 Gradle 中使用 Ant 任务比使用 Ant 的 XML 格式更容易也更强大。你甚至可以只把 Gradle 当作一个强大的 Ant 任务脚本的工具。
Ant可以分为两层。第一层是 Ant 的语言。它提供了用于 build.xml，处理的目标，特殊的构造方法比如宏，还有其他等等的语法。换句话说，除了 Ant 任务和类型之外全部都有。Gradle 理解这种语言，并允许您直接导入你的 Ant build.xml 到 Gradle 项目中。然后你可以使用你的 Ant 构建中的 target，就好像它们是 Gradle 任务一样。
Ant的第二层是其丰富的 Ant 任务和类型，如 javac、copy 或 jar。这一层 Gradle 单靠 Groovy 和不可思议的 AntBuilder，对其提供了集成。
最后，由于构建脚本是 Groovy 脚本，所以您始终可以作为一个外部进程来执行 Ant 构建。你的构建脚本可能包含有类似这样的语句：”ant clean compile”.execute()。[8]
你可以把 Gradle 的 Ant 集成当成一个路径，将你的构建从 Ant 迁移至 Gradle 。例如，你可以通过导入您现有的 Ant 构建来开始。然后，可以将您的依赖声明从 Ant 脚本移到您的构建文件。最后，您可以将整个任务移动到您的构建文件，或者把它们替换为一些 Gradle 插件。这个过程可以随着时间一点点完成，并且在这整个过程当中你的 Gradle 构建都可以使用用。</description></item><item><title>十六、Groovy 映射</title><link>https://www.shellio.cc/docs/java/groovy/16/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/groovy/16/</guid><description>映射（也称为关联数组，字典，表和散列）是对象引用的无序集合。Map集合中的元素由键值访问。 Map中使用的键可以是任何类。当我们插入到Map集合中时，需要两个值：键和值。
以下是一些映射的例子 –
[’TopicName’：’Lists’，’TopicName’：’Maps’] – 具有TopicName作为键的键值对的集合及其相应的值。 [：] – 空映射。 在本章中，我们将讨论Groovy中可用的映射方法。
序号 方法和描述 1 containsKey() 此映射是否包含此键？
2 get() 查找此Map中的键并返回相应的值。如果此映射中没有键的条目，则返回null。 3 keySet() 获取此映射中的一组键。
4 put() 将指定的值与此映射中的指定键相关联。如果此映射先前包含此键的映射，则旧值将替换为指定的值。
5 size() 返回此地图中的键值映射的数量。
6 values() 返回此地图中包含的值的集合视图。</description></item><item><title>十六、Hibernate 原生 SQL</title><link>https://www.shellio.cc/docs/java/hibernate/16/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/hibernate/16/</guid><description>原生 SQL 如果你想使用数据库特定的功能如查询提示或 Oracle 中的 CONNECT 关键字的话，你可以使用原生 SQL 数据库来表达查询。Hibernate 3.x 允许您为所有的创建，更新，删除，和加载操作指定手写 SQL ，包括存储过程。
您的应用程序会在会话界面用 createSQLQuery() 方法创建一个原生 SQL 查询：
1public SQLQuery createSQLQuery(String sqlString) throws HibernateException 当你通过一个包含 SQL 查询的 createsqlquery() 方法的字符串时，你可以将 SQL 的结果与现有的 Hibernate 实体，一个连接，或一个标量结果分别使用 addEntity(), addJoin(), 和 addScalar() 方法进行关联。
标量查询 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 最基本的 SQL 查询是从一个或多个列表中获取一个标量（值）列表。以下是使用原生 SQL 进行获取标量的值的语法：
1String sql = &amp;#34;SELECT first_name, salary FROM EMPLOYEE&amp;#34;; 2SQLQuery query = session.createSQLQuery(sql); 3query.setResultTransformer(Criteria.ALIAS_TO_ENTITY_MAP); 4List results = query.list(); 实体查询 以上的查询都是关于返回标量值的查询，只是基础性地返回结果集中的“原始”值。以下是从原生 SQL 查询中通过 addEntity() 方法获取实体对象整体的语法：
1String sql = &amp;#34;SELECT * FROM EMPLOYEE&amp;#34;; 2SQLQuery query = session.</description></item><item><title>十六、Java 8 新日期时间 API ( 中 ) – 时区日期时间</title><link>https://www.shellio.cc/docs/java/java8/16/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/java8/16/</guid><description>上一章节 Java 8 新日期时间 API ( 上 ) – 本地日期时间 我们对 Java 8 重新设计的日期时间 API 做了一些基础的介绍，同时详细介绍了和本地时间有关的几个类 LocalDateTime 、LocalDate 和 LocalTime 。
我同时也发现，这三个类没有任何时区相关的信息，但也不能说它们没处理时区，而只能说它们有选择的隐藏了时区的处理。它们内部会使用操作系统当前的时区。
以此同时，Java 在 java.time 包中也提供了几个类用于处理需要关注时区的日期时间 API。它们是 java.time.ZonedDateTime 和 java.time.ZoneId。前者用于处理需要时区的日期时间，后者用于处理时区。
ZonedDateTime 和 LocalDateTime 类似，几乎有着相同的 API。从某些方面说，ZonedLocalTime 如果不传递时区信息，那么它会默认使用操作系统的时区，这样，结果其实和 LocalDateTime 是类似的。
比如，我们可以使用 ZonedDateTime 的 now() 方法返回当前时区 ( 操作系统时区 ) 的日期时间，调用 parse() 方法可以将一个包含了时区信息的字符串格式的日期时间转化为一个 ZonedDateTime 实例。
Java8Tester.java 1import java.time.ZonedDateTime; 2public class Java8Tester { 3 public static void main(String args[]) { 4 Java8Tester tester = new Java8Tester(); 5 tester.</description></item><item><title>十六、Java 9 新特性 – 多分辨率图像 API</title><link>https://www.shellio.cc/docs/java/java9/16/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/java9/16/</guid><description>Java 9 引入了一种新的多分辨率图像 API，它支持具有不同分辨率变体的多个图像
这些API 允许将具有不同分辨率的一组图像用作单个多分辨率图像
方法 说明 getResolutionVariant(double destImageWidth, double destImageHeight) 获取特定图像，该图像是表示指定大小的逻辑图像的最佳变体 getResolutionVariants() 以可读列表的形式返回所有分辨率变体 接下来我们就来看看两个 API 如何使用吧。
假设存在三张图片
它们的地址分别为
1https://ddkk.com/static/upload/img/2018/09/03/20180903060845_4.png 2https://ddkk.com/static/upload/img/2018/09/03/20180903060900_4.png 3https://ddkk.com/static/upload/img/2018/09/03/20180903060914_4.png 在当前的工作区中创建一个文件 MultiResolutionTester.java 并输入以下内容
1import java.io.IOException; 2import java.net.URL; 3import java.net.MalformedURLException; 4import java.util.ArrayList; 5import java.util.List; 6import java.awt.Image; 7import java.awt.image.MultiResolutionImage; 8import java.awt.image.BaseMultiResolutionImage; 9import javax.imageio.ImageIO; 10public class MultiResolutionTester { 11 public static void main(String[] args) throws IOException, MalformedURLException { 12 List&amp;lt;String&amp;gt; imgUrls = List.of(&amp;#34;https://ddkk.com/static/upload/img/2018/09/03/20180903060845_4.png&amp;#34;, 13 &amp;#34;https://ddkk.com/static/upload/img/2018/09/03/20180903060900_4.png&amp;#34;, 14 &amp;#34;https://ddkk.com/static/upload/img/2018/09/03/20180903060914_4.png&amp;#34;); 15 List&amp;lt;Image&amp;gt; images = new ArrayList&amp;lt;Image&amp;gt;(); 16 for (String url : imgUrls) { 17 images.</description></item><item><title>十六、JSP Session</title><link>https://www.shellio.cc/docs/java/jsp/16/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/jsp/16/</guid><description>JSP Session HTTP是无状态协议，这意味着每次客户端检索网页时，都要单独打开一个服务器连接，因此服务器不会记录下先前客户端请求的任何信息。
有三种方法来维持客户端与服务器的会话：
Cookies 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 网络服务器可以指定一个唯一的session ID作为cookie来代表每个客户端，用来识别这个客户端接下来的请求。
这可能不是一种有效的方式，因为很多时候浏览器并不一定支持cookie，所以我们不建议使用这种方法来维持会话。
隐藏表单域 一个网络服务器可以发送一个隐藏的HTML表单域和一个唯一的session ID，就像下面这样：
1&amp;lt;input type=&amp;#34;hidden&amp;#34; name=&amp;#34;sessionid&amp;#34; value=&amp;#34;12345&amp;#34;&amp;gt; 这个条目意味着，当表单被提交时，指定的名称和值将会自动包含在GET或POST数据中。每当浏览器发送一个请求，session_id的值就可以用来保存不同浏览器的轨迹。
这种方式可能是一种有效的方式，但点击标签中的超链接时不会产生表单提交事件，因此隐藏表单域也不支持通用会话跟踪。
重写URL 您可以在每个URL后面添加一些额外的数据来区分会话，服务器能够根据这些数据来关联session标识符。
举例来说，http://w3cschool.cn/file.htm;sessionid=12345， session标识符为sessionid=12345，服务器可以用这个数据来识别客户端。
相比而言，重写URL是更好的方式来，就算浏览器不支持cookies也能工作，但缺点是您必须为每个URL动态指定session ID，就算这是个简单的HTML页面。
session对象 除了以上几种方法外，JSP利用servlet提供的HttpSession接口来识别一个用户，存储这个用户的所有访问信息。
默认情况下，JSP允许会话跟踪，一个新的HttpSession对象将会自动地为新的客户端实例化。禁止会话跟踪需要显式地关掉它，通过将page指令中session属性值设为false来实现，就像下面这样：
1&amp;lt;%@ page session=&amp;#34;false&amp;#34; %&amp;gt; JSP引擎将隐含的session对象暴露给开发者。由于提供了session对象，开发者就可以方便地存储或检索数据。
下表列出了session对象的一些重要方法：
S.N. 方法 &amp;amp; 描述 1 public Object getAttribute(String name)
返回session对象中与指定名称绑定的对象，如果不存在则返回null
2 public Enumeration getAttributeNames()
返回session对象中所有的对象名称
3 public long getCreationTime()
返回session对象被创建的时间， 以毫秒为单位，从1970年1月1号凌晨开始算起
4 public String getId()
返回session对象的ID
5 public long getLastAccessedTime()
返回客户端最后访问的时间，以毫秒为单位，从1970年1月1号凌晨开始算起
6 public int getMaxInactiveInterval()
返回最大时间间隔，以秒为单位，servlet 容器将会在这段时间内保持会话打开</description></item><item><title>十六、JUnit – Eclipse 插件</title><link>https://www.shellio.cc/docs/java/junit/16/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/junit/16/</guid><description>JUnit – Eclipse 插件 为了设置带有 eclipse 的 JUnit，需要遵循以下步骤。
步骤 1：下载 Junit archive 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 下载 JUnit
操作系统 文件名 Windows junit4.10.jar Linux junit4.10.jar Mac junit4.10.jar 假设你在 C:&amp;gt;JUnit 文件夹中复制了以上 JAR 文件。
步骤 2：设置 Eclipse 环境 打开 eclipse -&amp;gt; 右击 project 并 点击 property &amp;gt; Build Path &amp;gt; Configure Build Path，然后使用 Add External Jar 按钮在函数库中添加 junit-4.10.jar。 我们假设你的 eclipse 已经内置了 junit 插件并且它在 C:&amp;gt;eclipse/plugins 目录下，如不能获得，那么你可以从 JUnit Plugin 上下载。在 eclipse 的插件文件夹中解压下载的 zip 文件。最后重启 eclipse。 现在你的 eclipse 已经准备好 JUnit 测试用例的开发了。</description></item><item><title>十六、Maven 自动化部署</title><link>https://www.shellio.cc/docs/java/maven/16/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/maven/16/</guid><description>Maven – 自动化部署 一般情况下，在一个工程开发进程里，一次部署的过程包含需如下步骤：
合入每个子工程下的代码到 SVN 或者源代码库，并标记它。 从 SVN 下载完整的源代码。 构建应用程序。 保存构建结果为 WAR 或者 EAR 类型文件并存放到一个共同的指定的网络位置上。 从网络上获得该文件并且部署该文件到产品线上。 更新文档日期和应用程序的版本号。 问题陈述 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 通常，将会有很多不同的人参与到上述部署过程中。一个团队可以负责代码的合入工作，另外一个可以负责构建，以此类推。上述的任何一个步骤都可能因为人为的原因没有被执行。例如，较旧的版本没有在网络机器上更新，负责部署的团队再一次部署了旧的版本。
解决方案 通过结合如下的方案来实现自动化部署：
Maven 构建和发布项目， SubVersion, 源代码库用以管理源代码， 远程仓库管理工具 (Jfrog/Nexus) 用以管理工程的二进制文件。 更新工程的 POM.xml 我们将会使用 Maven 发布的插件来创建一个自动化发布过程：
例如：bus-core-api 工程的 POM.xml 如下
1&amp;lt;project xmlns=&amp;#34;http://maven.apache.org/POM/4.0.0&amp;#34; 2 xmlns:xsi=&amp;#34;http://www.w3.org/2001/XMLSchema-instance&amp;#34; 3 xsi:schemaLocation=&amp;#34;http://maven.apache.org/POM/4.0.0 4 http://maven.apache.org/xsd/maven-4.0.0.xsd&amp;#34;&amp;gt; 5 &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt; 6 &amp;lt;groupId&amp;gt;bus-core-api&amp;lt;/groupId&amp;gt; 7 &amp;lt;artifactId&amp;gt;bus-core-api&amp;lt;/artifactId&amp;gt; 8 &amp;lt;version&amp;gt;1.0-SNAPSHOT&amp;lt;/version&amp;gt; 9 &amp;lt;packaging&amp;gt;jar&amp;lt;/packaging&amp;gt; 10 &amp;lt;scm&amp;gt; 11 &amp;lt;url&amp;gt;http://www.svn.com&amp;lt;/url&amp;gt; 12 &amp;lt;connection&amp;gt;scm:svn:http://localhost:8080/svn/jrepo/trunk/ 13 Framework&amp;lt;/connection&amp;gt; 14 &amp;lt;developerConnection&amp;gt;scm:svn:${username}/${password}@localhost:8080: 15 common_core_api:1101:code&amp;lt;/developerConnection&amp;gt; 16 &amp;lt;/scm&amp;gt; 17 &amp;lt;distributionManagement&amp;gt; 18 &amp;lt;repository&amp;gt; 19 &amp;lt;id&amp;gt;Core-API-Java-Release&amp;lt;/id&amp;gt; 20 &amp;lt;name&amp;gt;Release repository&amp;lt;/name&amp;gt; 21 &amp;lt;url&amp;gt;http://localhost:8081/nexus/content/repositories/ 22 Core-Api-Release&amp;lt;/url&amp;gt; 23 &amp;lt;/repository&amp;gt; 24 &amp;lt;/distributionManagement&amp;gt; 25 &amp;lt;build&amp;gt; 26 &amp;lt;plugins&amp;gt; 27 &amp;lt;plugin&amp;gt; 28 &amp;lt;groupId&amp;gt;org.</description></item><item><title>十六、Memcached incr 与 decr 命令</title><link>https://www.shellio.cc/docs/java/memcached/16/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/memcached/16/</guid><description>Memcached decr 命令用于对已存在的 key(键) 的数字值进行自减操作
语法 1decr key decrement_value key : 键值 key-value 结构中的 key，用于查找缓存值 decrement_value ： 需要减少的数值 与incr 一样, decr 命令操作的数据必须是十进制的32位无符号整数
返回值 如果 key 不存在返回 NOT_FOUND 如果 key 的值不为数字，则返回 CLIENT_ERROR 其他错误返回 ERROR 范例 下面的范例，我们使用 countdown 作为 key，初始值为 100，之后进行减 5 操作
1set countdown 0 1000 3 2100 3STORED 4get countdown 5VALUE countdown 0 3 6100 7END 8decr countdown 5 995 10get countdown 11VALUE countdown 0 3 1295 13END 如果 key 不存在 如果key 不存在，那么返回 NOT_FOUND key 不存在错误</description></item><item><title>十七、2.5 configInterceptor (Interceptors me)</title><link>https://www.shellio.cc/docs/java/jfinal/17/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/jfinal/17/</guid><description>此方法用来配置 JFinal 的全局拦截器，全局拦截器将拦截所有 action 请求，除非使用@Clear 在 Controller 中清除，如下代码配置了名为 AuthInterceptor 的拦截器。
public void configInterceptor(Interceptorsme)
{ me.add(newAuthInterceptor());
}
JFinal 的 Interceptor 非常类似于 Struts2，但使用起来更方便，Interceptor 配置粒度分为 Global、Class、Method 三个层次，其中以上代码配置粒度为全局。Class 与 Method 级的 Interceptor 配置将在后续章节中详细介绍。</description></item><item><title>十七、Gradle 日志</title><link>https://www.shellio.cc/docs/java/gradle/17/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/gradle/17/</guid><description>日志 日志是构建工具的主要界面。如果日志太多，真正的警告和问题容易被隐藏。另一方面，如果出了错，你需要找出相关的信息。Gradle 定义了6个日志级别，如表 18.1，“日志级别”所示。除了那些您通过可能会看到的日志级别之外，有两个 Gradle 特定日志级别。这两个级别分别是 QUIET 和 LIFECYCLE. 默认使用后面的这个日志级别，用于报告构建进度。
表18.1. 日志级别
Level 用于 ERROR 错误消息 QUIET 重要的信息消息 WARNING 警告消息 LIFECYCLE 进度信息消息 INFO 信息性消息 DEBUG 调试消息 选择一个日志级别 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 您可以使用表 18.2，“日志级别的命令行选项”中所示的命令行开关来选择不同的日志级别。在表 18.3，“栈跟踪的命令行选项”中，你可以看到影响栈跟踪日志的命令行开关。
表18.2. 日志级别的命令行选项
选项 输出日志级别 没有日志选项 LIFECYCLE 及更高 --quiet QUIET 及更高 --info INFO 及更高 --debug DEBUG 及更高 表18.3. 栈跟踪的命令行选项
选项 意义 没有栈跟踪选项 构建错误（如编译错误）时没有栈跟踪打印到控制台。只有在内部异常的情况下才打印栈跟踪。如果选择&amp;nbsp;DEBUG&amp;nbsp;日志级别，则总是输出截取后的栈跟踪信息。 --stacktrace 输出截断的栈跟踪。我们推荐使用这一个选项而不是打印全栈的跟踪信息。Groovy 的全栈跟踪非常冗长 （由于其潜在的动态调用机制，然而他们通常不包含你的的代码中哪里错了的相关信息。） --full-stacktrace 打印全栈的跟踪信息。 编写自己的日志消息 在构建文件，打印日志的一个简单方法是把消息写到标准输出中。Gradle 会把写到标准输出的所有内容重定向到它的日志系统的 QUIET 级别中。
使用标准输出写日志
build.gradle
1println &amp;#39;A message which is logged at QUIET level&amp;#39; Gradle 还提供了一个 logger 属性给构建脚本，它是一个 Logger 实例。该接口扩展自 SLF4J的 Logger 接口，并添加了几个 Gradle 的特有方法。下面是关于如何在构建脚本中使用它的示例：</description></item><item><title>十七、Groovy 日期和时间</title><link>https://www.shellio.cc/docs/java/groovy/17/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/groovy/17/</guid><description>类Date表示特定的时刻，具有毫秒精度。 Date类有两个构造函数，如下所示。
# Date() 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 句法 1public Date() 参数 -无。
返回值
分配一个Date对象并初始化它，以便它表示分配的时间，以最近的毫秒为单位。
例子 下面是一个使用这个方法的例子 –
1class Example { 2 static void main(String[] args) { 3 Date date = new Date(); 4 // display time and date using toString() 5 System.out.println(date.toString()); 6 } 7} 当我们运行上面的程序，我们将得到以下结果。以下输出将为您提供当前日期和时间 –
1Thu Dec 10 21:31:15 GST 2015 # Date (长毫秒) 句法 1public Date(long millisec) 参数
毫秒– millisecconds的数量，因为标准的基准时间指定。
返回值 -分配一个Date对象并将其初始化以表示自标准基准时间（称为“该历元”，即1970年1月1日，00:00:00 GMT）起指定的毫秒数。
例子 下面是一个使用这个方法的例子 –
1class Example { 2 static void main(String[] args) { 3 Date date = new Date(100); 4 // display time and date using toString() 5 System.</description></item><item><title>十七、Hibernate 缓存</title><link>https://www.shellio.cc/docs/java/hibernate/17/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/hibernate/17/</guid><description>缓存 缓存是关于应用程序性能的优化，降低了应用程序对物理数据源访问的频次，从而提高应用程序的运行性能。
缓存对Hibernate 来说也是重要的，它使用了如下解释的多级缓存方案：
一级缓存 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 第一级缓存是 Session 缓存并且是一种强制性的缓存，所有的要求都必须通过它。Session 对象在它自己的权利之下，在将它提交给数据库之前保存一个对象。
如果你对一个对象发出多个更新，Hibernate 会尝试尽可能长地延迟更新来减少发出的 SQL 更新语句的数目。如果你关闭 session,所有缓存的对象丢失，或是存留，或是在数据库中被更新。
二级缓存 第二级缓存是一种可选择的缓存并且第一级缓存在任何想要在第二级缓存中找到一个对象前将总是被询问。第二级缓存可以在每一个类和每一个集合的基础上被安装，并且它主要负责跨会话缓存对象。
任何第三方缓存可以和 Hibernate 一起使用。org.hibernate.cache.CacheProvider 接口被提供，它必须实现来给 Hibernate 提供一个缓存实现的解决方法。
查询层次缓存 Hibernate 也实现了一个和第二级缓存密切集成的查询结果集缓存。
这是一个可选择的特点并且需要两个额外的物理缓存区域，它们保存着缓存的查询结果和表单上一次更新时的时间戳。这仅对以同一个参数频繁运行的查询来说是有用的。
第二级缓存 Hibernate 使用默认的一级缓存并且你不用使用一级缓存。让我们直接看向可选的二级缓存。不是所有的类从缓存中获益，所以能关闭二级缓存是重要的。
Hibernate 的二级缓存通过两步设置。第一，你必须决定好使用哪个并发策略。之后，你使用缓存提供程序来配置缓存到期时间和物理缓存属性。
并发策略 一个并发策略是一个中介，它负责保存缓存中的数据项和从缓存中检索它们。如果你将使用一个二级缓存，你必须决定，对于每一个持久类和集合，使用哪一个并发策略。
**Transactional:**为主读数据使用这个策略，在一次更新的罕见状况下并发事务阻止过期数据是关键的。 **Read-write:**为主读数据再一次使用这个策略，在一次更新的罕见状况下并发事务阻止过期数据是关键的。 **Nonstrict-read-write:**这个策略不保证缓存和数据库之间的一致性。如果数据几乎不改变并且过期数据不是很重要，使用这个策略。 **Read-only:**一个适合永不改变数据的并发策略。只为参考数据使用它。 如果我们将为我们的 Employee 类使用二级缓存，让我们使用 read-write 策略来添加需要告诉 Hibernate 来缓存 Employee 实例的映射元素。
1&amp;lt;?xml version=&amp;#34;1.0&amp;#34; encoding=&amp;#34;utf-8&amp;#34;?&amp;gt; 2&amp;lt;!DOCTYPE hibernate-mapping PUBLIC 3 &amp;#34;-//Hibernate/Hibernate Mapping DTD//EN&amp;#34; 4 &amp;#34;http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd&amp;#34;&amp;gt; 5&amp;lt;hibernate-mapping&amp;gt; 6 &amp;lt;class name=&amp;#34;Employee&amp;#34; table=&amp;#34;EMPLOYEE&amp;#34;&amp;gt; 7 &amp;lt;meta attribute=&amp;#34;class-description&amp;#34;&amp;gt; 8 This class contains the employee detail.</description></item><item><title>十七、Java 8 新日期时间 API ( 下 ) – 格式化</title><link>https://www.shellio.cc/docs/java/java8/17/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/java8/17/</guid><description>Java 8 似乎也对 java.text.SimpleDateFormat 也不太满意，竟然重新创建了一个 java.time.format 包，该包下包含了几个类和枚举用于格式化日期时间。
java.time.format 包 java.time.format 包提供了以下几个类用于格式化日期时间
类 说明 DateTimeFormatter 用于打印和解析日期时间对象的格式化程序 DateTimeFormatterBuilder 创建日期时间格式化样式的构建器 DecimalStyle 日期和时间格式中使用的本地化十进制样式 java.time.format 包还提供了以下几个枚举，包含了常见的几种日期时间格式。
枚举 说明 FormatStyle 包含了本地化日期，时间或日期时间格式器的样式的枚举 ResolverStyle 包含了解决日期和时间的不同方法的枚举 SignStyle 包含了如何处理正/负号的方法的枚举 TextStyle 包含了文本格式和解析的样式的枚举 DateTimeFormatter 类 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 DateTimeFormatter 类格式化日期时间的最重要的类，该类是一个最终类，只能实例化，不能被扩展和继承。
DateTimeFormatter 类的定义如下
1public final class DateTimeFormatter extends Object DateTimeFormatter 类用于打印和解析日期时间对象的格式化器。此类提供打印和解析的主要应用程序入口点，并提供 DateTimeFormatter 的常见模式
使用预定义的常量，比如 ISO_LOCAL_DATE 使用模式字母，例如 uuuu-MMM-dd 使用本地化样式，例如 long 或 medium 所有的日期时间类，包括本地日期时间和包含时区的日期时间类，都提供了两个重要的方法
1、 一个用于格式化，format(DateTimeFormatterformatter)；
2、 另一个用于解析，parse(CharSequencetext,DateTimeFormatterformatter)；
下面，我们写几个示例来演示下这两个方法，并演示下如和使用 DateTimeFormatter 类
Java8Tester 1import java.time.ZonedDateTime; 2import java.time.format.DateTimeFormatter; 3public class Java8Tester { 4 public static void main(String args[]) { 5 Java8Tester tester = new Java8Tester(); 6 tester.</description></item><item><title>十七、Java 9 新特性 – CompletableFuture API ( 上 )</title><link>https://www.shellio.cc/docs/java/java9/17/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/java9/17/</guid><description>CompletableFuture 类是在 Java 8 引入的。用于表示一个 Feture 的状态，可以通过设置其值或状态来明确表示 Feture 处于完成状态
说起来特拗口，理解起来就简单了
那个，Java 8 不是引入了并发编程了，对吧。并发编程里有一个概念就是并发执行是否完成了。这个是否完成了是由 java.util.concurrent.CompletionStage 来表示的。然后呢，CompletableFuture 是 CompletionStage 的父类。
如果你对 Java 的并发编程熟悉，那么一定直到，当并发完成时可以支持一个回调，这个回调也是由 CompletableFuture 提供的。
有时候会觉得，一个特性，应该在它出现的时候就比较完善了，直到别人提出了新的思维，才觉得原来还有改进的空间，就比如这个 CompletableFuture 吧
Java 9 竟然还给它添加了一些东西：
1、 支持延误和超时(timeout)机制；
2、 支持子类化；
3、 添加了一些新的工厂方法；
支持延误和超时机制 这两个功能是通过新增两个方法来达成的
方法 说明 completeOnTimeout(T value, long timeout, TimeUnit unit) 如果在指定时间内没完成，则返回一个指定的值 orTimeout(long timeout, TimeUnit unit) 如果在指定的时间内没完成，则抛出一个异常 TimeoutException 这两个方法的看起来是差不多的，都是在指定时间内没完成则执行一个动作，只不过前者是返回一个指定的值，后者则直接抛出异常
这两个方法的原型如下
1public CompletableFuture&amp;lt;T&amp;gt; completeOnTimeout(T value, long timeout, TimeUnit unit) 2public CompletableFuture&amp;lt;T&amp;gt; orTimeout(long timeout, TimeUnit unit) 范例 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 在我们的工作目录创建一个文件 CompletableFutureTimeoutTester.</description></item><item><title>十七、JSP 文件上传</title><link>https://www.shellio.cc/docs/java/jsp/17/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/jsp/17/</guid><description>JSP可以通过HTML的form表单上传文件到服务器。 文件类型可以是文本文件、二进制文件、图像文件等其他任何文档。 创建文件上传表单 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 接下来我们使用HTML标签来创建文件上传表单，以下为要注意的点：
form表单 method 属性必须设置为 POST 方法 ，不能使用 GET 方法。 form表单 enctype 属性需要设置为 multipart/form-data。 form表单 action 属性需要设置为提交到后台处理文件上传的jsp文件地址。例如 uploadFile.jsp 程序文件用来处理上传的文件。 上传文件元素需要使用 标签，属性设置为 type=”file”。如果需要上传多个文件，可以在 标签中设置不同的名称。 以下是一个上传文件的表单，实例如下：
1&amp;lt;html&amp;gt; 2&amp;lt;head&amp;gt; 3&amp;lt;title&amp;gt;File Uploading Form&amp;lt;/title&amp;gt; 4&amp;lt;/head&amp;gt; 5&amp;lt;body&amp;gt; 6&amp;lt;h3&amp;gt;File Upload:&amp;lt;/h3&amp;gt; 7Select a file to upload: &amp;lt;br /&amp;gt; 8&amp;lt;form action=&amp;#34;UploadServlet&amp;#34; method=&amp;#34;post&amp;#34; 9 enctype=&amp;#34;multipart/form-data&amp;#34;&amp;gt; 10&amp;lt;input type=&amp;#34;file&amp;#34; name=&amp;#34;file&amp;#34; size=&amp;#34;50&amp;#34; /&amp;gt; 11&amp;lt;br /&amp;gt; 12&amp;lt;input type=&amp;#34;submit&amp;#34; value=&amp;#34;Upload File&amp;#34; /&amp;gt; 13&amp;lt;/form&amp;gt; 14&amp;lt;/body&amp;gt; 15&amp;lt;/html&amp;gt; 在你本地浏览器访问该文件，显示界面如下所示，在你点击”Upload File”会弹出一个窗口让你选择要上传的文件：
后台JSP处理脚本 首先我们先定义文件上传后存储在服务上的位置，你可以将路径写在你的程序当中，或者我们可以在web.xml配置文件中通过设置 context-param 元素来设置文件存储的目录，如下所示：</description></item><item><title>十七、JUnit – 框架扩展</title><link>https://www.shellio.cc/docs/java/junit/17/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/junit/17/</guid><description>JUnit – 框架扩展 以下是JUnit 扩展
Cactus JWebUnit XMLUnit MockObject Cactus 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 Cactus 是一个简单框架用来测试服务器端的 Java 代码（Servlets, EJBs, Tag Libs, Filters）。Cactus 的设计意图是用来减小为服务器端代码写测试样例的成本。它使用 JUnit 并且在此基础上进行扩展。Cactus 实现了 in-container 的策略，意味着可以在容器内部执行测试。
Cactus 系统由以下几个部分组成：
Cactus Framework（Cactus 框架） 是 Cactus 的核心。它是提供 API 写 Cactus 测试代码的引擎。 Cactus Integration Modules（Cactus 集成模块） 它是提供使用 Cactus Framework（Ant scripts, Eclipse plugin, Maven plugin）的前端和框架。 这是使用 cactus 的样例代码。
1import org.apache.cactus.*; 2import junit.framework.*; 3public class TestSampleServlet extends ServletTestCase { 4 @Test 5 public void testServlet() { 6 // Initialize class to test 7 SampleServlet servlet = new SampleServlet(); 8 // Set a variable in session as the doSomething() 9 // method that we are testing 10 session.</description></item><item><title>十七、Maven Web 应用</title><link>https://www.shellio.cc/docs/java/maven/17/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/maven/17/</guid><description>Maven – Web 应用 本教程将指导你如何使用 Maven 版本控制系统来管理一个基于 Web 的工程。在此，你将学习到如何创建/构建/部署以及运行 Web 应用程序：
创建 Web 应用 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 建立一个简单的 Java web 应用，我们可以使用 maven-archetype-webapp 插件。首先我们打开命令控制台，进入 C:\MVN 目录并且执行以下的 mvn 命令。
1C:\MVN&amp;gt;mvn archetype:generate 2-DgroupId=com.companyname.automobile 3-DartifactId=trucks 4-DarchetypeArtifactId=maven-archetype-webapp 5-DinteractiveMode=false Maven 将开始处理并且将创建完整的基于 Web 的 java 应用工程结构。
1[INFO] Scanning for projects... 2[INFO] Searching repository for plugin with prefix: &amp;#39;archetype&amp;#39;. 3[INFO] ------------------------------------------------------------------- 4[INFO] Building Maven Default Project 5[INFO] task-segment: [archetype:generate] (aggregator-style) 6[INFO] ------------------------------------------------------------------- 7[INFO] Preparing archetype:generate 8[INFO] No goals needed for project - skipping 9[INFO] [archetype:generate {execution: default-cli}] 10[INFO] Generating project in Batch mode 11[INFO] -------------------------------------------------------------------- 12[INFO] Using following parameters for creating project 13from Old (1.</description></item><item><title>十七、Memcached stats 命令</title><link>https://www.shellio.cc/docs/java/memcached/17/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/memcached/17/</guid><description>Memcached stats 命令返回 Memcached 的统计信息，比如 PID(进程号)、版本号、连接数等。
语法 1stats stats 返回的每一项解释如下 pid ： memcache服务器进程ID uptime ：服务器已运行秒数 time ：服务器当前Unix时间戳 version：memcache版本 pointer_size ：操作系统指针大小 rusage_user ：进程累计用户时间 rusage_system ：进程累计系统时间 curr_connections ：当前连接数量 total_connections ：Memcached运行以来连接总数 connection_structures ：Memcached分配的连接结构数量 cmd_get ：get命令请求次数 cmd_set ：set命令请求次数 cmd_flush ：flush命令请求次数 get_hits ：get命令命中次数 get_misses ：get命令未命中次数 delete_misses ：delete命令未命中次数 delete_hits ：delete命令命中次数 incr_misses ：incr命令未命中次数 incr_hits ：incr命令命中次数 decr_misses ：decr命令未命中次数 decr_hits ：decr命令命中次数 cas_misses ：cas命令未命中次数 cas_hits ：cas命令命中次数 cas_badval ：使用擦拭次数 auth_cmds ：认证命令处理的次数 auth_errors ：认证失败数目 bytes_read ：读取总字节数 bytes_written ：发送总字节数 limit_maxbytes ：分配的内存总大小（字节） accepting_conns ：服务器是否达到过最大连接（0/1） listen_disabled_num ：失效的监听数 threads ：当前线程数 conn_yields ：连接操作主动放弃数目 bytes ：当前存储占用的字节数 curr_items ：当前存储的数据总数 total_items ：启动以来存储的数据总数 evictions ：LRU释放的对象数目 reclaimed ：已过期的数据条目来存储新数据的数目 范例 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 1flush_all 2OK 3set site 0 1000 11 4ddkk.</description></item><item><title>十三、2.1 概述</title><link>https://www.shellio.cc/docs/java/jfinal/13/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/jfinal/13/</guid><description>基于JFinal 的 web 项目需要创建一个继承自 JFinalConfig 类的子类，该类用于对整个 web
项目进行配置。
JFinalConfig 子类需要实现五个抽象方法，如下所示：
public class DemoConfigextends JFinalConfig
{ publicvoid configConstant(Constants me)
{} public void configRoute(Routesme) {}
publicvoid configPlugin(Plugins me) {}
public void configInterceptor(Interceptors me) {}
public void configHandler(Handlersme) {}
}</description></item><item><title>十三、Gradle 教程 – 杂七杂八</title><link>https://www.shellio.cc/docs/java/gradle/13/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/gradle/13/</guid><description>教程-杂七杂八 创建目录 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 有一个常见的情况是，多个任务都依赖于某个目录的存在。当然，你可以在这些任务的开始加入 mkdir 来解决这个问题。但这是种臃肿的解决方法。这里有一个更好的解决方案 (仅适用于这些需要这个目录的任务有着 dependsOn 的关系的情况)：
使用 mkdir 创建目录
build.gradle
1classesDir = new File(&amp;#39;build/classes&amp;#39;) 2task resources &amp;lt;&amp;lt; { 3 classesDir.mkdirs() 4 // do something 5task compile(dependsOn: &amp;#39;resources&amp;#39;) &amp;lt;&amp;lt; { 6 if (classesDir.isDirectory()) { 7 println &amp;#39;The class directory exists. I can operate&amp;#39; 8 } 9 // do something 10} gradle -q compile的输出结果
1&amp;gt; gradle -q compile 2The class directory exists. I can operate Gradle 属性和系统属性 Gradle 提供了许多方式将属性添加到您的构建中。 从Gradle 启动的 JVM，你可以使用 -D 命令行选项向它传入一个系统属性。 Gradle 命令的-D选项和 java 命令的 -D 选项有着同样的效果。</description></item><item><title>十三、Groovy 字符串</title><link>https://www.shellio.cc/docs/java/groovy/13/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/groovy/13/</guid><description>通过在引号中包含字符串文本，在Groovy中构造一个字符串文字。
Groovy提供了多种表示String字面量的方法。 Groovy中的字符串可以用单引号（’），双引号（“）或三引号（”“”）括起来。此外，由三重引号括起来的Groovy字符串可以跨越多行。
以下是Groovy中字符串使用的示例 –
1class Example { 2 static void main(String[] args) { 3 String a = &amp;#39;Hello Single&amp;#39;; 4 String b = &amp;#34;Hello Double&amp;#34;; 5 String c = &amp;#34;&amp;#39;Hello Triple&amp;#34; + &amp;#34;Multiple lines&amp;#39;&amp;#34;; 6 println(a); 7 println(b); 8 println(c); 9 } 当我们运行上面的程序，我们将得到以下结果 –
1Hello Single 2Hello Double 3&amp;#39;Hello TripleMultiple lines&amp;#39; 字符串索引 Groovy中的字符串是字符的有序序列。字符串中的单个字符可以通过其位置访问。这由索引位置给出。
字符串索引从零开始，以小于字符串长度的一个结束。 Groovy还允许负索引从字符串的末尾开始计数。
以下是Groovy中字符串索引的使用示例 –
1class Example { 2 static void main(String[] args) { 3 String sample = &amp;#34;Hello world&amp;#34;; 4 println(sample[4]); // Print the 5 character in the string 5 //Print the 1st character in the string starting from the back 6 println(sample[-1]); 7 println(sample[1.</description></item><item><title>十三、Hibernate 注释</title><link>https://www.shellio.cc/docs/java/hibernate/13/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/hibernate/13/</guid><description>注释 到现在为止，你已经看到 Hibernate 如何使用 XML 映射文件来完成从 POJO 到数据库表的数据转换的，反之亦然。Hibernate 注释是无需使用 XML 文件来定义映射的最新方法。你可以额外使用注释或直接代替 XML 映射元数据。
Hibernate 注释是一种强大的来给对象和关系映射表提供元数据的方法。所有的元数据被添加到 POJO java 文件代码中，这有利于用户在开发时更好的理解表的结构和 POJO。
如果你想让你的应用程序移植到其它 EJB 3 的 ORM 应用程序中,您必须使用注释来表示映射信息，但是如果想要得到更大的灵活性,那么你应该使用基于 XML 的映射。
Hibernate 注释的环境设置 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 首先你必须确定你使用的是 JDK 5.0，否则你需要升级你的 JDK 至 JDK 5.0，来使你的主机能够支持注释。
其次，你需要安装 Hibernate 3.x 注释包，可以从 sourceforge 行下载：（下载 Hibernate 注释） 并且从 Hibernate 注释发布中拷贝 hibernate-annotations.jar, lib/hibernate-comons-annotations.jar 和 lib/ejb3-persistence.jar 到你的 CLASSPATH。
注释类示例 正如我上面所提到的，所有的元数据被添加到 POJO java 文件代码中，这有利于用户在开发时更好的理解表的结构和 POJO。
下面我们将使用 EMPLOYEE 表来存储对象:
1create table EMPLOYEE ( 2 id INT NOT NULL auto_increment, 3 first_name VARCHAR(20) default NULL, 4 last_name VARCHAR(20) default NULL, 5 salary INT default NULL, 6 PRIMARY KEY (id) 7); 以下是用带有注释的 Employee 类来映射使用定义好的 Employee 表的对象:</description></item><item><title>十三、Java 8 可选值 java.util.Optional 类</title><link>https://www.shellio.cc/docs/java/java8/13/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/java8/13/</guid><description>在不考虑竖起来的情况下，抛一个硬币，落地时，显示正面的情况只有两种：是正面和不是正面。很多时候，这是一个 「 谓词 」，也就是返回布尔类型 ( bool )。但有时候，我们需要返回另一种类型：存在 和 空。
存在 就是硬币落地时显示为正面 空 就是硬币落地式显示的不是正面。 从另一方面说，结果就是 有值 和 空 。
一个类，如果可以同时表示 有值 和 空 ，我们称这种类为 可选类 ( Optional )
从某些方面说，Optional 类型就是 「那里有一个值，它等于 x，或者那里没有那个值」
JAVA 8 java.util.Optional 类 Java 8 在 java.util 包中添加了一个新的类 Optional 。
Optional 类是一个容器，用于表示可能包含也可能不包含非 null 值。如果存在值，isPresent() 方法将返回 true，get() 将返回该值。
Optional 类提供了许多方法用于处理 「 可用 」 或 「 不可用 」 ，而不是简单的检查空值情况。
java.util.Optional 类的声明如下
1public final class Optional&amp;lt;T&amp;gt; extends Object 注意：该类是一个最终类，不能被继承和扩展。
Optional 类提供了以下静态方法来创建 Optional 类的实例 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 Optional 类提供了三个静态方法用于创建 Optional 类的实例，这三个方法的返回值都是 Optional&amp;lt;T&amp;gt;</description></item><item><title>十三、Java 9 新特性 – 增强 @Deprecated 注解</title><link>https://www.shellio.cc/docs/java/java9/13/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/java9/13/</guid><description>@Deprecated 注解很早就存在了，如果我记得没错的话，好像是 Java 5 ( 后来我去查了资料，也的确是 Java 5 就引入了 ) 。
一个使用 @Deprecated 注解的元素，无论是一个类或是一个方法，可能是由以下原因导致了不应该再使用它
1、 使用它可能会导致错误；
2、 在未来的版本中不被兼容；
3、 在未来的版本中可能会被删除；
4、 存在更好的更有效的替代方法；
如果一个程序或代码片段使用了 @Deprecated 注解的元素，那么编译器就会生成一个警告信息，表明这个元素是不被推荐使用的。
我们都一直延续了这样的习惯好久，直到 Java 9 的发布，我才发现 @Deprecated 注解还可以做的更好
Java 9 对 @Deprecated 注解做了两项重要的增强。
1、 forRemoval–指示在将来的版本中是否要删除带注解的元素默认值为false；
2、 since–返回注解元素刚添加@Deprecated注解的版本；
一看不知道，看了很吃惊，这两个属性，还是蛮有作用的
@Deprecated 的 since 属性 对since 的使用，你可以查阅 Java 9 的官方文档中 Boolean 类型的文档，在该文档中演示了如何在 @Deprecated 注解上使用 since 属性
文档地址 https://docs.oracle.com/javase/9/docs/api/java/lang/Boolean.html#Boolean-boolean-
可以看到下图中粉色框框的内容
@Deprecated 的 forRemoval 属性 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 关于@Deprecated 的 forRemoval 属性的使用，可以查看官方提供的文档中的有关 System 类的部分，该部分演示了 @Deprecated 注解使用 forRemoval 属性</description></item><item><title>十三、JSP 表单处理</title><link>https://www.shellio.cc/docs/java/jsp/13/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/jsp/13/</guid><description>JSP 表单处理 我们在浏览网页的时候，经常需要向服务器提交信息，并让后台程序处理。浏览器中使用 GET 和 POST 方法向服务器提交数据。
GET 方法 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 GET方法将请求的编码信息添加在网址后面，网址与编码信息通过”?”号分隔。如下所示：
1//www.w3cschool.cn/hello?key1=value1&amp;amp;key2=value2 GET方法是浏览器默认传递参数的方法，一些敏感信息，如密码等建议不使用GET方法。
用get时，传输数据的大小有限制 （注意不是参数的个数有限制），最大为1024字节。
POST 方法 一些敏感信息，如密码等我们可以同过POST方法传递，post提交数据是隐式的。
POST提交数据是不可见的，GET是通过在url里面传递的（可以看一下你浏览器的地址栏）。
JSP使用getParameter()来获得传递的参数，getInputStream()方法用来处理客户端的二进制数据流的请求。
JSP 读取表单数据 getParameter(): 使用 request.getParameter() 方法来获取表单参数的值。 getParameterValues(): 获得如checkbox类（名字相同，但值有多个）的数据。 接收数组变量 ，如checkobx类型 **getParameterNames():**该方法可以取得所有变量的名称，该方法返回一个Emumeration。 **getInputStream():**调用此方法来读取来自客户端的二进制数据流。 使用URL的 GET 方法实例 以下是一个简单的URL,并使用GET方法来传递URL中的参数：
1http://localhost:8080/main.jsp?first_name=ZARA&amp;amp;last_name=ALI 以下是main.jsp文件的JSP程序用于处理客户端提交的表单数据，我们使用getParameter()方法来获取提交的数据：
1&amp;lt;html&amp;gt; 2&amp;lt;head&amp;gt; 3&amp;lt;title&amp;gt;Using GET Method to Read Form Data&amp;lt;/title&amp;gt; 4&amp;lt;/head&amp;gt; 5&amp;lt;body&amp;gt; 6&amp;lt;center&amp;gt; 7&amp;lt;h1&amp;gt;Using GET Method to Read Form Data&amp;lt;/h1&amp;gt; 8&amp;lt;ul&amp;gt; 9&amp;lt;li&amp;gt;&amp;lt;p&amp;gt;&amp;lt;b&amp;gt;First Name:&amp;lt;/b&amp;gt; 10 &amp;lt;%= request.getParameter(&amp;#34;first_name&amp;#34;)%&amp;gt; 11&amp;lt;/p&amp;gt;&amp;lt;/li&amp;gt; 12&amp;lt;li&amp;gt;&amp;lt;p&amp;gt;&amp;lt;b&amp;gt;Last Name:&amp;lt;/b&amp;gt; 13 &amp;lt;%= request.getParameter(&amp;#34;last_name&amp;#34;)%&amp;gt; 14&amp;lt;/p&amp;gt;&amp;lt;/li&amp;gt; 15&amp;lt;/ul&amp;gt; 16&amp;lt;/body&amp;gt; 17&amp;lt;/html&amp;gt; 接下来我们通过浏览器访问http://localhost:8080/main.</description></item><item><title>十三、JUnit – 异常测试</title><link>https://www.shellio.cc/docs/java/junit/13/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/junit/13/</guid><description>JUnit – 异常测试 Junit 用代码处理提供了一个追踪异常的选项。你可以测试代码是否它抛出了想要得到的异常。expected 参数和 @Test 注释一起使用。现在让我们看看活动中的 @Test(expected)。
创建一个类 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 在 C:\ &amp;gt; JUNIT_WORKSPACE 中创建一个叫做 MessageUtil.java 的 java 类来测试。 在 printMessage()方法中添加一个错误条件。 1/* 2* This class prints the given message on console. 3*/ 4public class MessageUtil { 5 private String message; 6 //Constructor 7 //@param message to be printed 8 public MessageUtil(String message){ 9 this.message = message; 10 } 11 // prints the message 12 public void printMessage(){ 13 System.</description></item><item><title>十三、Maven 快照</title><link>https://www.shellio.cc/docs/java/maven/13/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/maven/13/</guid><description>Maven – 快照 大型软件应用程序通常由多个模块组成，这是多个团队工作于同一应用程序的不同模块的常见场景。例如一个团队工作负责应用程序的前端应用用户接口工程（app-ui.jar:1.0)），同时他们使用数据服务工程（data-service.jar:1.0）。
现在负责数据服务的团队可能正在进行修正 bug 或者增强功能，并快速迭代，然后他们几乎每天都会 release 工程库文件到远程仓库中。
现在如果数据服务团队每天上传新的版本，那么就会有下面的问题：
每次数据服务团队发布了一版更新的代码时，都要告诉应用接口团队。 应用接口团队需要定期更新他们的 pom.xml 来得到更新的版本 为了解决这样的情况，快照概念发挥了作用.
什么是快照？ 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 快照是一个特殊的版本，它表示当前开发的一个副本。与常规版本不同，Maven 为每一次构建从远程仓库中检出一份新的快照版本。
现在数据服务团队会将每次更新的代码的快照（例如 data-service:1.0-SNAPSHOT）发布到仓库中，来替换旧的快照 jar 文件。
快照 vs 版本 对于版本，Maven 一旦下载了指定的版本（例如 data-service:1.0），它将不会尝试从仓库里再次下载一个新的 1.0 版本。想要下载新的代码，数据服务版本需要被升级到 1.1。
对于快照，每次用户接口团队构建他们的项目时，Maven 将自动获取最新的快照（data-service:1.0-SNAPSHOT）。
应用用户接口 pom.xml 应用用户接口工程正在使用 1.0 版本的数据服务的快照
1&amp;lt;project xmlns=&amp;#34;http://maven.apache.org/POM/4.0.0&amp;#34; 2 xmlns:xsi=&amp;#34;http://www.w3.org/2001/XMLSchema-instance&amp;#34; 3 xsi:schemaLocation=&amp;#34;http://maven.apache.org/POM/4.0.0 4 http://maven.apache.org/xsd/maven-4.0.0.xsd&amp;#34;&amp;gt; 5 &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt; 6 &amp;lt;groupId&amp;gt;app-ui&amp;lt;/groupId&amp;gt; 7 &amp;lt;artifactId&amp;gt;app-ui&amp;lt;/artifactId&amp;gt; 8 &amp;lt;version&amp;gt;1.0&amp;lt;/version&amp;gt; 9 &amp;lt;packaging&amp;gt;jar&amp;lt;/packaging&amp;gt; 10 &amp;lt;name&amp;gt;health&amp;lt;/name&amp;gt; 11 &amp;lt;url&amp;gt;http://maven.apache.org&amp;lt;/url&amp;gt; 12 &amp;lt;properties&amp;gt; 13 &amp;lt;project.build.sourceEncoding&amp;gt;UTF-8&amp;lt;/project.build.sourceEncoding&amp;gt; 14 &amp;lt;/properties&amp;gt; 15 &amp;lt;dependencies&amp;gt; 16 &amp;lt;dependency&amp;gt; 17 &amp;lt;groupId&amp;gt;data-service&amp;lt;/groupId&amp;gt; 18 &amp;lt;artifactId&amp;gt;data-service&amp;lt;/artifactId&amp;gt; 19 &amp;lt;version&amp;gt;1.</description></item><item><title>十三、Memcached gets 命令</title><link>https://www.shellio.cc/docs/java/memcached/13/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/memcached/13/</guid><description>Memcached gets 命令获取带有 CAS 令牌存 的 value(数据值) ，
语法 1gets key 多个key 使用空格隔开:
1gets key1 key2 key3 key ：键值 key-value 结构中的 key，用于查找缓存值 返回结果中，最后一列的数字为 CAS 令牌
如果key 不存在，则返回空
范例 使用gets 命令的输出结果中，在最后一列的数字 1 代表了 key 为 DDKK.COM 弟弟快看，程序员编程资料站 的 CAS 令牌
只 gets 一个 key
1flush_all 2OK 3set site 0 1000 11 4ddkk.com 5STORED 6set age 0 1000 2 728 8STORED 9gets site 10VALUE site 0 11 18 11ddkk.com 12END gets 多个 key 1flush_all 2OK 3set site 0 1000 11 4ddkk.</description></item><item><title>十四、2.2 configConstant(Constants me)</title><link>https://www.shellio.cc/docs/java/jfinal/14/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/jfinal/14/</guid><description>此方法用来配置 JFinal 常量值，如开发模式常量 devMode 的配置，默认视图类型 ViewType的配置，如下代码配置了 JFinal 运行在开发模式下且默认视图类型为 JSP：
public void configConstant(Constantsme)
{ me.setDevMode(true);
me.setViewType(ViewType.JSP);
}
在开发模式下，JFinal 会对每次请求输出报告，如输出本次请求的 Controller、Method 以 及请求所携带的参数。JFinal 支持 JSP、FreeMarker、Velocity 三种常用视图。</description></item><item><title>十四、Gradle 任务详述</title><link>https://www.shellio.cc/docs/java/gradle/14/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/gradle/14/</guid><description>任务详述 在入门教程构建基础中，你已经学习了如何创建简单的任务。之后您还学习了如何将其他行为添加到这些任务中。并且你已经学会了如何创建任务之间的依赖。这都是简单的任务。但 Gradle 让任务的概念更深远。Gradle 支持增强的任务，也就是，有自己的属性和方法的任务。这是真正的与你所使用的 Ant 目标（target）的不同之处。这种增强的任务可以由你提供，或由 Gradle 提供。
定义任务 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 在构建基础中我们已经看到如何通过关键字这种风格来定义任务。在某些情况中，你可能需要使用这种关键字风格的几种不同的变式。例如，在表达式中不能用这种关键字风格。
定义任务
build.gradle
1task(hello) &amp;lt;&amp;lt; { 2 println &amp;#34;hello&amp;#34; 3task(copy, type: Copy) { 4 from(file(&amp;#39;srcDir&amp;#39;)) 5 into(buildDir) 6} 您还可以使用字符串作为任务名称：
定义任务 — — 使用字符串作为任务名称
build.gradle
1task(&amp;#39;hello&amp;#39;) &amp;lt;&amp;lt; 2 println &amp;#34;hello&amp;#34; 3task(&amp;#39;copy&amp;#39;, type: Copy) { 4 from(file(&amp;#39;srcDir&amp;#39;)) 5 into(buildDir) 6} 对于定义任务，有一种替代的语法你可能更愿意使用：
使用替代语法定义任务
build.gradle
1tasks.create(name: &amp;#39;hello&amp;#39;) &amp;lt;&amp;lt; { 2 println &amp;#34;hello&amp;#34; 3tasks.create(name: &amp;#39;copy&amp;#39;, type: Copy) { 4 from(file(&amp;#39;srcDir&amp;#39;)) 5 into(buildDir) 6} 在这里我们将任务添加到 tasks 集合。关于 create() 方法的更多变化可以看看 TaskContainer。</description></item><item><title>十四、Groovy 范围</title><link>https://www.shellio.cc/docs/java/groovy/14/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/groovy/14/</guid><description>范围是指定值序列的速记。范围由序列中的第一个和最后一个值表示，Range可以是包含或排除。包含范围包括从第一个到最后一个的所有值，而独占范围包括除最后一个之外的所有值。这里有一些范例文字的例子 –
1..10 – 包含范围的示例 1 .. &amp;lt;10 – 独占范围的示例 ‘a’..’x’ – 范围也可以由字符组成 10..1 – 范围也可以按降序排列 ‘x’..’a’ – 范围也可以由字符组成并按降序排列。 以下是可用于范围的各种方法。
序号 方法和描述 1 contains()
检查范围是否包含特定值
2 get()
返回此范围中指定位置处的元素。
3 getFrom()
获得此范围的下限值。 4 getTo()
获得此范围的上限值。 5 isReverse()
这是一个反向的范围，反向迭代
6 size()
返回此范围的元素数。 7 subList()
返回此指定的fromIndex（包括）和toIndex（排除）之间的此范围部分的视图</description></item><item><title>十四、Hibernate 查询语言</title><link>https://www.shellio.cc/docs/java/hibernate/14/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/hibernate/14/</guid><description>查询语言 Hibernate 查询语言（HQL）是一种面向对象的查询语言，类似于 SQL，但不是去对表和列进行操作，而是面向对象和它们的属性。 HQL 查询被 Hibernate 翻译为传统的 SQL 查询从而对数据库进行操作。
尽管你能直接使用本地 SQL 语句，但我还是建议你尽可能的使用 HQL 语句，以避免数据库关于可移植性的麻烦，并且体现了 Hibernate 的 SQL 生成和缓存策略。
在HQL 中一些关键字比如 SELECT ，FROM 和 WHERE 等，是不区分大小写的，但是一些属性比如表名和列名是区分大小写的。
FROM 语句 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 如果你想要在存储中加载一个完整并持久的对象,你将使用 FROM 语句。以下是 FROM 语句的一些简单的语法：
1String hql = &amp;#34;FROM Employee&amp;#34;; 2Query query = session.createQuery(hql); 3List results = query.list(); 如果你需要在 HQL 中完全限定类名，只需要指定包和类名，如下：
1String hql = &amp;#34;FROM com.hibernatebook.criteria.Employee&amp;#34;; 2Query query = session.createQuery(hql); 3List results = query.list(); AS 语句 在HQL 中 AS 语句能够用来给你的类分配别名，尤其是在长查询的情况下。例如，我们之前的例子，可以用如下方式展示：</description></item><item><title>十四、Java 8 Nashorn JavaScript</title><link>https://www.shellio.cc/docs/java/java8/14/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/java8/14/</guid><description>对于Java 中的 JavaScript 引擎， Java 8 引入了 Nashorn 来代替原先的 Rhino。
Nashorn 使用 Java 7 中引入的调用动态特性，且直接编译内存中的代码并将字节码传递给 JVM。这两项改进，直接给 Nashorn 带了至少 2 到 10 倍的性能提升。
jjs 在Nashorn JavaScript 引擎中。JAVA 8 引入了一个新的命令行工具 jjs，用于在控制台执行 javascript 代码。
例如我们可以在当前目录下 ( 任意位置 ) 创建一个 JavaScript 文件 hello.js ，然后输入以下内容
1print(&amp;#39;你好，DDKK.COM 弟弟快看，程序员编程资料站，教程 ！&amp;#39;); 保存文件后，使用下面的 jjs 命令运行它
1jjs hello.js 运行结果如下
1[penglei@ddkk.com helloworld]$ jjs hello.js 2你好，DDKK.COM 弟弟快看，程序员编程资料站，教程 ！ jjs 交互式解释器 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 我们也可以直接在命令行中输出 jjs 进入 Java 8 提供的 jjs 交互式解释器。
1[penglei@ddkk.com helloworld]$ jjs 2jjs&amp;gt; 然后输入一些 JavaScript 语句，就会立即显示结果</description></item><item><title>十四、Java 9 新特性 – 内部类的方块操作符</title><link>https://www.shellio.cc/docs/java/java9/14/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/java9/14/</guid><description>方块操作符 ( &amp;lt;&amp;gt; ) 在 Java 7 中就引入了，目的是为了使代码更可读。
但是呢，这个操作符一直不能在匿名内部类中使用
Java 9 修正了这个问题，就是可以在匿名内部类中使用方块操作符了，在匿名类大行其道的今天，这才叫优化了阅读体验…
我们来看看一段 Java 9 之前的代码
DiamondOperatorTester.java 1public class DiamondOperatorTester { 2 public static void main(String[] args) { 3 Handler&amp;lt;Integer&amp;gt; intHandler = new Handler&amp;lt;Integer&amp;gt;(1) { 4 @Override 5 public void handle() { 6 System.out.println(content); 7 } 8 }; 9 intHandler.handle(); 10 Handler&amp;lt;? extends Number&amp;gt; intHandler1 = new Handler&amp;lt;Number&amp;gt;(2) { 11 @Override 12 public void handle() { 13 System.out.println(content); 14 } 15 }; 16 intHandler1.</description></item><item><title>十四、JSP 过滤器</title><link>https://www.shellio.cc/docs/java/jsp/14/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/jsp/14/</guid><description>JSP 过滤器 Servlet和JSP中的过滤器都是Java类，它们存在的目的如下：
在请求访问后端资源时拦截它 管理从服务器返回给客户端的响应 下面列出了多种常用的过滤器类型：
认证过滤器 数据压缩过滤器 加密过滤器 触发资源访问事件的过滤器 图像转换过滤器 登录和验证过滤器 MIME类型链过滤器 令牌过滤器 转换XML内容的XSL/T过滤器 过滤器将会被插入进web.xml文件中，然后映射servlet、JSP文件的名字，或URL模式。部署描述文件web.xml可以在 \conf 目录下找到。
当JSP容器启动网络应用程序时，它会创建每一个过滤器的实例，这些过滤器必须在部署描述文件web.xml中声明，并且按声明的顺序执行。
Servlet过滤器方法 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 一个过滤器就是一个Java类，它实现了javax.servlet.Filter 接口。javax.servlet.Filter接口定义了三个方法：
序号 方法 &amp;amp;描述 1 public void doFilter (ServletRequest, ServletResponse, FilterChain)
每当 request/response要通过过滤链时容器会调用这个方法，因为客户端请求链尾的资源
2 public void init(FilterConfig filterConfig)
容器调用这个方法来表明一个过滤器被安置在服务中
3 public void destroy()
容器调用这个方法来表明一个过滤器正在从服务中移除
JSP过滤器示例 这个例子将会打印IP地址和每次访问JSP文件的日期时间。当然，这只是个简单的例子，让您了解一些简单的过滤器用法，但是可以使用这些概念来自行构造更复杂的程序。
1// 引入Java包 2import java.io.*; 3import javax.servlet.*; 4import javax.servlet.http.*; 5import java.util.*; 6// 实现 Filter 类 7public class LogFilter implements Filter { 8 public void init(FilterConfig config) 9 throws ServletException{ 10 // 获取初始化参数 11 String testParam = config.</description></item><item><title>十四、JUnit – 参数化测试</title><link>https://www.shellio.cc/docs/java/junit/14/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/junit/14/</guid><description>JUnit – 参数化测试 Junit 4 引入了一个新的功能参数化测试。参数化测试允许开发人员使用不同的值反复运行同一个测试。你将遵循 5 个步骤来创建参数化测试。
用 @RunWith(Parameterized.class) 来注释 test 类。 创建一个由 @Parameters 注释的公共的静态方法，它返回一个对象的集合(数组)来作为测试数据集合。 创建一个公共的构造函数，它接受和一行测试数据相等同的东西。 为每一列测试数据创建一个实例变量。 用实例变量作为测试数据的来源来创建你的测试用例。 一旦每一行数据出现测试用例将被调用。让我们看看活动中的参数化测试。
创建一个类 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 在 C:\ &amp;gt; JUNIT_WORKSPACE 创建一个叫做 PrimeNumberChecker.java 的 java 类来测试。 1public class PrimeNumberChecker { 2 public Boolean validate(final Integer primeNumber) { 3 for (int i = 2; i &amp;lt; (primeNumber / 2); i++) { 4 if (primeNumber % i == 0) { 5 return false; 6 } 7 } 8 return true; 9 } 创建 Parameterized Test Case 类 创建一个叫做 PrimeNumberCheckerTest.</description></item><item><title>十四、Maven 构建自动化</title><link>https://www.shellio.cc/docs/java/maven/14/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/maven/14/</guid><description>Maven – 构建自动化 构建自动化定义为一种场景：一旦该工程成功构建完成，其相关的依赖工程即开始构建，目的是为了保证其依赖项目的稳定。
实例 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 考虑一个团队正在开发一个关于总线核心 Api（称其为 bus-core-api）的工程，依赖它的工程有 2 个，分别为网页 UI（称其为 app-web-ui）和应用程序桌面 UI（称其为 app-desktop-ui）。
app-web-ui 工程使用 1.0-SNAPSHOT 总线核心 Api 工程，其 POM 文件如下：
1&amp;lt;project xmlns=&amp;#34;http://maven.apache.org/POM/4.0.0&amp;#34; 2 xmlns:xsi=&amp;#34;http://www.w3.org/2001/XMLSchema-instance&amp;#34; 3 xsi:schemaLocation=&amp;#34;http://maven.apache.org/POM/4.0.0 4 http://maven.apache.org/xsd/maven-4.0.0.xsd&amp;#34;&amp;gt; 5 &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt; 6 &amp;lt;groupId&amp;gt;app-web-ui&amp;lt;/groupId&amp;gt; 7 &amp;lt;artifactId&amp;gt;app-web-ui&amp;lt;/artifactId&amp;gt; 8 &amp;lt;version&amp;gt;1.0&amp;lt;/version&amp;gt; 9 &amp;lt;packaging&amp;gt;jar&amp;lt;/packaging&amp;gt; 10 &amp;lt;dependencies&amp;gt; 11 &amp;lt;dependency&amp;gt; 12 &amp;lt;groupId&amp;gt;bus-core-api&amp;lt;/groupId&amp;gt; 13 &amp;lt;artifactId&amp;gt;bus-core-api&amp;lt;/artifactId&amp;gt; 14 &amp;lt;version&amp;gt;1.0-SNAPSHOT&amp;lt;/version&amp;gt; 15 &amp;lt;/dependency&amp;gt; 16 &amp;lt;/dependencies&amp;gt; 17&amp;lt;/project&amp;gt; app-desktop-ui 工程也正在使用 1.0-SNAPSHOT 总线核心 Api 工程，其 POM 文件如下：
1&amp;lt;project xmlns=&amp;#34;http://maven.apache.org/POM/4.0.0&amp;#34; 2 xmlns:xsi=&amp;#34;http://www.w3.org/2001/XMLSchema-instance&amp;#34; 3 xsi:schemaLocation=&amp;#34;http://maven.</description></item><item><title>十四、Memcached delete 命令</title><link>https://www.shellio.cc/docs/java/memcached/14/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/memcached/14/</guid><description>Memcached delete 命令用于删除已存在的 key(键)
语法： 1delete key [noreply] key ： 键值对 key-value 结构中的 key，用于查找缓存值 noreply: 可选, 该参数告知服务器不需要返回数据 删除成功时返回 DELETED
范例 我们先设置 site 的值为 ddkk.com ,存活时间 1000 秒，然后使用 delete 命令删除
1flush_all 2OK 3set site 0 1000 11 4ddkk.com 5STORED 6get site 7VALUE site 0 11 8ddkk.com 9END 10delete site 11DELETED 12get site 13END 删除一个不存在的键(key) 会返回 NOT_FOUND key不存在信息
1flush_all 2OK 3delete site 4NOT_FOUND</description></item><item><title>十五、2.3 configRoute(Routes me)</title><link>https://www.shellio.cc/docs/java/jfinal/15/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/jfinal/15/</guid><description>此方法用来配置 JFinal 访问路由，如下代码配置了将”/hello”映射到 HelloController 这个控 制器 ， 通 过 以 下 的 配 置 ， http://localhost/hello 将 访 问 HelloController.index() 方法， 而 http://localhost/hello/methodName 将访问到 HelloController.methodName()方法。
public void configRoute(Routes me)
{ me.add(“/hello”,
HelloController.class);
Routes 类主要有如下两个方法：
public Routes add(String controllerKey, Class&amp;lt;? **extends** Controller&amp;gt;
controllerClass, String viewPath)
public Routes add(String controllerKey, Class&amp;lt;? extends Controller&amp;gt;
controllerClass)
第一个参数 controllerKey 是指访问某个 Controller 所需要的一个字符串，该字符串唯一对 应一个 Controller，controllerKey 仅能定位到 Controller。第二个参数 controllerClass 是该 controllerKey 所对应到的 Controller。第三个参数 viewPath 是指该 Controller 返回的视图的相对 路径(该参数具体细节将在 Controller 相关章节中给出)。当 viewPath 未指定时默认值为 controllerKey。</description></item><item><title>十五、Gradle 使用文件</title><link>https://www.shellio.cc/docs/java/gradle/15/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/gradle/15/</guid><description>使用文件 大多数构建工作都要使用到文件。Gradle 添加了一些概念和 API 来帮助您实现这一目标。
定位文件 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 你可以使用 Project.file()方法来找到一个相对于项目目录的文件 。
查找文件
build.gradle
1// Using a relative path 2File configFile = file(&amp;#39;src/config.xml&amp;#39;) 3// Using an absolute path 4configFile = file(configFile.absolutePath) 5// Using a File object with a relative path 6configFile = file(new File(&amp;#39;src/config.xml&amp;#39;)) 您可以把任何对象传递给 file()方法，而它将尝试将其转换为一个绝对路径的 File 对象。通常情况下，你会传给它一个 String 或 File 的实例。而所提供的这个对象的 tostring() 方法的值会作为文件路径。如果这个路径是一个绝对路径，它会用于构构一个 File 实例。否则，会通过先计算所提供的路径相对于项目目录的相对路径来构造 File 实例。这个 file()方法也可以识别URL，例如是 file:/some/path.xml。
这是把一些用户提供的值转换为一个相对路径的 File 对象的有用方法。由于 file()方法总是去计算所提供的路径相对于项目目录的路径，最好是使用 new File(somePath)，因为它是一个固定的路径，而不会因为用户运行 Gradle 的具体工作目录而改变。
文件集合 一个文件集合只是表示一组文件。它通过 FileCollection 接口来表示。Gradle API 中的许多对象都实现了此接口。比如，依赖配置 就实现了 FileCollection 这一接口。</description></item><item><title>十五、Groovy 列表</title><link>https://www.shellio.cc/docs/java/groovy/15/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/groovy/15/</guid><description>列表是用于存储数据项集合的结构。在Groovy中，List保存了一系列对象引用。List中的对象引用占据序列中的位置，并通过整数索引来区分。列表文字表示为一系列用逗号分隔并用方括号括起来的对象。
要处理列表中的数据，我们必须能够访问各个元素。 Groovy列表使用索引操作符[]索引。列表索引从零开始，这指的是第一个元素。
以下是一些列表的示例 –
[11，12，13，14] – 整数值列表 [’Angular’，’Groovy’，’Java’] – 字符串列表 [1，2，[3，4]，5] – 嵌套列表 [’Groovy’，21，2.11] – 异构的对象引用列表 [] – 一个空列表 在本章中，我们将讨论Groovy中可用的列表方法。
序号 方法和描述 1 add() 将新值附加到此列表的末尾。
2 contains() 如果此列表包含指定的值，则返回true。
3 get() 返回此列表中指定位置的元素。
4 isEmpty() 如果此列表不包含元素，则返回true
5 minus() 创建一个由原始元素组成的新列表，而不是集合中指定的元素。
6 plus() 创建由原始元素和集合中指定的元素组成的新列表。
7 pop() 从此列表中删除最后一个项目
8 remove() 删除此列表中指定位置的元素。 9 reverse() 创建与原始列表的元素相反的新列表
10 size() 获取此列表中的元素数。
11 sort() 返回原始列表的排序副本。</description></item><item><title>十五、Hibernate 标准查询</title><link>https://www.shellio.cc/docs/java/hibernate/15/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/hibernate/15/</guid><description>标准查询 Hibernate 提供了操纵对象和相应的 RDBMS 表中可用的数据的替代方法。一种方法是标准的 API，它允许你建立一个标准的可编程查询对象来应用过滤规则和逻辑条件。
Hibernate Session 接口提供了 createCriteria() 方法，可用于创建一个 Criteria 对象，使当您的应用程序执行一个标准查询时返回一个持久化对象的类的实例。
以下是一个最简单的标准查询的例子，它只是简单地返回对应于员工类的每个对象：
1Criteria cr = session.createCriteria(Employee.class); 2List results = cr.list(); 对标准的限制 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 你可以使用 Criteria 对象可用的 add() 方法去添加一个标准查询的限制。
以下是一个示例，它实现了添加一个限制，令返回工资等于 2000 的记录：
1Criteria cr = session.createCriteria(Employee.class); 2cr.add(Restrictions.eq(&amp;#34;salary&amp;#34;, 2000)); 3List results = cr.list(); 以下是几个例子，涵盖了不同的情况，可按要求进行使用：
1Criteria cr = session.createCriteria(Employee.class); 2// To get records having salary more than 2000 3cr.add(Restrictions.gt(&amp;#34;salary&amp;#34;, 2000)); 4// To get records having salary less than 2000 5cr.add(Restrictions.lt(&amp;#34;salary&amp;#34;, 2000)); 6// To get records having fistName starting with zara 7cr.</description></item><item><title>十五、Java 8 新日期时间 API ( 上 ) – 本地日期时间</title><link>https://www.shellio.cc/docs/java/java8/15/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/java8/15/</guid><description>作为开发者，经常需要处理日期时间。如果你跟随者 Java 5 一路走来，那么一定会对 java.util.Date 、java.util.Calendar 、java.util.GregoiranCalendar 和 java.text.SimpleDateFormat 四大类非常熟悉，它们分别用于处理日期、日历、日历表示、日期时间格式化。
这四个类，对于编程老人来讲，应该是习惯了，但对于编程新人来讲，就有好多疑问，有好多陷阱和坑等着它们跳，比如
1、 非线程安全：java.util.Date并不是线程安全的开发者在使用这个类时必须自己处理多线程并发问题；
2、 设计不佳：一方面日期和日期格式化分布在多个包中另一方面，java.util.Date的默认日期，年竟然是从1900开始，月从1开始，日从0开始，没有统一性而且Date类也缺少直接操作日期的相关方法；
3、 时区处理困难：因为设计不佳，开发人员不得不编写大量代码来处理时区问题；
4、 还有其它一些问题；
面对种种问题，Java 8 终于重新设计了所有日期时间、日历及时区相关的 API。并把它们都统一放置在 java.time 包和子包下。并作出了以下改进
1、 新的日期时间API是线程安全的不仅没有setter方法，而且任何对实例的变更都会返回一个新的实例而保证原来的实例不变；
2、 新的日期时间API提供了大量的方法，用于修改日期时间的各个部分，并返回一个新的实例；
3、 在时区方面，新的日期时间API引入了域(domain)这个概念；
同时Java 8 还针对原来复杂的 API 进行重新组合和拆分，分成了好多个类。本章接下来的章节，我们就来详细介绍其中几个最重要的。
本地日期时间 API Java 8 为处理本地的日期时间提供了三个类 LocalDate 、LocalTime 和 LocalDateTime。分别用于处理 本地日期、本地时间 和 本地日期时间。
当使用这三个类时，开发者并不需要关心时区是什么。因为它默认使用的是操作系统的时区。
比如，可以使用 LocalDateTime.now() 方法返回当前的日期时间。
Java8Tester.java 1import java.time.LocalDateTime; 2public class Java8Tester { 3 public static void main(String args[]) { 4 Java8Tester tester = new Java8Tester(); 5 tester.</description></item><item><title>十五、Java 9 新特性 – Option 类</title><link>https://www.shellio.cc/docs/java/java9/15/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/java9/15/</guid><description>其实Option 类在 Java 8 中就引入了，用于避免 null 检查和 NullPointerException 指针问题
Java 9 中，又为该类添加了三个方法来改进它的功能
方法 说明 stream() 返回包含值的流，如果值不存在，则返回空流 ifPresentOrElse() 如果值存在则对值执行一些操作，否则执行另一个操作 or() 如果值存在，则返回用于描述该值的 Option，如果不存在则生成一个值 steam() 方法 steam() 方法的原型如下
1public Optional&amp;lt;T&amp;gt; or(Supplier&amp;lt;? extends Optional&amp;lt;? extends T&amp;gt;&amp;gt; supplier) 如果值存在，则返回包含值的有序的流，如果值不存在，则返回一个空流
范例 在我们的工作目录，创建一个文件 OptionStreamTester.java 并输入以下内容
1import java.util.Arrays; 2import java.util.List; 3import java.util.Optional; 4import java.util.stream.Collectors; 5import java.util.stream.Stream; 6public class OptionStreamTester { 7public static void main(String[] args) { 8 List&amp;lt;Optional&amp;lt;String&amp;gt;&amp;gt; list = Arrays.asList ( 9 Optional.empty(), 10 Optional.of(&amp;#34;A&amp;#34;), 11 Optional.empty(), 12 Optional.</description></item><item><title>十五、JSP Cookies 处理</title><link>https://www.shellio.cc/docs/java/jsp/15/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/jsp/15/</guid><description>JSP Cookies 处理 Cookies是存储在客户机的文本文件，它们保存了大量轨迹信息。在servlet技术基础上，JSP显然能够提供对HTTP cookies的支持。
通常有三个步骤来识别回头客：
服务器脚本发送一系列cookies至浏览器。比如名字，年龄，ID号码等等。 浏览器在本地机中存储这些信息，以备不时之需。 当下一次浏览器发送任何请求至服务器时，它会同时将这些cookies信息发送给服务器，然后服务器使用这些信息来识别用户或者干些其它事情。 本章节将会传授您如何去设置或重设cookie的方法，还有如何访问它们及如何删除它们。
Cookie剖析 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 Cookies通常在HTTP信息头中设置（虽然JavaScript能够直接在浏览器中设置cookies）。在JSP中，设置一个cookie需要发送如下的信息头给服务器：
1HTTP/1.1 200 OK 2Date: Fri, 04 Feb 2000 21:03:38 GMT 3Server: Apache/1.3.9 (UNIX) PHP/4.0b3 4Set-Cookie: name=xyz; expires=Friday, 04-Feb-07 22:03:38 GMT; 5 path=/; domain=tutorialspoint.com 6Connection: close 7Content-Type: text/html 正如您所见，Set-Cookie信息头包含一个键值对，一个GMT（格林尼治标准）时间，一个路径，一个域名。键值对会被编码为URL。有效期域是个指令，告诉浏览器在什么时候之后就可以清除这个cookie。
如果浏览器被配置成可存储cookies，那么它将会保存这些信息直到过期。如果用户访问的任何页面匹配了cookie中的路径和域名，那么浏览器将会重新将这个cookie发回给服务器。浏览器端的信息头长得就像下面这样：
1GET / HTTP/1.0 2Connection: Keep-Alive 3User-Agent: Mozilla/4.6 (X11; I; Linux 2.2.6-15apmac ppc) 4Host: zink.demon.co.uk:1126 5Accept: image/gif, */* 6Accept-Encoding: gzip 7Accept-Language: en 8Accept-Charset: iso-8859-1,*,utf-8 9Cookie: name=xyz JSP脚本通过request对象中的getCookies()方法来访问这些cookies，这个方法会返回一个Cookie对象的数组。
Servlet Cookies 方法 下表列出了Cookie对象中常用的方法：</description></item><item><title>十五、JUnit – ANT 插件</title><link>https://www.shellio.cc/docs/java/junit/15/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/junit/15/</guid><description>JUnit – ANT 插件 在这个例子中，我们将展示如何使用 ANT 运行 JUnit。让我们跟随以下步骤：
步骤 1:下载 Apache Ant 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 下载 Apache ANT
操作系统 文件名 Windows apache-ant-1.8.4-bin.zip Linux apache-ant-1.8.4-bin.tar.gz Mac apache-ant-1.8.4-bin.tar.gz 步骤 2:设置 Ant 环境 设置 ANT_HOME 环境变量来指向 ANT 函数库在机器中存储的基本文件地址。例如，我们已经在不同的操作系统的 apache-ant-1.8.4 文件夹中存储了 ANT 函数库。
操作系统 输出 Windows 在 C:\Program Files\Apache Software Foundation
\apache-ant-1.8.4 中设置环境变量 ANT_HOME Linux 导出 ANT_HOME=/usr/local/\apache-ant-1.8.4 Mac export ANT_HOME=/Library/\apache-ant-1.8.4 附加ANT 编译器地址到系统路径，对于不同的操作系统来说如下所示：
操作系统 输出 Windows 附加字符串 ;%ANT_HOME\bin to the end of the
system variable, Path. Linux 导出 PATH=$PATH:$ANT_HOME/bin/ Mac 不需要 步骤 3:下载 Junit Archive 下载 JUnit Archive</description></item><item><title>十五、Maven 管理依赖</title><link>https://www.shellio.cc/docs/java/maven/15/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/maven/15/</guid><description>Maven – 依赖管理 Maven 核心特点之一是依赖管理。一旦我们开始处理多模块工程（包含数百个子模块或者子工程）的时候，模块间的依赖关系就变得非常复杂，管理也变得很困难。针对此种情形，Maven 提供了一种高度控制的方法。
传递依赖发现 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 这种情形经常可见，当一个库 A 依赖于其他库 B. 另一工程 C 想要使用库 A, 那么该工程同样也需要使用到库 B。
Maven 可以避免去搜索所有需要的库资源的这种需求。通过读取工程文件（pom.xml）中的依赖项，Maven 可以找出工程之间的依赖关系。
我们只需要在每个工程的 pom 文件里去定义直接的依赖关系。Maven 则会自动的来接管后续的工作。
通过传递依赖，所有被包含的库的图形可能会快速的增长。当重复的库存在时，可能出现的情形将会持续上升。Maven 提供一些功能来控制可传递的依赖的程度。
功能 功能描述 依赖调节 决定当多个手动创建的版本同时出现时，哪个依赖版本将会被使用。 如果两个依赖版本在依赖树里的深度是一样的时候，第一个被声明的依赖将会被使用。 依赖管理 直接的指定手动创建的某个版本被使用。例如当一个工程 C 在自己的以来管理模块包含工程 B，即 B 依赖于 A， 那么 A 即可指定在 B 被引用时所使用的版本。 依赖范围 包含在构建过程每个阶段的依赖。 依赖排除 任何可传递的依赖都可以通过 “exclusion” 元素被排除在外。举例说明，A 依赖 B， B 依赖 C，因此 A 可以标记 C 为 “被排除的”。 依赖可选 任何可传递的依赖可以被标记为可选的，通过使用 “optional” 元素。例如：A 依赖 B， B 依赖 C。因此，B 可以标记 C 为可选的， 这样 A 就可以不再使用 C。 依赖范围 传递依赖发现可以通过使用如下的依赖范围来得到限制：</description></item><item><title>十五、Memcached incr 与 decr 命令</title><link>https://www.shellio.cc/docs/java/memcached/15/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/memcached/15/</guid><description>Memcached incr 命令用于对已存在的 key(键) 的数字值进行自增操作
语法 1incr key increment_value key ： 键值 key-value 结构中的 key，用于查找缓存值 increment_value ： 需要增加的数值 incr 命令操作的数据必须是十进制的32位无符号整数
返回值 如果 key 不存在返回 NOT_FOUND 如果 key 的值不为数字，则返回 CLIENT_ERROR 其他错误返回 ERROR 范例 下面的范例，我们使用 countdown 作为 key，初始值为 5，之后进行加 5 操作
1set countdown 0 1000 1 2STORED 3incr countdown 5 410 5get countdown 6VALUE countdown 0 2 710 8END 如果 key 不存在 如果key 不存在，那么返回 NOT_FOUND key 不存在错误
1flush_all 2OK 3incr age 5 4NOT_FOUND 如果 key 的值不为数字 如果key 的值不为数字,那么返回 CLIENT_ERROR 自增值不是数字错误</description></item><item><title>十一、1.6 开启浏览器看效果</title><link>https://www.shellio.cc/docs/java/jfinal/11/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/jfinal/11/</guid><description>打开浏览器在地址栏中输入: http://localhost/hello，输出内容为 Hello JFinal World 证明项目 框架搭建完成。如需完整 demo 示例可在 JFinal 官方网站下载：http://www.jfinal.com
注意：在 tomcat 下开发或运行项目时，需要先删除 jetty-server-xxx.jar 这个包，否则会引起冲 突。 Tomcat 启动项目不能使用上面介绍的启动方式，因为上面的启动方式需要用到jetty-server-xxx.jar。</description></item><item><title>十一、Gradle 使用 Gradle 图形用户界面</title><link>https://www.shellio.cc/docs/java/gradle/11/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/gradle/11/</guid><description>使用 Gradle 图形用户界面 除了支持传统的命令行界面，Gradle 也提供了一个图形用户界面（GUI）。这是一个独立的用户界面，可以通过加上 –gui 参数来启动。
Launching the GUI 1gradle --gui 注意：此命令行窗口被将锁定，直到 Gradle GUI 被关闭。如果是在 linux/unix 系统下，则可以通过(gradle –gui&amp;amp;)让它作为后台任务运行。
如果你在你的 Gradle 项目目录下运行 Gradle GUI，你应该会看到一个任务树。
GUI Task Tree
最好是从 Gradle 项目目录运行此命令，这样对 UI 的设置就可以存储在你的项目目录中。当然，你也可以先运行它，然后通过在 UI 中的设置（Setup）选项卡，改变工作目录。
在Gradle 的用户界面（UI）中，上面是 4 个选项卡，下面则是输出窗口。
任务树 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 任务树显示了所有项目和它们的任务的层次结构。双击一个任务可以执行它。
这里还提供了一个过滤器，可以把比较少用的任务隐藏。你可以通过过滤器（Filter）按钮切换是否进行过滤。通过编辑过滤器，你可以对哪些任务和项目要显示进行配置。隐藏的任务显示为红色。注意：新创建的任务默认情况下是显示状态（而不是隐藏状态）
任务树的上下文菜单会提供以下选项：
执行忽略依赖关系。这使得重新构建时不去依赖项目（与 -a 选项一样） 将任务添加到收藏夹（见收藏夹（Favourites）选项卡） 隐藏选择的任务。这将会把它们添加到过滤器中。 编辑 build.gradle 文件。注意：该操作需要 Java 1.6 或更高的版本，并且要求在你的操作系统中关联 gradle 文件。 收藏夹 收藏夹选项卡用来储存经常执行的命令。这些命令可以是复杂的命令（只要它们符合 Gradle 的语法），你可以给它们设置一个显示名称。它用于创建一个自定义的命令，来显示地跳过测试，文档，例子。你可以称之为“快速构建”。
你可以根据自己的喜好，对收藏夹进行排序，甚至可以把它们导出到磁盘，并在其他地方导入。如果你在编辑它们的时候，选上“始终显示实时输出”，它只有在你选上“当发生错误时才显示输出”时有效。它会始终强制显示输出。
命令行 命令行选项卡是直接执行单个的 Gradle 命令的地方。你只需要输入命令行中你经常在“Gradle”后面输入的命令即可。它也对要添加到收藏夹的命令提供了先去尝试的地方。
设置 设置（Setup）选项卡允许你配置一些常规的设置
GUI Setup</description></item><item><title>十一、Groovy 可选</title><link>https://www.shellio.cc/docs/java/groovy/11/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/groovy/11/</guid><description>Groovy是一个“可选”类型的语言，当理解语言的基本原理时，这种区别是一个重要的语言。与Java相比，Java是一种“强”类型的语言，由此编译器知道每个变量的所有类型，并且可以在编译时理解和尊重合同。这意味着方法调用能够在编译时确定。
当在Groovy中编写代码时，开发人员可以灵活地提供类型或不是类型。这可以提供一些简单的实现，并且当正确利用时，可以以强大和动态的方式为您的应用程序提供服务。
在Groovy中，可选的键入是通过’def’关键字完成的。下面是一个使用def方法的例子 –
1class Example { 2 static void main(String[] args) { 3 // Example of an Integer using def 4 def a = 100; 5 println(a); 6 // Example of an float using def 7 def b = 100.10; 8 println(b); 9 // Example of an Double using def 10 def c = 100.101; 11 println(c); 12 // Example of an String using def 13 def d = &amp;#34;HelloWorld&amp;#34;; 14 println(d); 15 } 16} 从上面的程序，我们可以看到，我们没有声明单个变量为Integer，float，double或string，即使它们包含这些类型的值。</description></item><item><title>十一、Hibernate 例子</title><link>https://www.shellio.cc/docs/java/hibernate/11/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/hibernate/11/</guid><description>例子 让我们看一个独立应用程序利用 Hibernate 提供 Java 持久性的例子。我们将通过不同的步骤使用 Hibernate 技术创建 Java 应用程序。
创建 POJO 类 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 创建应用程序的第一步就是建立 Java 的 POJO 类或者其它类，这取决于即将要存放在数据库中的应用程序。我们可以考虑一下让我们的 Employee 类使用 getXXX 和 setXXX 方法从而使它们变成符合 JavaBeans 的类。
POJO (Plain Old Java Object) 是 Java 的一个对象，这种对象不会扩展或者执行一些特殊的类并且它的接口都是分别在 EJB 框架的要求下的。所有正常的 Java 对象都是 POJO。
当你设计一个存放在 Hibernate 中的类时，最重要的是提供支持 JavaBeans 的代码和在 Employee 类中像 id 属性一样可以当做索引的属性。
1public class Employee { 2 private int id; 3 private String firstName; 4 private String lastName; 5 private int salary; 6 public Employee() {} 7 public Employee(String fname, String lname, int salary) { 8 this.</description></item><item><title>十一、Java 8 接口静态方法</title><link>https://www.shellio.cc/docs/java/java8/11/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/java8/11/</guid><description>本章节我们来讨论下 java.util.concurrent.CountDownLatch 这个类，顺带演示下如何在一些实际例子中使用它。
CountDownLatch 类的作用呢？ 怎么说呢？ 简单来说，我们可以使用它来阻塞线程，直到其他线程完成给定任务。
并发编程中使用 CountDownLatch 简而言之，CountDownLatch 有一个计数器字段，我们可以根据需要减少它，因此，我们可以使用它来阻止调用线程，直到它被计数到零。
如果我们正在进行一些并行处理，我们可以使用与计数器相同的值来实例化 CountDownLatch，因为我们想要处理多个线程。然后，我们可以在每个线程完成后调用 countdown()，保证调用 await() 的依赖线程将阻塞，直到工作线程完成。
使用 CountDownLatch 等待线程池完成 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 我们通过创建一个 Worker 来尝试这个模式，并使用 CountDownLatch 字段来指示它何时完成
1public class Worker implements Runnable { 2 private List&amp;lt;String&amp;gt; outputScraper; 3 private CountDownLatch countDownLatch; 4 public Worker(List&amp;lt;String&amp;gt; outputScraper, CountDownLatch countDownLatch) { 5 this.outputScraper = outputScraper; 6 this.countDownLatch = countDownLatch; 7 } 8 @Override 9 public void run() { 10 doSomeWork(); 11 outputScraper.add(&amp;#34;Counted down&amp;#34;); 12 countDownLatch.</description></item><item><title>十一、Java 9 新特性 – 增强流 ( Stream ) API</title><link>https://www.shellio.cc/docs/java/java9/11/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/java9/11/</guid><description>Java 中引入了流 ( Stream ) 的概念，真的是大大方便了我们 java 程序员，我们可以使用流从一系列对象中执行聚合操作。
其实，Java 8 中的流已经很强大了，而且只要涉及到 IO，只要涉及到对一系列数据进行操作，几乎都有流的影子。
当然了，Java 9 还不忘对其继续增强，这次的改进主要是如何设置停止流的条件上。为此在流的实例上提供了四个方法 takeWhile(Predicate Interface) 、iterate 、ofNullable 和 dropWhile(Predicate Interface)
takeWhile(Predicate Interface) takeWhile(Predicate Interface) 方法会处理流中所有的数据，直到条件 predicate 返回 false 为止
该方法的原型如下
1default Stream&amp;lt;T&amp;gt; takeWhile(Predicate&amp;lt;? super T&amp;gt; predicate) takeWhile() 方法会返回一个有序的流 ( stream ) ，返回的流中包含了原始流中于给定条件 predicate 相匹配的所有元素的最长前缀。
注意： 并不是所有匹配的元素，而是最长匹配前缀，因为一旦某个元素的 pridicate 返回 false，就立刻停止了
范例 在当前工作区创建一个文件 StreamTakeWhileTester.java ，并输入以下代码
1import java.util.stream.Stream; 2public class StreamTakeWhileTester{ 3 public static void main(String[] args) 4 { 5 Stream.of(&amp;#34;I&amp;#34;,&amp;#34;love&amp;#34;,&amp;#34;you&amp;#34;,&amp;#34;&amp;#34;,&amp;#34;so&amp;#34;,&amp;#34;much&amp;#34;).takeWhile(s-&amp;gt;!s.isEmpty()) 6 .</description></item><item><title>十一、JSP 服务器响应</title><link>https://www.shellio.cc/docs/java/jsp/11/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/jsp/11/</guid><description>JSP 服务器响应 Response响应对象主要将JSP容器处理后的结果传回到客户端。可以通过response变量设置HTTP的状态和向客户端发送数据，如Cookie、HTTP文件头信息等。
一个典型的响应看起来就像下面这样：
1HTTP/1.1 200 OK 2Content-Type: text/html 3Header2: ... 4... 5HeaderN: ... 6 (Blank Line) 7&amp;lt;!doctype ...&amp;gt; 8&amp;lt;html&amp;gt; 9&amp;lt;head&amp;gt;...&amp;lt;/head&amp;gt; 10&amp;lt;body&amp;gt; 11... 12&amp;lt;/body&amp;gt; 13&amp;lt;/html&amp;gt; 状态行包含HTTP版本信息，比如HTTP/1.1，一个状态码，比如200，还有一个非常短的信息对应着状态码，比如OK。
下表摘要出了HTTP1.1响应头中最有用的部分，在网络编程中您将会经常见到它们：
响应头 描述 Allow 指定服务器支持的request方法（GET，POST等等） Cache-Control 指定响应文档能够被安全缓存的情况。通常取值为&amp;nbsp;public，private&amp;nbsp;或no-cache&amp;nbsp;等等。 Public意味着文档可缓存，Private意味着文档只为单用户服务并且只能使用私有缓存。No-cache 意味着文档不被缓存。 Connection 命令浏览器是否要使用持久的HTTP连接。close值&amp;nbsp;命令浏览器不使用持久HTTP连接，而keep-alive 意味着使用持久化连接。 Content-Disposition 让浏览器要求用户将响应以给定的名称存储在磁盘中 Content-Encoding 指定传输时页面的编码规则 Content-Language 表述文档所使用的语言，比如en， en-us,，ru等等 Content-Length 表明响应的字节数。只有在浏览器使用持久化 (keep-alive) HTTP 连接时才有用 Content-Type 表明文档使用的MIME类型 Expires 指明啥时候过期并从缓存中移除 Last-Modified 指明文档最后修改时间。客户端可以 缓存文档并且在后续的请求中提供一个&amp;nbsp;If-Modified-Since请求头 Location 在300秒内，包含所有的有一个状态码的响应地址，浏览器会自动重连然后检索新文档 Refresh 指明浏览器每隔多久请求更新一次页面。 Retry-After 与503 (Service Unavailable)一起使用来告诉用户多久后请求将会得到响应 Set-Cookie 指明当前页面对应的cookie HttpServletResponse类 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 response对象是javax.</description></item><item><title>十一、JUnit – 忽略测试</title><link>https://www.shellio.cc/docs/java/junit/11/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/junit/11/</guid><description>JUnit – 忽略测试 有时可能会发生我们的代码还没有准备好的情况，这时测试用例去测试这个方法或代码的时候会造成失败。@Ignore 注释会在这种情况时帮助我们。
一个含有 @Ignore 注释的测试方法将不会被执行。 如果一个测试类有 @Ignore 注释，则它的测试方法将不会执行。 现在我们用例子来学习 @Ignore。
创建一个类 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 在目录 C:\ &amp;gt; JUNIT_WORKSPACE 中创建一个将被测试的 java 类命名为 MessageUtil.java。 1/* 2* This class prints the given message on console. 3*/ 4public class MessageUtil { 5 private String message; 6 //Constructor 7 //@param message to be printed 8 public MessageUtil(String message){ 9 this.message = message; 10 } 11 // prints the message 12 public String printMessage(){ 13 System.</description></item><item><title>十一、Maven 工程文档</title><link>https://www.shellio.cc/docs/java/maven/11/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/maven/11/</guid><description>Maven – 工程文档 本教程将教你如何创建应用程序的文档。那么让我们开始吧，在 C:/ MVN 目录下，创建你的 java consumerBanking 应用程序。打开 consumerBanking 文件夹并执行以下 mvn 命令。
1C:\MVN&amp;gt;mvn site Maven 将开始构建工程。
1[INFO] Scanning for projects... 2[INFO] ------------------------------------------------------------------- 3[INFO] Building consumerBanking 4[INFO]task-segment: [site] 5[INFO] ------------------------------------------------------------------- 6[INFO] [site:site {execution: default-site}] 7[INFO] artifact org.apache.maven.skins:maven-default-skin: 8checking for updates from central 9[INFO] Generating &amp;#34;About&amp;#34; report. 10[INFO] Generating &amp;#34;Issue Tracking&amp;#34; report. 11[INFO] Generating &amp;#34;Project Team&amp;#34; report. 12[INFO] Generating &amp;#34;Dependencies&amp;#34; report. 13[INFO] Generating &amp;#34;Continuous Integration&amp;#34; report. 14[INFO] Generating &amp;#34;Source Repository&amp;#34; report.</description></item><item><title>十一、Memcached CAS 命令</title><link>https://www.shellio.cc/docs/java/memcached/11/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/memcached/11/</guid><description>CAS （Check-And-Set 或 Compare-And-Swap） 又称原子指令或者原子操作
Memcached CAS 命令用于执行一个 检查并设置 的操作
它仅在当前客户端最后一次取值后，该key 对应的值没有被其他客户端修改的情况下， 才能够将值写入。
语法 1cas key flags exptime bytes unique_cas_token [noreply] 2value 通过cas_token 参数进行检查操作， 这个参数是Memcach指定给已经存在的元素的一个唯一的64位值
参数说明 key： 键值 key-value 结构中的 key，用于查找缓存值。 flags ：可以包括键值对的整型参数，Memcached 使用它存储键值对的额外信息 exptime ：缓存中键值对存活的时间长度（以秒为单位，0 表示永远） bytes ：缓存中存储的字节数 unique_cas_token 通过 gets 命令获取的一个唯一的64位值。 noreply（可选） ： 该参数告知服务器不需要返回数据 value ：存储的值（始终位于第二行）（可直接理解为key-value结构中的value） 返回 如果数据添加成功，则返回 STORED 如果出现语法错误，则返回 ERROR 最后一次取值后另外一个用户也在更新该数据，返回 EXISTS Memcached 上不存在该键，则返回 NOT_FOUND 范例 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 使用CAS 命令之前，要先用 gets 命令获取令牌（token）
使用CAS 操作的步骤一般如下：
1、 如果没有设置唯一令牌，则CAS命令执行错误；
2、 如果键key不存在，执行失败；</description></item><item><title>四、0.3 Model 与 Bean 合体后主要优势</title><link>https://www.shellio.cc/docs/java/jfinal/4/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/jfinal/4/</guid><description> 充分利用海量的针对于 Bean 设计的第三方工具，例如 jackson、freemarker 快速响应数据库表变动，极速重构，提升开发效率，提升代码质量 拥有 IDE 代码提示不用记忆数据表字段名，消除记忆负担，避免手写字段名出现手误 BaseModel 设计令 Model 中依然保持清爽，在表结构变化时极速重构关联代码 自动化 table 至 Model 映射 自动化主键、复合主键名称识别与映射 MappingKit 承载映射代码，JFinalConfig 保持干净清爽 有利于分布式场景和无数据源时使用 Model 新设计避免了以往自动扫描映射设计的若干缺点：引入新概念(如注解)增加学习成本、性 能低、jar 包扫描可靠性与安全性低</description></item><item><title>四、Gradle 问题反馈</title><link>https://www.shellio.cc/docs/java/gradle/4/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/gradle/4/</guid><description>问题反馈 当年使用 Gradle 或其它软件的时候或多或少都会遇到一些问题，或许是无法驾驭的新特性，或许是一些 bug，又抑或是关于 Gradle 一些常见问题。本章将给你一些解决问题的建议和如何获取帮助。
解决问题 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 当你遇到问题时，首先确认一下是否用的最新版本的 Gradle。最新版本总是会更加的完善并且带有更多的新特性。或许你的问题在最新版本中已经得到的解决。
如果你采用守护模式运行，那么尝试用 –no-daemon 来停掉守护模式。
获取帮助 你可以去 Gralde 官方论坛 http://forums.gradle.org 来寻求一些帮助。在这里你可以和 Gradle 的开发人员以及其他社区人员进行交流。
如果有什么搞不定了，去论坛发帖是解决问题的最佳方式。或许这对我们而言也是一些良好的改进建议。同时，开发团队也会周期性的在论坛发布一些帖子和发布最新版本。这样可以使你与 Gradle 开发团队一样时刻保持最新版本。</description></item><item><title>四、Groovy 数据类型</title><link>https://www.shellio.cc/docs/java/groovy/4/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/groovy/4/</guid><description>在任何编程语言中，需要使用各种变量来存储各种类型的信息。变量只是保留值的存储位置,这意味着，当你创建一个变量，你保留在内存中的一些空间来存储与变量相关的值。
您可能喜欢存储各种数据类型的信息，如字符串，字符，宽字符，整数，浮点数，布尔值等。基于变量的数据类型，操作系统分配内存并决定什么可以存储在保留的存储器中。
内置数据类型 Groovy提供多种内置数据类型。以下是在Groovy中定义的数据类型的列表 –
byte -这是用来表示字节值。例如2。 short -这是用来表示一个短整型。例如10。 int -这是用来表示整数。例如1234。 long -这是用来表示一个长整型。例如10000090。 float -这是用来表示32位浮点数。例如12.34。 double -这是用来表示64位浮点数，这些数字是有时可能需要的更长的十进制数表示。例如12.3456565。 char -这定义了单个字符文字。例如“A”。 Boolean -这表示一个布尔值，可以是true或false。 String -这些是以字符串的形式表示的文本。例如，“Hello World”的。 绑定值 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 下表显示了数字和小数点文字中的最大允许值。
byte -128到127 short -32,768到32,767 int 2,147,483,648 到,147,483,647 long -9,223,372,036,854,775,808到+9,223,372,036,854,775,807 float 1.40129846432481707e-45到3.40282346638528860e + 38 double 4.94065645841246544e-324d 到1.79769313486231570e + 308d 数字类 类型除了基本类型，还允许以下对象类型（有时称为包装器类型）-
java.lang.Byte java.lang.Short java.lang.Integer java.lang.Long java.lang.Float java.lang.Double 此外，以下类可用于支持高精度计算 –
名称 描述 例如 java.math.BigInteger 不可变的任意精度的有符号整数数字 30克 java.math.BigDecimal 不可变的任意精度的有符号十进制数 3.5克 以下代码示例说明如何使用不同的内置数据类型 –
1class Example { 2 static void main(String[] args) { 3 //Example of a int datatype 4 int x = 5; 5 //Example of a long datatype 6 long y = 100L; 7 //Example of a floating point datatype 8 float a = 10.</description></item><item><title>四、Hibernate 架构</title><link>https://www.shellio.cc/docs/java/hibernate/4/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/hibernate/4/</guid><description>架构 Hibernate 架构是分层的，作为数据访问层，你不必知道底层 API 。Hibernate 利用数据库以及配置数据来为应用程序提供持续性服务（以及持续性对象）。
下面是一个非常高水平的 Hibernate 应用程序架构视图。
下面是一个详细的 Hibernate 应用程序体系结构视图以及一些重要的类。
Hibernate 使用不同的现存 Java API，比如 JDBC，Java 事务 API（JTA），以及 Java 命名和目录界面（JNDI）。JDBC 提供了一个基本的抽象级别的通用关系数据库的功能， Hibernate 支持几乎所有带有 JDBC 驱动的数据库。JNDI 和 JTA 允许 Hibernate 与 J2EE 应用程序服务器相集成。
下面的部分简要地描述了在 Hibernate 应用程序架构所涉及的每一个类对象。
配置对象 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 配置对象是你在任何 Hibernate 应用程序中创造的第一个 Hibernate 对象，并且经常只在应用程序初始化期间创造。它代表了 Hibernate 所需一个配置或属性文件。配置对象提供了两种基础组件。
数据库连接：由 Hibernate 支持的一个或多个配置文件处理。这些文件是 hibernate.properties 和 hibernate.cfg.xml。 类映射设置：这个组件创造了 Java 类和数据库表格之间的联系。 SessionFactory 对象 配置对象被用于创造一个 SessionFactory 对象，使用提供的配置文件为应用程序依次配置 Hibernate，并允许实例化一个会话对象。SessionFactory 是一个线程安全对象并由应用程序所有的线程所使用。
SessionFactory 是一个重量级对象所以通常它都是在应用程序启动时创造然后留存为以后使用。每个数据库需要一个 SessionFactory 对象使用一个单独的配置文件。所以如果你使用多种数据库那么你要创造多种 SessionFactory 对象。
Session 对象 一个会话被用于与数据库的物理连接。Session 对象是轻量级的，并被设计为每次实例化都需要与数据库的交互。持久对象通过 Session 对象保存和检索。</description></item><item><title>四、Java 9 新特性 – 模块化</title><link>https://www.shellio.cc/docs/java/java9/4/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/java9/4/</guid><description>Java 9 最大的特性就是模块化 ( Module ) 了。本章，我们就对这个 模块化 进行一些简单的讲解，包括 Java 9 模块化的概念、如何实现、如何使用等
对于Java 9 来说，模块化 ( Module ) 是一个新引入的新型的编程组件 ( Component )
因为是一个组件，所以也是一个自我完备的系统，是代码和数据的自描述的集合，而且有一个自我标识的名称，也就是模块名
Java 9 模块化的特性 Java 9 为了引入新的模块化的编程方式，特意增强和改进了一些功能，也添加了一些新的特性
1、 Java程序编译运行过程中，引入了一个新的可选的阶段「链接时间」(linktime)；
这个阶段介于编译时和运行时之间
在该阶段，可以组装和优化一组模块，可以使用 jlink 工具制作自定义运行时镜像 ( image )
2、 javac、jlink和java三个命令都添加了一些可选项用于指定模块路径；
这些选项用于指定模块的定义位置
3、 增强JAR格式，更新JAR格式更新为模块化JAR，并且在JAR根目录下包含module-info.class文件；
4、 引入了JMOD格式，这种一种类似于JAR的新的打包格式，这种格式中可以包含本地(native)代码和配置文件；
5、 特意引入了module关键字，用于定义一个模块，不过这个关键字仅限于module-info.java中使用；
模块化的概念 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 从Java 9 为模块化的改变来看，Java 9 中的模块化其实就是一个 JAR 或 JMOD 格式的归档文件，该归档文件里包含了一些代码和数据还有一些配置文件，其中一定包含了一个名为 module-info.class 的文件，在该文件中定义了模块的一些信息
创建一个 Java 9 模块 接下来我们来看看如何定义一个 Java 9 模块，假设我们想要定义的模块名为 com.ddkk.module.greeting</description></item><item><title>四、Java8 Runnable Lambda 表达式</title><link>https://www.shellio.cc/docs/java/java8/4/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/java8/4/</guid><description>本章节我们重点来讲讲 Java 8 中的 Runnable Lambda 表达式。众所周知，Java 8 中的 Runable 和 Callable 两个接口都添加了 @FunctionalInterface 注解，因此我们可以直接使用 Lambda 表达式来代替它们的 run() 和 call() 方法
Runnable 表达式 Java 8 开始支持 Lambda 表达式，所以，好像，一夜间，所有添加了 @FunctionalInterface 注解的方法都可以使用 Lambda 表达式来创建实例，Runnable 也不例外，我们可以直接使用一个 Lambda 表达式来创建它的实例
1Runnable r = () -&amp;gt; System.out.println(&amp;#34;Hello World!&amp;#34;); 2Thread th = new Thread(r); 3th.start(); 运行结果输出为 Hello World ，是不是很神奇，如果没有 Lambda 表达式，那么原来的代码可能如下
1Runnable r = new Runnable() { 2 @Override 3 public void run() { 4 System.out.println(&amp;#34;Hello World!&amp;#34;); 5 } 6}; 7Thread th = new Thread(r); 8th.</description></item><item><title>四、JSP 结构</title><link>https://www.shellio.cc/docs/java/jsp/4/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/jsp/4/</guid><description>JSP 结构 网络服务器需要一个JSP引擎，也就是一个容器来处理JSP页面。容器负责截获对JSP页面的请求。本教程使用内嵌JSP容器的Apache来支持JSP开发。
JSP容器与Web服务器协同合作，为JSP的正常运行提供必要的运行环境和其他服务，并且能够正确识别专属于JSP网页的特殊元素。
下图显示了JSP容器和JSP文件在Web应用中所处的位置。
JSP处理 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 以下步骤表明了Web服务器是如何使用JSP来创建网页的：
就像其他普通的网页一样，您的浏览器发送一个HTTP请求给服务器。 Web服务器识别出这是一个对JSP网页的请求，并且将该请求传递给JSP引擎。通过使用URL或者.jsp文件来完成。 JSP引擎从磁盘中载入JSP文件，然后将它们转化为servlet。这种转化只是简单地将所有模板文本改用println()语句，并且将所有的JSP元素转化成Java代码。 JSP引擎将servlet编译成可执行类，并且将原始请求传递给servlet引擎。 Web服务器的某组件将会调用servlet引擎，然后载入并执行servlet类。在执行过程中，servlet产生HTML格式的输出并将其内嵌于HTTP response中上交给Web服务器。 Web服务器以静态HTML网页的形式将HTTP response返回到您的浏览器中。 最终，Web浏览器处理HTTP response中动态产生的HTML网页，就好像在处理静态网页一样。 以上提及到的步骤可以用下图来表示：
一般情况下，JSP引擎会检查JSP文件对应的servlet是否已经存在，并且检查JSP文件的修改日期是否早于servlet。如果JSP文件的修改日期早于对应的servlet，那么容器就可以确定JSP文件没有被修改过并且servlet有效。这使得整个流程与其他脚本语言（比如PHP）相比要高效快捷一些。
总的来说，JSP网页就是用另一种方式来编写servlet而不用成为Java编程高手。除了解释阶段外，JSP网页几乎可以被当成一个普通的servlet来对待。</description></item><item><title>四、JUnit – 基本用法</title><link>https://www.shellio.cc/docs/java/junit/4/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/junit/4/</guid><description>JUnit – 基本用法 现在我们将应用简单的例子来一步一步教你如何使用 Junit。
创建一个类 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 在C:\ &amp;gt; JUNIT_WORKSPACE 路径下创建一个名为 MessageUtil.java 的类用来测试。 1/* 2* This class prints the given message on console. 3*/ 4public class MessageUtil { 5 private String message; 6 //Constructor 7 //@param message to be printed 8 public MessageUtil(String message){ 9 this.message = message; 10 } 11 // prints the message 12 public String printMessage(){ 13 System.out.println(message); 14 return message; 15 } 16} 创建 Test Case 类 创建一个名为 TestJunit.</description></item><item><title>四、Maven 构建生命周期</title><link>https://www.shellio.cc/docs/java/maven/4/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/maven/4/</guid><description>Maven – 构建生命周期 什么是构建生命周期 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 构建生命周期是一组阶段的序列（sequence of phases），每个阶段定义了目标被执行的顺序。这里的阶段是生命周期的一部分。
举例说明，一个典型的 Maven 构建生命周期是由以下几个阶段的序列组成的：
阶段 处理 描述 prepare-resources 资源拷贝 本阶段可以自定义需要拷贝的资源 compile 编译 本阶段完成源代码编译 package 打包 本阶段根据 pom.xml 中描述的打包配置创建 JAR / WAR 包 install 安装 本阶段在本地 / 远程仓库中安装工程包 当需要在某个特定阶段之前或之后执行目标时，可以使用 pre 和 post 来定义这个目标。
当Maven 开始构建工程，会按照所定义的阶段序列的顺序执行每个阶段注册的目标。Maven 有以下三个标准的生命周期：
clean default(or build) site 目标表示一个特定的、对构建和管理工程有帮助的任务。它可能绑定了 0 个或多个构建阶段。没有绑定任何构建阶段的目标可以在构建生命周期之外被直接调用执行。
执行的顺序依赖于目标和构建阶段被调用的顺序。例如，考虑下面的命令。clean 和 package 参数是构建阶段，而 dependency:copy-dependencies 是一个目标。
1mvn clean dependency:copy-dependencies package 这里的clean 阶段将会被首先执行，然后 dependency:copy-dependencies 目标会被执行，最终 package 阶段被执行。
Clean 生命周期 当我们执行 mvn post-clean 命令时，Maven 调用 clean 生命周期，它包含以下阶段。</description></item><item><title>四、Memcached 连接</title><link>https://www.shellio.cc/docs/java/memcached/4/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/memcached/4/</guid><description>可以通过 telnet 命令并指定 主机IP 和 **端口(port)**来连接 Memcached
语法 1telnet HOST PORT 命令中的 HOST 和 PORT 为运行 Memcached 服务的 IP 和 端口。
11211 为所有 Memcached 服务默认的端口号
范例 1. 连接到 127.0.0.1 上 11211 的 Memcached 服务 假设我们的 Memcached 服务运行在本机， IP 为 127.0.0.1 ,端口为 11211
那么连接到 Memcached 的命令为
1telnet 127.0.0.1 11211 输出如下
1$ telnet 127.0.0.1 11211 2Trying 127.0.0.1... 3Connected to localhost. 4Escape character is &amp;#39;^]&amp;#39;. 2. 进行简单的 set 和 get 操作 1$ telnet 127.</description></item><item><title>四十、5.4 JavaBean 与 Model 合体</title><link>https://www.shellio.cc/docs/java/jfinal/40/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/jfinal/40/</guid><description>JFinal 2.1 版本提供了 ModelGenerator 、 BaseModelGenerator 、 MappingKitGernator 、 DataDictionaryGenerator，分别生成 Model、BaseModel、MappingKit、DataDictionary 四类文件。 可根据数据表自动化生成这四类文件。
相对于JFinal 2.1 之前的版本，生成后的 Model 继承自 BaseModel 而非继承自 Model， BaseModel 中拥有 getter、setter 方法遵守传统 java bean 规范，Model 继承自 BaseModel 即完成 了 JavaBean 与 Model 合体，拥有了传统 JavaBean 所有的优势，并且所有的 getter、setter 方法 完全无需人工干预，数据表有任何变动一键重新生成即可。
具体用法可在 jfinal 官网下载相关 GeneratorDemo，用法极度简单。</description></item><item><title>四十八、5.12 多数据源支持</title><link>https://www.shellio.cc/docs/java/jfinal/48/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/jfinal/48/</guid><description>ActiveRecordPlugin 可同时支持多数据源、多方言、多缓存、多事务级别等特性，对每个 ActiveRecordPlugin 可进行彼此独立的配置。简言之 JFinal 可以同时使用多数据源，并且可 以针对这多个数据源配置独立的方言、缓存、事务级别等。
当使用多数据源时，只需要对每个 ActiveRecordPlugin 指定一个 configName 即可，如下是代码示例：
public void configPlugin(Plugins me) {
// mysql 数据源
C3p0Plugin dsMysql = new C3p0Plugin(…); me.add(dsMysql);
// mysql ActiveRecrodPlugin 实例，并指定configName为 mysql ActiveRecordPlugin arpMysql = new ActiveRecordPlugin(“mysql”, dsMysql); me.add(arpMysql);
arpMysql.setCache( new EhCache()); arpMysql.addMapping(“user”, User. class);
// oracle 数据源
C3p0Plugin dsOracle = new C3p0Plugin(…); me.add(dsOracle);
// oracle ActiveRecrodPlugin 实例，并指定configName为 oracle ActiveRecordPlugin arpOracle = new ActiveRecordPlugin(“oracle”, dsOracle); me.add(arpOracle);
arpOracle.setDialect( new OracleDialect()); arpOracle.setTransactionLevel(8); arpOracle.addMapping(“blog”, Blog.</description></item><item><title>四十二、5.6 声明式事务</title><link>https://www.shellio.cc/docs/java/jfinal/42/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/jfinal/42/</guid><description>ActiveRecord 支持声名式事务，声明式事务需要使用 ActiveRecordPlugin 提供的拦截器来 实现，拦截器的配置方法见 Interceptor 有关章节。以下代码是声明式事务示例：
// 本例仅为示例, 并未严格考虑账户状态等业务逻辑
@Before(Tx. class)
public void trans_demo() {
// 获取转账金额
Integer transAmount = getParaToInt(“transAmount”);
// 获取转出账户id
Integer fromAccountId = getParaToInt(“fromAccountId”);
// 获取转入账户id
Integer toAccountId = getParaToInt(“toAccountId”);
// 转出操作
Db.update(“update account set cash = cash – ? where id = ?”, transAmount, fromAccountId);
// 转入操作
Db.update(“update account set cash = cash + ? where id = ?”, transAmount, toAccountId);
}
以上代码中，仅声明了一个 Tx 拦截器即为 action 添加了事务支持。除此之外 ActiveRecord 还配备了 TxByActionKeys、TxByActionKeyRegex、TxByMethods、TxByMethodRegex，分别 支持 actionKeys、actionKey 正则、actionMethods、actionMethod 正则声明式事务，以下是示例代码：</description></item><item><title>四十九、5.13 非 web 环境下使用 ActiveRecord</title><link>https://www.shellio.cc/docs/java/jfinal/49/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/jfinal/49/</guid><description>ActiveRecordPlugin 可以独立于 java web 环境运行在任何普通的 java 程序中，使用方式极 度简单，相对于 web 项目只需要手动调用一下其 start() 方法即可立即使用。以下是代码示例：
public class ActiveRecordTest {
public static void main(String[] args) {
DruidPlugin dp = new DruidPlugin(“localhost”, “userName”, “password”); ActiveRecordPlugin arp = new ActiveRecordPlugin(dp); arp.addMapping(“blog”, Blog. class);
// 与web环境唯一的不同是要手动调用一次相关插件的start()方法
dp.start();
arp.start();
// 通过上面简单的几行代码，即可立即开始使用
new Blog().set(“title”, “title”).set(“content”, “cxt text”).save(); Blog. me.findById(123);
}
}
注意：ActiveRecordPlugin 所依赖的其它插件也必须手动调用一下 start()方法，如上例中的 dp.start()。</description></item><item><title>四十六、5.10 复合主键</title><link>https://www.shellio.cc/docs/java/jfinal/46/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/jfinal/46/</guid><description>JFinal ActiveRecord 从 2.0 版本开始，采用极简设计支持复合主键，对于 Model 来说需要 在映射时指定复合主键名称，以下是具体例子：
ActiveRecordPlugin arp = new ActiveRecordPlugin(c3p0Plugin);
// 多数据源的配置仅仅是如下第二个参数指定一次复合主键名称
arp.addMapping(“user_role”, “userId, roleId”, UserRole. class);
//同时指定复合主键值即可查找记录 UserRole. dao.findById(123, 456);
//同时指定复合主键值即可删除记录 UserRole. dao.deleteById(123, 456);
如上代码所示，对于 Model 来说，只需要在添加 Model 映射时指定复合主键名称即可开 始使用复合主键，在后续的操作中 JFinal 会对复合主键支持的个数进行检测，当复合主键数量 不正确时会报异常，尤其是复合主键数量不够时能够确保数据安全。复合主键不限定只能有两 个，可以是数据库支持下的任意多个。
对于Db + Record 模式来说，复合主键的使用不需要配置，直接用即可：
Db. findById(“user_role”, “roleId, userId”, 123, 456);
Db. deleteById(“user_role”, “roleId, userId”, 123, 456);</description></item><item><title>四十七、5.11 Oracle 支持</title><link>https://www.shellio.cc/docs/java/jfinal/47/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/jfinal/47/</guid><description>Oracle 数据库具有一定的特殊性，JFinal 针对这些特殊性进行了一些额外的支持以方便广 大的 Oracle 使用者。以下是一个完整的 Oracle 配置示例：
public class DemoConfig extends JFinalConfig {
public void configPlugin(Plugins me) { C3p0Plugin cp = new C3p0Plugin(……);
//配置Oracle驱动
cp. setDriverClass(“oracle.jdbc.driver.OracleDriver”); me.add(cp);
ActiveRecordPlugin arp = new ActiveRecordPlugin(cp); me.add(arp);
// 配置Oracle方言
arp.setDialect(new OracleDialect());
// 配置属性名(字段名)大小写不敏感容器工厂 arp.setContainerFactory( new CaseInsensitiveContainerFactory()); arp.addMapping(“user”, “user_id”, User. class);
}
由于Oracle 数据库会自动将属性名(字段名)转换成大写，所以需要手动指定主键名为大写， 如：arp.addMaping(“user”, “ID”, User.class)。如果想让 ActiveRecord 对属性名（字段名）的大 小 写 不 敏 感 可 以 通 过 设 置 CaseInsensitiveContainerFactory 来达到 ， 有 了 这 个 设 置 ， 则 arp.</description></item><item><title>四十三、5.7 Cache</title><link>https://www.shellio.cc/docs/java/jfinal/43/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/jfinal/43/</guid><description>ActiveRecord 可以使用缓存以大大提高性能，以下代码是 Cache 使用示例：
public void list() {
List blogList = Blog. dao.findByCache(“cacheName”, “key”, “select * from blog”);
setAttr(“blogList”, blogList).render(“list.html”);
}
上例findByCache 方 法 中 的 cacheName 需 要 在 ehcache.xml 中配置 如： 。 此 外 Model.paginateByCache(…) 、 Db.findByCache(…) 、 Db.paginateByCache(…)方法都提供了 cache 支持。在使用时，只需传入 cacheName、key 以及 在 ehccache.xml 中配置相对应的 cacheName 就可以了。</description></item><item><title>四十四、5.8 Dialect 多数据库支持</title><link>https://www.shellio.cc/docs/java/jfinal/44/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/jfinal/44/</guid><description>目前ActiveRecordPlugin 提供了 MysqlDialect、OracleDialect、AnsiSqlDialect 实现类。 MysqlDialect 与 OracleDialect 分别实现对 Mysql 与 Oracle 的支持，AnsiSqlDialect 实现对遵守 ANSI SQL 数据库的支持。以下是数据库 Dialect 的配置代码：
public class DemoConfig extends JFinalConfig {
public void configPlugin(Plugins me) { ActiveRecordPlugin arp = new ActiveRecordPlugin(…); me.add(arp);
// 配置Postgresql方言
arp.setDialect(new PostgresqlDialect());
}
}</description></item><item><title>四十五、5.9 表关联操作</title><link>https://www.shellio.cc/docs/java/jfinal/45/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/jfinal/45/</guid><description>JFinal ActiveRecord 天然支持表关联操作，并不需要学习新的东西，此为无招胜有招。表 关联操作主要有两种方式：一是直接使用 sql 得到关联数据；二是在 Model 中添加获取关联数据的方法。
假定现有两张数据库表：user、blog，并且 user 到 blog 是一对多关系，blog 表中使用 user_id关联到 user 表。如下代码演示使用第一种方式得到 user_name：
public void relation() {
String sql = “select b.*, u.user_name from blog b inner join user u on b.user_id=u.id where b.id=?”;
Blog blog = Blog. dao.findFirst(sql, 123); String name = blog.getStr(“user_name”);
}
以下代码演示第二种方式在 Blog 中获取相关联的 User 以及在 User 中获取相关联的Blog：
public class Blog extends Model {
public static final Blog dao = new Blog();</description></item><item><title>四十一、5.5 JFinal 独创 Db + Record 模式</title><link>https://www.shellio.cc/docs/java/jfinal/41/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/jfinal/41/</guid><description>Db类及其配套的 Record 类，提供了在 Model 类之外更为丰富的数据库操作功能。使用 Db 与 Record 类时，无需对数据库表进行映射，Record 相当于一个通用的 Model。以下为 Db + Record 模式的一些常见用法：
// 创建name属性为James,age属性为25的record对象并添加到数据库
Record user = new Record().set(“name”, “James”).set(“age”, 25); Db. save(“user”, user);
// 删除id值为25的user表中的记录
Db. deleteById(“user”, 25);
// 查询id值为25的Record将其name属性改为James并更新到数据库 user = Db. findById(“user”, 25).set(“name”, “James”); Db. update(“user”, user);
// 获取user的name属性
String userName = user.getStr(“name”);
// 获取user的age属性
Integer userAge = user.getInt(“age”);
// 查询所有年龄大于18岁的user
List users = Db. find(“select * from user where age &amp;gt; 18”);
// 分页查询年龄大于18的user,当前页号为1,每页10个user</description></item><item><title>五、0.4 Model 与 Bean 合体后注意事项</title><link>https://www.shellio.cc/docs/java/jfinal/5/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/jfinal/5/</guid><description> 合体后 JSP 模板输出 Bean 中的数据将依赖其 getter 方法，输出的变量名即为 getter 方法去 掉”get”前缀字符后剩下的字符首字母变小写，如果希望 JSP 仍然使用之前的输出方式，可 以在系统启动时调用一下 ModelRecordElResolver. setResolveBeanAsModel(true); Controller 之中的 getModel()需要表单域名称对应于数据表字段名，而 getBean()则依赖于 setter 方法，表单域名对应于 setter 方法去掉”set”前缀字符后剩下的字符串字母变小写。 许多类似于 jackson、fastjson 的第三方工具依赖于 Bean 的 getter 方法进行操作，所以只有 合体后才可以使用 jackson、fastjson JFinalJson 将 Model 转换为 json 数据时，json 的 keyName 是原始的数据表字段名，而 jackson、 fastjson 这类依赖于 getter 方法转化成的 json 的 keyName 是数据表字段名转换而成的驼峰 命名 建议 mysql 数据表的字段名直接使用驼峰命名，这样可以令 json 的 keyName 完全一致， 也可以使 JSP 在页面中取值时使用完全一致的属性名。注意：mysql 数据表的名称仍然使 用下划线命名方式并使用小写字母，方便在 linux 与 windows 系统之间移植。 总之，合体后的 Bean 在使用时要清楚使用的是其 BaseModel 中的 getter、setter 方法还是 其 Model 中的 get(String attrName)方法</description></item><item><title>五、Gradle 构建基础</title><link>https://www.shellio.cc/docs/java/gradle/5/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/gradle/5/</guid><description>构建基础 Projects 和 tasks 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 projects 和 tasks是 Gradle 中最重要的两个概念。
任何一个 Gradle 构建都是由一个或多个 projects 组成。每个 project 包括许多可构建组成部分。 这完全取决于你要构建些什么。举个例子，每个 project 或许是一个 jar 包或者一个 web 应用，它也可以是一个由许多其他项目中产生的 jar 构成的 zip 压缩包。一个 project 不必描述它只能进行构建操作。它也可以部署你的应用或搭建你的环境。不要担心它像听上去的那样庞大。 Gradle 的 build-by-convention 可以让您来具体定义一个 project 到底该做什么。
每个project 都由多个 tasks 组成。每个 task 都代表了构建执行过程中的一个原子性操作。如编译，打包，生成 javadoc，发布到某个仓库等操作。
到目前为止，可以发现我们可以在一个 project 中定义一些简单任务，后续章节将会阐述多项目构建和多项目多任务的内容。
Hello world 你可以通过在命令行运行 gradle 命令来执行构建，gradle 命令会从当前目录下寻找 build.gradle 文件来执行构建。我们称 build.gradle 文件为构建脚本。严格来说这其实是一个构建配置脚本，后面你会了解到这个构建脚本定义了一个 project 和一些默认的 task。
你可以创建如下脚本到 build.gradle 中 To try this out，create the following build script named build.</description></item><item><title>五、Groovy 变量</title><link>https://www.shellio.cc/docs/java/groovy/5/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/groovy/5/</guid><description>Groovy中的变量可以通过两种方式定义 – 使用数据类型的本地语法，或者使用def关键字。对于变量定义，必须明确提供类型名称或在替换中使用“def”。这是Groovy解析器需要的。
Groovy中有以下基本类型的变量，如上一章所述 –
byte - 这用于表示字节值。例如2。 short - 用于表示一个短数。例如10。 int - 这用于表示整数。 例如1234。 long - 这用于表示一个长数。例如10000090。 float - 用于表示32位浮点数。例如12.34。 double - 这用于表示64位浮点数。例如12.3456565。 char - 这定义了单个字符文字。例如’a’。 Boolean - 这表示一个布尔值，可以是true或false。 String - 这是以字符串形式表示的文本。 例如“Hello World”。 Groovy还允许其他类型的变量，如数组，结构和类，我们将在后续章节中看到。
变量声明 变量声明告诉编译器为变量创建存储的位置和大小。
下面是一个变量声明的例子 –
1class Example { 2 static void main(String[] args) { 3 // x is defined as a variable 4 String x = &amp;#34;Hello&amp;#34;; 5 // The value of the variable is printed to the console 6 println(x); 7 } 当我们运行上面的程序，我们会得到以下结果 –</description></item><item><title>五、Hibernate 环境</title><link>https://www.shellio.cc/docs/java/hibernate/5/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/hibernate/5/</guid><description>环境 这个章节会告诉你为了给 Hibernate 应用准备需要的开发环境，该怎样安装 Hibernate 应用和一些其它相关的包。我们会用 MySQL 数据库来对一些 Hibernate 应用的例子进行试验，所以先要确保你已经安装过了 MySQL 数据库。想了解更多的关于 MySQL 数据库的详情的话，你可以搜索我们的 MySQL教程。
下载 Hibernate 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 如果你已经在你的机器上安装了 Java 的最新版本，那么按照以下这些简易的步骤来下载并安装 Hibernate 在你的机器上就可以了。
首先要在想要把 Hibernate 应用安装在 Windows 系统或是 Unix 系统这两者之间做出选择，之后继续到下一个步骤去下载与 Windows 系统对应的 .zip 文件或是与 Unix 系统对应的 .tz 文件。 之后到 http://www.hibernate.org/downloads 这个网址来下载最新版本的 Hibernate 应用。 在写这个教程时我下载的是 hibernate-distribution-3.6.4.Final 这个版本的应用，在这个版本的应用下当我们解压下载的文件时会显示以下的目录结构。 安装 Hibernate 一旦你下好并且解压了 Hibernate 应用最新版本的安装文件，你需要执行以下两个简单的步骤。一定要确保你把你的 CLASSPATH 变量设置合理，否则当你编译你的应用时可能会遇到问题。
首先把从 /lib 复制来的所有库文件拷贝到 CLASSPATH 里，并且改变你的 CLASSPATH 变量来涵盖所有的 JAR。 最后复制 hibernate3.jar 这个文件到 CLASSPATH 里。这个文件位于安装文件的根目录里，它是 Hibernate 应用针对的主要 JAR。 Hibernate 的前提 以下是一个 Hibernate 应用需要的有关包/库的表格，在安装 Hibernate 应用之前你需要先安装它们。为了安装这些包你必须把来自 /lib 的库文件拷贝到 CLASSPATH ，并按以下说明相应地改变 CLASSPATH 变量。</description></item><item><title>五、Java 8 java.util.Base64 编码解码</title><link>https://www.shellio.cc/docs/java/java8/5/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/java8/5/</guid><description>Base64 是一种常见的字符编码解码方式，一般用于将二进制数据编码为更具可读性的 Base64 进制格式。
在Java 6 （ JDK 1.6 ) 之前， JDK 一直没有包含 Base64 的实现类。因此大部分人都使用 Sum/Orale JDK 里面的 sun.misc.BASE64Encode 和sun.misc.BASE64Decode。然后这也成为很多 Java 开发者的习惯。一直沿用到今天的 Java8 中还有人在用。
JDK1.6 虽然添加了 Base64 的实现。但是，非常隐秘，竟然是在 javax.xml.bind 包下的 DatastypeConvert 类中的两个静态方法 parseBase64Binary 和 printBase64Binary.
Java 8 终于把 Base64 扶正了，在 java.util 包下提供了 Base64 类用于编码和解码 Base64 数据。
Java 8 java.util.Base64 Java 8 中的 java.util.Base64 类提供了三种类型的 Base64 编码解码格式：
1、 简单类型(simple):编码字符只包含A-Za-z0-9+/等64个字符且编码的时候不会包含任何换行符(\r、\n、\r\n）解码的时候也只会解码A-Za-z0-9+/内的字符，超出的则会被拒绝；
2、 URL:编码字符只包含A-Za-z0-9+_等64个字符和简单相比，就是把/换成了_因为没有/字符，因此这种编码方式非常适合URL和文件名等；
3、 MIME:编码会被映射为MIME友好格式：每一行输出不超过76个字符，而且每行以\r\n符结束但末尾行并不会包含\r\n；
内部类 java.util.Base64 还包含了两个内部静态类，分别实现了 RFC 4648 和 RFC 2045 中规范的 Base64 编码和解码方式。</description></item><item><title>五、Java 9 新特性 – REPL ( JShell )</title><link>https://www.shellio.cc/docs/java/java9/5/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/java9/5/</guid><description>REPL ，全称 Read Eval Print Loop ,中文 「 交互式解释器 」，其实，就是一种代码所见即所得的即时编译器
Java 9 引入了 REPL ，并将其命令为 「 JShell 」 ，这真是我们 Java 开发的福音，以后演示代码的时候再也不用搬着一个 IDE 到处跑了
对于我们 Java 开发者来说，应该是 Java 9 带来的最大的个性吧。我们终于可以像 Python 、 Ruby 和 Node.js 那样在 Shell 可见即可得的运行一些范例代码了
也就是说，使用 REPL，我们可以编写和测试基于 Java 的逻辑，无需使用 javac 进行编译，直接查看计算结果
运行 JShell 打开命令行提示符 ( Window 7 / Window xp ) 或 PowerShell ( Window 8 / Window 10 ) 或终端 ( Linux / Mac OSX ) ，并输入 jshell 进入 JShell。启动过程有点缓慢</description></item><item><title>五、JSP 生命周期</title><link>https://www.shellio.cc/docs/java/jsp/5/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/jsp/5/</guid><description>JSP 生命周期 理解JSP底层功能的关键就是去理解它们所遵守的生命周期。
JSP生命周期就是从创建到销毁的整个过程，类似于servlet生命周期，区别在于JSP生命周期还包括将JSP文件编译成servlet。
以下是JSP生命周期中所走过的几个阶段：
编译阶段： servlet容器编译servlet源文件，生成servlet类
初始化阶段： 加载与JSP对应的servlet类，创建其实例，并调用它的初始化方法
执行阶段： 调用与JSP对应的servlet实例的服务方法
销毁阶段： 调用与JSP对应的servlet实例的销毁方法，然后销毁servlet实例
很明显，JSP生命周期的四个主要阶段和servlet生命周期非常相似，下面给出图示：
JSP编译 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 当浏览器请求JSP页面时，JSP引擎会首先去检查是否需要编译这个文件。如果这个文件没有被编译过，或者在上次编译后被更改过，则编译这个JSP文件。
编译的过程包括三个步骤：
解析JSP文件。 将JSP文件转为servlet。 编译servlet。 JSP初始化 容器载入JSP文件后，它会在为请求提供任何服务前调用jspInit()方法。如果您需要执行自定义的JSP初始化任务，复写jspInit()方法就行了，就像下面这样：
1public void jspInit(){ 2 // 初始化代码 一般来讲程序只初始化一次，servlet也是如此。通常情况下您可以在jspInit()方法中初始化数据库连接、打开文件和创建查询表。
JSP执行 这一阶段描述了JSP生命周期中一切与请求相关的交互行为，直到被销毁。
当JSP网页完成初始化后，JSP引擎将会调用_jspService()方法。
_jspService()方法需要一个HttpServletRequest对象和一个HttpServletResponse对象作为它的参数，就像下面这样：
1void _jspService(HttpServletRequest request,HttpServletResponse response) 2 // 服务端处理代码 _jspService()方法在每个request中被调用一次并且负责产生与之相对应的response，并且它还负责产生所有7个HTTP方法的回应，比如GET、POST、DELETE等等。
JSP清理 JSP生命周期的销毁阶段描述了当一个JSP网页从容器中被移除时所发生的一切。
jspDestroy()方法在JSP中等价于servlet中的销毁方法。当您需要执行任何清理工作时复写jspDestroy()方法，比如释放数据库连接或者关闭文件夹等等。
jspDestroy()方法的格式如下：
1public void jspDestroy() 2 // 清理代码 实例 JSP生命周期代码实例如下所示：
1&amp;lt;%@ page language=&amp;#34;java&amp;#34; contentType=&amp;#34;text/html; charset=UTF-8&amp;#34; 2 pageEncoding=&amp;#34;UTF-8&amp;#34;%&amp;gt; 3&amp;lt;html&amp;gt; 4&amp;lt;head&amp;gt; 5&amp;lt;title&amp;gt;life.jsp&amp;lt;/title&amp;gt; 6&amp;lt;/head&amp;gt; 7&amp;lt;body&amp;gt; 8&amp;lt;%! 9 private int initVar=0; 10 private int serviceVar=0; 11 private int destroyVar=0; 12%&amp;gt; 13&amp;lt;%!</description></item><item><title>五、JUnit – API</title><link>https://www.shellio.cc/docs/java/junit/5/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/junit/5/</guid><description>JUnit – API JUnit 中的重要的 API 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 JUnit 中的最重要的程序包是 junit.framework 它包含了所有的核心类。一些重要的类列示如下：
序号 类的名称 类的功能 1 Assert assert 方法的集合 2 TestCase 一个定义了运行多重测试的固定装置 3 TestResult TestResult 集合了执行测试样例的所有结果 4 TestSuite TestSuite 是测试的集合 Assert 类 下面介绍的是 org.junit.Assert 类：
1public class Assert extends java.lang.Object 这个类提供了一系列的编写测试的有用的声明方法。只有失败的声明方法才会被记录。Assert 类的重要方法列式如下：
序号 方法和描述 1 void assertEquals(boolean expected, boolean actual) 检查两个变量或者等式是否平衡 2 void assertFalse(boolean condition) 检查条件是假的 3 void assertNotNull(Object object) 检查对象不是空的 4 void assertNull(Object object) 检查对象是空的 5 void assertTrue(boolean condition) 检查条件为真 6 void fail() 在没有报告的情况下使测试不通过 下面让我们在例子中来测试一下上面提到的一些方法。在 C:\ &amp;gt; JUNIT_WORKSPACE 目录下创建一个名为 TestJunit1.</description></item><item><title>五、Maven 构建配置文件</title><link>https://www.shellio.cc/docs/java/maven/5/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/maven/5/</guid><description>Maven – 构建配置文件 什么是构建配置文件？ 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 构建配置文件是一组配置的集合，用来设置或者覆盖 Maven 构建的默认配置。使用构建配置文件，可以为不同的环境定制构建过程，例如 Producation 和 Development 环境。
Profile 在 pom.xml 中使用 activeProfiles / profiles 元素指定，并且可以用很多方式触发。Profile 在构建时修改 POM，并且为变量设置不同的目标环境（例如，在开发、测试和产品环境中的数据库服务器路径）。
Profile 类型 Profile 主要有三种类型。
类型 在哪里定义 Per Project 定义在工程 POM 文件 pom.xml 中 Per User 定义在 Maven 设置 xml 文件中 （%USER_HOME%/.m2/settings.xml） Global 定义在 Maven 全局配置 xml 文件中 （%M2_HOME%/conf/settings.xml） Profile 激活 Maven 的 Profile 能够通过几种不同的方式激活。
显式使用命令控制台输入 通过 maven 设置 基于环境变量（用户 / 系统变量） 操作系统配置（例如，Windows family） 现存 / 缺失 文件 Profile 激活示例 我们假定你的工程目录像下面这样：</description></item><item><title>五、Memcached quit 命令</title><link>https://www.shellio.cc/docs/java/memcached/5/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/memcached/5/</guid><description>Memcached quit 命令用户关闭一个客户端连接
语法 1quit 范例 连接到127.0.0.1 上 11211 的 Memcached 服务, 然后退出
1$ telnet 127.0.0.1 11211 2Trying 127.0.0.1... 3Connected to localhost. 4Escape character is &amp;#39;^]&amp;#39;. 5quit 退出 6Connection closed by foreign host. 从返回信息看是 Memcached 主动关闭了连接</description></item><item><title>五十、6.1 概述</title><link>https://www.shellio.cc/docs/java/jfinal/50/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/jfinal/50/</guid><description>EhCachePlugin 是 JFinal 集成的缓存插件，通过使用 EhCachePlugin 可以提高系统的并发 访问速度。</description></item><item><title>五十八、7.3 Redis 与 Cache</title><link>https://www.shellio.cc/docs/java/jfinal/58/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/jfinal/58/</guid><description>Redis 与 Cache 联合起来可以非常方便地使用 Redis 服务，Redis 对象通过 use()方法来获取 到 Cache 对象，Cache 对象提供了丰富的 API 用于使用 Redis 服务，下面是具体使用示例：
public void redisDemo() {
// 获取名称为 bbs的 Redis Cache对象 Cache bbsCache = Redis. use(“bbs”); bbsCache.set(“key”, “value”); bbsCache.get(“key”);
// 获取名称为news的 Redis Cache对象 Cache newsCache = Redis. use(“news”); newsCache.set(“k”, “v”); newsCache.get(“k”);
// 最先创建的Cache将成为主Cache，所以可以省去cacheName参数来获取 bbsCache = Redis. use(); // 主缓存可以省去cacheName参数 bbsCache.set(“jfinal”, “awesome”);
}
以上代码中通过”bbs”、”news”做为 use 方法的参数分别获取到了两个 Cache 对象，使用这 两个对象即可操作其所对应的 Redis 服务端。
通常情况下只会创建一个 RedisPlugin 连接一个 redis 服务端，使用 Redis.use().set(key,value)即可。</description></item><item><title>五十二、6.3 CacheInterceptor</title><link>https://www.shellio.cc/docs/java/jfinal/52/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/jfinal/52/</guid><description>CacheInterceptor 可以将 action 所需数据全部缓存起来，下次请求到来时如果 cache 存在则 直接使用数据并 render，而不会去调用 action。此用法可使 action 完全不受 cache 相关代码所 污染，即插即用，以下是示例代码：
@Before(CacheInterceptor. class)
public void list() {
List blogList = Blog. dao.find(“select * from blog”); User user = User. dao.findById(getParaToInt()); setAttr(“blogList”, blogList);
setAttr(“user”, user); render(“blog.html”);
}
上例中的用法将使用 actionKey 作为 cacheName，在使用之前需要在 ehcache.xml 中配置以 actionKey 命名的 cache 如： ，注意 actionKey 作为 cacheName 配置 时斜杠”/”不能省略。此外 CacheInterceptor 还可以与 CacheName 注解配合使用，以此来取代默认的 actionKey 作为actionName，以下是示例代码：
@Before(CacheInterceptor. class)
@CacheName(“blogList”)
public void list() {
List blogList = Blog.</description></item><item><title>五十九、7.4 非 web 环境使用 RedisPlugin</title><link>https://www.shellio.cc/docs/java/jfinal/59/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/jfinal/59/</guid><description>RedisPlugin 也 可 以 在 非 web 环 境 下 使 用 ， 只需 引入 jfinal.jar 然 后 多 调用一下redisPlugin.start()即可，以下是代码示例：
public class RedisTest {
public static void main(String[] args) {
RedisPlugin rp = new RedisPlugin(“myRedis”, “localhost”);
// 与web下唯一区别是需要这里调用一次start()方法rp.start();
Redis. use().set(“key”, “value”);
Redis. use().get(“key”);
}
}</description></item><item><title>五十六、7.1 概述</title><link>https://www.shellio.cc/docs/java/jfinal/56/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/jfinal/56/</guid><description>RedisPlugin 是支持 Redis 的极速化插件。使用 RedisPlugin 可以极度方便的使用 redis，该 插件不仅提供了丰富的 API，而且还同时支持多 redis 服务端。Redis 拥有超高的性能，丰富的 数据结构，天然支持数据持久化，是目前应用非常广泛的 nosql 数据库。对于 redis 的有效应 用可极大提升系统性能，节省硬件成本。</description></item><item><title>五十七、7.2 RedisPlugin</title><link>https://www.shellio.cc/docs/java/jfinal/57/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/jfinal/57/</guid><description>RedisPlugin 是作为 JFinal 的 Plugin 而存在的，所以使用时需要在 JFinalConfig 中配置RedisPlugin，以下是 RedisPlugin 配置示例代码：
public class DemoConfig extends JFinalConfig {
public void configPlugin(Plugins me) {
// 用于缓存 bbs模块的 redis服务
RedisPlugin bbsRedis = new RedisPlugin(“bbs”, “localhost”); me.add(bbsRedis);
// 用于缓存news模块的 redis服务
RedisPlugin newsRedis = new RedisPlugin(“news”, “192.168.3.9”); me.add(newsRedis);
}
}
以上代码创建了两个 RedisPlugin 对象，分别为 bbsRedis 和 newsRedis。最先创建的 RedisPlugin 对象所持有的 Cache 对象将成为主缓存对象，主缓存对象可通过 Redis.use()直接获 取，否则需要提供 cacheName 参数才能获取，例如：Redis.use(“news”)。</description></item><item><title>五十三、6.4 EvictInterceptor</title><link>https://www.shellio.cc/docs/java/jfinal/53/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/jfinal/53/</guid><description>EvictInterceptor 可以根据 CacheName 注解自动清除缓存。以下是示例代码：
@Before(EvictInterceptor. class)
@CacheName(“blogList”)
public void update() { getModel(Blog.class).update(); redirect(“blog.html”);
}
上例中的用法将清除 cacheName 为 blogList 的缓存数据，与其配合的 CacheInterceptor 会 自动更新 cacheName 为 blogList 的缓存数据。</description></item><item><title>五十四、6.5 CacheKit</title><link>https://www.shellio.cc/docs/java/jfinal/54/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/jfinal/54/</guid><description>CacheKit 是缓存操作工具类，以下是示例代码：
public void list() {
List blogList = CacheKit. get(“blog”, “blogList”);
if (blogList == null) {
blogList = Blog. dao.find(“select * from blog”); CacheKit. put(“blog”, “blogList”, blogList);
}
setAttr(“blogList”, blogList); render(“blog.html”);
}
CacheKit 中最重要的两个方法是 get(String cacheName, Object key)与 put(String cacheName,Object key, Object value)。get 方法是从 cache 中取数据，put 方法是将数据放入 cache。参数 cacheName 与 ehcache.xml 中的 name 属性值对应；参数 key 是指取值用 到的 key；参数 value 是被缓存的数据。
以下代码是 CacheKit 中重载的 CacheKit.get(String, String, IDataLoader)方法使用示例：
public void list() {</description></item><item><title>五十五、6.6 ehcache.xml 简介</title><link>https://www.shellio.cc/docs/java/jfinal/55/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/jfinal/55/</guid><description>EhCache 的使用需要有 ehcache.xml 配置文件支持，该配置文件中配置了很多 cache 节点， 每个 cache 节点会配置一个 name 属性，例如： ，该属性是 CacheKit 取值所必须的。其它配置项如 eternal、 overflowToDisk、timeToIdleSeconds、 timeToLiveSeconds 详见 EhCache 官方文档。</description></item><item><title>五十一、6.2 EhCachePlugin</title><link>https://www.shellio.cc/docs/java/jfinal/51/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/jfinal/51/</guid><description>EhCachePlugin 是作为 JFinal 的 Plugin 而存在的，所以使用时需要在 JFinalConfig 中配置EhCachePlugin，以下是 Plugin 配置示例代码：
public class DemoConfig extends JFinalConfig {
public void configPlugin(Plugins me) { me.add( new EhCachePlugin());
}
}</description></item><item><title>一、Gradle 简介</title><link>https://www.shellio.cc/docs/java/gradle/1/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/gradle/1/</guid><description>简介 介绍 很高兴能向大家介绍 Gradle，这是一个基于 JVM 的富有突破性构建工具。
它为您提供了:
一个像 ant 一样，通用的灵活的构建工具 一种可切换的，像 maven 一样的基于约定约定优于配置的构建框架 强大的多工程构建支持 强大的依赖管理(基于 ApacheIvy) 对已有的 maven 和 ivy 仓库的全面支持 支持传递性依赖管理，而不需要远程仓库或者 pom.xml 或者 ivy 配置文件 ant 式的任务和构建是 gradle 的第一公民 基于 groovy，其 build 脚本使用 groovy dsl 编写 具有广泛的领域模型支持你的构建 在第二章节概述中，你会看到关于 Gradle 的详细介绍和指导 关于本手册 与Gradle 一样，本手册也在不停的更新中。许多部分并未完全进行描述。有些内容并未完全描述。我们需要你来一起帮助改进本手册。你可以在 Gradle 官方网站找到其余格式的文档。</description></item><item><title>一、Groovy 概述</title><link>https://www.shellio.cc/docs/java/groovy/1/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/groovy/1/</guid><description>Groovy是一种基于Java平台的面向对象语言。 Groovy 1.0于2007年1月2日发布，其中Groovy 2.4是当前的主要版本。 Groovy通过Apache License v 2.0发布。
Groovy的特点 Groovy中有以下特点:
同时支持静态和动态类型。 支持运算符重载。 本地语法列表和关联数组。 对正则表达式的本地支持。 各种标记语言，如XML和HTML原生支持。 Groovy对于Java开发人员来说很简单，因为Java和Groovy的语法非常相似。 您可以使用现有的Java库。 Groovy扩展了java.lang.Object。 Groovy的官方网站是http://www.groovy-lang.org/</description></item><item><title>一、Hibernate 教程</title><link>https://www.shellio.cc/docs/java/hibernate/1/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/hibernate/1/</guid><description>Hibernate 教程 Hibernate 是一个高性能的对象关系型持久化存储和查询的服务，其遵循开源的 GNU Lesser General Public License (LGPL) 而且可以免费下载。Hibernate 不仅关注于从 Java 类到数据库表的映射，也有 Java 数据类型到 SQL 数据类型的映射，另外也提供了数据查询和检索服务。
这个教程将指导你如何以简单的方式使用 Hibernate 来开发基于数据库的 Web 应用程序。
适用人群 这个教程是为需要理解 Hibernate 框架和 API 的 Java 编程人员设计的。读完这份教程后你将发现自己在使用 Hibernate 上从一个中等程度迈向更高的层次。
学习前提 我们假设你已经很好的理解了 Java 编程语言。若对关系型数据库，JDBC 和 SQL 有些基本的了解会更好。
版本信息 书中演示代码基于以下版本：
框架 版本信息 Hibernate 3.0</description></item><item><title>一、Java 9 新特性 – 介绍</title><link>https://www.shellio.cc/docs/java/java9/1/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/java9/1/</guid><description>Java 9 推出好长时间了，但是它有什么新的东西和废弃了什么东西，我一直没认真去了解过。
本专栏，我一边收集各种资料，一边写一些基础的介绍文章。
Java 9 Java 9 应该是当初最为期待的版本吧。当时因为 Java 8 带来了很多新特性，大家都以为 Java 9 会持续带来更多的新特性。结果呢 ？ 虽然说不上多惊艳，但还是马马虎虎过得去了。
Java 9 是非常理论上应该是名利双收的，但实际上，夹在 Java 7 Java 8 和 Java 10 之间，其实大部分人都还停留在 Java 8 ，如果要升级，早就到了 Java 10 了…
所以，其实，我这个专栏，应该算是介绍性的文章，以简单直观的方式解释了Java 9的基本到高级功能及其用法。如果可以，就深入一点。
我是 Java 9 专栏的读者么 ？ 只要你会 Java，你就可以阅读这个专栏。
本专栏对大多数 Java 开发人员非常有用，从初学者到专家
完成阅读本专栏后，你将发现自己在 Java 9 中具有中等水平的专业知识，当然了，继续的提高还要你的继续努力实践
阅读前提 在你继续阅读本专栏之前，我希望你有一定的 Java 语言基础，或者其它使用 Java Runtime 的语言基础，这样你将事半功倍。
除此之外，别无要求</description></item><item><title>一、Java8 收集器 – java.util.stream.Collectors</title><link>https://www.shellio.cc/docs/java/java8/1/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/java8/1/</guid><description>Java 8 流的新类 java.util.stream.Collectors 实现了 java.util.stream.Collector 接口，同时又提供了大量的方法对流 ( stream ) 的元素执行 map and reduce 操作，或者统计操作。
本章节，我们就来看看那些常用的方法，顺便写几个示例练练手。
Collectors.averagingDouble() Collectors.averagingDouble() 方法将流中的所有元素视为 double 类型并计算他们的平均值。该方法返回的是同一个 Collectors 实例，因此可以进行链式操作。
Collectors.averagingDouble() 接受一个参数，这个参数是一个 lambda 表达式，用于对所有的元素执行一个 map 操作。
Java 所有集合的 stream().collect() 可以接受一个收集器实例作为其参数并返回该收集器的计算结果
例如下面的代码，collect() 方法会把所有的元素收集起来然后传递给 Collectors.averagingDouble(d-&amp;gt;d*2) 收集器，对每个元素执行 *2 操作后计算平均值
AveragingDoubleExample.java 1package com.ddkk.util.stream; 2import java.util.Arrays; 3import java.util.List; 4import java.util.stream.Collectors; 5public class AveragingDoubleExample { 6 public static void main(String[] args) { 7 List&amp;lt;Integer&amp;gt; list = Arrays.asList(1,2,3,4); 8 Double result = list.stream().collect(Collectors.averagingDouble(d-&amp;gt;d*2)); 9 System.</description></item><item><title>一、JFinal 摘要</title><link>https://www.shellio.cc/docs/java/jfinal/1/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/jfinal/1/</guid><description>JFinal 是基于 Java 语言的极速 WEB + ORM 开发框架，其核心设计目标是开发迅速、代 码量少、学习简单、功能强大、轻量级、易扩展、Restful。在拥有 Java语言所有优势的同时 再拥有 ruby、python、php 等动态语言的开发效率！为您节约更多时间，去陪恋人、家人和朋 友 : )
JFinal 有如下主要特点： MVC 架构，设计精巧，使用简单 遵循 COC 原则，零配置，无 xml 独创 Db + Record 模式，灵活便利 ActiveRecord 支持，使数据库开发极致快速 自动加载修改后的 java 文件，开发过程中无需重启 web server AOP 支持，拦截器配置灵活，功能强大 Plugin 体系结构，扩展性强 多视图支持，支持 FreeMarker、JSP、Velocity 强大的 Validator 后端校验功能 功能齐全，拥有 struts2 绝大部分核心功能 体积小仅 303K，且无第三方依赖 JFinal 官方网站：http://www.jfinal.com
JFinal 官方 QQ 群: 322076903、432462639
JFinal 官方微信:</description></item><item><title>一、JSP 简介</title><link>https://www.shellio.cc/docs/java/jsp/1/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/jsp/1/</guid><description>JSP 简介 什么是Java Server Pages? JSP全称Java Server Pages，是一种动态网页开发技术。它使用JSP标签在HTML网页中插入Java代码。标签通常以&amp;lt;%开头以%&amp;gt;结束。
JSP是一种Java servlet，主要用于实现Java web应用程序的用户界面部分。网页开发者们通过结合HTML代码、XHTML代码、XML元素以及嵌入JSP操作和命令来编写JSP。
JSP通过网页表单获取用户输入数据、访问数据库及其他数据源，然后动态地创建网页。
JSP标签有多种功能，比如访问数据库、记录用户选择信息、访问JavaBeans组件等，还可以在不同的网页中传递控制信息和共享信息。
为什么使用JSP？ JSP程序与CGI程序有着相似的功能，但和CGI程序相比，JSP程序有如下优势：
性能更加优越，因为JSP可以直接在HTML网页中动态嵌入元素而不需要单独引用CGI文件。 服务器调用的是已经编译好的JSP文件，而不像CGI/Perl那样必须先载入解释器和目标脚本。 JSP基于Java Servlets API，因此，JSP拥有各种强大的企业级Java API，包括JDBC，JNDI，EJB，JAXP等等。 JSP页面可以与处理业务逻辑的servlets一起使用，这种模式被Java servlet 模板引擎所支持。 最后，JSP是Java EE不可或缺的一部分，是一个完整的企业级应用平台。这意味着JSP可以用最简单的方式来实现最复杂的应用。
JSP的优势 以下列出了使用JSP带来的其他好处：
与ASP相比：JSP有两大优势。首先，动态部分用Java编写，而不是VB或其他MS专用语言，所以更加强大与易用。第二点就是JSP易于移植到非MS平台上。 与纯 Servlets相比：JSP可以很方便的编写或者修改HTML网页而不用去面对大量的println语句。 与SSI相比：SSI无法使用表单数据、无法进行数据库链接。 与JavaScript相比：虽然JavaScript可以在客户端动态生成HTML，但是很难与服务器交互，因此不能提供复杂的服务，比如访问数据库和图像处理等等。 与静态HTML相比：静态HTML不包含动态信息。 接下来呢？ 我们将会带您一步一步地来搭建JSP运行环境，这需要有一定的Java基础。
如果您还未学过Java，可以先学习我们为您提供的Java教程。</description></item><item><title>一、JUnit – 概述</title><link>https://www.shellio.cc/docs/java/junit/1/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/junit/1/</guid><description>JUnit – 概述 所谓单元测试是测试应用程序的功能是否能够按需要正常运行，并且确保是在开发人员的水平上，单元测试生成图片。单元测试是一个对单一实体（类或方法）的测试。单元测试是每个软件公司提高产品质量、满足客户需求的重要环节。
单元测试可以由两种方式完成
人工测试 自动测试 手动执行测试用例并不借助任何工具的测试被称为人工测试。
– 消耗时间并单调：由于测试用例是由人力资源执行，所以非常缓慢并乏味。
– 人力资源上投资巨大：由于测试用例需要人工执行，所以在人工测试上需要更多的试验员。
– 可信度较低：人工测试可信度较低是可能由于人工错误导致测试运行时不够精确。
– 非程式化：编写复杂并可以获取隐藏的信息的测试的话，这样的程序无法编写。 借助工具支持并且利用自动工具执行用例被称为自动测试。
– 快速自动化运行测试用例时明显比人力资源快。 – 人力资源投资较少：测试用例由自动工具执行，所以在自动测试中需要较少的试验员。
– 可信度更高：自动化测试每次运行时精确地执行相同的操作。
– 程式化：试验员可以编写复杂的测试来显示隐藏信息。 什么是 JUnit？ JUnit 是一个 Java 编程语言的单元测试框架。JUnit 在测试驱动的开发方面有很重要的发展，是起源于 JUnit 的一个统称为 xUnit 的单元测试框架之一。
JUnit 促进了“先测试后编码”的理念，强调建立测试数据的一段代码，可以先测试，然后再应用。这个方法就好比“测试一点，编码一点，测试一点，编码一点……”，增加了程序员的产量和程序的稳定性，可以减少程序员的压力和花费在排错上的时间。
特点： JUnit 是一个开放的资源框架，用于编写和运行测试。 提供注释来识别测试方法。 提供断言来测试预期结果。 提供测试运行来运行测试。 JUnit 测试允许你编写代码更快，并能提高质量。 JUnit 优雅简洁。没那么复杂，花费时间较少。 JUnit 测试可以自动运行并且检查自身结果并提供即时反馈。所以也没有必要人工梳理测试结果的报告。 JUnit 测试可以被组织为测试套件，包含测试用例，甚至其他的测试套件。 JUnit 在一个条中显示进度。如果运行良好则是绿色；如果运行失败，则变成红色。 什么是一个单元测试用例? 单元测试用例是一部分代码，可以确保另一端代码（方法）按预期工作。为了迅速达到预期的结果，就需要测试框架。JUnit 是 java 编程语言理想的单元测试框架。
一个正式的编写好的单元测试用例的特点是：已知输入和预期输出，即在测试执行前就已知。已知输入需要测试的先决条件，预期输出需要测试后置条件。
每一项需求至少需要两个单元测试用例：一个正检验，一个负检验。如果一个需求有子需求，每一个子需求必须至少有正检验和负检验两个测试用例。</description></item><item><title>一、Maven 概述</title><link>https://www.shellio.cc/docs/java/maven/1/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/maven/1/</guid><description>Maven – 概述 Maven 是什么？ Maven 是一个项目管理和整合工具。Maven 为开发者提供了一套完整的构建生命周期框架。开发团队几乎不用花多少时间就能够自动完成工程的基础构建配置，因为 Maven 使用了一个标准的目录结构和一个默认的构建生命周期。
在有多个开发团队环境的情况下，Maven 能够在很短的时间内使得每项工作都按照标准进行。因为大部分的工程配置操作都非常简单并且可复用，在创建报告、检查、构建和测试自动配置时，Maven 可以让开发者的工作变得更简单。
Maven 能够帮助开发者完成以下工作：
构建 文档生成 报告 依赖 SCMs 发布 分发 邮件列表 总的来说，Maven 简化了工程的构建过程，并对其标准化。它无缝衔接了编译、发布、文档生成、团队合作和其他任务。Maven 提高了重用性，负责了大部分构建相关的任务。
Maven 的历史 Maven 最初是在 Jakarta Turbine 项目中为了简化构建过程而设计的。项目中有几个子工程，每个工程包含稍有不同的 ANT 文件。JAR 文件使用 CVS 管理。
Apache 小组随后开发了 Maven，能够同时构建多个工程、发布工程信息、部署工程、在几个工程中共享 JAR 文件，并且协助团队合作。
Maven 的目标 Maven 的主要目的是为开发者提供
一个可复用、可维护、更易理解的工程综合模型 与这个模型交互的插件或者工具 Maven 工程结构和内容被定义在一个 xml 文件中 － pom.xml，是 Project Object Model (POM) 的简称，此文件是整个 Maven 系统的基础组件。详细内容请参考 Maven POM 部分。
约定优于配置 Maven 使用约定而不是配置，意味着开发者不需要再自己创建构建过程。
开发者不需要再关心每一个配置细节。Maven 为工程提供了合理的默认行为。当创建 Maven 工程时，Maven 会创建默认的工程结构。开发者只需要合理的放置文件，而在 pom.</description></item><item><title>一、Memcached 教程</title><link>https://www.shellio.cc/docs/java/memcached/1/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/java/memcached/1/</guid><description>Memcached是一个自由开源的，高性能，分布式内存键值对缓存系统
Memcached 是一种基于内存的key-value存储，用来存储小块的任意数据（字符串、对象），这些数据可以是数据库调用、API调用或者是页面渲染的结果
Memcached 的简洁设计便于快速开发，减轻开发难度，解决了大数据量缓存的很多问题
它的API 通俗易懂，非常容易开发，且兼容大部分流行的开发语言。
简单的说： Memcached 是一个简洁的key-value内存缓存存储系统
使用 Memcached 后的架构图 有了Memcached ，我们就可以通过缓存数据库查询结果，减少数据库访问次数，以提高动态Web应用的速度、提高可扩展性
![Memcached 缓存构架] (/static/i/memcached_goujia.jpg)
Memcached 官网 http://memcached.org/
Memcached 特征 Memcached作为高速运行的分布式缓存服务器，具有以下的特点
协议简单，使用文本协议，使用换行符作为命令结束 基于 libevent 的事件处理 内置内存存储方式 Memcached 使用客户端哈希的不互相通信的分布式</description></item></channel></rss>