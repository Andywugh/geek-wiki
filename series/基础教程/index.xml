<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>基础教程 on 程序员安仔</title><link>https://www.shellio.cc/series/%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/</link><description>Recent content in 基础教程 on 程序员安仔</description><generator>Hugo -- gohugo.io</generator><language>zh-hans</language><copyright>个人技术博客</copyright><lastBuildDate>Sat, 21 Oct 2023 12:22:54 +0800</lastBuildDate><atom:link href="https://www.shellio.cc/series/%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/index.xml" rel="self" type="application/rss+xml"/><item><title>八、Git 创建仓库 – git init</title><link>https://www.shellio.cc/docs/git/8/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/git/8/</guid><description>Git使用 git init 命令初始化一个 Git 仓库
我们可以使用一个已经存在的目录作为 Git 仓库
git init 命令 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 Git使用 git init 命令来初始化一个 Git 仓库
Git的很多命令都需要在 Git 的仓库中运行，所以 git init 是使用 Git 的第一个命令
在执行完成 git init 命令后
Git仓库会生成一个 .git 目录，该目录包含了资源的所有元数据，其它的项目目录保持不变
语法 下面的命令在当前目录下创建一个 Git 仓库
1$ git init 2Initialized empty Git repository in /tmp/git/.git/ 该命令执行完后会在当前目录生成一个 .git 目录
1$ ls -al 2total 0 3drwxr-xr-x 4 penglei staff 128 11 4 17:33 . 4drwxrwxrwx 52 penglei staff 1664 11 4 17:33 .</description></item><item><title>八、Go 语言常量</title><link>https://www.shellio.cc/docs/programing/golang/8/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/programing/golang/8/</guid><description>常量是一个简单值的标识符，在程序运行时，不会被修改的量。
常量中的数据类型只可以是布尔型、数字型（整数型、浮点型和复数）和字符串型。
常量的定义格式：
1const identifier [type] = value 我们可以省略类型说明符 [type]，因为编译器可以根据变量的值来推断其类型
显式类型定义：const b string = &amp;ldquo;abc&amp;rdquo; 隐式类型定义：const b = &amp;ldquo;abc&amp;rdquo; 多个相同类型的声明可以简写为：
1const c_name1, c_name2 = value1, value2 下面的范例演示了常量的使用
1/** 2 * file: main.go 3 * author: DDKK.COM 弟弟快看，程序员编程资料站(ddkk.com) 4 * Copyright © 2015-2065 ddkk.com. All rights reserved. 5 */ 6package main 7import &amp;#34;fmt&amp;#34; 8func main() { 9 const LENGTH int = 10 10 const WIDTH int = 5 11 var area int 12 const a, b, c = 1, false, &amp;#34;str&amp;#34; //多重赋值 13 area = LENGTH * WIDTH 14 fmt.</description></item><item><title>二、Git 安装 – Linux</title><link>https://www.shellio.cc/docs/git/2/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/git/2/</guid><description>Git不是系统内置的软件，需要安装才能使用
Git是垮平台的，支持的系统有 Linux/Unix、Solaris、Mac和 Windows
Git各个平台的安装包下载地址为 http://git-scm.com/downloads
下面我们就来介绍如何在 Linux 平台安装 Git
Linux 平台上安装 Git 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 Git需要依赖 curl，zlib，openssl，expat，libiconv 等第三方库，因此在安装之前我们先要安装这些依赖
各个系统都有包管理工具，我们可以很容易使用这些包管理工具协助安装
安装完依赖后我们就能安装 Git 了，各个 Linux 平台安装 Git 步骤如下
Debian/Ubuntu 1、 安装依赖；
1 $ apt-get install libcurl4-gnutls-dev libexpat1-dev gettext libz-dev libssl-dev 2、 安装Git；
1 $ apt-get install git-core 3、 查看Git版本；
1 $ git --version 2 git version 1.8.3.1 Centos/RedHat 1、 安装依赖；
1 $ yum install curl-devel expat-devel gettext-devel openssl-devel zlib-devel 2、 安装Git；
1 $ yum -y install git-core 3、 查看安装的Git版本；</description></item><item><title>二、Go 语言 – 简介</title><link>https://www.shellio.cc/docs/programing/golang/2/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/programing/golang/2/</guid><description>Golang 是一种设计用来系统编程的通用语言
Go语言最初在 2007 年由Google Griesemer，Rob Pike 和 Ken Thompson 在 Google 开发，并于 2009 年 11 月对外公布
Go语言提供垃圾收集的内置支持，并支持并发编程
Go 编程的特点 1、 支持类型推到功能，例如x：=0会自动判断x是int类型；
2、 编译时间快；
3、 内置并发支持：轻量级进程（通过goroutine），channel，select语句；
4、 Go程序简单，简洁，安全；
5、 支持接口和类型绑定；
6、 生成没有外部依赖关系的静态链接的本机二进制可执行文件；
Go 语言刻意避免的语法 为了保持语言简洁扼要，Go 语言删减了很多其它语言都有的功能
1、 不支持类型继承；
2、 不支持方法或操作符重载；
3、 不支持包之间的循环依赖；
4、 不支持指针运算；
5、 不支持断言；
6、 不支持泛型编程；</description></item><item><title>二十、Git 快速参考手册</title><link>https://www.shellio.cc/docs/git/20/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/git/20/</guid><description>我们制作了一份 Git 快速参考手册供随时预览
Gitcheat sheet 让你不用再去记所有的 git 命令
配置 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 列出当前配置 1$ git config --list 列出 repository 配置 1$ git config --local --list 列出全局配置 1$ git config --global --list 列出系统配置 1$ git config --system --list 设置用户名 1$ git config --global user.name “[firstname lastname]” 设置用户邮箱 1$ git config --global user.email “[valid-email]” 设置 git 命令输出为彩色 1$ git config --global color.ui auto 设置 git 使用的文本编辑器 1$ git config --global core.editor vi 配置文件 Repository 配置对应的配置文件路径[–local] 1&amp;lt;repo&amp;gt;/.</description></item><item><title>二十、Go 语言 – 哈希表(map)</title><link>https://www.shellio.cc/docs/programing/golang/20/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/programing/golang/20/</guid><description>map又称哈希表，是一种一种无序的键值对的集合
map最重要特点是通过 key 来快速检索数据，key 类似于索引，指向数据的值
Go语言中的 map 也是一种集合，所以我们可以像迭代数组和切片那样迭代它
但在迭代时需要注意：map 是无序的，我们无法决定它的返回顺序，因为 map 是使用 hash 表来实现的
定义 map 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 1.使用内建函数 make 来定义 map 1map_variable := make(map[key_data_type]value_data_type) 2. 使用 map 关键字来定义 map 这种方式声明的 map 默认是 nil
1var map_variable map[key_data_type]value_data_type 如果不初始化 map，那么就会创建一个 nil map
nilmap 不能用来存放键值对
范例 下面的范例演示了如何定义 map 和如何通过 键(key) 访问 map 中的元素
1/** 2 * file: main.go 3 * author: DDKK.COM 弟弟快看，程序员编程资料站(ddkk.com) 4 * Copyright © 2015-2065 ddkk.com. All rights reserved. 5 */ 6package main 7import &amp;#34;fmt&amp;#34; 8func main() { 9 var countryCapitalmap map[string]string 10 /* 创建集合 */ 11 countryCapitalmap = make(map[string]string) 12 /* map 插入 key-value 对，各个国家对应的首都 */ 13 countryCapitalmap[&amp;#34;France&amp;#34;] = &amp;#34;Paris&amp;#34; 14 countryCapitalmap[&amp;#34;Italy&amp;#34;] = &amp;#34;Rome&amp;#34; 15 countryCapitalmap[&amp;#34;Japan&amp;#34;] = &amp;#34;Tokyo&amp;#34; 16 countryCapitalmap[&amp;#34;India&amp;#34;] = &amp;#34;New Delhi&amp;#34; 17 /* 使用 key 输出 map 值 */ 18 for country := range countryCapitalmap { 19 fmt.</description></item><item><title>二十八、Go 语言 – 多维数组</title><link>https://www.shellio.cc/docs/programing/golang/28/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/programing/golang/28/</guid><description>Go语言支持多维数组
语法 Go语言声明多维数组的语法格式如下
1var variable_name [SIZE1][SIZE2]...[SIZEN] variable_type 下面的代码声明了三维整形数组：
1var threedim [5][10][4]int 二维数组 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 二维数组是最简单的多维数组
二维数组本质上是由一维数组组成的
语法 Go语言定义二维数组的语法格式如下
1var arrayName [ x ][ y ] variable_type 其中
variable_type 是数据类型，可以是基本数据类型，也可以是结构体或者 map 等数据类型 arrayName 为数组名 二维数组可认为是一个表格，x 为行，y 为列，下图演示了一个二维数组 a 为三行四列
初始化二维数组 二维数组可通过大括号来初始值
下面的代码初始化了一个 3 行 4 列的二维数组
1a = [3][4]int{ 2 {0, 1, 2, 3} , /* 第一行索引为 0 */ 3 {4, 5, 6, 7} , /* 第二行索引为 1 */ 4 {8, 9, 10, 11} /* 第三行索引为 2 */ 访问二维数组 二维数组可以通过指定坐标来访问，如数组中的行索引与列索引 a[ i ][ j ]</description></item><item><title>二十二、Git Flow</title><link>https://www.shellio.cc/docs/git/22/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/git/22/</guid><description>GitFlow 是一种使用 Git 开展项目的工作流程
安装 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 你需要有一个可以工作的 git 作为前提。 Git flow 可以工作在 OSX, Linux 和 Windows之下 OSX Homebrew: 1$ brew install git-flow OSX Macports: 1$ port install git-flow Linux: 1$ apt-get install git-flow Windows (Cygwin): 安装git-flow, 你需要 wget 和 util-linux。
1$ wget -q -O - --no-check-certificate https://github.com/nvie/gitflow/raw/develop/contrib/gitflow-installer.sh | bash 开始 为了自定义你的项目，Git flow 需要初始化过程。 使用 git-flow，从初始化一个现有的 git 库内开始。 初始化，你必须回答几个关于分支的命名约定的问题。建议使用默认值。 1git flow init 特性 为即将发布的版本开发新功能特性 这通常只存在开发者的库中 创建一个新特性: 下面操作创建了一个新的 feature 分支，并切换到该分支
1git flow feature start MYFEATURE 完成新特性的开发: 完成开发新特性。这个动作执行下面的操作： 1.</description></item><item><title>二十二、Go 语言 – 关键字 delete</title><link>https://www.shellio.cc/docs/programing/golang/22/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/programing/golang/22/</guid><description>Go语言 delete 关键字用于删除哈希表 map 中的元素, 参数为 map 和其对应的 key
语法 Go语言 delete 关键字语法格式如下
1delete(map,key) 范例 1/** 2 * file: main.go 3 * author: DDKK.COM 弟弟快看，程序员编程资料站(ddkk.com) 4 * Copyright © 2015-2065 ddkk.com. All rights reserved. 5 */ 6package main 7import &amp;#34;fmt&amp;#34; 8func main() { 9 /* 创建 map */ 10 countryCapitalMap := map[string] string {&amp;#34;France&amp;#34;:&amp;#34;Paris&amp;#34;,&amp;#34;Italy&amp;#34;:&amp;#34;Rome&amp;#34;,&amp;#34;Japan&amp;#34;:&amp;#34;Tokyo&amp;#34;,&amp;#34;India&amp;#34;:&amp;#34;New Delhi&amp;#34;} 11 fmt.Println(&amp;#34;原始 map&amp;#34;) 12 /* 打印 map */ 13 for country := range countryCapitalMap { 14 fmt.</description></item><item><title>二十九、Go 语言 break 语句</title><link>https://www.shellio.cc/docs/programing/golang/29/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/programing/golang/29/</guid><description>Go语言中的 break 语句既可以用于退出循环又可以跳出 case 语句
语法 Go语言 break 语句语法格式如下
1break; break 语句用于以下两方面：
1、 用于在循环语句中跳出循环，并开始执行循环之后的语句；
2、 用在switch中在执行一条case后跳出语句的作用；
break 语句流程图 Go语言 break 语句执行流程如下
范例 1/** 2 * file: main.go 3 * author: DDKK.COM 弟弟快看，程序员编程资料站(ddkk.com) 4 * Copyright © 2015-2065 ddkk.com. All rights reserved. 5 */ 6package main 7import &amp;#34;fmt&amp;#34; 8func main() { 9 /* 定义局部变量 */ 10 var a int = 11 11 /* for 循环 */ 12 for a &amp;lt; 17 { 13 fmt.</description></item><item><title>二十六、Go 语言 – 开发工具</title><link>https://www.shellio.cc/docs/programing/golang/26/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/programing/golang/26/</guid><description>我们推荐使用下面四款 Go 语言开发工具，排名不分先后
1. Sublime Text 3 Sublime Text 是一款具有代码高亮、语法提示、自动完成且反应快速的编辑器软件，不仅具有华丽的界面，还支持插件扩展机制，用她来写代码，绝对是一种享受
相比于难于上手的 Vim，浮肿沉重的 Eclipse，VS，即便体积轻巧迅速启动的 Editplus、Notepad++，在 Sublime Text 面前大略显失色，无疑这款性感无比的编辑器是 Coding 和Writing 最佳的选择，没有之一
Sublime Text 3 下载地址 http://www.sublimetext.com/3
你可以选择合适的平台，然后下载安装即可
更多Sublime Text 3 的内容，可以查看 如何优雅地使用Sublime Text
2. Visual Studio Code 在Build 2015 大会上，微软推出免费跨平台的 Visual Studio Code 编辑器
Visual Studio Code (简称 VS Code / VSC) 是一款免费开源的现代化轻量级代码编辑器，支持几乎所有主流的开发语言的语法高亮、智能代码补全、自定义热键、括号匹配、代码片段、代码对比 Diff、GIT 等特性，支持插件扩展，并针对网页开发和云端应用开发做了优化
软件跨平台支持 Win、Mac 以及 Linux，运行流畅，可谓是微软的良心之作…
Visual Studio Code 下载地址 https://code.visualstudio.com/
3. LiteIDE LiteIDE 是一款开源、跨平台的轻量级 Go 语言集成开发环境（IDE）
支持的操作系统 Windows x86 (32-bit or 64-bit) Linux x86 (32-bit or 64-bit) MacOS X10.</description></item><item><title>二十七、Go 语言 for 循环语句</title><link>https://www.shellio.cc/docs/programing/golang/27/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/programing/golang/27/</guid><description>Go语言 for 循环语句是一个循环控制结构，可以执行指定次数的循环
语法 Go语言的 for循环有 3 种形式，但只有其中的一种使用分号
1. 和 C 语言 的 for 一样 1for init; condition; post { } 2. 和 C 语言的 while 语句 一样 1for condition { } 3. 和 C 的 for(;;) 一样 1for { } 上面3 种 for 语句中
init： 一般为赋值表达式，给控制变量赋初值 condition： 关系表达式或逻辑表达式，循环控制条件 post： 一般为赋值表达式，给控制变量增量或减量 for语句执行过程如下 1、 先对表达式1赋初值；
2、 判断赋值表达式init是否满足给定条件：；
11. 若其值为真，满足循环条件，则执行循环体内语句，然后执行 post，进入第二次循环，再判别 condition 22. 否则判断 condition 的值为假，不满足条件，就终止for循环，执行循环体外语句 for…range 语句 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 for循环的 range 语句可以对 slice、map、数组、字符串等进行迭代循环</description></item><item><title>二十三、Go 语言递归函数</title><link>https://www.shellio.cc/docs/programing/golang/23/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/programing/golang/23/</guid><description>程序调用自身的编程技巧称为递归（ recursion）
一般来说，递归需要有边界条件、递归前进段和递归返回段
当边界条件不满足时，递归前进；当边界条件满足时，递归返回
Go语言支持递归调用
语法 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 Go语言中递归调用的语法格式如下
1func recursion() { 2 recursion() /* 函数调用自身 */ 3func main() { 4 recursion() 记住，在在使用递归时，需要设置退出条件，否则递归将陷入无限循环中
递归函数对于解决数学上的问题是非常有用的，就像计算阶乘，生成斐波那契数列等
范例： 阶乘 下面的范例通过 Go 语言的递归函数实例阶乘
1/** 2 * file: main.go 3 * author: DDKK.COM 弟弟快看，程序员编程资料站(ddkk.com) 4 * Copyright © 2015-2065 ddkk.com. All rights reserved. 5 */ 6package main 7import &amp;#34;fmt&amp;#34; 8func Factorial(x int) (result int) { 9 if x == 0 { 10 result = 1; 11 } else { 12 result = x * Factorial(x - 1); 13 } 14 return; 15func main() { 16 var i int = 15 17 fmt.</description></item><item><title>二十四、Go 语言 – 类型转换</title><link>https://www.shellio.cc/docs/programing/golang/24/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/programing/golang/24/</guid><description>类型转换就是将一种数据类型的变量转换成另一种数据类型的变量
语法 Go语言类型转换语法格式如下
1type_name(expression) 其中
type_name 为数据类型 expression 为需要转换的表达式，可以是变量，常量或者结构体等 范例 下面的范例两个 int 类型的变量 sum 和 count 转换成 float32 型的变量
1/** 2 * file: main.go 3 * author: DDKK.COM 弟弟快看，程序员编程资料站(ddkk.com) 4 * Copyright © 2015-2065 ddkk.com. All rights reserved. 5 */ 6package main 7import &amp;#34;fmt&amp;#34; 8func main() { 9 var sum int = 17 10 var count int = 5 11 var mean float32 12 mean = float32(sum)/float32(count) 13 fmt.Printf(&amp;#34;mean 的值为: %f\n&amp;#34;,mean) 编译运行以上 Go 语言范例，输出结果如下</description></item><item><title>二十五、Go 语言 – 错误处理</title><link>https://www.shellio.cc/docs/programing/golang/25/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/programing/golang/25/</guid><description>Go语言通过内置的错误接口提供了非常简单的错误处理机制
Go语言中的错误处理分为五个步骤
1、 生成错误；
2、 返回错误；
3、 接收错误；
4、 错误判断；
5、 处理错误；
看起来很多，但其实每个都是一句话的事
1. 定义错误类型 Go语言提供了 error interface 类型来生成错误
error 类型是一个接口类型，它的定义如下：
1type error interface { 2 Error() string 我们可以在代码中通过实现 error 接口类型来生成错误信息
1errors.New(&amp;#34;这里定义错误消息&amp;#34;) 2. 返回错误 Go语言没有其它语言那样的 try...catch...except..finall 的错误处理机制，它简单的直接返回错误给调用者，让调用者自己处理错误
Go语言函数通常在最后的返回值中返回错误信息
1func Sqrt(f float64) (float64, error) { 2 if f &amp;lt; 0 { 3 return 0, errors.New(&amp;#34;math: square root of negative number&amp;#34;) 4 } 5 // 实现 3. 接收错误 因为函数会返回错误，所以我们可以定义一个变量来接收错误，Go 社区推荐使用 err 作为变量名</description></item><item><title>二十一、Git 基本操作</title><link>https://www.shellio.cc/docs/git/21/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/git/21/</guid><description>Git的工作就是创建和保存项目的快照及与之后的快照进行对比
本章我们对之前所学的 Git 知识做一个简单的梳理
获取与创建项目命令 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 git init 用git init 在目录中创建新的 Git 仓库。 你可以在任何时候、任何目录中这么做，完全是本地化的。
在目录中执行 git init，就可以创建一个 Git 仓库了。比如我们创建 souyunku 项目：
1$ mkdir souyunku 2$ cd souyunku/ 3$ git init 4Initialized empty Git repository in /Users/tianqixin/www/souyunku/.git/ 5# 在 /www/souyunku/.git/ 目录初始化空 Git 仓库完毕。 现在你可以看到在你的项目中生成了 .git 这个子目录。 这就是你的 Git 仓库了，所有有关你的此项目的快照数据都存放在这里。
1ls -a 2. .. .git git clone 使用git clone 拷贝一个 Git 仓库到本地，让自己能够查看该项目，或者进行修改。
如果你需要与他人合作一个项目，或者想要复制一个项目，看看代码，你就可以克隆那个项目。 执行命令：
1git clone [url] [url] 为你想要复制的项目，就可以了。
例如我们克隆 Github 上的项目：</description></item><item><title>二十一、Go 语言 – range 关键字</title><link>https://www.shellio.cc/docs/programing/golang/21/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/programing/golang/21/</guid><description>Go语言中 range 关键字用于 for 循环 中迭代数组(array)、切片(slice)、通道(channel)或集合(map)的元素
range 在迭代数组和切片时返回元素的索引值，在集合中返回 key-value 对的 key 值
范例 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 1/** 2 * file: main.go 3 * author: DDKK.COM 弟弟快看，程序员编程资料站(ddkk.com) 4 * Copyright © 2015-2065 ddkk.com. All rights reserved. 5 */ 6package main 7import &amp;#34;fmt&amp;#34; 8func main() { 9 //这是我们使用range去求一个slice的和。使用数组跟这个很类似 10 nums := []int{2, 3, 4} 11 sum := 0 12 for _, num := range nums { 13 sum += num 14 } 15 fmt.</description></item><item><title>九、Git 添加文件到暂存区- git add</title><link>https://www.shellio.cc/docs/git/9/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/git/9/</guid><description>前面我们已经初始化了一个 Git 仓库
假设我们已经创建了几个文件，如下
1$ tree . 2├── README 3└── main.c 40 directories, 2 files 现在我们想让这几个文件提交到暂存区，则需要使用 git add 命令
语法 gitadd 语法格式如下
1$ git add &amp;lt;file&amp;gt; 范例 比如下面的命令就是把当前目录下的 README 和 main.c 提交到暂存区
1$ git add *.c 2$ git add README 我们可以使用 git status 查看暂存区的状态
1$ git status 2On branch master 3No commits yet 4Changes to be committed: 5 (use &amp;#34;git rm --cached &amp;lt;file&amp;gt;...&amp;#34; to unstage) 6 new file: README 7 new file: main.</description></item><item><title>九、Go 语言运算符</title><link>https://www.shellio.cc/docs/programing/golang/9/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/programing/golang/9/</guid><description>运算符用于在程序运行时执行数学或逻辑运算
Go 语言内置了如下几种运算符 算术运算符 关系运算符 逻辑运算符 位运算符 赋值运算符 其他运算符 算术运算符 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 下表列出了 Go 语言支持的所有算术运算符
我们假定 A 值为 13，B 值为 7
运算符 描述 范例 + 相加 A + B 输出结果 20 – 相减 A – B 输出结果 6 * 相乘 A * B 输出结果 91 / 相除 A / B 输出结果 2 % 求余 A % B 输出结果 6 ++ 自增 A++ 输出结果 14 — 自减 A– 输出结果 10 范例 1/** 2 * file: main.</description></item><item><title>六、Git 工作流程</title><link>https://www.shellio.cc/docs/git/6/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/git/6/</guid><description>配置好了 Git，我们就可以来学习如何使用 Git 进行日常的开发
使用Git 日常开发的流程一般如下
1、 创建或克隆Git资源作为工作目录；
2、 在克隆的资源上添加或修改文件；
3、 如果其他人修改了，我们可以更新资源；
4、 在提交前查看修改；
5、 提交修改到本地；
6、 提交修改到远程；
7、 在修改完成后，如果发现错误，可以撤回提交并再次修改并提交；
下图展示了这种工作的流程</description></item><item><title>六、Go 语言数据类型</title><link>https://www.shellio.cc/docs/programing/golang/6/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/programing/golang/6/</guid><description>数据类型用于声明函数和变量
数据类型指的是用于声明不同类型的变量或函数的一个广泛的系统。
变量的类型决定了变量存储占用的空间，以及如何解释存储的位模式
Go 语言数据类别 Go语言按类别有以下几种数据类型：
类型 描述 布尔型 布尔型的值只可以是常量 true 或者 false 数字类型 包括整型 int 和浮点型 float
Go 语言支持整型和浮点型数字，并且原生支持复数 字符串类型 字符串就是一串固定长度的字符连接起来的字符序列
Go 的字符串是由单个字节连接起来的
Go 语言的字符串的字节使用 UTF-8编码标识 Unicode 文本 派生类型 包括：(a) 指针类型（Pointer）(b) 数组类型(c) 结构化类型(struct) (d) Channel 类型(e) 函数类型(f) 切片类型 (g) 接口类型（interface）(h) Map 类型 数字类型 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 1. 整形 类型 描述 uint8 无符号 8 位整型 (0 到 255) uint16 无符号 16 位整型 (0 到 65535) uint32 无符号 32 位整型 (0 到 4294967295) uint64 无符号 64 位整型 (0 到 18446744073709551615) int8 有符号 8 位整型 (-128 到 127) int16 有符号 16 位整型 (-32768 到 32767) int32 有符号 32 位整型 (-2147483648 到 2147483647) int64 有符号 64 位整型 (-9223372036854775808 到 9223372036854775807) 2.</description></item><item><title>七、Git 工作区、暂存区和版本库</title><link>https://www.shellio.cc/docs/git/7/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/git/7/</guid><description>我们已经了解了使用 Git 进行日常开发的基本流程，现在我们来学习 Git 三大基本概念
Git日常开发几乎都是与 工作区、暂存区和版本库打交道
工作区、暂存区和版本库 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 1、 **工作区：**我们在电脑上能看到的目录；
2、 **暂存区：**英文stage,或index；
1暂存区一般存放在 &amp;#34;.git目录下&amp;#34; 下的 index 文件 ( .git/index )中 2有些地方把暂存区有时也叫作索引 ( index ) 3、 **版本库：**工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库；
工作区、暂存区和版本库在目录中的位置如下 工作区、暂存区和版本库关系图示 下图展示了工作区、版本库中的暂存区和版本库之间的关系
图中
左侧为工作区 右侧为版本库 在版本库中标记为 “index” 的区域是暂存区（stage, index） 标记为 “master” 的是 master 分支所代表的目录树。 图中我们可以看出此时 “HEAD” 实际是指向 master 分支的一个”游标” 所以图示的命令中出现 HEAD 的地方可以用 master 来替换
图中的 objects 标识的区域为 Git 的对象库，实际位于 “.git/objects” 目录下，里面包含了创建的各种对象及内容 git 命令的效果 1、 当对工作区修改（或新增）的文件执行gitadd命令时，暂存区的目录树被更新，同时工作区修改（或新增）的文件内容被写入到对象库中的一个新的对象中，而该对象的ID被记录在暂存区的文件索引中；
2、 当执行提交操作gitcommit-m&amp;lt;message&amp;gt;时，暂存区的目录树写到版本库（对象库）中，master分支会做相应的更新；
1即 master 指向的目录树就是提交时暂存区的目录树 3、 当执行gitresetHEAD命令时，暂存区的目录树会被重写，被master分支指向的目录树所替换，但是工作区不受影响；</description></item><item><title>七、Go 语言变量</title><link>https://www.shellio.cc/docs/programing/golang/7/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/programing/golang/7/</guid><description>变量是程序可操作的存储区的名称。Go 语言中 中每个变量都有特定的类型，类型决定了变量存储的大小和布局，该范围内的值都可以存储在内存中
Go语言中的变量名是标准的标识符，由字母、数字、下划线组成，不能以数字开头
变量声明 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 var 关键字用来声明变量
1var identifier type 声明变量时可以指定变量类型，声明后若不赋值，Go 语言会使用默认值
1var v_name v_type 2v_name = value 声明变量时同时初始化，则可以省去变量类型， Go 编译器会根据值自行判定变量类型
1var v_name = value 声明变量时还可以省去 var 关键字，但要同时初始化，语法如下
1v_name := value 注意:= 左侧的变量不能是已经声明过的，否则会导致编译错误
例如
1var a int = 10 2var b = 10 3c : = 10 范例 1package main 2var a = &amp;#34;DDKK.COM 弟弟快看，程序员编程资料站&amp;#34; 3var b string = &amp;#34;ddkk.com&amp;#34; 4var c bool 5func main(){ 6 println(a, b, c) 编译运行以上 Go 语言范例，输出结果如下</description></item><item><title>三、Git 安装 – Window</title><link>https://www.shellio.cc/docs/git/3/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/git/3/</guid><description>Git不是系统内置的软件，需要安装才能使用
Git是垮平台的，支持的系统有 Linux/Unix、Solaris、Mac和 Windows
Git各个平台的安装包下载地址为 http://git-scm.com/downloads
Windows 平台上安装 Git 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 Windows 上可以使用 msysgit 项目提供的安装包
msysgit 的官方地址为 http://msysgit.github.io/
很悲剧的一点，似乎受到某些不可抗击的原因，下载速度简直慢如蜗牛
我们可以选择合适的 CPU 版本，现在的 Window 电脑一般都是 64 位的
下载完成可以双击 Git-2.15.0-64-bit.exe 进行安装
msysgit 除了提供终端(命令行) 的 git 命令外，还提供了操作简单的 Git 图形界面
安装完成后可以在开始菜单里找到”Git”-&amp;gt;”Git Bash”，会弹出 Git 命令窗口
接下来我们就可以在该窗口进行 Git 操作</description></item><item><title>三、Go 语言环境配置</title><link>https://www.shellio.cc/docs/programing/golang/3/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/programing/golang/3/</guid><description>Go语言是垮平台的，它支持主流的操作系统，包括但不限于以下几种
1、 Linux；
2、 FreeBSD；
3、 MacOSX（也称为Darwin）；
4、 Window；
Go语言安装包下载地址是 https://golang.org/dl/
如果你访问不了上面的网址，也可以使用 [Go 语言中文网 – 下载][Go _ _]
当前最新的版本是 1.9.2
Go 语言各个系统对应的包名 操作系统 包名 Windows go1.9.2.windows-amd64.msi Linux go1.9.2.linux-amd64.tar.gz Mac go1.9.2darwin-amd64-osx10.8.pkg FreeBSD go1.9.2.freebsd-amd64.tar.gz UNIX/Linux/Mac OS X, 和 FreeBSD 安装 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 接下来我们介绍如何在 UNIX/Linux/Mac OS X 和 FreeBSD系统下配置 Golang 环境
1、 下载go1.9.2.linux-amd64.tar.gz；
2、 解压go1.9.2.linux-amd64.tar.gz到/usr/local目录；
1 tar -C /usr/local -xzf go1.9.2.linux-amd64.tar.gz 3、 将/usr/local/go/bin目录添加至PATH环境变量；
1 export PATH=$PATH:/usr/local/go/bin Mac 其它安装方法 1、 使用brew；
1 brew installl go 2、 直接下载.</description></item><item><title>三十、Go 语言 – 指向指针的指针</title><link>https://www.shellio.cc/docs/programing/golang/30/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/programing/golang/30/</guid><description>如果一个指针变量存放的又是另一个指针变量的地址，则称这个指针变量为指向指针的指针变量
好绕口啊，指向指针的指针呢就是一个指针的变量的值是另一个指针
当定义一个指向指针的指针变量时，第一个指针存放第二个指针的地址，第二个指针存放变量的地址：
语法 Go语言声明指向指针的指针变量的语法格式如下
1var ptr **int; 上面的代码中指向指针的指针变量 ptr 为整型
访问指向指针的指针变量 访问指向指针的指针变量值需要使用两个 * 号
1println(**ptr) 范例 1/** 2 * file: main.go 3 * author: DDKK.COM 弟弟快看，程序员编程资料站(ddkk.com) 4 * Copyright © 2015-2065 ddkk.com. All rights reserved. 5 */ 6package main 7import &amp;#34;fmt&amp;#34; 8func main() { 9 var a int 10 var ptr *int 11 var pptr **int 12 a = 3000 13 /* 指针 ptr 地址 */ 14 ptr = &amp;amp;a 15 /* 指向指针 ptr 地址 */ 16 pptr = &amp;amp;ptr 17 /* 获取 pptr 的值 */ 18 fmt.</description></item><item><title>三十八、Go 语言 select 语句</title><link>https://www.shellio.cc/docs/programing/golang/38/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/programing/golang/38/</guid><description>Go语言相比于其它语言多了 select 语句这种判断结构
select 语句是 Go 语言的一个控制结构，类似于用于 channel 的 switch 语句
select 语句中的每个 case 语句必须是一个 channel 操作，要么是发送要么是接收
select 语句随机执行一个可运行的 case，如果没有 case 可运行，它将阻塞，直到有 case 可运行
default 语句应该总是可运行的
语法 Go语言 select 语句语法格式如下
1select { 2 case communication clause : 3 statement(s); 4 case communication clause : 5 statement(s); 6 /* 你可以定义任意数量的 case */ 7 default : /* 可选 */ 8 statement(s); 1、 每个case都必须是一个channel；
2、 所有channel表达式都会被求值；
3、 所有被发送的表达式都会被求值；
4、 如果任意某个channel可以进行，它就执行；其他被忽略；
5、 如果多个case都可以运行，select语句会随机公平地选出一个执行，其他不会执行；
1否则： 2 * 如果有 default 子句，则执行该语句 3 * 如果没有 default 子句，select 将阻塞，直到某个 channel 可以运行； 6、 select不会重新对channel或值进行求值；</description></item><item><title>三十二、Go 语言 goto 语句</title><link>https://www.shellio.cc/docs/programing/golang/32/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/programing/golang/32/</guid><description>Go语言的 goto 语句可以无条件地将执行流程转移到 label 指定的行
goto 语句通常与条件语句配合使用，可用来实现条件转移， 构成循环，跳出循环体等功能
但是，在结构化程序设计中一般不主张使用 goto 语句， 以免造成程序流程的混乱，使理解和调试程序都产生困难
但是，Go 这么简洁的语言竟然还保留了 goto ，说明它还是很有用的，是不是很矛盾
语法 Go语言 goto 语句语法格式如下
1goto label; 2.. 3... 4label: statement; label 可以在 goto 语句之前，也可以在 goto 语句之后
break 语句流程图 Go语言 break 语句执行流程如下
范例 1/** 2 * file: main.go 3 * author: DDKK.COM 弟弟快看，程序员编程资料站(ddkk.com) 4 * Copyright © 2015-2065 ddkk.com. All rights reserved. 5 */ 6package main 7import &amp;#34;fmt&amp;#34; 8func main() { 9 /* 定义局部变量 */ 10 var a int = 11 11 /* 循环 */ 12 LOOP: for a &amp;lt; 17 { 13 if a == 15 { 14 /* 跳过迭代 */ 15 a = a + 1 16 goto LOOP 17 } 18 fmt.</description></item><item><title>三十九、Go 语言 if…else 语句</title><link>https://www.shellio.cc/docs/programing/golang/39/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/programing/golang/39/</guid><description>Go语言 if 语句 后可以使用可选的 else 语句
else 语句中的表达式在布尔表达式为 false 时执行
语法 Go语言 if…else 语句语法格式如下：
1if 布尔表达式 { 2 /* 在布尔表达式为 true 时执行 */ 3} else { 4 /* 在布尔表达式为 false 时执行 */ 在if 在布尔表达式为 true 时执行
如果布尔表达式为 false 则执行 else 语句块
Go 语言 if…else 语句流程图 Go语言 if…else 语句流程图如下
范例 1/** 2 * file: main.go 3 * author: DDKK.COM 弟弟快看，程序员编程资料站(ddkk.com) 4 * Copyright © 2015-2065 ddkk.com. All rights reserved. 5 */ 6package main 7import &amp;#34;fmt&amp;#34; 8func main() { 9 /* 局部变量定义 */ 10 var a int = 21; 11 /* 判断布尔表达式 */ 12 if a &amp;lt; 17 { 13 /* 如果条件为 true 则执行以下语句 */ 14 fmt.</description></item><item><title>三十六、Go 语言 – 向函数传递数组</title><link>https://www.shellio.cc/docs/programing/golang/36/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/programing/golang/36/</guid><description>Go语言的可以向函数传递数组作为参数
如果想向函数传递数组参数，我们需要在函数定义时，声明形参为数组
声明形参为数组的方法有两种
1. 形参设定数组大小 1func myFunction(param [10]int) 2 // 函数体 2. 形参未设定数组大小 如果形参未设定数组大小，则需要额外的形参告知函数数组的大小
1func myFunction(param []int, length int) 2 // 函数体 范例 1. 我们先定义一个 getAverage 函数 getAverage() 函数接收整型数组参数，另一个参数指定了数组元素的个数，并返回平均值
1func getAverage(arr []int, size int) float32 2 var i int 3 var avg, sum float32 4 for i = 0; i &amp;lt; size; ++i { 5 sum += arr[i] 6 } 7 return sum / size 然后我们写一个范例调用上面定义的函数
1/** 2 * file: main.</description></item><item><title>三十七、Go 语言 – 函数 – 引用传值</title><link>https://www.shellio.cc/docs/programing/golang/37/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/programing/golang/37/</guid><description>引用传值是指在调用函数时将实际参数的地址传递到函数中，那么在函数中对参数所进行的修改，将影响到实际参数
范例 这个swap 函数，通过引用传值，交换两个变量的值
1/* 定义交换值函数*/ 2func swap(x *int, y *int) { 3 var temp int 4 temp = *x /* 保持 x 地址上的值 */ 5 *x = *y /* 将 y 值赋给 x */ 6 *y = temp /* 将 temp 值赋给 y */ 以下我们通过使用引用传递来调用 swap() 函数：
1/** 2 * file: main.go 3 * author: DDKK.COM 弟弟快看，程序员编程资料站(ddkk.com) 4 * Copyright © 2015-2065 ddkk.com. All rights reserved. 5 */ 6package main 7import &amp;#34;fmt&amp;#34; 8func main() { 9 /* 定义局部变量 */ 10 var a int = 13 11 var b int= 17 12 fmt.</description></item><item><title>三十三、Go 语言 if 语句</title><link>https://www.shellio.cc/docs/programing/golang/33/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/programing/golang/33/</guid><description>Go语言 if 语句由布尔表达式后紧跟一个或多个语句组成。
语法 Go语言中 if 语句语法格式如下
1if 布尔表达式 { 2 /* 在布尔表达式为 true 时执行 */ if语句在布尔表达式为 true 时，执行大括号里的语句块，如果为 false 则跳过大括号里的语句
Go 语言 if 语句流程图 范例 1/** 2 * file: main.go 3 * author: DDKK.COM 弟弟快看，程序员编程资料站(ddkk.com) 4 * Copyright © 2015-2065 ddkk.com. All rights reserved. 5 */ 6package main 7import &amp;#34;fmt&amp;#34; 8func main() { 9 /* 定义局部变量 */ 10 var a int = 13 11 /* 使用 if 语句判断布尔表达式 */ 12 if a &amp;lt; 17 { 13 /* 如果条件为 true 则执行以下语句 */ 14 fmt.</description></item><item><title>三十四、Go 语言函数值传递调用</title><link>https://www.shellio.cc/docs/programing/golang/34/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/programing/golang/34/</guid><description>值传递是指在调用函数时将实际参数复制一份传递到函数中，这样在函数中如果对参数进行修改，将不会影响到实际参数
Go语言默认使用值传递，即在调用过程中不会影响到实际参数
范例 我们先定义一个 swap() 函数用来交换两个变量的值
1/* 定义相互交换值的函数 */ 2func swap(x, y int) int { 3 var temp int 4 temp = x /* 保存 x 的值 */ 5 x = y /* 将 y 值赋给 x */ 6 y = temp /* 将 temp 值赋给 y*/ 7 return temp; 接下来我们使用值传递调用刚刚定义的 swap() 函数
1/** 2 * file: main.go 3 * author: DDKK.COM 弟弟快看，程序员编程资料站(ddkk.com) 4 * Copyright © 2015-2065 ddkk.com. All rights reserved.</description></item><item><title>三十五、Go 语言 for 循环嵌套</title><link>https://www.shellio.cc/docs/programing/golang/35/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/programing/golang/35/</guid><description>Go语言允许在 for 循环语句内再使用 for 循环语句
语法 for语句嵌套 for 语句格式如下：
1for [condition | ( init; condition; increment ) | Range] 2 for [condition | ( init; condition; increment ) | Range] 3 { 4 statement(s); 5 } 6 statement(s); 范例 我们使用 for 循环嵌套语句输出 2 到 50 之间所有的素数
1/** 2 * file: main.go 3 * author: DDKK.COM 弟弟快看，程序员编程资料站(ddkk.com) 4 * Copyright © 2015-2065 ddkk.com. All rights reserved. 5 */ 6package main 7import &amp;#34;fmt&amp;#34; 8func main() { 9 /* 定义局部变量 */ 10 var i, j int 11 for i=2; i &amp;lt; 50; i++ { 12 for j=2; j &amp;lt;= (i/j); j++ { 13 if(i%j==0) { 14 break; // 如果发现因子，则不是素数 15 } 16 } 17 if(j &amp;gt; (i/j)) { 18 fmt.</description></item><item><title>三十一、Go 语言 – 指针作为函数参数</title><link>https://www.shellio.cc/docs/programing/golang/31/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/programing/golang/31/</guid><description>Go语言允许向函数传递指针
向函数传递指针只需要在函数定义是将参数上设置为指针类型即可
例如下面的函数 swap 的 2 个形参就是指针类型
1func swap(x *int, y *int) { 2 var temp int 3 temp = *x /* 保存 x 地址的值 */ 4 *x = *y /* 将 y 赋值给 x */ 5 *y = temp /* 将 temp 赋值给 y */ 范例 下面的范例演示了如何向函数传递指针，并在函数内部修改指针变量的值
1/** 2 * file: main.go 3 * author: DDKK.COM 弟弟快看，程序员编程资料站(ddkk.com) 4 * Copyright © 2015-2065 ddkk.com. All rights reserved. 5 */ 6package main 7import &amp;#34;fmt&amp;#34; 8func main() { 9 /* 定义局部变量 */ 10 var a int = 13 11 var b int= 7 12 fmt.</description></item><item><title>十、Git 提交文件到版本库 – git commit</title><link>https://www.shellio.cc/docs/git/10/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/git/10/</guid><description>前面章节我们已经把 README 和 main.c 文件从工作区添加到了暂存区
假设我们已经完成了开发任务，需要把暂存区的文件提交到版本库
使用git commit 命令可以把当前暂存区的文件提交到版本库
语法 gitcommit 命令语法格式如下
1$ git commit -m &amp;#34;&amp;lt;本次提交说明信息&amp;gt;&amp;#34; 范例 使用以下的命令可以把 README 和 main.c 文件提交到版本库
1$ git commit -m &amp;#34;初始化项目&amp;#34; 输出结果如下
因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 1$ git commit -m &amp;#34;初始化项目&amp;#34; 2[master (root-commit) b8af03d] 初始化项目 3 2 files changed, 0 insertions(+), 0 deletions(-) 4 create mode 100644 README 5 create mode 100644 main.c 使用git status 查看当前项目状态，显示如下
1$ git status 2On branch master 3nothing to commit, working tree clean 使用git log --pretty=oneline 可以查看我们刚刚的提交</description></item><item><title>十、Go 语言条件语句</title><link>https://www.shellio.cc/docs/programing/golang/10/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/programing/golang/10/</guid><description>判断语句要求程序员指定一个或多个要评估或测试的条件，以及条件为真时要执行的语句（必需的）和条件为假时要执行的语句（可选的）
Go语言把任何 非零 和 非空 的值假定为 true ，把 零 或 null 假定为 false
下面是大多数编程语言中典型的判断结构的一般形式
判断语句 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 Go语言提供了以下 5 种条件判断语句：
语句 描述 if 语句 if 语句由一个布尔表达式后紧跟一个或多个语句组成 if…else 语句 if 语句后可以使用可选的else 语句
else 语句中的表达式在布尔表达式为 false 时执行 if 嵌套语句 你可以在if或else if语句中嵌入一个或多个if或else if语句 switch 语句 switch语句用于基于不同条件执行不同动作 select 语句 select 会随机执行一个可运行的 case
如果没有 case 可运行，它将阻塞，直到有 case 可运行</description></item><item><title>十八、Git 远程仓库 ( Github )</title><link>https://www.shellio.cc/docs/git/18/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/git/18/</guid><description>之前我们使用到的 Git 命令都是在本地执行，如果你想通过 Git 分享代码或者与其它开发人员合作
那么就需要将数据放到一台其他开发人员能够连接的服务器上
本章节，我们将使用 GitHub 作为远程仓库，演示如何操作远程仓库
如果你还没有 Github 账号，可以在官网 https://github.com/ 注册
配置 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 由于我们的本地 Git 仓库和 GitHub 仓库之间的传输是通过 SSH 加密的，所以我们需要配置验证信息
1、 使用以下命令生成SSHKey；
1 ssh-keygen -t rsa -C &amp;#34;your_email@youremail.com&amp;#34; 1后面的 **your\_email@youremail.com** 改为你在 github 上注册的邮箱 2、 然后会出现下面的提示要求确认路径；
1 Enter file in which to save the key (~/.ssh/id_rsa): 1我们建议将路径改成 ~/.ssh/github 2也就是最后会保存为 github 而不是 id_rsa 3&amp;gt; 这样可以避免主要的 SSH 被覆盖 3、 按回车之后，会出现下面的提示要求输入密码，我们这使用默认的一路回车就行；
1 Enter passphrase (empty for no passphrase): 2 Enter same passphrase again: 1&amp;gt; 为什么不设置呢？ 因为有些 Git 客户端软件没有设置密码的地方，省的以后每次输入密码麻烦 4、 成功的话会在~/.</description></item><item><title>十八、Go 语言 – 数据类型 interface</title><link>https://www.shellio.cc/docs/programing/golang/18/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/programing/golang/18/</guid><description>很多教程都把 interface 翻译成接口，类似于 Java 但我觉得还是把它称之为一种数据类型，它类似于 Java 中的 Object
interface 把所有的具有共性的方法定义在一起， 任何其他类型只要实现了这些方法就是实现了这个 interface
我们可以这么理解， Go 语言没有基类，如果有那么就是
1interface {} 任何一个 inteface 都是这个基类的子类，因为它们都可以向上一路转换到 interface{}
比如说
1interface add { 2 add() 是的子类
语法 Go语言定义 interface 的语法格式如下
1type interface_name interface { 2 method_name1 [return_type] 3 method_name2 [return_type] 4 method_name3 [return_type] 5 ... 6 method_namen [return_type] 如果一个 结构体 struct 实现了一个 interface 中所有的方法，那么我们就可以说这个结构体实现了这个 interface
1/* 定义结构体 */ 2type struct_name struct { 3 /* variables */ 4/* 实现接口方法 */ 5func (struct_name_variable struct_name) method_name1() [return_type] { 6 /* 方法实现 */ 7.</description></item><item><title>十二、Git 删除文件 – git rm</title><link>https://www.shellio.cc/docs/git/12/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/git/12/</guid><description>如果只是简单地从工作目录中手工删除文件，运行 git status 时就显示 Changes not staged for commit的提示
要从Git 中移除某个文件，就必须要从已跟踪文件清单中移除，然后提交。可以用以下命令完成此项工作
1git rm &amp;lt;file&amp;gt; 如果删除之前修改过并且已经放到暂存区域的话，则必须要用强制删除选项-f
1git rm -f &amp;lt;file&amp;gt; 如果把文件从暂存区域移除，但仍然希望保留在当前工作目录中，换句话说，仅是从跟踪清单中删除，使用–cached选项即可
1git rm --cached &amp;lt;file&amp;gt; 如我们删除 hello.php文件：
因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 1$ git rm hello.php 2rm &amp;#39;hello.php&amp;#39; 3$ ls 4README 不从工作区中删除文件：
1$ git rm --cached README 2rm &amp;#39;README&amp;#39; 3$ ls 4README 可以递归删除，即如果后面跟的是一个目录做为参数，则会递归删除整个目录中的所有子目录和文件：
1git rm –r * 进入某个目录中，执行此语句，会删除该目录下的所有文件和子目录。</description></item><item><title>十二、Go 语言函数</title><link>https://www.shellio.cc/docs/programing/golang/12/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/programing/golang/12/</guid><description>函数是代码块的包装，把一些完成指定任务的代码放到一起，起个名字，就成为了函数
因此我们可以使用函数来划分不同功能，逻辑上每个函数执行的是指定的任务
Go语言使用 func 关键字定义函数
函数定义 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 Go语言函数定义语法格式如下：
1func function_name( [parameter list] ) [return_types] { 2 //函数体 func ： 函数由 func 开始声明 **function_name ：**函数名称，函数名和参数列表一起构成了函数签名 parameter list： 参数列表 参数就像一个占位符，当函数被调用时，我们可以将值传递给参数，这个值被称为实际参数
参数列表指定的是参数类型、顺序、及参数个数。参数是可选的，也就是说函数也可以不包含参数
return_types： 返回类型 函数返回一列值，return_types 是该列值的数据类型
有些功能不需要返回值，这种情况下 return_types 不是必须的
函数体： 函数定义的代码集合 其它说明 Go语言至少有个 main() 函数
函数声明告诉了编译器函数的名称，返回类型，和参数
Go语言标准库提供了多种可动用的内置的函数
例如，len() 函数可以接受不同类型参数并返回该类型的长度，例如我们传入的是字符串则返回字符串的长度，如果传入的是数组，则返回数组中包含的函数个数
范例 下面的代码定义了一个 max 函数
max函数传入两个整型参数 num1 和 num2，并返回这两个参数的最大值
1/* 函数返回两个数的最大值 */ 2func max(num1, num2 int) int { 3 /* 声明局部变量 */ 4 var result int 5 if (num1 &amp;gt; num2) { 6 result = num1 7 } else { 8 result = num2 9 } 10 return result 函数调用 创建函数，就是定义了函数需要做什么</description></item><item><title>十九、Git 远程服务搭建</title><link>https://www.shellio.cc/docs/git/19/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/git/19/</guid><description>我们可能需要与别人共享代码，协作开发
这时候我们就需要一台 Git 服务器作为远程 Git 仓库
下面我们就以在 Centos7 上安装 Git 服务器为例学习如何配置远程 Git 仓库
1. 安装 Git 依赖 1[root@ddkk.com ~]# yum install curl-devel expat-devel gettext-devel openssl-devel zlib-devel perl-devel 2. 安装 Git 1[root@ddkk.com ~]# yum install git 3. 创建 git 用户和用户组 创建一个git用户组和用户，用来运行 Git 服务
1[root@ddkk.com ~]# groupadd git 2[root@ddkk.com ~]# adduser git -g git 4. 创建 ssh 登录证书 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 收集所有需要登录的用户的公钥，公钥位于 ~/.ssh/id_rsa.pub 文件中
把每个开发者的公钥导入到 /home/git/.ssh/authorized_keys 文件里，一行一个
如果没有 /home/git/.ssh/authorized_keys 文件则使用下面的命令创建
1[root@ddkk.com ~]# cd /home/git/ 2[root@ddkk.</description></item><item><title>十九、Go 语言 – 切片(slice)</title><link>https://www.shellio.cc/docs/programing/golang/19/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/programing/golang/19/</guid><description>Go语言切片是对数组的抽象
Go语言数组的长度不可改变，在特定场景中这样的集合就不太适用
Go语言提供了一种灵活，功能强悍的内置类型切片(slice,”动态数组”)
slice 的长度是不固定的，可以追加元素，在追加时可能使切片的容量增大
定义切片 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 声明切片(slice) 的语法和声明数组的语法一样，除了不用在中括号内设置数组的长度
1var identifier []type 切片不需要指定长度
或者可以使用 make 关键字来创建切片
1var slice1 []type = make([]type, len) 也可以简写为
1slice1 := make([]type, len) 也可以指定容量，其中capacity为可选参数。
1make([]T, length, capacity) 这里len 切片的初始长度
切片初始化 可以在定义切片的同时初始化
1s :=[] int {1,2,3 } []表示是切片类型，{1,2,3}初始化值依次是1,2,3
其中cap=len=3
可以使用对数组的应用来创建切片 语法如下
1s := arr[startIndex:endIndex] 将arr 中从下标 startIndex 到 endIndex-1 下的元素创建为一个新的切片
如果 startIndex 和 endIndex 都缺省，则表示引用数组的全部数据 1s := arr[:] 缺省endIndex时将表示一直到arr的最后一个元素 1s := arr[startIndex:] 缺省startIndex时将表示从arr的第一个元素开始 1s := arr[:endIndex] 可以通过切片 s 初始化切片 s1 1s1 := s[startIndex:endIndex] 通过内置函数make()初始化切片s,[]int 标识为其元素类型为 int 的切片 1s :=make([]int,len,cap) len() 和 cap() 函数 切片是可索引的，并且可以由 len() 方法获取长度</description></item><item><title>十六、Git 查看提交历史 – git log</title><link>https://www.shellio.cc/docs/git/16/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/git/16/</guid><description>在使用Git 提交了若干更新之后，又或者克隆了某个项目，想回顾下提交历史，我们可以使用 git log 命令查看。
针对我们前一章节的操作，使用 git log 命令列出历史提交记录如下：
1$ git log 2commit 88afe0e02adcdfea6844bb627de97da21eb10af1 3Merge: 14b4dca d7e7346 4Author: penglei penglei@souyunku.cn 5Date: Sun Mar 1 15:03:42 2015 +0800 6 Merge branch &amp;#39;change_site&amp;#39; 7 Conflicts: 8 test.txt 9commit 14b4dcadbdc847207651d5a9fae0d315057f346e 10Author: penglei penglei@souyunku.cn 11Date: Sun Mar 1 14:53:15 2015 +0800 12 新增加一行 13commit d7e734640da06055e107eaf29cf350b3f1de1c2c 14Author: penglei penglei@souyunku.cn 15Date: Sun Mar 1 14:48:57 2015 +0800 16 changed the site 17commit 556f0a0637978097b82287ac665a717623b21f3f 18Author: penglei penglei@souyunku.cn 19Date: Sun Mar 1 14:40:34 2015 +0800 20 removed test2.</description></item><item><title>十六、Go 语言 – 指针</title><link>https://www.shellio.cc/docs/programing/golang/16/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/programing/golang/16/</guid><description>我们前面学习过，每一个变量都有一个内存位置，每一个内存位置都可使用取址运算符(&amp;amp;) 来访问的地址，它表示了在内存中的一个地址。
Go语言支持指针，但只支持指针的取址运算符(&amp;amp;) 和解址运算符(*),不支持指针的算术运算
因此Go 语言中指针是很容易学习的，Go 语言中使用指针可以更简单的执行一些任务
下面的范例输出了变量 a 在内存中的地址
1/** 2 * file: main.go 3 * author: DDKK.COM 弟弟快看，程序员编程资料站(ddkk.com) 4 * Copyright © 2015-2065 ddkk.com. All rights reserved. 5 */ 6package main 7import &amp;#34;fmt&amp;#34; 8func main() { 9 var a int = 10 10 fmt.Printf(&amp;#34;变量的地址: %x\n&amp;#34;, &amp;amp;a ) 编译运行以上 Go 语言范例，输出结果如下
1$ go run main.go 2变量的地址: c420014158 什么是指针 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 一个指针变量可以指向任何一个值的内存地址它指向那个值的内存地址
指针类似于变量和常量，在使用指针前需要声明指针
语法 声明一个指针的语法格式如下
1var var_name *var-type var-type 为指针类型 var_name 为指针变量名 号用于指定变量是作为一个指针 一个指针变量通常缩写为 ptr</description></item><item><title>十七、Git 标签 – git tag</title><link>https://www.shellio.cc/docs/git/17/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/git/17/</guid><description>如果你达到一个重要的阶段，并希望永远记住那个特别的提交快照，你可以使用 git tag 给它打上标签。
比如说，我们想为我们的 git-demo 项目发布一个 “1.0” 版本
我们可以用 git tag -a v1.0 命令给最新一次提交打上（HEAD）”v1.0″的标签。
-a选项意为”创建一个带注解的标签”。 不用 -a 选项也可以执行的，但它不会记录这标签是啥时候打的，谁打的，也不会让你添加个标签的注解。 我推荐一直创建带注解的标签。
1$ git tag -a v1.0 当你执行 git tag -a 命令时，Git 会打开你的编辑器，让你写一句标签注解，就像你给提交写注解一样。
现在，注意当我们执行 git log –decorate 时，我们可以看到我们的标签了：
1$ git log --oneline --decorate --graph 2* 88afe0e (HEAD, tag: v1.0, master) Merge branch &amp;#39;change_site&amp;#39; 3|\ 4| * d7e7346 (change_site) changed the site 5* | 14b4dca 新增加一行 6|/ 7* 556f0a0 removed test2.txt 8* 2e082b7 add test2.</description></item><item><title>十七、Go 语言 – 结构体</title><link>https://www.shellio.cc/docs/programing/golang/17/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/programing/golang/17/</guid><description>Go语言中数组可以存储相同类型的数据， 结构 则是另一种允许用户自定义的可用的数据类型，它允许您存储不同类型的数据。
结构通常用于表示一条记录，假设想要跟踪图书馆中书本的动态，我们可能需要跟踪每本书的下列属性：
Title Author Subject Book ID 定义结构体 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 Go语言使用 type 和 struct 关键字定义结构体
struct 语句定义了一个新的数据类型，结构体有中一个或多个成员
type 语句设定了结构体的名称
定义结构体语法 Go语言定义结构体的语法格式如下
1type struct_variable_type struct { 2 member definition; 3 member definition; 4 ... 5 member definition; 一旦定义了结构体类型，我们就能用它来声明变量
定义结构体变量语法 一旦定义了结构体类型，它就能用于变量的声明，语法格式如下
1variable_name := structure_variable_type {value1, value2...valuen} 访问结构体成员 Go语言使用点号(.)操作符访问结构体成员
格式为：”结构体.成员名”
范例 下面的语句定义了一个结构体 Books
1/** 2 * file: main.go 3 * author: DDKK.COM 弟弟快看，程序员编程资料站(ddkk.com) 4 * Copyright © 2015-2065 ddkk.com. All rights reserved.</description></item><item><title>十三、Git 重命名文件 – git mv</title><link>https://www.shellio.cc/docs/git/13/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/git/13/</guid><description>gitmv 命令用于移动或重命名一个文件、目录、软连接
语法 gitmv 命令语法格式如下
1git mv &amp;lt;old_file&amp;gt; &amp;lt;new_file&amp;gt; 范例 假如当前项目版本库中有如下文件
1$ ls 2README main.c 现在我们想把 README 文件重命名为 README.md 则可以使用下面的命令
因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 1$ git mv README README.md 2$ ls 3README.md main.c 4$ git status 5On branch master 6Changes to be committed: 7 (use &amp;#34;git reset HEAD &amp;lt;file&amp;gt;...&amp;#34; to unstage) 8 renamed: README -&amp;gt; README.md 9(spider) 我们可以看到，重命名后文件会放入暂存区，需要使用 git commit 命令提交到仓库</description></item><item><title>十三、Go 语言 – 变量作用域</title><link>https://www.shellio.cc/docs/programing/golang/13/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/programing/golang/13/</guid><description>通常来说，一段程序代码中所用到的变量并不总是有效/可用的，而限定这个变量的可用性的代码范围就是这个变量的作用域 简称变量作用域
作用域标示了常量、类型、变量、函数或包在源代码中的作用范围
Go语言中变量可以在三个地方声明
1、 函数内定义的变量称为局部变量；
2、 函数外定义的变量称为全局变量；
3、 函数定义中的变量称为形式参数；
局部变量 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 在函数体内声明的变量称之为局部变量，它们的作用域只在函数体内，参数和返回值变量也是局部变量
下面的范例定义了三个局部变量 a, b, c
1package main 2import &amp;#34;fmt&amp;#34; 3func main() { 4 /* 声明局部变量 */ 5 var a, b, c int 6 /* 初始化参数 */ 7 a = 10 8 b = 20 9 c = a + b 10 fmt.Printf (&amp;#34;结果： a = %d, b = %d and c = %d\n&amp;#34;, a, b, c) 编译运行以上 Go 语言范例，输出结果如下</description></item><item><title>十四、Git 取消已缓存 – git reset HEAD</title><link>https://www.shellio.cc/docs/git/14/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/git/14/</guid><description>gitreset HEAD 命令用于取消已缓存的内容
我们先将 README 文件内容修改如下
1DDKK.COM 弟弟快看，程序员编程资料站 (ddkk.com) 2DDKK.COM 弟弟快看，程序员编程资料站，教程 hello.php 文件修改为：
1&amp;lt;?php 2echo &amp;#39;教程 ：ddkk.com&amp;#39;; 3echo &amp;#39;教程 ：ddkk.com&amp;#39;; 4echo &amp;#39;教程 ：ddkk.com&amp;#39;; 然后将两个修改的文件都提交到了缓存区，我们现在要取消其中一个的缓存，操作如下：
因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 1$ git status -s 2 M README 3 M hello.php 4$ git add . 5$ git status -s 6M README 7M hello.php 8$ git reset HEAD -- hello.php 9Unstaged changes after reset: 10M hello.php 11$ git status -s 12M README 13 M hello.php 现在我们执行 git commit，只会将 README 文件的改动提交，而 hello.</description></item><item><title>十四、Go 语言 – 数组</title><link>https://www.shellio.cc/docs/programing/golang/14/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/programing/golang/14/</guid><description>数组是具有相同唯一类型的一组已编号且长度固定的数据项序列，这种类型可以是任意的原始类型例如整形、字符串或者自定义类型
相对于去声明 number0, number1, …, and number99 的变量，使用数组形式 numbers[0], numbers[1] …, numbers[99] 更加方便且易于扩展
数组元素可以通过索引（位置）来读取（或者修改），索引从0开始，第一个元素索引为 0，第二个索引为 1，以此类推
Go语言提供了数组类型的数据结构，而且索引下表从 0 开始
声明数组 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 Go语言数组声明需要指定元素类型及元素个数
语法 Go语言声明数组的语法格式如下
1var variable_name [SIZE] variable_type 上面是一维数组的定义语法
数组长度必须是整数且大于 0
下面的代码定义了一个长度为 10 的 float32 类型的数组
1var balance [10] float32 初始化数组 Go语言的数组初始化和 C/C++ 语言一样，使用大括号 ( {} )
1var balance = [5]float32{1000.0, 2.0, 3.4, 7.0, 50.0} 初始化数组时带括号 {} 中的元素个数不能大于中括号 [] 中的数字
如果忽略 [] 中的数字不设置数组大小，Go 语言会根据元素的个数来设置数组的大小
1var balance = [...]float32{1000.0, 2.0, 3.</description></item><item><title>十五、Git 分支管理 – git branch</title><link>https://www.shellio.cc/docs/git/15/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/git/15/</guid><description>几乎每一种版本控制系统都以某种形式支持分支
使用分支意味着你可以从开发主线上分离开来，然后在不影响主线的同时继续工作
有人把Git 的分支模型称为”必杀技特性”，而正是因为它，将 Git 从版本控制系统家族里区分出来
创建分支命令： 1git branch (branchname) 切换分支命令: 1git checkout (branchname) 当我们切换分支的时候，Git 会用该分支的最后提交的快照替换你的工作目录的内容， 所以多个分支不需要多个目录。
合并分支命令 1git merge 我们可以多次合并到统一分支， 也可以选择在合并之后直接删除被并入的分支。
列出分支 列出分支基本命令：
因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 1git branch 没有参数时，git branch 会列出你在本地的分支。
1$ git branch 2* master 此例的意思就是，我们有一个叫做”master”的分支，并且该分支是当前分支。
当你执行 git init 的时候，缺省情况下 Git 就会为你创建”master”分支。
如果我们要手动创建一个分支。执行 git branch (branchname) 即可。
1$ git branch testing 2$ git branch 3* master 4 testing 现在我们可以看到，有了一个新分支 testing。
当你以此方式在上次提交更新之后创建了新分支，如果后来又有更新提交， 然后又切换到了”testing”分支，Git 将还原你的工作目录到你创建分支时候的样子
接下来我们将演示如何切换分支，我们用 git checkout (branch) 切换到我们要修改的分支。
1$ ls 2README 3$ echo &amp;#39;souyunku.</description></item><item><title>十五、Go 语言 – 字符串</title><link>https://www.shellio.cc/docs/programing/golang/15/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/programing/golang/15/</guid><description>Strings, which are widely used in Go programming, are a readonly slice of bytes. In the Go programming language, strings are slices . The Go platform provides various libraries to manipulate strings. – unicode – regexp – strings
Creating Strings 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 Themost direct way to create a string is to write −
1var greeting = &amp;#34;Hello world!&amp;#34; Whenever it encounters a string literal in your code, the compiler creates a string object with its value in this case, “Hello world!</description></item><item><title>十一、Git 克隆仓库 – git clone</title><link>https://www.shellio.cc/docs/git/11/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/git/11/</guid><description>Git除了可以使用 git init 初始化一个仓库外，还可以使用 git clone 从现有 Git 仓库中拷贝项目
语法 gitclone 命令克隆仓库的语法格式如下
1git clone &amp;lt;repo&amp;gt; 如果我们需要克隆到指定的目录，可以使用以下命令格式：
1git clone &amp;lt;repo&amp;gt; &amp;lt;directory&amp;gt; 参数说明 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 参数 说明 repo Git 仓库 directory 本地目录 范例 比如，要克隆 Ruby 语言的 Git 代码仓库 Grit，可以用下面的命令：
1$ git clone git://github.com/schacon/grit.git 执行该命令后，会在当前目录下创建一个名为 grit 的目录，其中包含一个 .git 的目录，用于保存下载下来的所有版本记录
如果要自己定义要新建的项目目录名称，可以在上面的命令末尾指定新的名字：
1$ git clone git://github.com/schacon/grit.git mygrit</description></item><item><title>十一、Go 语言循环语句</title><link>https://www.shellio.cc/docs/programing/golang/11/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/programing/golang/11/</guid><description>一般情况下，语句是按顺序执行的：函数中的第一个语句先执行，接着是第二个语句，依此类推。但有的时候，我们可能需要多次执行同一块代码，C 语言提供的循环语句解决了我们的问题。
循环语句和前面的条件语句，为编程语言提供了更为复杂执行路径的多种控制结构。
循环语句允许我们多次执行一个语句或语句组。
循环语句流程图 大多数编程语言循环语句的流程图如下：
Go 语言循环语句 Go语言提供了以下几种循环处理语句
循环类型 描述 for 循环语句 重复执行语句块 for 语句循环嵌套 在 for 循环中嵌套一个或多个 for 循环 循环控制语句 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 循环控制语句可以控制循环体内语句的执行过程
Go语言提供了下几种循环控制语句
控制语句 描述 break 语句 经常用于中断当前 for 循环或跳出 switch 语句 continue 语句 跳过当前循环的剩余语句，然后继续进行下一轮循环 goto 语句 将控制转移到被标记的语句 无限循环 如果for 循环中条件语句永远不为 false 则会进行无限循环
我们可以通过 for 循环语句中只设置一个 true 条件表达式来执行无限循环
1/** 2 * file: main.go 3 * author: DDKK.COM 弟弟快看，程序员编程资料站(ddkk.com) 4 * Copyright © 2015-2065 ddkk.com. All rights reserved. 5 */ 6package main 7import &amp;#34;fmt&amp;#34; 8func main() { 9 for true { 10 fmt.</description></item><item><title>四、Git 安装 – Mac OS</title><link>https://www.shellio.cc/docs/git/4/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/git/4/</guid><description>Git不是系统内置的软件，需要安装才能使用
Git是垮平台的，支持的系统有 Linux/Unix、Solaris、Mac和 Windows
Git各个平台的安装包下载地址为 http://git-scm.com/downloads
Mac 平台上安装 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 Mac平台上有两种安装 Git 的方法
1、 官方安装包；
在官方下载界面下载 Git https://git-scm.com/download/mac
这个网址会跳转到以下地址 https://sourceforge.net/projects/git-osx-installer/?source=typ_redirect
1、 下载完然后双击安装；
1、 然后右键点击git-2.14.1-intel-universal-mavericks.pkg；
1、 一路向下点击Next直至安装完成；
2、 使用brew包管理工具安装；
1$ brew install git 查看 Git 版本 1$ git --version 2git version 2.14.2</description></item><item><title>四、Go 语言结构</title><link>https://www.shellio.cc/docs/programing/golang/4/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/programing/golang/4/</guid><description>在前面的 Go 语言环境配置 我们运行了 hllo.go 范例，现在，我们就以这个范例来讲解 Go 语言的基本结构
Go Hello World 范例 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 先来看看我们之前运行的 Hello World 范例
1/** 2 * file: main.go 3 * author: DDKK.COM 弟弟快看，程序员编程资料站(ddkk.com) 4 * Copyright © 2015-2065 ddkk.com. All rights reserved. 5 */ 6package main 7import &amp;#34;fmt&amp;#34; 8func main() { 9 /* 这是我的第一个简单的程序 */ 10 greet := &amp;#34;Hello World!&amp;#34; 11 fmt.Println( greet ) 这几乎是最短的 Golang 语言程序，但麻雀虽小，五脏俱全，它包括了一下几个部分
包声明
package main 定义了包名
我们必须在源文件中非注释的第一行指明这个文件属于哪个包，如：package main
package main 表示一个可独立执行的程序，每个 Go 应用程序都包含一个名为 main 的包</description></item><item><title>四十、Go 语言 switch 语句</title><link>https://www.shellio.cc/docs/programing/golang/40/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/programing/golang/40/</guid><description>Go语言 switch 语句 根据不同条件执行不同动作
Go语言 switch 语句 中的每一个 case 分支都是唯一的，从上直下逐一测试，直到匹配为止
switch 语句执行的过程从上至下，直到找到匹配项后停止匹配
Go语言中的 switch 语句与其它语言不通，匹配项后不需要再加 break 语句
语法 Go语言 switch 语句语法格式如下
1switch var1 { 2 case val1: 3 ... 4 case val2: 5 ... 6 default: 7 ... 变量var1 可以是任何类型，而 val1 和 val2 则可以是同类型的任意值
var1 val1 val2 类型不限于常量或整数，但必须是相同的类型或者最终结果为相同类型的表达式
我们可以同时测试多个可能符合条件的值，使用逗号分割它们
1switch var1 { 2 case val1,val2,val3: 3 ... 4 case val4: 5 ... 6 default: 7 ... Go 语言 switch 语句流程图 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 Go语言 switch 语句执行流程如下</description></item><item><title>四十二、Go 语言指针数组</title><link>https://www.shellio.cc/docs/programing/golang/42/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/programing/golang/42/</guid><description>指针数组就是数组里的每一个元素保存的都是其它变量的地址的数组
一般情况下很少用到指针数组
在我们继续学习指针数组前，我们先来看一个范例
下面的范例定义了一个长度为 3 的整形数组
1/** 2 * file: main.go 3 * author: DDKK.COM 弟弟快看，程序员编程资料站(ddkk.com) 4 * Copyright © 2015-2065 ddkk.com. All rights reserved. 5 */ 6package main 7import &amp;#34;fmt&amp;#34; 8const MAX int = 3 9func main() { 10 a := []int{10,100,200} 11 var i int 12 for i = 0; i &amp;lt; MAX; i++ { 13 fmt.Printf(&amp;#34;a[%d] = %d\n&amp;#34;, i, a[i] ) 14 } 编译运行以上 Go 语言范例，输出结果如下
1$ go run main.</description></item><item><title>四十六、Go 语言 continue 语句</title><link>https://www.shellio.cc/docs/programing/golang/46/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/programing/golang/46/</guid><description>Go语言 continue 语句用于跳过剩下的循环语句开始下一次循环
continue 语句类似于 break 语句 但 continue 不是跳出循环，而是跳过当前循环执行下一次循环语句
for循环 语句中的 continue 语句会触发 for 增量语句的执行
语法 Go语言 continue 语句语法格式如下：
1continue; continue 语句流程图 Go语言 continue 语句执行流程如下所示
范例 1/** 2 * file: main.go 3 * author: DDKK.COM 弟弟快看，程序员编程资料站(ddkk.com) 4 * Copyright © 2015-2065 ddkk.com. All rights reserved. 5 */ 6package main 7import &amp;#34;fmt&amp;#34; 8func main() { 9 /* 定义局部变量 */ 10 var a int = 11 11 /* for 循环 */ 12 for a &amp;lt; 17 { 13 if a == 15 { 14 /* 跳过此次循环 */ 15 a = a + 1; 16 continue; 17 } 18 fmt.</description></item><item><title>四十三、Go 语言 if 语句嵌套</title><link>https://www.shellio.cc/docs/programing/golang/43/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/programing/golang/43/</guid><description>Go语言允许在 if 或 else if 语句中嵌入一个或多个 if 或 else if 语句
语法 Go语言 if…else 语句语法格式如下：
1if 布尔表达式 1 { 2 /* 在布尔表达式 1 为 true 时执行 */ 3 if 布尔表达式 2 { 4 /* 在布尔表达式 2 为 true 时执行 */ 5 } 同样的，我们也可以用同样的方式在 if 语句中嵌套 else if…else 语句
范例 1/** 2 * file: main.go 3 * author: DDKK.COM 弟弟快看，程序员编程资料站(ddkk.com) 4 * Copyright © 2015-2065 ddkk.com. All rights reserved. 5 */ 6package main 7import &amp;#34;fmt&amp;#34; 8func main() { 9 /* 定义局部变量 */ 10 var a int = 13 11 var b int = 7 12 /* 判断条件 */ 13 if a == 13 { 14 /* if 条件语句为 true 执行 */ 15 if b == 7 { 16 /* if 条件语句为 true 执行 */ 17 fmt.</description></item><item><title>四十四、Go 语言 – 函数作为值</title><link>https://www.shellio.cc/docs/programing/golang/44/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/programing/golang/44/</guid><description>Go语言中函数是一等公民，我们可以把一个 匿名函数 赋值给一个变量，然后向另一个函数传递这个变量
范例 下面的范例定义的函数中初始化一个变量，该函数仅仅是为了使用内置函数 math.sqrt()
1/** 2 * file: main.go 3 * author: DDKK.COM 弟弟快看，程序员编程资料站(ddkk.com) 4 * Copyright © 2015-2065 ddkk.com. All rights reserved. 5 */ 6package main 7import ( 8 &amp;#34;fmt&amp;#34; 9 &amp;#34;math&amp;#34; 10func main(){ 11 /* 声明函数变量 */ 12 getSquareRoot := func(x float64) float64 { 13 return math.Sqrt(x) 14 } 15 /* 使用函数 */ 16 fmt.Println(getSquareRoot(9)) 编译运行以上 Go 语言范例，输出结果如下
1$ go run main.go</description></item><item><title>四十五、Go 语言函数方法</title><link>https://www.shellio.cc/docs/programing/golang/45/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/programing/golang/45/</guid><description>Go语言中既有函数又有方法，一个方法就是一个包含了接受者的函数，接受者可以是命名类型或者结构体类型的一个值或者是一个指针
所有给定类型的方法属于该类型的方法集
语法 Go语言中方法的语法格式如下
1func (variable_name variable_data_type) function_name() [return_type]{ 2 /* 函数体*/ 范例 下面的范例为一个结构体类型 Circle 定义了一个 getArea() 方法
1/** 2 * file: main.go 3 * author: DDKK.COM 弟弟快看，程序员编程资料站(ddkk.com) 4 * Copyright © 2015-2065 ddkk.com. All rights reserved. 5 */ 6package main 7import ( 8 &amp;#34;fmt&amp;#34; 9/* 定义函数 */ 10type Circle struct { 11 radius float64 12func main() { 13 var c1 Circle 14 c1.radius = 10.00 15 fmt.Println(&amp;#34;Area of Circle(c1) = &amp;#34;, c1.</description></item><item><title>四十一、Go 语言 – 闭包函数</title><link>https://www.shellio.cc/docs/programing/golang/41/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/programing/golang/41/</guid><description>Go语言支持闭包函数，又称匿名函数
匿名函数是一个 “内联” 语句或表达式
匿名函数的优越性在于可以直接使用函数内的变量，不必申明
Go语言使用 func() 定义匿名函数
语法 Go语言中定义闭包函数的语法格式如下
1func([parameter_list]) [return_type] { 2 // 函数体 与一般函数的区别就是，闭包函数没有 函数名
范例 下面的范例，我们创建了一个函数 getSequence() 返回另外一个函数，该函数的目的是在闭包中递增 i 变量
1/** 2 * file: main.go 3 * author: DDKK.COM 弟弟快看，程序员编程资料站(ddkk.com) 4 * Copyright © 2015-2065 ddkk.com. All rights reserved. 5 */ 6package main 7import &amp;#34;fmt&amp;#34; 8func getSequence() func() int { 9 i:=0 10 return func() int { 11 i+=1 12 return i 13 } 14func main(){ 15 /* nextNumber 为一个函数，函数 i 为 0 */ 16 nextNumber := getSequence() 17 /* 调用 nextNumber 函数，i 变量自增 1 并返回 */ 18 fmt.</description></item><item><title>五、Git 配置 – git config</title><link>https://www.shellio.cc/docs/git/5/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/git/5/</guid><description>经过上一章的紧张安装，我们终于可以使用 Git 了，但在这之前我们先做一些简单的配置
Git提供了 git config 命令来配置 Git
Git 环境变量 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 gitconfig 命令专门用来配置或读取相应的工作环境变量
Git有三种级别的环境变量，它们分别是： 系统 Git 配置、当前用户 Git 配置 和 当前项目 Git 配置
这些环境变量，决定了 Git 在各个环节的具体工作方式和行为
三种级别的 Git 环境变量存储在 三个 不同的配置文件中
1、 系统Git配置：/etc/gitconfig文件；
1/etc/gitconfig 是对所有用户都普遍适用的配置 2可以使用以下命令来读写 /etc/gitconfig 文件 1 $ git config --system 2、 当前用户Git配置：~/.gitconfig文件；
1~/.gitconfig 这个当前用户目录下的配置文件只适用于当前用户 2可以使用以下命令来读写 ~/.gitconfig 文件 1 $ git config --global 3、 当前项目的Git配置：.git/config文件；
1.git/config 是当前项目下的配置文件，只适用于当前项目有效 2可以使用以下命令来读写 .git/config 文件 1 $ git config 每一个级别的配置都会覆盖上层的相同配置，所以 .git/config 里的配置会覆盖 /etc/gitconfig中的同名变量</description></item><item><title>五、Go 语言基础语法</title><link>https://www.shellio.cc/docs/programing/golang/5/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/programing/golang/5/</guid><description>在上一章节中我们学习了 Go 语言程序的基本结构，现在我们继续学习 Go 语言的基础语法
1. Go 标记 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 标记可以是 关键字，标识符，常量，字符串或符号
Go程序可以由多个标记组成，例如下面的 GO 语句由 6 个标记组成
1 fmt.Println(&amp;#34;Hello, World!&amp;#34;) 2//-- - ----- - ------------- - 3// 1 2 3 4 5 6 1、 fmt；
2、 .；
3、 Println；
4、 (；
5、 “Hello,World!”；
6、 )；
行分隔符 Go语言语法规定，每一行代表一个语句结束，比如下面是两个语句
每个语句不需要像 C 家族中的其它语言一样以分号(;) 结尾，这些工作会由 Go 编译器自动完成
1fmt.Println(&amp;#34;Hello, World!&amp;#34;) 2fmt.Println(&amp;#34;DDKK.COM 弟弟快看，程序员编程资料站：ddkk.com&amp;#34;) 如果我们打算将多个语句写在同一行，则必须使用分号(;) 人为区分
当然实际开发中我们不会这么做，为啥要省个那么一两行，造成代码不可读
注释 Go语言编译器会自动忽略注释
单行注释是最常见的注释形式，我们可以在任何地方使用以 // 开头的单行注释
多行注释也叫块注释，均已以 /* 开头，并以 */ 结尾</description></item><item><title>一、Git 基础教程</title><link>https://www.shellio.cc/docs/git/1/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/git/1/</guid><description>一、Git 基础教程 Git是一个开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目
Git是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件
Git采用了分布式版本库的方式，不必服务器端软件支持
Git 与 SVN 区别 GIT不仅仅是个版本控制系统，它也是个内容管理系统(CMS),工作管理系统等
如果你是一个具有使用 SVN 背景的人，你需要做一定的思想转换，来适应 GIT 提供的一些概念和特征
1、 Git是分布式的，SVN不是；
1这是 Git 和其它非分布式的版本控制系统，例如 SVN，CVS 等，最核心的区别 2、 Git把内容按元数据方式存储，而SVN是按文件；
1所有的资源控制系统都是把文件的元信息隐藏在一个类似 .svn,.cvs 等的文件夹里 3、 Git分支和SVN的分支不同；
1SVN 中的分支可以说是版本库的另一个目录 4、 Git没有一个全局的版本号，而SVN有；
5、 Git的内容完整性要优于SVN；
1Git 的内容存储使用的是 SHA-1 哈希算法 2这能确保代码内容的完整性，确保在遇到磁盘故障和网络问题时降低对版本库的破坏</description></item><item><title>一、Go 语言基础教程</title><link>https://www.shellio.cc/docs/programing/golang/1/</link><pubDate>Sat, 21 Oct 2023 12:22:54 +0800</pubDate><guid>https://www.shellio.cc/docs/programing/golang/1/</guid><description>一、Go 语言基础教程 Go是一个开源的编程语言，它能让构造简单、可靠且高效的软件变得容易
Go是 2007 年末由 Google 的 Robert Griesemer, Rob Pike, Ken Thompson 三位大神开发的，并于 2009年 11 月份正式对外开放
Go语言是一种静态类型的语言，具有与 C 类似的语法
Go语言提供垃圾收集，类型安全性，动态打字功能，许多高级内置类型，如可变长度数组和键值映射
Go语言还提供了丰富的标准库
Go 语言特色 1、 简洁、快速、安全；
2、 并行、有趣、开源；
3、 内存管理、v数组安全、编译迅速；
Go 语言用途 1、 Go语言可以用于分布式系统开发，因为goroutime使得Go语言开发分布式系统变得简单；
2、 Go语言可开发Web服务，内置的http模块可以很容易就搭建一个小Web应用程序；
Go 语言 Hello World 创建一个文件 hello.go 并输入以下内容
1/** 2 * file: hello.go 3 * author: DDKK.COM 弟弟快看，程序员编程资料站(ddkk.com) 4 * Copyright © 2015-2065 ddkk.com. All rights reserved. 5 */ 6package main 7import &amp;#34;fmt&amp;#34; 8func main() { 9 fmt.</description></item><item><title>C++ 常量</title><link>https://www.shellio.cc/docs/programing/c++/default/8/</link><pubDate>Thu, 06 Oct 2022 22:42:23 +0800</pubDate><guid>https://www.shellio.cc/docs/programing/c++/default/8/</guid><description>C++ 常量 常量是固定值，在程序执行期间不会改变。这些固定的值，又叫做字面量。
常量可以是任何的基本数据类型，可分为整型数字、浮点数字、字符、字符串和布尔值。
常量就像是常规的变量，只不过常量的值在定义后不能进行修改。
整数常量 整数常量可以是十进制、八进制或十六进制的常量。前缀指定基数：0x 或 0X 表示十六进制，0 表示八进制，不带前缀则默认表示十进制。
整数常量也可以带一个后缀，后缀是 U 和 L 的组合，U 表示无符号整数（unsigned），L 表示长整数（long）。后缀可以是大写，也可以是小写，U 和 L 的顺序任意。
下面列举几个整数常量的实例：
1212 // 合法的 2215u // 合法的 30xFeeL // 合法的 4078 // 非法的：8 不是八进制的数字 5032UU // 非法的：不能重复后缀 以下是各种类型的整数常量的实例：
185 // 十进制 20213 // 八进制 30x4b // 十六进制 430 // 整数 530u // 无符号整数 630l // 长整数 730ul // 无符号长整数 浮点常量 浮点常量由整数部分、小数点、小数部分和指数部分组成。您可以使用小数形式或者指数形式来表示浮点常量。
当使用小数形式表示时，必须包含小数点、指数，或同时包含两者。当使用指数形式表示时，必须包含整数部分、小数部分，或同时包含两者。带符号的指数是用 e 或 E 引入的。
下面列举几个浮点常量的实例：
13.14159 // 合法的 2314159E-5L // 合法的 3510E // 非法的：不完整的指数 4210f // 非法的：没有小数或指数 5.</description></item><item><title>八、Docker top 查看容器进程</title><link>https://www.shellio.cc/docs/cloud-native/docker/8/</link><pubDate>Thu, 06 Oct 2022 22:42:23 +0800</pubDate><guid>https://www.shellio.cc/docs/cloud-native/docker/8/</guid><description>Docker 是一个开源的应用容器引擎，基于 Go 语言 并遵从 Apache2.0 协议开源
Docker 可以让开发者打包它们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化
Docker 使用完全使用沙箱机制，两个容器之间不会有任何接口 (这个有点像 iPhone 的 app ) ,更重要的是容器性能开销极低
学习前提 在继续阅读之前，我们希望你对 Linux 有一些基本的了解，包括
1、 会使用Linux常用的命令；
2、 知道大部分的Linux常识，比如终端、service、ip、用户、组等；
3、 熟练使用Ubuntu或者Centos或者MacOS种的一种昂；
如果你对这些知识还是一知半解，可以访问我们的 Linux 基础教程 先进行一些简单的了解
因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 Docker的应用场景 1、 Web应用的自动化打包和发布；
2、 自动化测试和持续集成、发布；
3、 在服务型环境中部署和调整数据库或其他的后台应用；
4、 从头编译或者扩展现有的OpenShift或CloudFoundry平台来搭建自己的PaaS环境；
Docker 的优点 1、 简化程序；
1Docker 让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的 Linux 机器上，便可以实现虚拟化 2Docker 改变了虚拟化的方式，使开发者可以直接将自己的成果放入 Docker 中进行管理 3方便快捷已经是 Docker 的最大优势，过去需要用数天乃至数周的 任务，在Docker容器的处理下，只需要数秒就能完成 2、 解决运维配置噩梦；
1在没有 Docker 之前，每一台机器，每一个要用到的依赖，几乎都要重新配置一遍 2比如新增一台 MySQL 数据库，就要从头开始配置所有环境 3有了 Docker 之后，只需要从仓库里把之前的 MySQL 镜像拉出来，直接使用 3、 节省开支；</description></item><item><title>C++ 环境设置</title><link>https://www.shellio.cc/docs/programing/c++/default/2/</link><pubDate>Thu, 06 Oct 2022 22:42:23 +0800</pubDate><guid>https://www.shellio.cc/docs/programing/c++/default/2/</guid><description>C++ 环境设置 本地环境设置 如果您想要设置 C++ 语言环境，您需要确保电脑上有以下两款可用的软件，文本编辑器和 C++ 编译器。
文本编辑器 这将用于输入您的程序。文本编辑器包括 Windows Notepad、OS Edit command、Brief、Epsilon、EMACS 和 vim/vi。
文本编辑器的名称和版本在不同的操作系统上可能会有所不同。例如，Notepad 通常用于 Windows 操作系统上，vim/vi 可用于 Windows 和 Linux/UNIX 操作系统上。
通过编辑器创建的文件通常称为源文件，源文件包含程序源代码。C++ 程序的源文件通常使用扩展名 .cpp、.cp 或 .c。
在开始编程之前，请确保您有一个文本编辑器，且有足够的经验来编写一个计算机程序，然后把它保存在一个文件中，编译并执行它。
C++ 编译器 写在源文件中的源代码是人类可读的源。它需要”编译”，转为机器语言，这样 CPU 可以按给定指令执行程序。
C++编译器用于把源代码编译成最终的可执行程序。
大多数的 C++ 编译器并不在乎源文件的扩展名，但是如果您未指定扩展名，则默认使用 .cpp。
最常用的免费可用的编译器是 GNU 的 C/C++ 编译器，如果您使用的是 HP 或 Solaris，则可以使用各自操作系统上的编译器。
以下部分将指导您如何在不同的操作系统上安装 GNU 的 C/C++ 编译器。这里同时提到 C/C++，主要是因为 GNU 的 gcc 编译器适合于 C 和 C++ 编程语言。
安装 GNU 的 C/C++ 编译器 UNIX/Linux 上的安装 如果您使用的是 Linux 或 UNIX，请在命令行使用下面的命令来检查您的系统上是否安装了 GCC：</description></item><item><title>二、Docker 架构</title><link>https://www.shellio.cc/docs/cloud-native/docker/2/</link><pubDate>Thu, 06 Oct 2022 22:42:23 +0800</pubDate><guid>https://www.shellio.cc/docs/cloud-native/docker/2/</guid><description>Docker 是一个开源的应用容器引擎，基于 Go 语言 并遵从 Apache2.0 协议开源
Docker 可以让开发者打包它们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化
Docker 使用完全使用沙箱机制，两个容器之间不会有任何接口 (这个有点像 iPhone 的 app ) ,更重要的是容器性能开销极低
学习前提 在继续阅读之前，我们希望你对 Linux 有一些基本的了解，包括 1、 会使用Linux常用的命令；
2、 知道大部分的Linux常识，比如终端、service、ip、用户、组等；
3、 熟练使用Ubuntu或者Centos或者MacOS种的一种昂；
如果你对这些知识还是一知半解，可以访问我们的 Linux 基础教程 先进行一些简单的了解
Docker的应用场景 1、 Web应用的自动化打包和发布；
2、 自动化测试和持续集成、发布；
3、 在服务型环境中部署和调整数据库或其他的后台应用；
4、 从头编译或者扩展现有的OpenShift或CloudFoundry平台来搭建自己的PaaS环境；
Docker 的优点 1、 简化程序；
1Docker 让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的 Linux 机器上，便可以实现虚拟化 2Docker 改变了虚拟化的方式，使开发者可以直接将自己的成果放入 Docker 中进行管理 3方便快捷已经是 Docker 的最大优势，过去需要用数天乃至数周的 任务，在Docker容器的处理下，只需要数秒就能完成 2、 解决运维配置噩梦；
1在没有 Docker 之前，每一台机器，每一个要用到的依赖，几乎都要重新配置一遍 2比如新增一台 MySQL 数据库，就要从头开始配置所有环境 3有了 Docker 之后，只需要从仓库里把之前的 MySQL 镜像拉出来，直接使用 3、 节省开支；</description></item><item><title>C++ 日期 &amp; 时间</title><link>https://www.shellio.cc/docs/programing/c++/default/20/</link><pubDate>Thu, 06 Oct 2022 22:42:23 +0800</pubDate><guid>https://www.shellio.cc/docs/programing/c++/default/20/</guid><description>C++ 日期 &amp;amp; 时间 C++标准库没有提供所谓的日期类型。C++ 继承了 C 语言用于日期和时间操作的结构和函数。为了使用日期和时间相关的函数和结构，需要在 C++ 程序中引用 头文件。
有四个与时间相关的类型：clock_t、time_t、size_t 和 tm。类型 clock_t、size_t 和 time_t 能够把系统时间和日期表示为某种整数。
结构类型 tm 把日期和时间以 C 结构的形式保存，tm 结构的定义如下：
1struct tm { 2 int tm_sec; // 秒，正常范围从 0 到 59，但允许至 61 3 int tm_min; // 分，范围从 0 到 59 4 int tm_hour; // 小时，范围从 0 到 23 5 int tm_mday; // 一月中的第几天，范围从 1 到 31 6 int tm_mon; // 月，范围从 0 到 11 7 int tm_year; // 自 1900 年起的年数 8 int tm_wday; // 一周中的第几天，范围从 0 到 6，从星期日算起 9 int tm_yday; // 一年中的第几天，范围从 0 到 365，从 1 月 1 日算起 10 int tm_isdst; // 夏令时 下面是C/C++ 中关于日期和时间的重要函数。所有这些函数都是 C/C++ 标准库的组成部分，您可以在 C++ 标准库中查看一下各个函数的细节。</description></item><item><title>二十、Docker build 构建镜像</title><link>https://www.shellio.cc/docs/cloud-native/docker/20/</link><pubDate>Thu, 06 Oct 2022 22:42:23 +0800</pubDate><guid>https://www.shellio.cc/docs/cloud-native/docker/20/</guid><description>Docker 是一个开源的应用容器引擎，基于 Go 语言 并遵从 Apache2.0 协议开源
Docker 可以让开发者打包它们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化
Docker 使用完全使用沙箱机制，两个容器之间不会有任何接口 (这个有点像 iPhone 的 app ) ,更重要的是容器性能开销极低
学习前提 在继续阅读之前，我们希望你对 Linux 有一些基本的了解，包括
1、 会使用Linux常用的命令；
2、 知道大部分的Linux常识，比如终端、service、ip、用户、组等；
3、 熟练使用Ubuntu或者Centos或者MacOS种的一种昂；
如果你对这些知识还是一知半解，可以访问我们的 Linux 基础教程 先进行一些简单的了解
Docker的应用场景 1、 Web应用的自动化打包和发布；
2、 自动化测试和持续集成、发布；
3、 在服务型环境中部署和调整数据库或其他的后台应用；
4、 从头编译或者扩展现有的OpenShift或CloudFoundry平台来搭建自己的PaaS环境；
Docker 的优点 1、 简化程序；
因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 1Docker 让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的 Linux 机器上，便可以实现虚拟化 2Docker 改变了虚拟化的方式，使开发者可以直接将自己的成果放入 Docker 中进行管理 3方便快捷已经是 Docker 的最大优势，过去需要用数天乃至数周的 任务，在Docker容器的处理下，只需要数秒就能完成 2、 解决运维配置噩梦；
1在没有 Docker 之前，每一台机器，每一个要用到的依赖，几乎都要重新配置一遍 2比如新增一台 MySQL 数据库，就要从头开始配置所有环境 3有了 Docker 之后，只需要从仓库里把之前的 MySQL 镜像拉出来，直接使用 3、 节省开支；</description></item><item><title>C++ 数据封装</title><link>https://www.shellio.cc/docs/programing/c++/default/28/</link><pubDate>Thu, 06 Oct 2022 22:42:23 +0800</pubDate><guid>https://www.shellio.cc/docs/programing/c++/default/28/</guid><description>C++ 数据封装 所有的C++ 程序都有以下两个基本要素：
**程序语句（代码）：**这是程序中执行动作的部分，它们被称为函数。 **程序数据：**数据是程序的信息，会受到程序函数的影响。 封装是面向对象编程中的把数据和操作数据的函数绑定在一起的一个概念，这样能避免受到外界的干扰和误用，从而确保了安全。数据封装引申出了另一个重要的 OOP 概念，即数据隐藏。
数据封装是一种把数据和操作数据的函数捆绑在一起的机制，数据抽象是一种仅向用户暴露接口而把具体的实现细节隐藏起来的机制。
C++通过创建类来支持封装和数据因此。我们已经知道，类包含私有成员（private）、保护成员（protected）和公有成员（public）成员。默认情况下，在类中定义的所有项目都是私有的。例如：
1class Box 2 public: 3 double getVolume(void) 4 { 5 return length * breadth * height; 6 } 7 private: 8 double length; // 长度 9 double breadth; // 宽度 10 double height; // 高度 11}; 变量length、breadth 和 height 都是私有的（private）。这意味着它们只能被 Box 类中的其他成员访问，而不能被程序中其他部分访问。这是实现封装的一种方式。
为了使类中的成员变成公有的（即，程序中的其他部分也能访问），必须在这些成员前使用 public 关键字进行声明。所有定义在 public 标识符后边的变量或函数可以被程序中所有其他的函数访问。
把一个类定义为另一个类的友元类，会暴露实现细节，从而降低了封装性。理想的做法是尽可能地对外隐藏每个类的实现细节。
数据封装的实例 C++程序中，任何带有公有和私有成员的类都可以作为数据封装和数据抽象的实例。请看下面的实例：
1#include &amp;lt;iostream&amp;gt; 2using namespace std; 3class Adder{ 4 public: 5 // 构造函数 6 Adder(int i = 0) 7 { 8 total = i; 9 } 10 // 对外的接口 11 void addNum(int number) 12 { 13 total += number; 14 } 15 // 对外的接口 16 int getTotal() 17 { 18 return total; 19 }; 20 private: 21 // 对外隐藏的数据 22 int total; 23}; 24int main( ) 25 Adder a; 26 a.</description></item><item><title>二十八、Docker 安装 MongoDB</title><link>https://www.shellio.cc/docs/cloud-native/docker/28/</link><pubDate>Thu, 06 Oct 2022 22:42:23 +0800</pubDate><guid>https://www.shellio.cc/docs/cloud-native/docker/28/</guid><description>Docker 是一个开源的应用容器引擎，基于 Go 语言 并遵从 Apache2.0 协议开源
Docker 可以让开发者打包它们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化
Docker 使用完全使用沙箱机制，两个容器之间不会有任何接口 (这个有点像 iPhone 的 app ) ,更重要的是容器性能开销极低
学习前提 在继续阅读之前，我们希望你对 Linux 有一些基本的了解，包括
1、 会使用Linux常用的命令；
2、 知道大部分的Linux常识，比如终端、service、ip、用户、组等；
3、 熟练使用Ubuntu或者Centos或者MacOS种的一种昂；
如果你对这些知识还是一知半解，可以访问我们的 Linux 基础教程 先进行一些简单的了解
Docker的应用场景 1、 Web应用的自动化打包和发布；
2、 自动化测试和持续集成、发布；
3、 在服务型环境中部署和调整数据库或其他的后台应用；
4、 从头编译或者扩展现有的OpenShift或CloudFoundry平台来搭建自己的PaaS环境；
Docker 的优点 1、 简化程序；
1Docker 让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的 Linux 机器上，便可以实现虚拟化 2Docker 改变了虚拟化的方式，使开发者可以直接将自己的成果放入 Docker 中进行管理 3方便快捷已经是 Docker 的最大优势，过去需要用数天乃至数周的 任务，在Docker容器的处理下，只需要数秒就能完成 2、 解决运维配置噩梦；
1在没有 Docker 之前，每一台机器，每一个要用到的依赖，几乎都要重新配置一遍 2比如新增一台 MySQL 数据库，就要从头开始配置所有环境 3有了 Docker 之后，只需要从仓库里把之前的 MySQL 镜像拉出来，直接使用 3、 节省开支；</description></item><item><title>C++ 数据结构</title><link>https://www.shellio.cc/docs/programing/c++/default/22/</link><pubDate>Thu, 06 Oct 2022 22:42:23 +0800</pubDate><guid>https://www.shellio.cc/docs/programing/c++/default/22/</guid><description>C++ 数据结构 C/C++ 数组允许定义可存储相同类型数据项的变量，但是结构是 C++ 中另一种用户自定义的可用的数据类型，它允许您存储不同类型的数据项。
结构用于表示一条记录，假设您想要跟踪图书馆中书本的动态，您可能需要跟踪每本书的下列属性：
Title Author Subject Book ID 定义结构 为了定义结构，您必须使用 struct 语句。struct 语句定义了一个包含多个成员的新的数据类型，struct 语句的格式如下：
1struct [structure tag] 2 member definition; 3 member definition; 4 ... 5 member definition; 6} [one or more structure variables]; structure tag 是可选的，每个 member definition 是标准的变量定义，比如 int i; 或者 float f; 或者其他有效的变量定义。在结构定义的末尾，最后一个分号之前，您可以指定一个或多个结构变量，这是可选的。下面是声明 Book 结构的方式：
1struct Books 2 char title[50]; 3 char author[50]; 4 char subject[100]; 5 int book_id; }book;
访问结构成员 为了访问结构的成员，我们使用成员访问运算符（.）。成员访问运算符是结构变量名称和我们要访问的结构成员之间的一个句号。您可以使用 struct 关键字来定义结构类型的变量。下面的实例演示了结构的用法：</description></item><item><title>二十二、Docker 部署 Nginx 环境</title><link>https://www.shellio.cc/docs/cloud-native/docker/22/</link><pubDate>Thu, 06 Oct 2022 22:42:23 +0800</pubDate><guid>https://www.shellio.cc/docs/cloud-native/docker/22/</guid><description>Docker 是一个开源的应用容器引擎，基于 Go 语言 并遵从 Apache2.0 协议开源
Docker 可以让开发者打包它们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化
Docker 使用完全使用沙箱机制，两个容器之间不会有任何接口 (这个有点像 iPhone 的 app ) ,更重要的是容器性能开销极低
学习前提 在继续阅读之前，我们希望你对 Linux 有一些基本的了解，包括
1、 会使用Linux常用的命令；
2、 知道大部分的Linux常识，比如终端、service、ip、用户、组等；
3、 熟练使用Ubuntu或者Centos或者MacOS种的一种昂；
如果你对这些知识还是一知半解，可以访问我们的 Linux 基础教程 先进行一些简单的了解
Docker的应用场景 1、 Web应用的自动化打包和发布；
2、 自动化测试和持续集成、发布；
3、 在服务型环境中部署和调整数据库或其他的后台应用；
4、 从头编译或者扩展现有的OpenShift或CloudFoundry平台来搭建自己的PaaS环境；
Docker 的优点 1、 简化程序；
1Docker 让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的 Linux 机器上，便可以实现虚拟化 2Docker 改变了虚拟化的方式，使开发者可以直接将自己的成果放入 Docker 中进行管理 3方便快捷已经是 Docker 的最大优势，过去需要用数天乃至数周的 任务，在Docker容器的处理下，只需要数秒就能完成 2、 解决运维配置噩梦；
1在没有 Docker 之前，每一台机器，每一个要用到的依赖，几乎都要重新配置一遍 2比如新增一台 MySQL 数据库，就要从头开始配置所有环境 3有了 Docker 之后，只需要从仓库里把之前的 MySQL 镜像拉出来，直接使用 3、 节省开支；</description></item><item><title>C++ 接口（抽象类）</title><link>https://www.shellio.cc/docs/programing/c++/default/29/</link><pubDate>Thu, 06 Oct 2022 22:42:23 +0800</pubDate><guid>https://www.shellio.cc/docs/programing/c++/default/29/</guid><description>C++ 接口（抽象类） 接口描述了类的行为和功能，而不需要完成类的特定实现。
C++接口是使用抽象类来实现的，抽象类与数据抽象互不混淆，数据抽象是一个把实现细节与相关的数据分离开的概念。
如果类中至少有一个函数被声明为纯虚函数，则这个类就是抽象类。纯虚函数是通过在声明中使用 “= 0” 来指定的，如下所示：
1class Box 2 public: 3 // 纯虚函数 4 virtual double getVolume() = 0; 5 private: 6 double length; // 长度 7 double breadth; // 宽度 8 double height; // 高度 9}; 设计抽象类（通常称为 ABC）的目的，是为了给其他类提供一个可以继承的适当的基类。抽象类不能被用于实例化对象，它只能作为接口使用。如果试图实例化一个抽象类的对象，会导致编译错误。
因此，如果一个 ABC 的子类需要被实例化，则必须实现每个虚函数，这也意味着 C++ 支持使用 ABC 声明接口。如果没有在派生类中重载纯虚函数，就尝试实例化该类的对象，会导致编译错误。
可用于实例化对象的类被称为具体类。
抽象类的实例 请看下面的实例，基类 Shape 提供了一个接口 getArea()，在两个派生类 Rectangle 和 Triangle 中分别实现了 getArea()：
1#include &amp;lt;iostream&amp;gt; 2using namespace std; 3// 基类 4class Shape 5public: 6 // 提供接口框架的纯虚函数 7 virtual int getArea() = 0; 8 void setWidth(int w) 9 { 10 width = w; 11 } 12 void setHeight(int h) 13 { 14 height = h; 15 } 16protected: 17 int width; 18 int height; 19}; 20// 派生类 21class Rectangle: public Shape 22public: 23 int getArea() 24 { 25 return (width * height); 26 } 27}; 28class Triangle: public Shape 29public: 30 int getArea() 31 { 32 return (width * height)/2; 33 } 34}; 35int main(void) 36 Rectangle Rect; 37 Triangle Tri; 38 Rect.</description></item><item><title>二十九、Docker 安装 Apache</title><link>https://www.shellio.cc/docs/cloud-native/docker/29/</link><pubDate>Thu, 06 Oct 2022 22:42:23 +0800</pubDate><guid>https://www.shellio.cc/docs/cloud-native/docker/29/</guid><description>Docker 是一个开源的应用容器引擎，基于 Go 语言 并遵从 Apache2.0 协议开源
Docker 可以让开发者打包它们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化
Docker 使用完全使用沙箱机制，两个容器之间不会有任何接口 (这个有点像 iPhone 的 app ) ,更重要的是容器性能开销极低
学习前提 在继续阅读之前，我们希望你对 Linux 有一些基本的了解，包括
1、 会使用Linux常用的命令；
2、 知道大部分的Linux常识，比如终端、service、ip、用户、组等；
3、 熟练使用Ubuntu或者Centos或者MacOS种的一种昂；
如果你对这些知识还是一知半解，可以访问我们的 Linux 基础教程 先进行一些简单的了解
Docker的应用场景 1、 Web应用的自动化打包和发布；
2、 自动化测试和持续集成、发布；
3、 在服务型环境中部署和调整数据库或其他的后台应用；
4、 从头编译或者扩展现有的OpenShift或CloudFoundry平台来搭建自己的PaaS环境；
Docker 的优点 1、 简化程序；
1Docker 让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的 Linux 机器上，便可以实现虚拟化 2Docker 改变了虚拟化的方式，使开发者可以直接将自己的成果放入 Docker 中进行管理 3方便快捷已经是 Docker 的最大优势，过去需要用数天乃至数周的 任务，在Docker容器的处理下，只需要数秒就能完成 2、 解决运维配置噩梦；
1在没有 Docker 之前，每一台机器，每一个要用到的依赖，几乎都要重新配置一遍 2比如新增一台 MySQL 数据库，就要从头开始配置所有环境 3有了 Docker 之后，只需要从仓库里把之前的 MySQL 镜像拉出来，直接使用 3、 节省开支；</description></item><item><title>C++ 多态</title><link>https://www.shellio.cc/docs/programing/c++/default/26/</link><pubDate>Thu, 06 Oct 2022 22:42:23 +0800</pubDate><guid>https://www.shellio.cc/docs/programing/c++/default/26/</guid><description>C++ 多态 多态按字面的意思就是多种形态。当类之间存在层次结构，并且类之间是通过继承关联时，就会用到多态。
C++多态意味着调用成员函数时，会根据调用函数的对象的类型来执行不同的函数。
下面的实例中，基类 Shape 被派生为两个类，如下所示：
1#include &amp;lt;iostream&amp;gt; 2using namespace std; 3class Shape { 4 protected: 5 int width, height; 6 public: 7 Shape( int a=0, int b=0) 8 { 9 width = a; 10 height = b; 11 } 12 int area() 13 { 14 cout &amp;lt;&amp;lt; &amp;#34;Parent class area :&amp;#34; &amp;lt;&amp;lt;endl; 15 return 0; 16 } 17}; 18class Rectangle: public Shape{ 19 public: 20 Rectangle( int a=0, int b=0):Shape(a, b) { } 21 int area () 22 { 23 cout &amp;lt;&amp;lt; &amp;#34;Rectangle class area :&amp;#34; &amp;lt;&amp;lt;endl; 24 return (width * height); 25 } 26}; 27class Triangle: public Shape{ 28 public: 29 Triangle( int a=0, int b=0):Shape(a, b) { } 30 int area () 31 { 32 cout &amp;lt;&amp;lt; &amp;#34;Triangle class area :&amp;#34; &amp;lt;&amp;lt;endl; 33 return (width * height / 2); 34 } 35}; 36// 程序的主函数 37int main( ) 38 Shape *shape; 39 Rectangle rec(10,7); 40 Triangle tri(10,5); 41 // 存储矩形的地址 42 shape = &amp;amp;rec; 43 // 调用矩形的求面积函数 area 44 shape-&amp;gt;area(); 45 // 存储三角形的地址 46 shape = &amp;amp;tri; 47 // 调用三角形的求面积函数 area 48 shape-&amp;gt;area(); 49 return 0; 当上面的代码被编译和执行时，它会产生下列结果：</description></item><item><title>二十六、Docker 安装 Python</title><link>https://www.shellio.cc/docs/cloud-native/docker/26/</link><pubDate>Thu, 06 Oct 2022 22:42:23 +0800</pubDate><guid>https://www.shellio.cc/docs/cloud-native/docker/26/</guid><description>Docker 是一个开源的应用容器引擎，基于 Go 语言 并遵从 Apache2.0 协议开源
Docker 可以让开发者打包它们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化
Docker 使用完全使用沙箱机制，两个容器之间不会有任何接口 (这个有点像 iPhone 的 app ) ,更重要的是容器性能开销极低
学习前提 在继续阅读之前，我们希望你对 Linux 有一些基本的了解，包括
1、 会使用Linux常用的命令；
2、 知道大部分的Linux常识，比如终端、service、ip、用户、组等；
3、 熟练使用Ubuntu或者Centos或者MacOS种的一种昂；
如果你对这些知识还是一知半解，可以访问我们的 Linux 基础教程 先进行一些简单的了解
Docker的应用场景 1、 Web应用的自动化打包和发布；
2、 自动化测试和持续集成、发布；
3、 在服务型环境中部署和调整数据库或其他的后台应用；
4、 从头编译或者扩展现有的OpenShift或CloudFoundry平台来搭建自己的PaaS环境；
Docker 的优点 1、 简化程序；
1Docker 让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的 Linux 机器上，便可以实现虚拟化 2Docker 改变了虚拟化的方式，使开发者可以直接将自己的成果放入 Docker 中进行管理 3方便快捷已经是 Docker 的最大优势，过去需要用数天乃至数周的 任务，在Docker容器的处理下，只需要数秒就能完成 2、 解决运维配置噩梦；
1在没有 Docker 之前，每一台机器，每一个要用到的依赖，几乎都要重新配置一遍 2比如新增一台 MySQL 数据库，就要从头开始配置所有环境 3有了 Docker 之后，只需要从仓库里把之前的 MySQL 镜像拉出来，直接使用 3、 节省开支；</description></item><item><title>C++ 数据抽象</title><link>https://www.shellio.cc/docs/programing/c++/default/27/</link><pubDate>Thu, 06 Oct 2022 22:42:23 +0800</pubDate><guid>https://www.shellio.cc/docs/programing/c++/default/27/</guid><description>C++ 数据抽象 数据抽象是指，只向外界提供关键信息，并隐藏其后台的实现细节，即只表现必要的信息而不呈现细节。
数据抽象是一种依赖于接口和实现分离的编程（设计）技术。
让我们举一个现实生活中的真实例子，比如一台电视机，您可以打开和关闭、切换频道、调整音量、添加外部组件（如喇叭、录像机、DVD 播放器），但是您不知道它的内部实现细节，也就是说，您并不知道它是如何通过缆线接收信号，如何转换信号，并最终显示在屏幕上。
因此，我们可以说电视把它的内部实现和外部接口分离开了，您无需知道它的内部实现原理，直接通过它的外部接口（比如电源按钮、遥控器、声量控制器）就可以操控电视。
现在，让我们言归正传，就 C++ 编程而言，C++ 类为数据抽象提供了可能。它们向外界提供了大量用于操作对象数据的公共方法，也就是说，外界实际上并不清楚类的内部实现。
例如，您的程序可以调用 sort() 函数，而不需要知道函数中排序数据所用到的算法。实际上，函数排序的底层实现会因库的版本不同而有所差异，只要接口不变，函数调用就可以照常工作。
在C++ 中，我们使用类来定义我们自己的抽象数据类型（ADT）。您可以使用类 ostream 的 cout 对象来输出数据到标准输出，如下所示：
1#include &amp;lt;iostream&amp;gt; 2using namespace std; 3int main( ) 4 cout &amp;lt;&amp;lt; &amp;#34;Hello C++&amp;#34; &amp;lt;&amp;lt;endl; 5 return 0; 在这里，您不需要理解 cout 是如何在用户的屏幕上显示文本。您只需要知道公共接口即可，cout 的底层实现可以自由改变。
访问标签强制抽象 在C++ 中，我们使用访问标签来定义类的抽象接口。一个类可以包含零个或多个访问标签：
使用公共标签定义的成员都可以访问该程序的所有部分。一个类型的数据抽象视图是由它的公共成员来定义的。 使用私有标签定义的成员无法访问到使用类的代码。私有部分对使用类型的代码隐藏了实现细节。 访问标签出现的频率没有限制。每个访问标签指定了紧随其后的成员定义的访问级别。指定的访问级别会一直有效，直到遇到下一个访问标签或者遇到类主体的关闭右括号为止。
数据抽象的好处 数据抽象有两个重要的优势：
类的内部受到保护，不会因无意的用户级错误导致对象状态受损。 类实现可能随着时间的推移而发生变化，以便应对不断变化的需求，或者应对那些要求不改变用户级代码的错误报告。 如果只在类的私有部分定义数据成员，编写该类的作者就可以随意更改数据。如果实现发生改变，则只需要检查类的代码，看看这个改变会导致哪些影响。如果数据是公有的，则任何直接访问旧表示形式的数据成员的函数都可能受到影响。
数据抽象的实例 C++程序中，任何带有公有和私有成员的类都可以作为数据抽象的实例。请看下面的实例：
因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 1#include &amp;lt;iostream&amp;gt; 2using namespace std; 3class Adder{ 4 public: 5 // 构造函数 6 Adder(int i = 0) 7 { 8 total = i; 9 } 10 // 对外的接口 11 void addNum(int number) 12 { 13 total += number; 14 } 15 // 对外的接口 16 int getTotal() 17 { 18 return total; 19 }; 20 private: 21 // 对外隐藏的数据 22 int total; 23}; 24int main( ) 25 Adder a; 26 a.</description></item><item><title>二十七、Docker 安装 Redis</title><link>https://www.shellio.cc/docs/cloud-native/docker/27/</link><pubDate>Thu, 06 Oct 2022 22:42:23 +0800</pubDate><guid>https://www.shellio.cc/docs/cloud-native/docker/27/</guid><description>Docker 是一个开源的应用容器引擎，基于 Go 语言 并遵从 Apache2.0 协议开源
Docker 可以让开发者打包它们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化
Docker 使用完全使用沙箱机制，两个容器之间不会有任何接口 (这个有点像 iPhone 的 app ) ,更重要的是容器性能开销极低
学习前提 在继续阅读之前，我们希望你对 Linux 有一些基本的了解，包括
1、 会使用Linux常用的命令；
2、 知道大部分的Linux常识，比如终端、service、ip、用户、组等；
3、 熟练使用Ubuntu或者Centos或者MacOS种的一种昂；
如果你对这些知识还是一知半解，可以访问我们的 Linux 基础教程 先进行一些简单的了解
Docker的应用场景 1、 Web应用的自动化打包和发布；
2、 自动化测试和持续集成、发布；
3、 在服务型环境中部署和调整数据库或其他的后台应用；
4、 从头编译或者扩展现有的OpenShift或CloudFoundry平台来搭建自己的PaaS环境；
Docker 的优点 1、 简化程序；
1Docker 让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的 Linux 机器上，便可以实现虚拟化 2Docker 改变了虚拟化的方式，使开发者可以直接将自己的成果放入 Docker 中进行管理 3方便快捷已经是 Docker 的最大优势，过去需要用数天乃至数周的 任务，在Docker容器的处理下，只需要数秒就能完成 2、 解决运维配置噩梦；
1在没有 Docker 之前，每一台机器，每一个要用到的依赖，几乎都要重新配置一遍 2比如新增一台 MySQL 数据库，就要从头开始配置所有环境 3有了 Docker 之后，只需要从仓库里把之前的 MySQL 镜像拉出来，直接使用 3、 节省开支；</description></item><item><title>C++ 类 &amp; 对象</title><link>https://www.shellio.cc/docs/programing/c++/default/23/</link><pubDate>Thu, 06 Oct 2022 22:42:23 +0800</pubDate><guid>https://www.shellio.cc/docs/programing/c++/default/23/</guid><description>C++ 类 &amp;amp; 对象 C++在 C 语言的基础上增加了面向对象编程，C++ 支持面向对象程序设计。类是 C++ 的核心特性，通常被称为用户定义的类型。
类用于指定对象的形式，它包含了数据表示法和用于处理数据的方法。类中的数据和方法称为类的成员。函数在一个类被称为类的成员。
C++ 类定义 定义一个类，本质上是定义一个数据类型的蓝图。这实际上并没有定义任何数据，但它定义了类的名称意味着什么，也就是说，它定义了类的对象包括了什么，以及可以在这个对象上执行哪些操作。
类定义是以关键字 class 开头，后跟类的名称。类的主体是包含在一对花括号中。类定义后必须跟着一个分号或一个声明列表。例如，我们使用关键字 class 定义 Box 数据类型，如下所示：
1class Box 2 public: 3 double length; // Length of a box 4 double breadth; // Breadth of a box 5 double height; // Height of a box 6}; 关键字public 确定了类成员的访问属性。在类对象作用域内，公共成员在类的外部是可访问的。您也可以指定类的成员为 private 或 protected，这个我们稍后会进行讲解。
定义 C++ 对象 类提供了对象的蓝图，所以基本上，对象是根据类来创建的。声明类的对象，就像声明基本类型的变量一样。下面的语句声明了类 Box 的两个对象：
1Box Box1; // 声明 Box1，类型为 Box 2Box Box2; // 声明 Box2，类型为 Box 对象Box1 和 Box2 都有它们各自的数据成员。</description></item><item><title>二十三、Docker 部署 PHP 环境</title><link>https://www.shellio.cc/docs/cloud-native/docker/23/</link><pubDate>Thu, 06 Oct 2022 22:42:23 +0800</pubDate><guid>https://www.shellio.cc/docs/cloud-native/docker/23/</guid><description>Docker 是一个开源的应用容器引擎，基于 Go 语言 并遵从 Apache2.0 协议开源
Docker 可以让开发者打包它们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化
Docker 使用完全使用沙箱机制，两个容器之间不会有任何接口 (这个有点像 iPhone 的 app ) ,更重要的是容器性能开销极低
学习前提 在继续阅读之前，我们希望你对 Linux 有一些基本的了解，包括
1、 会使用Linux常用的命令；
2、 知道大部分的Linux常识，比如终端、service、ip、用户、组等；
3、 熟练使用Ubuntu或者Centos或者MacOS种的一种昂；
如果你对这些知识还是一知半解，可以访问我们的 Linux 基础教程 先进行一些简单的了解
Docker的应用场景 1、 Web应用的自动化打包和发布；
2、 自动化测试和持续集成、发布；
3、 在服务型环境中部署和调整数据库或其他的后台应用；
4、 从头编译或者扩展现有的OpenShift或CloudFoundry平台来搭建自己的PaaS环境；
Docker 的优点 1、 简化程序；
1Docker 让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的 Linux 机器上，便可以实现虚拟化 2Docker 改变了虚拟化的方式，使开发者可以直接将自己的成果放入 Docker 中进行管理 3方便快捷已经是 Docker 的最大优势，过去需要用数天乃至数周的 任务，在Docker容器的处理下，只需要数秒就能完成 2、 解决运维配置噩梦；
1在没有 Docker 之前，每一台机器，每一个要用到的依赖，几乎都要重新配置一遍 2比如新增一台 MySQL 数据库，就要从头开始配置所有环境 3有了 Docker 之后，只需要从仓库里把之前的 MySQL 镜像拉出来，直接使用 3、 节省开支；</description></item><item><title>C++ 继承</title><link>https://www.shellio.cc/docs/programing/c++/default/24/</link><pubDate>Thu, 06 Oct 2022 22:42:23 +0800</pubDate><guid>https://www.shellio.cc/docs/programing/c++/default/24/</guid><description>C++ 继承 面向对象程序设计中最重要的一个概念是继承。继承允许我们依据另一个类来定义一个类，这使得创建和维护一个应用程序变得更容易。这样做，也达到了重用代码功能和提高执行时间的效果。
当创建一个类时，您不需要重新编写新的数据成员和成员函数，只需指定新建的类继承了一个已有的类的成员即可。这个已有的类称为基类，新建的类称为派生类。
继承代表了 is a 关系。例如，哺乳动物是动物，狗是哺乳动物，因此，狗是动物，等等。
基类 &amp;amp; 派生类 一个类可以派生自多个类，这意味着，它可以从多个基类继承数据和函数。定义一个派生类，我们使用一个类派生列表来指定基类。类派生列表以一个或多个基类命名，形式如下：
1class derived-class: access-specifier base-class 其中，访问修饰符 access-specifier 是 public、protected 或 private 其中的一个，base-class 是之前定义过的某个类的名称。如果未使用访问修饰符 access-specifier，则默认为 private。
假设有一个基类 Shape，Rectangle 是它的派生类，如下所示：
1#include &amp;lt;iostream&amp;gt; 2using namespace std; 3// 基类 4class Shape 5 public: 6 void setWidth(int w) 7 { 8 width = w; 9 } 10 void setHeight(int h) 11 { 12 height = h; 13 } 14 protected: 15 int width; 16 int height; 17}; 18// 派生类 19class Rectangle: public Shape 20 public: 21 int getArea() 22 { 23 return (width * height); 24 } 25}; 26int main(void) 27 Rectangle Rect; 28 Rect.</description></item><item><title>二十四、Docker 安装 MySQL</title><link>https://www.shellio.cc/docs/cloud-native/docker/24/</link><pubDate>Thu, 06 Oct 2022 22:42:23 +0800</pubDate><guid>https://www.shellio.cc/docs/cloud-native/docker/24/</guid><description>Docker 是一个开源的应用容器引擎，基于 Go 语言 并遵从 Apache2.0 协议开源
Docker 可以让开发者打包它们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化
Docker 使用完全使用沙箱机制，两个容器之间不会有任何接口 (这个有点像 iPhone 的 app ) ,更重要的是容器性能开销极低
学习前提 在继续阅读之前，我们希望你对 Linux 有一些基本的了解，包括
1、 会使用Linux常用的命令；
2、 知道大部分的Linux常识，比如终端、service、ip、用户、组等；
3、 熟练使用Ubuntu或者Centos或者MacOS种的一种昂；
如果你对这些知识还是一知半解，可以访问我们的 Linux 基础教程 先进行一些简单的了解
Docker的应用场景 1、 Web应用的自动化打包和发布；
2、 自动化测试和持续集成、发布；
3、 在服务型环境中部署和调整数据库或其他的后台应用；
4、 从头编译或者扩展现有的OpenShift或CloudFoundry平台来搭建自己的PaaS环境；
Docker 的优点 1、 简化程序；
1Docker 让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的 Linux 机器上，便可以实现虚拟化 2Docker 改变了虚拟化的方式，使开发者可以直接将自己的成果放入 Docker 中进行管理 3方便快捷已经是 Docker 的最大优势，过去需要用数天乃至数周的 任务，在Docker容器的处理下，只需要数秒就能完成 2、 解决运维配置噩梦；
1在没有 Docker 之前，每一台机器，每一个要用到的依赖，几乎都要重新配置一遍 2比如新增一台 MySQL 数据库，就要从头开始配置所有环境 3有了 Docker 之后，只需要从仓库里把之前的 MySQL 镜像拉出来，直接使用 3、 节省开支；</description></item><item><title>C++ 重载运算符和重载函数</title><link>https://www.shellio.cc/docs/programing/c++/default/25/</link><pubDate>Thu, 06 Oct 2022 22:42:23 +0800</pubDate><guid>https://www.shellio.cc/docs/programing/c++/default/25/</guid><description>C++ 重载运算符和重载函数 C++允许在同一作用域中的某个函数和运算符指定多个定义，分别称为函数重载和运算符重载。
重载声明是指一个与之前已经在该作用域内声明过的函数或方法具有相同名称的声明，但是它们的参数列表和定义（实现）不相同。
当您调用一个重载函数或重载运算符时，编译器通过把您所使用的参数类型与定义中的参数类型进行比较，决定选用最合适的定义。选择最合适的重载函数或重载运算符的过程，称为重载决策。
C++ 中的函数重载 在同一个作用域内，可以声明几个功能类似的同名函数，但是这些同名函数的形式参数（指参数的个数、类型或者顺序）必须不同。您不能仅通过返回类型的不同来重载函数。
下面的实例中，同名函数 print() 被用于输出不同的数据类型：
1#include &amp;lt;iostream&amp;gt; 2using namespace std; 3class printData 4 public: 5 void print(int i) { 6 cout &amp;lt;&amp;lt; &amp;#34;Printing int: &amp;#34; &amp;lt;&amp;lt; i &amp;lt;&amp;lt; endl; 7 } 8 void print(double f) { 9 cout &amp;lt;&amp;lt; &amp;#34;Printing float: &amp;#34; &amp;lt;&amp;lt; f &amp;lt;&amp;lt; endl; 10 } 11 void print(char* c) { 12 cout &amp;lt;&amp;lt; &amp;#34;Printing character: &amp;#34; &amp;lt;&amp;lt; c &amp;lt;&amp;lt; endl; 13 } 14}; 15int main(void) 16 printData pd; 17 // Call print to print integer 18 pd.</description></item><item><title>二十五、Docker 安装 Tomcat</title><link>https://www.shellio.cc/docs/cloud-native/docker/25/</link><pubDate>Thu, 06 Oct 2022 22:42:23 +0800</pubDate><guid>https://www.shellio.cc/docs/cloud-native/docker/25/</guid><description>Docker 是一个开源的应用容器引擎，基于 Go 语言 并遵从 Apache2.0 协议开源
Docker 可以让开发者打包它们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化
Docker 使用完全使用沙箱机制，两个容器之间不会有任何接口 (这个有点像 iPhone 的 app ) ,更重要的是容器性能开销极低
学习前提 在继续阅读之前，我们希望你对 Linux 有一些基本的了解，包括
1、 会使用Linux常用的命令；
2、 知道大部分的Linux常识，比如终端、service、ip、用户、组等；
3、 熟练使用Ubuntu或者Centos或者MacOS种的一种昂；
如果你对这些知识还是一知半解，可以访问我们的 Linux 基础教程 先进行一些简单的了解
Docker的应用场景 1、 Web应用的自动化打包和发布；
2、 自动化测试和持续集成、发布；
3、 在服务型环境中部署和调整数据库或其他的后台应用；
4、 从头编译或者扩展现有的OpenShift或CloudFoundry平台来搭建自己的PaaS环境；
Docker 的优点 1、 简化程序；
1Docker 让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的 Linux 机器上，便可以实现虚拟化 2Docker 改变了虚拟化的方式，使开发者可以直接将自己的成果放入 Docker 中进行管理 3方便快捷已经是 Docker 的最大优势，过去需要用数天乃至数周的 任务，在Docker容器的处理下，只需要数秒就能完成 2、 解决运维配置噩梦；
1在没有 Docker 之前，每一台机器，每一个要用到的依赖，几乎都要重新配置一遍 2比如新增一台 MySQL 数据库，就要从头开始配置所有环境 3有了 Docker 之后，只需要从仓库里把之前的 MySQL 镜像拉出来，直接使用 3、 节省开支；</description></item><item><title>C++ 基本的输入输出</title><link>https://www.shellio.cc/docs/programing/c++/default/21/</link><pubDate>Thu, 06 Oct 2022 22:42:23 +0800</pubDate><guid>https://www.shellio.cc/docs/programing/c++/default/21/</guid><description>C++ 基本的输入输出 C++标准库提供了一组丰富的输入/输出功能，我们将在后续的章节进行介绍。本章将讨论 C++ 编程中最基本和最常见的 I/O 操作。
C++的 I/O 发生在流中，流是字节序列。如果字节流是从设备（如键盘、磁盘驱动器、网络连接等）流向内存，这叫做输入操作。如果字节流是从内存流向设备（如显示屏、打印机、磁盘驱动器、网络连接等），这叫做输出操作。
I/O 库头文件 下列的头文件在 C++ 编程中很重要。
头文件 函数和描述 &amp;lt;iostream&amp;gt; 该文件定义了 cin、cout、cerr 和 clog 对象，分别对应于标准输入流、标准输出流、非缓冲标准错误流和缓冲标准错误流。 &amp;lt;iomanip&amp;gt; 该文件通过所谓的参数化的流操纵器（比如 setw 和 setprecision），来声明对执行标准化 I/O 有用的服务。 &amp;lt;fstream&amp;gt; 该文件为用户控制的文件处理声明服务。我们将在文件和流的相关章节讨论它的细节。 标准输出流（cout） 预定义的对象 cout 是 ostream 类的一个实例。cout 对象”连接”到标准输出设备，通常是显示屏。cout 是与流插入运算符 &amp;laquo; 结合使用的，如下所示：
1#include &amp;lt;iostream&amp;gt; 2using namespace std; 3int main( ) 4 char str[] = &amp;#34;Hello C++&amp;#34;; 5 cout &amp;lt;&amp;lt; &amp;#34;Value of str is : &amp;#34; &amp;lt;&amp;lt; str &amp;lt;&amp;lt; endl; 6} 当上面的代码被编译和执行时，它会产生下列结果：</description></item><item><title>二十一、Docker 镜像打标签</title><link>https://www.shellio.cc/docs/cloud-native/docker/21/</link><pubDate>Thu, 06 Oct 2022 22:42:23 +0800</pubDate><guid>https://www.shellio.cc/docs/cloud-native/docker/21/</guid><description>Docker 是一个开源的应用容器引擎，基于 Go 语言 并遵从 Apache2.0 协议开源
Docker 可以让开发者打包它们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化
Docker 使用完全使用沙箱机制，两个容器之间不会有任何接口 (这个有点像 iPhone 的 app ) ,更重要的是容器性能开销极低
学习前提 在继续阅读之前，我们希望你对 Linux 有一些基本的了解，包括
1、 会使用Linux常用的命令；
2、 知道大部分的Linux常识，比如终端、service、ip、用户、组等；
3、 熟练使用Ubuntu或者Centos或者MacOS种的一种昂；
如果你对这些知识还是一知半解，可以访问我们的 Linux 基础教程 先进行一些简单的了解
Docker的应用场景 1、 Web应用的自动化打包和发布；
2、 自动化测试和持续集成、发布；
3、 在服务型环境中部署和调整数据库或其他的后台应用；
4、 从头编译或者扩展现有的OpenShift或CloudFoundry平台来搭建自己的PaaS环境；
Docker 的优点 1、 简化程序；
1Docker 让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的 Linux 机器上，便可以实现虚拟化 2Docker 改变了虚拟化的方式，使开发者可以直接将自己的成果放入 Docker 中进行管理 3方便快捷已经是 Docker 的最大优势，过去需要用数天乃至数周的 任务，在Docker容器的处理下，只需要数秒就能完成 2、 解决运维配置噩梦；
1在没有 Docker 之前，每一台机器，每一个要用到的依赖，几乎都要重新配置一遍 2比如新增一台 MySQL 数据库，就要从头开始配置所有环境 3有了 Docker 之后，只需要从仓库里把之前的 MySQL 镜像拉出来，直接使用 3、 节省开支；</description></item><item><title>C++ 修饰符类型</title><link>https://www.shellio.cc/docs/programing/c++/default/9/</link><pubDate>Thu, 06 Oct 2022 22:42:23 +0800</pubDate><guid>https://www.shellio.cc/docs/programing/c++/default/9/</guid><description>C++ 修饰符类型 C++允许在 char、int 和 double 数据类型前放置修饰符。修饰符用于改变基本类型的含义，所以它更能满足各种情境的需求。
下面列出了数据类型修饰符：
signed unsigned long short 修饰符signed、unsigned、long 和 short 可应用于整型，signed 和 unsigned 可应用于字符型，long 可应用于双精度型。
修饰符signed 和 unsigned 也可以作为 long 或 short 修饰符的前缀。例如：unsigned long int。
C++允许使用速记符号来声明无符号短整数或无符号长整数。您可以不写 int，只写单词 unsigned short 或 unsigned long，int 是隐含的。例如，下面的两个语句都声明了无符号整型变量。
1unsigned x; 2unsigned int y; 为了理解 C++ 解释有符号整数和无符号整数修饰符之间的差别，我们来运行一下下面这个短程序：
1#include &amp;lt;iostream&amp;gt; 2using namespace std; 3/* 4 * 这个程序演示了有符号整数和无符号整数之间的差别 5*/ 6int main() 7 short int i; // 有符号短整数 8 short unsigned int j; // 无符号短整数 9 j = 50000; 10 i = j; 11 cout &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &amp;#34; &amp;#34; &amp;lt;&amp;lt; j; 12 return 0; 13} 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 当上面的程序运行时，会输出下列结果：</description></item><item><title>九、Docker inspect 容器元数据</title><link>https://www.shellio.cc/docs/cloud-native/docker/9/</link><pubDate>Thu, 06 Oct 2022 22:42:23 +0800</pubDate><guid>https://www.shellio.cc/docs/cloud-native/docker/9/</guid><description>Docker 是一个开源的应用容器引擎，基于 Go 语言 并遵从 Apache2.0 协议开源
Docker 可以让开发者打包它们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化
Docker 使用完全使用沙箱机制，两个容器之间不会有任何接口 (这个有点像 iPhone 的 app ) ,更重要的是容器性能开销极低
学习前提 在继续阅读之前，我们希望你对 Linux 有一些基本的了解，包括
1、 会使用Linux常用的命令；
2、 知道大部分的Linux常识，比如终端、service、ip、用户、组等；
3、 熟练使用Ubuntu或者Centos或者MacOS种的一种昂；
如果你对这些知识还是一知半解，可以访问我们的 Linux 基础教程 先进行一些简单的了解
Docker的应用场景 1、 Web应用的自动化打包和发布；
2、 自动化测试和持续集成、发布；
3、 在服务型环境中部署和调整数据库或其他的后台应用；
4、 从头编译或者扩展现有的OpenShift或CloudFoundry平台来搭建自己的PaaS环境；
Docker 的优点 1、 简化程序；
1Docker 让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的 Linux 机器上，便可以实现虚拟化 2Docker 改变了虚拟化的方式，使开发者可以直接将自己的成果放入 Docker 中进行管理 3方便快捷已经是 Docker 的最大优势，过去需要用数天乃至数周的 任务，在Docker容器的处理下，只需要数秒就能完成 2、 解决运维配置噩梦；
1在没有 Docker 之前，每一台机器，每一个要用到的依赖，几乎都要重新配置一遍 2比如新增一台 MySQL 数据库，就要从头开始配置所有环境 3有了 Docker 之后，只需要从仓库里把之前的 MySQL 镜像拉出来，直接使用 3、 节省开支；</description></item><item><title>C++ 变量类型</title><link>https://www.shellio.cc/docs/programing/c++/default/6/</link><pubDate>Thu, 06 Oct 2022 22:42:23 +0800</pubDate><guid>https://www.shellio.cc/docs/programing/c++/default/6/</guid><description>C++ 变量类型 变量其实只不过是程序可操作的存储区的名称。C++ 中每个变量都有指定的类型，类型决定了变量存储的大小和布局，该范围内的值都可以存储在内存中，运算符可应用于变量上。
变量的名称可以由字母、数字和下划线字符组成。它必须以字母或下划线开头。大写字母和小写字母是不同的，因为 C++ 是大小写敏感的。
基于前一章讲解的基本类型，有以下几种基本的变量类型，将在下一章中进行讲解：
类型 描述 bool 存储值 true 或 false。 char 通常是一个八位字节（一个字节）。这是一个整数类型。 int 对机器而言，整数的最自然的大小。 float 单精度浮点值。 double 双精度浮点值。 void 表示类型的缺失。 wchar_t 宽字符类型。 C++也允许定义各种其他类型的变量，比如枚举、指针、数组、引用、数据结构、类等等，这将会在后续的章节中进行讲解。
下面我们将讲解如何定义、声明和使用各种类型的变量。
C++ 中的变量定义 变量定义就是告诉编译器在何处创建变量的存储，以及如何创建变量的存储。变量定义指定一个数据类型，并包含了该类型的一个或多个变量的列表，如下所示：
1type variable_list; 在这里，type 必须是一个有效的 C++ 数据类型，可以是 char、w_char、int、float、double、bool 或任何用户自定义的对象，variable_list 可以由一个或多个标识符名称组成，多个标识符之间用逗号分隔。下面列出几个有效的声明：
1int i, j, k; 2char c, ch; 3float f, salary; 4double d; 行 int i, j, k; 声明并定义了变量 i、j 和 k，这指示编译器创建类型为 int 的名为 i、j、k 的变量。
变量可以在声明的时候被初始化（指定一个初始值）。初始化器由一个等号，后跟一个常量表达式组成，如下所示：
1type variable_name = value; 下面列举几个实例：</description></item><item><title>六、Docker run 运行镜像</title><link>https://www.shellio.cc/docs/cloud-native/docker/6/</link><pubDate>Thu, 06 Oct 2022 22:42:23 +0800</pubDate><guid>https://www.shellio.cc/docs/cloud-native/docker/6/</guid><description>Docker 是一个开源的应用容器引擎，基于 Go 语言 并遵从 Apache2.0 协议开源
Docker 可以让开发者打包它们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化
Docker 使用完全使用沙箱机制，两个容器之间不会有任何接口 (这个有点像 iPhone 的 app ) ,更重要的是容器性能开销极低
学习前提 在继续阅读之前，我们希望你对 Linux 有一些基本的了解，包括
1、 会使用Linux常用的命令；
2、 知道大部分的Linux常识，比如终端、service、ip、用户、组等；
3、 熟练使用Ubuntu或者Centos或者MacOS种的一种昂；
如果你对这些知识还是一知半解，可以访问我们的 Linux 基础教程 先进行一些简单的了解
Docker的应用场景 1、 Web应用的自动化打包和发布；
2、 自动化测试和持续集成、发布；
3、 在服务型环境中部署和调整数据库或其他的后台应用；
4、 从头编译或者扩展现有的OpenShift或CloudFoundry平台来搭建自己的PaaS环境；
Docker 的优点 1、 简化程序；
1Docker 让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的 Linux 机器上，便可以实现虚拟化 2Docker 改变了虚拟化的方式，使开发者可以直接将自己的成果放入 Docker 中进行管理 3方便快捷已经是 Docker 的最大优势，过去需要用数天乃至数周的 任务，在Docker容器的处理下，只需要数秒就能完成 2、 解决运维配置噩梦；
1在没有 Docker 之前，每一台机器，每一个要用到的依赖，几乎都要重新配置一遍 2比如新增一台 MySQL 数据库，就要从头开始配置所有环境 3有了 Docker 之后，只需要从仓库里把之前的 MySQL 镜像拉出来，直接使用 3、 节省开支；</description></item><item><title>C++ 变量作用域</title><link>https://www.shellio.cc/docs/programing/c++/default/7/</link><pubDate>Thu, 06 Oct 2022 22:42:23 +0800</pubDate><guid>https://www.shellio.cc/docs/programing/c++/default/7/</guid><description>C++ 变量作用域 作用域是程序的一个区域，一般来说有三个地方可以声明变量：
在函数或一个代码块内部声明的变量，称为局部变量。 在函数参数的定义中声明的变量，称为形式参数。 在所有函数外部声明的变量，称为全局变量。 我们将在后续的章节中学习什么是函数和参数。本章我们先来讲解声明是局部变量和全局变量。
局部变量 在函数或一个代码块内部声明的变量，称为局部变量。它们只能被函数内部或者代码块内部的语句使用。下面的实例使用了局部变量：
1#include &amp;lt;iostream&amp;gt; 2using namespace std; 3int main () 4 // 局部变量声明 5 int a, b; 6 int c; 7 // 实际初始化 8 a = 10; 9 b = 20; 10 c = a + b; 11 cout &amp;lt;&amp;lt; c; return 0; 12} 全局变量 在所有函数外部定义的变量（通常是在程序的头部），称为全局变量。全局变量的值在程序的整个生命周期内都是有效的。
全局变量可以被任何函数访问。也就是说，全局变量一旦声明，在整个程序中都是可用的。下面的实例使用了全局变量和局部变量：
1#include &amp;lt;iostream&amp;gt; 2using namespace std; 3// 全局变量声明 4int g; 5int main () 6 // 局部变量声明 7 int a, b; 8 // 实际初始化 9 a = 10; 10 b = 20; 11 g = a + b; 12 cout &amp;lt;&amp;lt; g; return 0; 13 } 在程序中，局部变量和全局变量的名称可以相同，但是在函数内，局部变量的值会覆盖全局变量的值。下面是一个实例：</description></item><item><title>七、Docker 容器</title><link>https://www.shellio.cc/docs/cloud-native/docker/7/</link><pubDate>Thu, 06 Oct 2022 22:42:23 +0800</pubDate><guid>https://www.shellio.cc/docs/cloud-native/docker/7/</guid><description>Docker 是一个开源的应用容器引擎，基于 Go 语言 并遵从 Apache2.0 协议开源
Docker 可以让开发者打包它们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化
Docker 使用完全使用沙箱机制，两个容器之间不会有任何接口 (这个有点像 iPhone 的 app ) ,更重要的是容器性能开销极低
学习前提 在继续阅读之前，我们希望你对 Linux 有一些基本的了解，包括
1、 会使用Linux常用的命令；
2、 知道大部分的Linux常识，比如终端、service、ip、用户、组等；
3、 熟练使用Ubuntu或者Centos或者MacOS种的一种昂；
如果你对这些知识还是一知半解，可以访问我们的 Linux 基础教程 先进行一些简单的了解
Docker的应用场景 1、 Web应用的自动化打包和发布；
2、 自动化测试和持续集成、发布；
3、 在服务型环境中部署和调整数据库或其他的后台应用；
4、 从头编译或者扩展现有的OpenShift或CloudFoundry平台来搭建自己的PaaS环境；
Docker 的优点 1、 简化程序；
1Docker 让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的 Linux 机器上，便可以实现虚拟化 2Docker 改变了虚拟化的方式，使开发者可以直接将自己的成果放入 Docker 中进行管理 3方便快捷已经是 Docker 的最大优势，过去需要用数天乃至数周的 任务，在Docker容器的处理下，只需要数秒就能完成 2、 解决运维配置噩梦；
1在没有 Docker 之前，每一台机器，每一个要用到的依赖，几乎都要重新配置一遍 2比如新增一台 MySQL 数据库，就要从头开始配置所有环境 3有了 Docker 之后，只需要从仓库里把之前的 MySQL 镜像拉出来，直接使用 3、 节省开支；</description></item><item><title>C++ 基本语法</title><link>https://www.shellio.cc/docs/programing/c++/default/3/</link><pubDate>Thu, 06 Oct 2022 22:42:23 +0800</pubDate><guid>https://www.shellio.cc/docs/programing/c++/default/3/</guid><description>C++ 基本语法 C++程序可以定义为对象的集合，这些对象通过调用彼此的方法进行交互。现在让我们简要地看一下什么是类、对象，方法、即时变量。
对象 – 对象具有状态和行为。例如：一只狗的状态 – 颜色、名称、品种，行为 – 摇动、叫唤、吃。对象是类的实例。 类 – 类可以定义为描述对象行为/状态的模板/蓝图。 方法 – 从基本上说，一个方法表示一种行为。一个类可以包含多个方法。可以在方法中写入逻辑、操作数据以及执行所有的动作。 即时变量 – 每个对象都有其独特的即时变量。对象的状态是由这些即时变量的值创建的。 C++ 程序结构 让我们看一段简单的代码，可以输出单词 Hello World。
1#include &amp;lt;iostream&amp;gt; 2using namespace std; 3// main() 是程序开始执行的地方 4int main() 5 cout &amp;lt;&amp;lt; &amp;#34;Hello World&amp;#34;; // 输出 Hello World return 0; 6} 接下来我们讲解一下上面这段程序：
C++ 语言定义了一些头文件，这些头文件包含了程序中必需的或有用的信息。上面这段程序中，包含了头文件 。 行 using namespace std; 告诉编译器使用 std 命名空间。命名空间是 C++ 中一个相对新的概念。 下一行 // main() 是程序开始执行的地方 是一个单行注释。单行注释以 // 开头，在行末结束。 下一行 int main() 是主函数，程序从这里开始执行。 下一行 cout &amp;laquo; “Hello World”; 会在屏幕上显示消息 “Hello World”。 下一行 return 0; 终止 main( )函数，并向调用进程返回值 0。 编译 &amp;amp; 执行 C++ 程序 接下来让我们看看如何把源代码保存在一个文件中，以及如何编译并运行它。下面是简单的步骤：</description></item><item><title>三、Ubuntu 安装 Docker</title><link>https://www.shellio.cc/docs/cloud-native/docker/3/</link><pubDate>Thu, 06 Oct 2022 22:42:23 +0800</pubDate><guid>https://www.shellio.cc/docs/cloud-native/docker/3/</guid><description>Docker 是一个开源的应用容器引擎，基于 Go 语言 并遵从 Apache2.0 协议开源
Docker 可以让开发者打包它们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化
Docker 使用完全使用沙箱机制，两个容器之间不会有任何接口 (这个有点像 iPhone 的 app ) ,更重要的是容器性能开销极低
学习前提 在继续阅读之前，我们希望你对 Linux 有一些基本的了解，包括
1、 会使用 Linux 常用的命令；
2、 知道大部分的 Linux 常识，比如终端、service、ip、用户、组等；
3、 熟练使用 Ubuntu 或者 Centos 或者 MacOS 种的一种昂；
如果你对这些知识还是一知半解，可以访问我们的 Linux 基础教程 先进行一些简单的了解
Docker 的应用场景 1、 Web 应用的自动化打包和发布；
2、 自动化测试和持续集成、发布；
3、 在服务型环境中部署和调整数据库或其他的后台应用；
4、 从头编译或者扩展现有的 OpenShift 或 CloudFoundry 平台来搭建自己的 PaaS 环境；
Docker 的优点 1、 简化程序；
1Docker 让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的 Linux 机器上，便可以实现虚拟化 2Docker 改变了虚拟化的方式，使开发者可以直接将自己的成果放入 Docker 中进行管理 3方便快捷已经是 Docker 的最大优势，过去需要用数天乃至数周的 任务，在Docker容器的处理下，只需要数秒就能完成 2、 解决运维配置噩梦；</description></item><item><title>C++ 文件和流</title><link>https://www.shellio.cc/docs/programing/c++/default/30/</link><pubDate>Thu, 06 Oct 2022 22:42:23 +0800</pubDate><guid>https://www.shellio.cc/docs/programing/c++/default/30/</guid><description>C++ 文件和流 到目前为止，我们已经使用了 iostream 标准库，它提供了 cin 和 cout 方法分别用于从标准输入读取流和向标准输出写入流。
本教程介绍如何从文件读取流和向文件写入流。这就需要用到 C++ 中另一个标准库 fstream，它定义了三个新的数据类型：
数据类型 描述 ofstream 该数据类型表示输出文件流，用于创建文件并向文件写入信息。 ifstream 该数据类型表示输入文件流，用于从文件读取信息。 fstream 该数据类型通常表示文件流，且同时具有 ofstream 和 ifstream 两种功能，这意味着它可以创建文件，向文件写入信息，从文件读取信息。 要在C++ 中进行文件处理，必须在 C++ 源代码文件中包含头文件 和 。
打开文件 在从文件读取信息或者向文件写入信息之前，必须先打开文件。ofstream 和 fstream 对象都可以用来打开文件进行写操作，如果只需要打开文件进行读操作，则使用 ifstream 对象。
下面是open() 函数的标准语法，open() 函数是 fstream、ifstream 和 ofstream 对象的一个成员。
1void open(const char *filename, ios::openmode mode); 在这里，open() 成员函数的第一参数指定要打开的文件的名称和位置，第二个参数定义文件被打开的模式。
模式标志 描述 ios::app 追加模式。所有写入都追加到文件末尾。 ios::ate 文件打开后定位到文件末尾。 ios::in 打开文件用于读取。 ios::out 打开文件用于写入。 ios::trunc 如果该文件已经存在，其内容将在打开文件之前被截断，即把文件长度设为 0。 您可以把以上两种或两种以上的模式结合使用。例如，如果您想要以写入模式打开文件，并希望截断文件，以防文件已存在，那么您可以使用下面的语法：
1ofstream outfile; 2outfile.open(&amp;#34;file.dat&amp;#34;, ios::out | ios::trunc ); 类似地，您如果想要打开一个文件用于读写，可以使用下面的语法：</description></item><item><title>三十、Docker 命令大全</title><link>https://www.shellio.cc/docs/cloud-native/docker/30/</link><pubDate>Thu, 06 Oct 2022 22:42:23 +0800</pubDate><guid>https://www.shellio.cc/docs/cloud-native/docker/30/</guid><description>Docker 是一个开源的应用容器引擎，基于 Go 语言 并遵从 Apache2.0 协议开源
Docker 可以让开发者打包它们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化
Docker 使用完全使用沙箱机制，两个容器之间不会有任何接口 (这个有点像 iPhone 的 app ) ,更重要的是容器性能开销极低
学习前提 在继续阅读之前，我们希望你对 Linux 有一些基本的了解，包括
1、 会使用Linux常用的命令；
2、 知道大部分的Linux常识，比如终端、service、ip、用户、组等；
3、 熟练使用Ubuntu或者Centos或者MacOS种的一种昂；
如果你对这些知识还是一知半解，可以访问我们的 Linux 基础教程 先进行一些简单的了解
Docker的应用场景 1、 Web应用的自动化打包和发布；
2、 自动化测试和持续集成、发布；
3、 在服务型环境中部署和调整数据库或其他的后台应用；
4、 从头编译或者扩展现有的OpenShift或CloudFoundry平台来搭建自己的PaaS环境；
Docker 的优点 1、 简化程序；
1Docker 让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的 Linux 机器上，便可以实现虚拟化 2Docker 改变了虚拟化的方式，使开发者可以直接将自己的成果放入 Docker 中进行管理 3方便快捷已经是 Docker 的最大优势，过去需要用数天乃至数周的 任务，在Docker容器的处理下，只需要数秒就能完成 2、 解决运维配置噩梦；
1在没有 Docker 之前，每一台机器，每一个要用到的依赖，几乎都要重新配置一遍 2比如新增一台 MySQL 数据库，就要从头开始配置所有环境 3有了 Docker 之后，只需要从仓库里把之前的 MySQL 镜像拉出来，直接使用 3、 节省开支；</description></item><item><title>C++ Web 编程</title><link>https://www.shellio.cc/docs/programing/c++/default/38/</link><pubDate>Thu, 06 Oct 2022 22:42:23 +0800</pubDate><guid>https://www.shellio.cc/docs/programing/c++/default/38/</guid><description>C++ Web 编程 什么是 CGI？ 公共网关接口（CGI），是一套标准，定义了信息是如何在 Web 服务器和客户端脚本之间进行交换的。 CGI 规范目前是由 NCSA 维护的，NCSA 定义 CGI 如下： 公共网关接口（CGI），是一种用于外部网关程序与信息服务器（如 HTTP 服务器）对接的接口标准。 目前的版本是 CGI/1.1，CGI/1.2 版本正在推进中。 Web 浏览 为了更好地了解 CGI 的概念，让我们点击一个超链接，浏览一个特定的网页或 URL，看看会发生什么。
您的浏览器联系上 HTTP Web 服务器，并请求 URL，即文件名。 Web 服务器将解析 URL，并查找文件名。如果找到请求的文件，Web 服务器会把文件发送回浏览器，否则发送一条错误消息，表明您请求了一个错误的文件。 Web 浏览器从 Web 服务器获取响应，并根据接收到的响应来显示文件或错误消息。 然而，以这种方式搭建起来的 HTTP 服务器，不管何时请求目录中的某个文件，HTTP 服务器发送回来的不是该文件，而是以程序形式执行，并把执行产生的输出发送回浏览器显示出来。
公共网关接口（CGI），是使得应用程序（称为 CGI 程序或 CGI 脚本）能够与 Web 服务器以及客户端进行交互的标准协议。这些 CGI 程序可以用 Python、PERL、Shell、C 或 C++ 等进行编写。
CGI 架构图 下图演示了 CGI 的架构：
Web 服务器配置 在您进行 CGI 编程之前，请确保您的 Web 服务器支持 CGI，并已配置成可以处理 CGI 程序。所有由 HTTP 服务器执行的 CGI 程序，都必须在预配置的目录中。该目录称为 CGI 目录，按照惯例命名为 /var/www/cgi-bin。虽然 CGI 文件是 C++ 可执行文件，但是按照惯例它的扩展名是 .</description></item><item><title>C++ 动态内存</title><link>https://www.shellio.cc/docs/programing/c++/default/32/</link><pubDate>Thu, 06 Oct 2022 22:42:23 +0800</pubDate><guid>https://www.shellio.cc/docs/programing/c++/default/32/</guid><description>C++ 动态内存 了解动态内存在 C++ 中是如何工作的是成为一名合格的 C++ 程序员必不可少的。C++ 程序中的内存分为两个部分：
**栈：**在函数内部声明的所有变量都将占用栈内存。 **堆：**这是程序中未使用的内存，在程序运行时可用于动态分配内存。 很多时候，您无法提前预知需要多少内存来存储某个定义变量中的特定信息，所需内存的大小需要在运行时才能确定。
在C++ 中，您可以使用特殊的运算符为给定类型的变量在运行时分配堆内的内存，这会返回所分配的空间地址。这种运算符即 new 运算符。
如果您不需要动态分配内存，可以使用 delete 运算符，删除之前由 new 运算符分配的内存。
new 和 delete 运算符 下面是使用 new 运算符来为任意的数据类型动态分配内存的通用语法：
1new data-type; 在这里，data-type 可以是包括数组在内的任意内置的数据类型，也可以是包括类或结构在内的用户自定义的任何数据类型。让我们先来看下内置的数据类型。例如，我们可以定义一个指向 double 类型的指针，然后请求内存，该内存在执行时被分配。我们可以按照下面的语句使用 new 运算符来完成这点：
1double* pvalue = NULL; // 初始化为 null 的指针 2pvalue = new double; // 为变量请求内存 如果自由存储区已被用完，可能无法成功分配内存。所以建议检查 new 运算符是否返回 NULL 指针，并采取以下适当的操作：
1double* pvalue = NULL; 2if( !(pvalue = new double )) 3 cout &amp;lt;&amp;lt; &amp;#34;Error: out of memory.</description></item><item><title>C++ STL 教程</title><link>https://www.shellio.cc/docs/programing/c++/default/39/</link><pubDate>Thu, 06 Oct 2022 22:42:23 +0800</pubDate><guid>https://www.shellio.cc/docs/programing/c++/default/39/</guid><description>C++ STL 教程 在前面的章节中，我们已经学习了 C++ 模板的概念。C++ STL（标准模板库）是一套功能强大的 C++ 模板类，提供了通用的模板类和函数，这些模板类和函数可以实现多种流行和常用的算法和数据结构，如向量、链表、队列、栈。
C++标准模板库的核心包括以下三个组件：
组件 描述 容器（Containers） 容器是用来管理某一类对象的集合。C++ 提供了各种不同类型的容器，比如 deque、list、vector、map 等。 算法（Algorithms） 算法作用于容器。它们提供了执行各种操作的方式，包括对容器内容执行初始化、排序、搜索和转换等操作。 迭代器（terators） 迭代器用于遍历对象集合的元素。这些集合可能是容器，也可能是容器的子集。 这三个组件都带有丰富的预定义函数，帮助我们通过简单的方式处理复杂的任务。
下面的程序演示了向量容器（一个 C++ 标准的模板），它与数组十分相似，唯一不同的是，向量在需要扩展大小的时候，会自动处理它自己的存储需求：
1#include &amp;lt;iostream&amp;gt; 2#include &amp;lt;vector&amp;gt; 3using namespace std; 4int main() 5 // 创建一个向量存储 int 6 vector&amp;lt;int&amp;gt; vec; 7 int i; 8 // 显示 vec 的原始大小 9 cout &amp;lt;&amp;lt; &amp;#34;vector size = &amp;#34; &amp;lt;&amp;lt; vec.size() &amp;lt;&amp;lt; endl; 10 // 推入 5 个值到向量中 11 for(i = 0; i &amp;lt; 5; i++){ 12 vec.</description></item><item><title>C++ 信号处理</title><link>https://www.shellio.cc/docs/programing/c++/default/36/</link><pubDate>Thu, 06 Oct 2022 22:42:23 +0800</pubDate><guid>https://www.shellio.cc/docs/programing/c++/default/36/</guid><description>C++ 信号处理 信号是由操作系统传给进程的中断，会提早终止一个程序。在 UNIX、LINUX、Mac OS X 或 Windows 系统上，可以通过按 Ctrl+C 产生中断。
有些信号不能被程序捕获，但是下表所列信号可以在程序中捕获，并可以基于信号采取适当的动作。这些信号是定义在 C++ 头文件 中。
信号 描述 SIGABRT 程序的异常终止，如调用 abort。 SIGFPE 错误的算术运算，比如除以零或导致溢出的操作。 SIGILL 检测非法指令。 SIGINT 接收到交互注意信号。 SIGSEGV 非法访问内存。 SIGTERM 发送到程序的终止请求。 signal() 函数 C++信号处理库提供了 signal 函数，用来捕获突发事件。以下是 signal() 函数的语法：
1void (*signal (int sig, void (*func)(int)))(int); 这个函数接收两个参数：第一个参数是一个整数，代表了信号的编号；第二个参数是一个指向信号处理函数的指针。
让我们编写一个简单的 C++ 程序，使用 signal() 函数捕获 SIGINT 信号。不管您想在程序中捕获什么信号，您都必须使用 signal 函数来注册信号，并将其与信号处理程序相关联。看看下面的实例：
1#include &amp;lt;iostream&amp;gt; 2#include &amp;lt;csignal&amp;gt; 3#include &amp;lt;unistd.h&amp;gt; 4using namespace std; 5void signalHandler( int signum ) 6 cout &amp;lt;&amp;lt; &amp;#34;Interrupt signal (&amp;#34; &amp;lt;&amp;lt; signum &amp;lt;&amp;lt; &amp;#34;) received.</description></item><item><title>C++ 多线程</title><link>https://www.shellio.cc/docs/programing/c++/default/37/</link><pubDate>Thu, 06 Oct 2022 22:42:23 +0800</pubDate><guid>https://www.shellio.cc/docs/programing/c++/default/37/</guid><description>C++ 多线程 多线程是多任务处理的一种特殊形式，多任务处理允许让电脑同时运行两个或两个以上的程序。在一般情况下，有两种类型的多任务处理：基于进程和基于线程。
基于进程的多任务处理处理的是程序的并发执行。基于线程的多任务处理的是同一程序的片段的并发执行。
多线程程序包含可以同时运行的两个或多个部分。这样的程序中的每个部分称为一个线程，每个线程定义了一个单独的执行路径。
C++不包含多线程应用程序的任何内置支持。相反，它完全依赖于操作系统来提供此功能。
本教程假设您使用的是 Linux 操作系统，我们要使用 POSIX 编写多线程 C++ 程序。POSIX Threads 或 Pthreads 提供的 API 可在多种类 Unix POSIX 系统上可用，比如 FreeBSD、NetBSD、GNU/Linux、Mac OS X 和 Solaris。
创建线程 有下面的例程，我们可以用它来创建一个 POSIX 线程：
1#include &amp;lt;pthread.h&amp;gt; 2pthread_create (thread, attr, start_routine, arg) 在这里，pthread_create 创建一个新的线程，并让它可执行。这个例程可在代码内的任何地方被调用任意次数。下面是关于参数的说明：
参数 描述 thread 一个不透明的、唯一的标识符，用来标识例程返回的新线程。 attr 一个不透明的属性对象，可以被用来设置线程属性。您可以指定线程属性对象，也可以使用默认值 NULL。 start_routine C++ 例程，一旦线程被创建就会执行。 arg 一个可能传递给 start_routine 的参数。它必须通过把引用作为指针强制转换为 void 类型进行传递。如果没有传递参数，则使用 NULL。 一个进程可以创建的最大线程数是依赖于实现的。线程一旦被创建，就是同等的，而且可以创建其他线程。线程之间没有隐含层次或依赖。
终止线程 有下面的例程，我们可以用它来终止一个 POSIX 线程：
1#include &amp;lt;pthread.h&amp;gt; 2pthread_exit (status) 在这里，pthread_exit 用于显式地退出一个线程。通常情况下，pthread_exit() 例程是在线程完成工作后无需继续存在时被调用。
如果main() 是在它所创建的线程之前结束，并通过 pthread_exit() 退出，那么其他线程将继续执行。否则，它们将在 main() 结束时自动被终止。</description></item><item><title>C++ 命名空间</title><link>https://www.shellio.cc/docs/programing/c++/default/33/</link><pubDate>Thu, 06 Oct 2022 22:42:23 +0800</pubDate><guid>https://www.shellio.cc/docs/programing/c++/default/33/</guid><description>C++ 命名空间 假设这样一种情况，当一个班上有两个名叫 Zara 的学生时，为了明确区分它们，我们在使用名字之外，不得不使用一些额外的信息，比如他们的家庭住址，或者他们父母的名字等等。
同样的情况也出现在 C++ 应用程序中。例如，您可能会写一个名为 xyz() 的函数，在另一个可用的库中也存在一个相同的函数 xyz()。这样，编译器就无法判断您所使用的是哪一个 xyz() 函数。
因此，引入了命名空间这个概念，专门用于解决上面的问题，它可作为附加信息来区分不同库中相同名称的函数、类、变量等。使用了命名空间即定义了上下文。本质上，命名空间就是定义了一个范围。
定义命名空间 命名空间的定义使用关键字 namespace，后跟命名空间的名称，如下所示：
1namespace namespace_name { 2 // 代码声明 为了调用带有命名空间的函数或变量，需要在前面加上命名空间的名称，如下所示：
1name::code; // code 可以是变量或函数 让我们来看看命名空间如何为变量或函数等实体定义范围：
1#include &amp;lt;iostream&amp;gt; 2using namespace std; 3// 第一个命名空间 4namespace first_space{ 5 void func(){ 6 cout &amp;lt;&amp;lt; &amp;#34;Inside first_space&amp;#34; &amp;lt;&amp;lt; endl; 7 } 8// 第二个命名空间 9namespace second_space{ 10 void func(){ 11 cout &amp;lt;&amp;lt; &amp;#34;Inside second_space&amp;#34; &amp;lt;&amp;lt; endl; 12 } 13int main () 14 // 调用第一个命名空间中的函数 15 first_space::func(); 16 // 调用第二个命名空间中的函数 17 second_space::func(); 18 return 0; 当上面的代码被编译和执行时，它会产生下列结果：</description></item><item><title>C++ 模板</title><link>https://www.shellio.cc/docs/programing/c++/default/34/</link><pubDate>Thu, 06 Oct 2022 22:42:23 +0800</pubDate><guid>https://www.shellio.cc/docs/programing/c++/default/34/</guid><description>C++ 模板 模板是泛型编程的基础，泛型编程即以一种独立于任何特定类型的方式编写代码。
模板是创建泛型类或函数的蓝图或公式。库容器，比如迭代器和算法，都是泛型编程的例子，它们都使用了模板的概念。
每个容器都有一个单一的定义，比如 向量，我们可以定义许多不同类型的向量，比如 vector 或 vector 。
您可以使用模板来定义函数和类，接下来让我们一起来看看如何使用。
函数模板 模板函数定义的一般形式如下所示：
1template &amp;lt;class type&amp;gt; ret-type func-name(parameter list) 2 // 函数的主体 3} 在这里，type 是函数所使用的数据类型的占位符名称。这个名称可以在函数定义中使用。
下面是函数模板的实例，返回两个数中的最大值：
1#include &amp;lt;iostream&amp;gt; 2#include &amp;lt;string&amp;gt; 3using namespace std; 4template &amp;lt;typename T&amp;gt; 5inline T const&amp;amp; Max (T const&amp;amp; a, T const&amp;amp; b) 6{ 7 return a &amp;lt; b ? b:a; 8} 9int main () 10 int i = 39; 11 int j = 20; 12 cout &amp;lt;&amp;lt; &amp;#34;Max(i, j): &amp;#34; &amp;lt;&amp;lt; Max(i, j) &amp;lt;&amp;lt; endl; 13 double f1 = 13.</description></item><item><title>C++ 预处理器</title><link>https://www.shellio.cc/docs/programing/c++/default/35/</link><pubDate>Thu, 06 Oct 2022 22:42:23 +0800</pubDate><guid>https://www.shellio.cc/docs/programing/c++/default/35/</guid><description>C++ 预处理器 预处理器是一些指令，指示编译器在实际编译之前所需完成的预处理。
所有的预处理器指令都是以井号（#）开头，只有空格字符可以出现在预处理指令之前。预处理指令不是 C++ 语句，所以它们不会以分号（;）结尾。
我们已经看到，之前所有的实例中都有 #include 指令。这个宏用于把头文件包含到源文件中。
C++ 还支持很多预处理指令，比如 #include、#define、#if、#else、#line 等，让我们一起看看这些重要指令。
#define 预处理 #define 预处理指令用于创建符号常量。该符号常量通常称为宏，指令的一般形式是：
1#define macro-name replacement-text 当这一行代码出现在一个文件中时，在该文件中后续出现的所有宏都将会在程序编译之前被替换为 replacement-text。例如：
1#include &amp;lt;iostream&amp;gt; 2using namespace std; 3#define PI 3.14159 4int main () 5 cout &amp;lt;&amp;lt; &amp;#34;Value of PI :&amp;#34; &amp;lt;&amp;lt; PI &amp;lt;&amp;lt; endl; 6 return 0; 现在，让我们测试这段代码，看看预处理的结果。假设源代码文件已经存在，接下来使用 -E 选项进行编译，并把结果重定向到 test.p。现在，如果您查看 test.p 文件，将会看到它已经包含大量的信息，而且在文件底部的值被改为如下：
1$gcc -E test.cpp &amp;gt; test.p 2... 3int main () 4 cout &amp;lt;&amp;lt; &amp;#34;Value of PI :&amp;#34; &amp;lt;&amp;lt; 3.</description></item><item><title>C++ 异常处理</title><link>https://www.shellio.cc/docs/programing/c++/default/31_miss/</link><pubDate>Thu, 06 Oct 2022 22:42:23 +0800</pubDate><guid>https://www.shellio.cc/docs/programing/c++/default/31_miss/</guid><description>C++ 异常处理 异常是程序在执行期间产生的问题。C++ 异常是指在程序运行时发生的特殊情况，比如尝试除以零的操作。
异常提供了一种转移程序控制权的方式。C++ 异常处理涉及到三个关键字：try、catch、throw。
throw: 当问题出现时，程序会抛出一个异常。这是通过使用 throw 关键字来完成的。 catch: 在您想要处理问题的地方，通过异常处理程序捕获异常。catch 关键字用于捕获异常。 try: try 块中的代码标识将被激活的特定异常。它后面通常跟着一个或多个 catch 块。 如果有一个块抛出一个异常，捕获异常的方法会使用 try 和 catch 关键字。try 块中放置可能抛出异常的代码，try 块中的代码被称为保护代码。使用 try/catch 语句的语法如下所示：
1try 2 // 保护代码 3}catch( ExceptionName e1 ) 4 // catch 块 5}catch( ExceptionName e2 ) 6 // catch 块 7}catch( ExceptionName eN ) 8 // catch 块 如果 try 块在不同的情境下会抛出不同的异常，这个时候可以尝试罗列多个 catch 语句，用于捕获不同类型的异常。
抛出异常 您可以使用 throw 语句在代码块中的任何地方抛出异常。throw 语句的操作数可以是任意的表达式，表达式的结果的类型决定了抛出的异常的类型。
以下是尝试除以零时抛出异常的实例：
1double division(int a, int b) 2 if( b == 0 ) 3 { 4 throw &amp;#34;Division by zero condition!</description></item><item><title>C++ 存储类</title><link>https://www.shellio.cc/docs/programing/c++/default/10/</link><pubDate>Thu, 06 Oct 2022 22:42:23 +0800</pubDate><guid>https://www.shellio.cc/docs/programing/c++/default/10/</guid><description>C++ 存储类 存储类定义 C++ 程序中变量/函数的范围（可见性）和生命周期。这些说明符放置在它们所修饰的类型之前。下面列出 C++ 程序中可用的存储类：
auto register static extern mutable auto 存储类 auto 存储类是所有局部变量默认的存储类。
1{ 2 int mount; 3 auto int month; 上面的实例定义了两个带有相同存储类的变量，auto 只能用在函数内，即 auto 只能修饰局部变量。
register 存储类 register 存储类用于定义存储在寄存器中而不是 RAM 中的局部变量。这意味着变量的最大尺寸等于寄存器的大小（通常是一个词），且不能对它应用一元的 ‘&amp;amp;’ 运算符（因为它没有内存位置）。
1{ 2 register int miles; 寄存器只用于需要快速访问的变量，比如计数器。还应注意的是，定义 ‘register’ 并不意味着变量将被存储在寄存器中，它意味着变量可能存储在寄存器中，这取决于硬件和实现的限制。
static 存储类 static 存储类指示编译器在程序的生命周期内保持局部变量的存在，而不需要在每次它进入和离开作用域时进行创建和销毁。因此，使用 static 修饰局部变量可以在函数调用之间保持局部变量的值。
static 修饰符也可以应用于全局变量。当 static 修饰全局变量时，会使变量的作用域限制在声明它的文件内。
在C++ 中，当 static 用在类数据成员上时，会导致仅有一个该成员的副本被类的所有对象共享。
1#include &amp;lt;iostream&amp;gt; 2// 函数声明 3void func(void); 4static int count = 10; /* 全局变量 */ 5int main() 6 while(count--) 7 { 8 func(); 9 } 10 return 0; 11// 函数定义 12void func( void ) 13 static int i = 5; // 局部静态变量 14 i++; 15 std::cout &amp;lt;&amp;lt; &amp;#34;变量 i 为 &amp;#34; &amp;lt;&amp;lt; i ; 16 std::cout &amp;lt;&amp;lt; &amp;#34; , 变量 count 为 &amp;#34; &amp;lt;&amp;lt; count &amp;lt;&amp;lt; std::endl; 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 当上面的代码被编译和执行时，它会产生下列结果：</description></item><item><title>十、Docker start 启动容器</title><link>https://www.shellio.cc/docs/cloud-native/docker/10/</link><pubDate>Thu, 06 Oct 2022 22:42:23 +0800</pubDate><guid>https://www.shellio.cc/docs/cloud-native/docker/10/</guid><description>Docker 是一个开源的应用容器引擎，基于 Go 语言 并遵从 Apache2.0 协议开源
Docker 可以让开发者打包它们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化
Docker 使用完全使用沙箱机制，两个容器之间不会有任何接口 (这个有点像 iPhone 的 app ) ,更重要的是容器性能开销极低
学习前提 在继续阅读之前，我们希望你对 Linux 有一些基本的了解，包括
1、 会使用 Linux 常用的命令；
2、 知道大部分的 Linux 常识，比如终端、service、ip、用户、组等；
3、 熟练使用 Ubuntu 或者 Centos 或者 MacOS 种的一种昂；
如果你对这些知识还是一知半解，可以访问我们的 Linux 基础教程 先进行一些简单的了解
Docker 的应用场景 1、 Web 应用的自动化打包和发布；
2、 自动化测试和持续集成、发布；
3、 在服务型环境中部署和调整数据库或其他的后台应用；
4、 从头编译或者扩展现有的 OpenShift 或 CloudFoundry 平台来搭建自己的 PaaS 环境；
Docker 的优点 1、 简化程序；
1Docker 让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的 Linux 机器上，便可以实现虚拟化 2Docker 改变了虚拟化的方式，使开发者可以直接将自己的成果放入 Docker 中进行管理 3方便快捷已经是 Docker 的最大优势，过去需要用数天乃至数周的 任务，在Docker容器的处理下，只需要数秒就能完成 2、 解决运维配置噩梦；</description></item><item><title>C++ 指针</title><link>https://www.shellio.cc/docs/programing/c++/default/18/</link><pubDate>Thu, 06 Oct 2022 22:42:23 +0800</pubDate><guid>https://www.shellio.cc/docs/programing/c++/default/18/</guid><description>C++ 指针 学习C++ 的指针既简单又有趣。通过指针，可以简化一些 C++ 编程任务的执行，还有一些任务，如动态内存分配，没有指针是无法执行的。所以，想要成为一名优秀的 C++ 程序员，学习指针是很有必要的。
正如您所知道的，每一个变量都有一个内存位置，每一个内存位置都定义了可使用连字号（&amp;amp;）运算符访问的地址，它表示了在内存中的一个地址。请看下面的实例，它将输出定义的变量地址：
1#include &amp;lt;iostream&amp;gt; 2using namespace std; 3int main () 4 int var1; 5 char var2[10]; 6 cout &amp;lt;&amp;lt; &amp;#34;var1 变量的地址： &amp;#34;; 7 cout &amp;lt;&amp;lt; &amp;amp;var1 &amp;lt;&amp;lt; endl; 8 cout &amp;lt;&amp;lt; &amp;#34;var2 变量的地址： &amp;#34;; 9 cout &amp;lt;&amp;lt; &amp;amp;var2 &amp;lt;&amp;lt; endl; 10 return 0; 当上面的代码被编译和执行时，它会产生下列结果：
1var1 变量的地址： 0xbfebd5c0 2var2 变量的地址： 0xbfebd5b6 通过上面的实例，我们了解了什么是内存地址以及如何访问它。接下来让我们看看什么是指针。
什么是指针？ 指针是一个变量，其值为另一个变量的地址，即，内存位置的直接地址。就像其他变量或常量一样，您必须在使用指针存储其他变量地址之前，对其进行声明。指针变量声明的一般形式为：
1type *var-name; 在这里，type 是指针的基类型，它必须是一个有效的 C++ 数据类型，var-name 是指针变量的名称。用来声明指针的星号 * 与乘法中使用的星号是相同的。但是，在这个语句中，星号是用来指定一个变量是指针。以下是有效的指针声明：
1int *ip; /* 一个整型的指针 */ 2double *dp; /* 一个 double 型的指针 */ 3float *fp; /* 一个浮点型的指针 */ 4char *ch /* 一个字符型的指针 */ 所有指针的值的实际数据类型，不管是整型、浮点型、字符型，还是其他的数据类型，都是一样的，都是一个代表内存地址的长的十六进制数。不同数据类型的指针之间唯一的不同是，指针所指向的变量或常量的数据类型不同。</description></item><item><title>十八、Docker commit 更新镜像</title><link>https://www.shellio.cc/docs/cloud-native/docker/18/</link><pubDate>Thu, 06 Oct 2022 22:42:23 +0800</pubDate><guid>https://www.shellio.cc/docs/cloud-native/docker/18/</guid><description>Docker 是一个开源的应用容器引擎，基于 Go 语言 并遵从 Apache2.0 协议开源
Docker 可以让开发者打包它们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化
Docker 使用完全使用沙箱机制，两个容器之间不会有任何接口 (这个有点像 iPhone 的 app ) ,更重要的是容器性能开销极低
学习前提 在继续阅读之前，我们希望你对 Linux 有一些基本的了解，包括
1、 会使用Linux常用的命令；
2、 知道大部分的Linux常识，比如终端、service、ip、用户、组等；
3、 熟练使用Ubuntu或者Centos或者MacOS种的一种昂；
如果你对这些知识还是一知半解，可以访问我们的 Linux 基础教程 先进行一些简单的了解
Docker的应用场景 1、 Web应用的自动化打包和发布；
2、 自动化测试和持续集成、发布；
3、 在服务型环境中部署和调整数据库或其他的后台应用；
4、 从头编译或者扩展现有的OpenShift或CloudFoundry平台来搭建自己的PaaS环境；
Docker 的优点 1、 简化程序；
1Docker 让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的 Linux 机器上，便可以实现虚拟化 2Docker 改变了虚拟化的方式，使开发者可以直接将自己的成果放入 Docker 中进行管理 3方便快捷已经是 Docker 的最大优势，过去需要用数天乃至数周的 任务，在Docker容器的处理下，只需要数秒就能完成 2、 解决运维配置噩梦；
1在没有 Docker 之前，每一台机器，每一个要用到的依赖，几乎都要重新配置一遍 2比如新增一台 MySQL 数据库，就要从头开始配置所有环境 3有了 Docker 之后，只需要从仓库里把之前的 MySQL 镜像拉出来，直接使用 3、 节省开支；</description></item><item><title>C++ 循环</title><link>https://www.shellio.cc/docs/programing/c++/default/12_miss/</link><pubDate>Thu, 06 Oct 2022 22:42:23 +0800</pubDate><guid>https://www.shellio.cc/docs/programing/c++/default/12_miss/</guid><description>C++ 循环 有的时候，可能需要多次执行同一块代码。一般情况下，语句是顺序执行的：函数中的第一个语句先执行，接着是第二个语句，依此类推。
编程语言提供了允许更为复杂的执行路径的多种控制结构。
循环语句允许我们多次执行一个语句或语句组，下面是大多数编程语言中循环语句的一般形式：
##
##
##
##
##
##
##
##
##
循环类型 C++编程语言提供了以下几种循环类型。点击链接查看每个类型的细节。
循环类型 描述 while 循环 当给定条件为真时，重复语句或语句组。它会在执行循环主体之前测试条件。 for 循环 多次执行一个语句序列，简化管理循环变量的代码。 do…while 循环 除了它是在循环主体结尾测试条件外，其他与 while 语句类似。 嵌套循环 您可以在 while、for 或 do..while 循环内使用一个或多个循环。 循环控制语句 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 循环控制语句更改执行的正常序列。当执行离开一个范围时，所有在该范围中创建的自动对象都会被销毁。
C++提供了下列的控制语句。点击链接查看每个语句的细节。
控制语句 描述 break 语句 终止 loop 或 switch 语句，程序流将继续执行紧接着 loop 或 switch 的下一条语句。 continue 语句 引起循环跳过主体的剩余部分，立即重新开始测试条件。 goto 语句 将控制转移到被标记的语句。但是不建议在程序中使用 goto 语句。 无限循环 如果条件永远不为假，则循环将变成无限循环。for 循环在传统意义上可用于实现无限循环。由于构成循环的三个表达式中任何一个都不是必需的，您可以将某些条件表达式留空来构成一个无限循环。
1#include &amp;lt;iostream&amp;gt; 2using namespace std; 3int main () 4 for( ; ; ) 5 { 6 printf(&amp;#34;This loop will run forever.</description></item><item><title>十二、Docker rm 删除已停止的容器</title><link>https://www.shellio.cc/docs/cloud-native/docker/12/</link><pubDate>Thu, 06 Oct 2022 22:42:23 +0800</pubDate><guid>https://www.shellio.cc/docs/cloud-native/docker/12/</guid><description>Docker 是一个开源的应用容器引擎，基于 Go 语言 并遵从 Apache2.0 协议开源
Docker 可以让开发者打包它们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化
Docker 使用完全使用沙箱机制，两个容器之间不会有任何接口 (这个有点像 iPhone 的 app ) ,更重要的是容器性能开销极低
学习前提 在继续阅读之前，我们希望你对 Linux 有一些基本的了解，包括
1、 会使用Linux常用的命令；
2、 知道大部分的Linux常识，比如终端、service、ip、用户、组等；
3、 熟练使用Ubuntu或者Centos或者MacOS种的一种昂；
如果你对这些知识还是一知半解，可以访问我们的 Linux 基础教程 先进行一些简单的了解
Docker的应用场景 1、 Web应用的自动化打包和发布；
2、 自动化测试和持续集成、发布；
3、 在服务型环境中部署和调整数据库或其他的后台应用；
4、 从头编译或者扩展现有的OpenShift或CloudFoundry平台来搭建自己的PaaS环境；
因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 Docker 的优点 1、 简化程序；
1Docker 让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的 Linux 机器上，便可以实现虚拟化 2Docker 改变了虚拟化的方式，使开发者可以直接将自己的成果放入 Docker 中进行管理 3方便快捷已经是 Docker 的最大优势，过去需要用数天乃至数周的 任务，在Docker容器的处理下，只需要数秒就能完成 2、 解决运维配置噩梦；
1在没有 Docker 之前，每一台机器，每一个要用到的依赖，几乎都要重新配置一遍 2比如新增一台 MySQL 数据库，就要从头开始配置所有环境 3有了 Docker 之后，只需要从仓库里把之前的 MySQL 镜像拉出来，直接使用 3、 节省开支；</description></item><item><title>C++ 引用</title><link>https://www.shellio.cc/docs/programing/c++/default/19/</link><pubDate>Thu, 06 Oct 2022 22:42:23 +0800</pubDate><guid>https://www.shellio.cc/docs/programing/c++/default/19/</guid><description>C++ 引用 引用变量是一个别名，也就是说，它是某个已存在变量的另一个名字。一旦把引用初始化为某个变量，就可以使用该引用名称或变量名称来指向变量。
C++ 引用 vs 指针 引用很容易与指针混淆，它们之间有三个主要的不同：
不存在空引用。引用必须连接到一块合法的内存。 一旦引用被初始化为一个对象，就不能被指向到另一个对象。指针可以在任何时候指向到另一个对象。 引用必须在创建时被初始化。指针可以在任何时间被初始化。 C++ 中创建引用 试想变量名称是变量附属在内存位置中的标签，您可以把引用当成是变量附属在内存位置中的第二个标签。因此，您可以通过原始变量名称或引用来访问变量的内容。例如：
1int i = 17; 我们可以为 i 声明引用变量，如下所示：
1int&amp;amp; r = i; 在这些声明中，&amp;amp; 读作引用。因此，第一个声明可以读作 “r 是一个初始化为 i 的整型引用”，第二个声明可以读作 “s 是一个初始化为 d 的 double 型引用”。下面的实例使用了 int 和 double 引用：
1#include &amp;lt;iostream&amp;gt; 2using namespace std; 3int main () 4 // 声明简单的变量 5 int i; 6 double d; 7 // 声明引用变量 8 int&amp;amp; r = i; 9 double&amp;amp; s = d; 10 i = 5; 11 cout &amp;lt;&amp;lt; &amp;#34;Value of i : &amp;#34; &amp;lt;&amp;lt; i &amp;lt;&amp;lt; endl; 12 cout &amp;lt;&amp;lt; &amp;#34;Value of i reference : &amp;#34; &amp;lt;&amp;lt; r &amp;lt;&amp;lt; endl; 13 d = 11.</description></item><item><title>十九、Docker Dockerfile 创建镜像</title><link>https://www.shellio.cc/docs/cloud-native/docker/19/</link><pubDate>Thu, 06 Oct 2022 22:42:23 +0800</pubDate><guid>https://www.shellio.cc/docs/cloud-native/docker/19/</guid><description>Docker 是一个开源的应用容器引擎，基于 Go 语言 并遵从 Apache2.0 协议开源
Docker 可以让开发者打包它们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化
Docker 使用完全使用沙箱机制，两个容器之间不会有任何接口 (这个有点像 iPhone 的 app ) ,更重要的是容器性能开销极低
学习前提 在继续阅读之前，我们希望你对 Linux 有一些基本的了解，包括
1、 会使用Linux常用的命令；
2、 知道大部分的Linux常识，比如终端、service、ip、用户、组等；
3、 熟练使用Ubuntu或者Centos或者MacOS种的一种昂；
如果你对这些知识还是一知半解，可以访问我们的 Linux 基础教程 先进行一些简单的了解
Docker的应用场景 1、 Web应用的自动化打包和发布；
2、 自动化测试和持续集成、发布；
3、 在服务型环境中部署和调整数据库或其他的后台应用；
4、 从头编译或者扩展现有的OpenShift或CloudFoundry平台来搭建自己的PaaS环境；
Docker 的优点 1、 简化程序；
1Docker 让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的 Linux 机器上，便可以实现虚拟化 2Docker 改变了虚拟化的方式，使开发者可以直接将自己的成果放入 Docker 中进行管理 3方便快捷已经是 Docker 的最大优势，过去需要用数天乃至数周的 任务，在Docker容器的处理下，只需要数秒就能完成 2、 解决运维配置噩梦；
1在没有 Docker 之前，每一台机器，每一个要用到的依赖，几乎都要重新配置一遍 2比如新增一台 MySQL 数据库，就要从头开始配置所有环境 3有了 Docker 之后，只需要从仓库里把之前的 MySQL 镜像拉出来，直接使用 3、 节省开支；</description></item><item><title>C++ 数组</title><link>https://www.shellio.cc/docs/programing/c++/default/16_miss/</link><pubDate>Thu, 06 Oct 2022 22:42:23 +0800</pubDate><guid>https://www.shellio.cc/docs/programing/c++/default/16_miss/</guid><description>C++ 数组 C++支持数组数据结构，它可以存储一个固定大小的相同类型元素的顺序集合。数组是用来存储一系列数据，但它往往被认为是一系列相同类型的变量。
数组的声明并不是声明一个个单独的变量，比如 number0、number1、…、number99，而是声明一个数组变量，比如 numbers，然后使用 numbers[0]、numbers[1]、…、numbers[99] 来代表一个个单独的变量。数组中的特定元素可以通过索引访问。
所有的数组都是由连续的内存位置组成。最低的地址对应第一个元素，最高的地址对应最后一个元素。
声明数组 在C++ 中要声明一个数组，需要指定元素的类型和元素的数量，如下所示：
1type arrayName [ arraySize ]; 这叫做一维数组。arraySize 必须是一个大于零的整数常量，type 可以是任意有效的 C++ 数据类型。例如，要声明一个类型为 double 的包含 10 个元素的数组 balance，声明语句如下：
1double balance[10]; 现在 balance 是一个可用的数组，可以容纳 10 个类型为 double 的数字。
初始化数组 在C++ 中，您可以逐个初始化数组，也可以使用一个初始化语句，如下所示：
1double balance[5] = {1000.0, 2.0, 3.4, 17.0, 50.0}; 大括号{ } 之间的值的数目不能大于我们在数组声明时在方括号 [ ] 中指定的元素数目。
如果您省略掉了数组的大小，数组的大小则为初始化时元素的个数。因此，如果：
1double balance[] = {1000.0, 2.0, 3.4, 17.0, 50.0}; 您将创建一个数组，它与前一个实例中所创建的数组是完全相同的。下面是一个为数组中某个元素赋值的实例：
1balance[4] = 50.0; 上述的语句把数组中第五个元素的值赋为 50.0。所有的数组都是以 0 作为它们第一个元素的索引，也被称为基索引，数组的最后一个索引是数组的总大小减去 1。以下是上面所讨论的数组的的图形表示：</description></item><item><title>十六、Docker images 本地镜像列表</title><link>https://www.shellio.cc/docs/cloud-native/docker/16/</link><pubDate>Thu, 06 Oct 2022 22:42:23 +0800</pubDate><guid>https://www.shellio.cc/docs/cloud-native/docker/16/</guid><description>Docker 是一个开源的应用容器引擎，基于 Go 语言 并遵从 Apache2.0 协议开源
Docker 可以让开发者打包它们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化
Docker 使用完全使用沙箱机制，两个容器之间不会有任何接口 (这个有点像 iPhone 的 app ) ,更重要的是容器性能开销极低
学习前提 在继续阅读之前，我们希望你对 Linux 有一些基本的了解，包括
1、 会使用Linux常用的命令；
2、 知道大部分的Linux常识，比如终端、service、ip、用户、组等；
3、 熟练使用Ubuntu或者Centos或者MacOS种的一种昂；
如果你对这些知识还是一知半解，可以访问我们的 Linux 基础教程 先进行一些简单的了解
Docker的应用场景 1、 Web应用的自动化打包和发布；
2、 自动化测试和持续集成、发布；
3、 在服务型环境中部署和调整数据库或其他的后台应用；
4、 从头编译或者扩展现有的OpenShift或CloudFoundry平台来搭建自己的PaaS环境；
Docker 的优点 1、 简化程序；
1Docker 让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的 Linux 机器上，便可以实现虚拟化 2Docker 改变了虚拟化的方式，使开发者可以直接将自己的成果放入 Docker 中进行管理 3方便快捷已经是 Docker 的最大优势，过去需要用数天乃至数周的 任务，在Docker容器的处理下，只需要数秒就能完成 2、 解决运维配置噩梦；
1在没有 Docker 之前，每一台机器，每一个要用到的依赖，几乎都要重新配置一遍 2比如新增一台 MySQL 数据库，就要从头开始配置所有环境 3有了 Docker 之后，只需要从仓库里把之前的 MySQL 镜像拉出来，直接使用 3、 节省开支；</description></item><item><title>C++ 字符串</title><link>https://www.shellio.cc/docs/programing/c++/default/17/</link><pubDate>Thu, 06 Oct 2022 22:42:23 +0800</pubDate><guid>https://www.shellio.cc/docs/programing/c++/default/17/</guid><description>C++ 字符串 C++提供了以下两种类型的字符串表示形式：
C 风格字符串 C++ 引入的 string 类类型 C 风格字符串 C风格的字符串起源于 C 语言，并在 C++ 中继续得到支持。字符串实际上是使用 null 字符 ” 终止的一维字符数组。因此，一个以 null 结尾的字符串，包含了组成字符串的字符。
下面的声明和初始化创建了一个 “Hello” 字符串。由于在数组的末尾存储了空字符，所以字符数组的大小比单词 “Hello” 的字符数多一个。char greeting[6] = {’H’, ‘e’, ‘l’, ‘l’, ‘o’, ”};
依据数组初始化规则，您可以把上面的语句写成以下语句：
1char greeting[] = &amp;#34;Hello&amp;#34;; 以下是C/C++ 中定义的字符串的内存表示：
其实，您不需要把 null 字符放在字符串常量的末尾。C++ 编译器会在初始化数组时，自动把 ” 放在字符串的末尾。让我们尝试输出上面的字符串
1#include &amp;lt;iostream&amp;gt; 2using namespace std; 3int main () 4 char greeting[6] = {&amp;#39;H&amp;#39;, &amp;#39;e&amp;#39;, &amp;#39;l&amp;#39;, &amp;#39;l&amp;#39;, &amp;#39;o&amp;#39;, &amp;#39;\0&amp;#39;}; 5 cout &amp;lt;&amp;lt; &amp;#34;Greeting message: &amp;#34;; 6 cout &amp;lt;&amp;lt; greeting &amp;lt;&amp;lt; endl; 7 return 0; 8} 当上面的代码被编译和执行时，它会产生下列结果：</description></item><item><title>十七、Docker 查找镜像</title><link>https://www.shellio.cc/docs/cloud-native/docker/17/</link><pubDate>Thu, 06 Oct 2022 22:42:23 +0800</pubDate><guid>https://www.shellio.cc/docs/cloud-native/docker/17/</guid><description>Docker 是一个开源的应用容器引擎，基于 Go 语言 并遵从 Apache2.0 协议开源
Docker 可以让开发者打包它们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化
Docker 使用完全使用沙箱机制，两个容器之间不会有任何接口 (这个有点像 iPhone 的 app ) ,更重要的是容器性能开销极低
学习前提 在继续阅读之前，我们希望你对 Linux 有一些基本的了解，包括
1、 会使用Linux常用的命令；
2、 知道大部分的Linux常识，比如终端、service、ip、用户、组等；
3、 熟练使用Ubuntu或者Centos或者MacOS种的一种昂；
如果你对这些知识还是一知半解，可以访问我们的 Linux 基础教程 先进行一些简单的了解
Docker的应用场景 1、 Web应用的自动化打包和发布；
2、 自动化测试和持续集成、发布；
3、 在服务型环境中部署和调整数据库或其他的后台应用；
4、 从头编译或者扩展现有的OpenShift或CloudFoundry平台来搭建自己的PaaS环境；
Docker 的优点 1、 简化程序；
1Docker 让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的 Linux 机器上，便可以实现虚拟化 2Docker 改变了虚拟化的方式，使开发者可以直接将自己的成果放入 Docker 中进行管理 3方便快捷已经是 Docker 的最大优势，过去需要用数天乃至数周的 任务，在Docker容器的处理下，只需要数秒就能完成 2、 解决运维配置噩梦；
1在没有 Docker 之前，每一台机器，每一个要用到的依赖，几乎都要重新配置一遍 2比如新增一台 MySQL 数据库，就要从头开始配置所有环境 3有了 Docker 之后，只需要从仓库里把之前的 MySQL 镜像拉出来，直接使用 3、 节省开支；</description></item><item><title>C++ 判断</title><link>https://www.shellio.cc/docs/programing/c++/default/13_miss/</link><pubDate>Thu, 06 Oct 2022 22:42:23 +0800</pubDate><guid>https://www.shellio.cc/docs/programing/c++/default/13_miss/</guid><description>C++ 判断 判断结构要求程序员指定一个或多个要评估或测试的条件，以及条件为真时要执行的语句（必需的）和条件为假时要执行的语句（可选的）。
下面是大多数编程语言中典型的判断结构的一般形式：
##
##
##
##
##
##
##
##
##
判断语句 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 C++编程语言提供了以下类型的判断语句。点击链接查看每个语句的细节。
语句 描述 if 语句 一个 if 语句 由一个布尔表达式后跟一个或多个语句组成。 if…else 语句 一个 if 语句 后可跟一个可选的 else 语句，else 语句在布尔表达式为假时执行。 嵌套 if 语句 您可以在一个 if 或 else if 语句内使用另一个 if 或 else if 语句。 switch 语句 一个 switch 语句允许测试一个变量等于多个值时的情况。 嵌套 switch 语句 您可以在一个 switch 语句内使用另一个 switch 语句。 ? : 运算符 我们已经在前面的章节中讲解了 条件运算符 ? :，可以用来替代 if…else 语句。它的一般形式如下：</description></item><item><title>十三、Docker 命名容器</title><link>https://www.shellio.cc/docs/cloud-native/docker/13/</link><pubDate>Thu, 06 Oct 2022 22:42:23 +0800</pubDate><guid>https://www.shellio.cc/docs/cloud-native/docker/13/</guid><description>Docker 是一个开源的应用容器引擎，基于 Go 语言 并遵从 Apache2.0 协议开源
Docker 可以让开发者打包它们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化
Docker 使用完全使用沙箱机制，两个容器之间不会有任何接口 (这个有点像 iPhone 的 app ) ,更重要的是容器性能开销极低
学习前提 在继续阅读之前，我们希望你对 Linux 有一些基本的了解，包括
1、 会使用Linux常用的命令；
2、 知道大部分的Linux常识，比如终端、service、ip、用户、组等；
3、 熟练使用Ubuntu或者Centos或者MacOS种的一种昂；
如果你对这些知识还是一知半解，可以访问我们的 Linux 基础教程 先进行一些简单的了解
Docker的应用场景 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 1、 Web应用的自动化打包和发布；
2、 自动化测试和持续集成、发布；
3、 在服务型环境中部署和调整数据库或其他的后台应用；
4、 从头编译或者扩展现有的OpenShift或CloudFoundry平台来搭建自己的PaaS环境；
Docker 的优点 1、 简化程序；
1Docker 让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的 Linux 机器上，便可以实现虚拟化 2Docker 改变了虚拟化的方式，使开发者可以直接将自己的成果放入 Docker 中进行管理 3方便快捷已经是 Docker 的最大优势，过去需要用数天乃至数周的 任务，在Docker容器的处理下，只需要数秒就能完成 2、 解决运维配置噩梦；
1在没有 Docker 之前，每一台机器，每一个要用到的依赖，几乎都要重新配置一遍 2比如新增一台 MySQL 数据库，就要从头开始配置所有环境 3有了 Docker 之后，只需要从仓库里把之前的 MySQL 镜像拉出来，直接使用 3、 节省开支；</description></item><item><title>C++ 函数</title><link>https://www.shellio.cc/docs/programing/c++/default/14/</link><pubDate>Thu, 06 Oct 2022 22:42:23 +0800</pubDate><guid>https://www.shellio.cc/docs/programing/c++/default/14/</guid><description>C++ 函数 函数是一组一起执行一个任务的语句。每个 C++ 程序都至少有一个函数，即主函数 main() ，所有简单的程序都可以定义其他额外的函数。
您可以把代码划分到不同的函数中。如何划分代码到不同的函数中是由您来决定的，但在逻辑上，划分通常是根据每个函数执行一个特定的任务来进行的。
函数声明告诉编译器函数的名称、返回类型和参数。函数定义提供了函数的实际主体。
C++标准库提供了大量的程序可以调用的内置函数。例如，函数 strcat() 用来连接两个字符串，函数 memcpy() 用来复制内存到另一个位置。
函数还有很多叫法，比如方法、子例程或程序，等等。
定义函数 C++中的函数定义的一般形式如下：
1return_type function_name( parameter list ) 2 body of the function 在C++ 中，函数由一个函数头和一个函数主体组成。下面列出一个函数的所有组成部分：
**返回类型：**一个函数可以返回一个值。return_type 是函数返回的值的数据类型。有些函数执行所需的操作而不返回值，在这种情况下，return_type 是关键字 void。 **函数名称：**这是函数的实际名称。函数名和参数列表一起构成了函数签名。 **参数：**参数就像是占位符。当函数被调用时，您向参数传递一个值，这个值被称为实际参数。参数列表包括函数参数的类型、顺序、数量。参数是可选的，也就是说，函数可能不包含参数。 **函数主体：**函数主体包含一组定义函数执行任务的语句。 实例 以下是max() 函数的源代码。该函数有两个参数 num1 和 num2，会返回这两个数中较大的那个数：
1// 函数返回两个数中较大的那个数 2int max(int num1, int num2) 3 // 局部变量声明 4 int result; 5 if (num1 &amp;gt; num2) 6 result = num1; 7 else 8 result = num2; 9 return result; 函数声明 函数声明会告诉编译器函数名称及如何调用函数。函数的实际主体可以单独定义。</description></item><item><title>十四、Docker 容器运行 Web 应用</title><link>https://www.shellio.cc/docs/cloud-native/docker/14/</link><pubDate>Thu, 06 Oct 2022 22:42:23 +0800</pubDate><guid>https://www.shellio.cc/docs/cloud-native/docker/14/</guid><description>Docker 是一个开源的应用容器引擎，基于 Go 语言 并遵从 Apache2.0 协议开源
Docker 可以让开发者打包它们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化
Docker 使用完全使用沙箱机制，两个容器之间不会有任何接口 (这个有点像 iPhone 的 app ) ,更重要的是容器性能开销极低
学习前提 在继续阅读之前，我们希望你对 Linux 有一些基本的了解，包括
1、 会使用Linux常用的命令；
2、 知道大部分的Linux常识，比如终端、service、ip、用户、组等；
3、 熟练使用Ubuntu或者Centos或者MacOS种的一种昂；
如果你对这些知识还是一知半解，可以访问我们的 Linux 基础教程 先进行一些简单的了解
Docker的应用场景 1、 Web应用的自动化打包和发布；
2、 自动化测试和持续集成、发布；
3、 在服务型环境中部署和调整数据库或其他的后台应用；
4、 从头编译或者扩展现有的OpenShift或CloudFoundry平台来搭建自己的PaaS环境；
Docker 的优点 1、 简化程序；
1Docker 让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的 Linux 机器上，便可以实现虚拟化 2Docker 改变了虚拟化的方式，使开发者可以直接将自己的成果放入 Docker 中进行管理 3方便快捷已经是 Docker 的最大优势，过去需要用数天乃至数周的 任务，在Docker容器的处理下，只需要数秒就能完成 2、 解决运维配置噩梦；
1在没有 Docker 之前，每一台机器，每一个要用到的依赖，几乎都要重新配置一遍 2比如新增一台 MySQL 数据库，就要从头开始配置所有环境 3有了 Docker 之后，只需要从仓库里把之前的 MySQL 镜像拉出来，直接使用 3、 节省开支；</description></item><item><title>C++ 数字</title><link>https://www.shellio.cc/docs/programing/c++/default/15/</link><pubDate>Thu, 06 Oct 2022 22:42:23 +0800</pubDate><guid>https://www.shellio.cc/docs/programing/c++/default/15/</guid><description>C++ 数字 通常，当我们需要用到数字时，我们会使用原始的数据类型，如 int、short、long、float 和 double 等等。这些用于数字的数据类型，其可能的值和数值范围，我们已经在 C++ 数据类型一章中讨论过。
C++ 定义数字 我们已经在之前章节的各种实例中定义过数字。下面是一个 C++ 中定义各种类型数字的综合实例：
1#include &amp;lt;iostream&amp;gt; 2using namespace std; 3int main () 4 // 数字定义 5 short s; 6 int i; 7 long l; 8 float f; 9 double d; 10 // 数字赋值 11 s = 10; 12 i = 1000; 13 l = 1000000; 14 f = 230.47; 15 d = 30949.374; 16 // 数字输出 17 cout &amp;lt;&amp;lt; &amp;#34;short s :&amp;#34; &amp;lt;&amp;lt; s &amp;lt;&amp;lt; endl; 18 cout &amp;lt;&amp;lt; &amp;#34;int i :&amp;#34; &amp;lt;&amp;lt; i &amp;lt;&amp;lt; endl; 19 cout &amp;lt;&amp;lt; &amp;#34;long l :&amp;#34; &amp;lt;&amp;lt; l &amp;lt;&amp;lt; endl; 20 cout &amp;lt;&amp;lt; &amp;#34;float f :&amp;#34; &amp;lt;&amp;lt; f &amp;lt;&amp;lt; endl; 21 cout &amp;lt;&amp;lt; &amp;#34;double d :&amp;#34; &amp;lt;&amp;lt; d &amp;lt;&amp;lt; endl; 22 return 0; 当上面的代码被编译和执行时，它会产生下列结果：</description></item><item><title>十五、Docker 端口映射</title><link>https://www.shellio.cc/docs/cloud-native/docker/15/</link><pubDate>Thu, 06 Oct 2022 22:42:23 +0800</pubDate><guid>https://www.shellio.cc/docs/cloud-native/docker/15/</guid><description>Docker 是一个开源的应用容器引擎，基于 Go 语言 并遵从 Apache2.0 协议开源
Docker 可以让开发者打包它们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化
Docker 使用完全使用沙箱机制，两个容器之间不会有任何接口 (这个有点像 iPhone 的 app ) ,更重要的是容器性能开销极低
学习前提 在继续阅读之前，我们希望你对 Linux 有一些基本的了解，包括
1、 会使用Linux常用的命令；
2、 知道大部分的Linux常识，比如终端、service、ip、用户、组等；
3、 熟练使用Ubuntu或者Centos或者MacOS种的一种昂；
如果你对这些知识还是一知半解，可以访问我们的 Linux 基础教程 先进行一些简单的了解
Docker的应用场景 1、 Web应用的自动化打包和发布；
2、 自动化测试和持续集成、发布；
3、 在服务型环境中部署和调整数据库或其他的后台应用；
4、 从头编译或者扩展现有的OpenShift或CloudFoundry平台来搭建自己的PaaS环境；
Docker 的优点 1、 简化程序；
1Docker 让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的 Linux 机器上，便可以实现虚拟化 2Docker 改变了虚拟化的方式，使开发者可以直接将自己的成果放入 Docker 中进行管理 3方便快捷已经是 Docker 的最大优势，过去需要用数天乃至数周的 任务，在Docker容器的处理下，只需要数秒就能完成 2、 解决运维配置噩梦；
1在没有 Docker 之前，每一台机器，每一个要用到的依赖，几乎都要重新配置一遍 2比如新增一台 MySQL 数据库，就要从头开始配置所有环境 3有了 Docker 之后，只需要从仓库里把之前的 MySQL 镜像拉出来，直接使用 3、 节省开支；</description></item><item><title>C++ 运算符</title><link>https://www.shellio.cc/docs/programing/c++/default/11/</link><pubDate>Thu, 06 Oct 2022 22:42:23 +0800</pubDate><guid>https://www.shellio.cc/docs/programing/c++/default/11/</guid><description>C++ 运算符 运算符是一种告诉编译器执行特定的数学或逻辑操作的符号。C++ 内置了丰富的运算符，并提供了以下类型的运算符：
算术运算符 关系运算符 逻辑运算符 位运算符 赋值运算符 杂项运算符 本章将逐一介绍算术运算符、关系运算符、逻辑运算符、位运算符、赋值运算符和其他运算符。
算术运算符 下表显示了 C++ 支持的所有算术运算符。
假设变量 A 的值为 10，变量 B 的值为 20，则：
运算符 描述 实例 + 把两个操作数相加 A + B 将得到 30 – 从第一个操作数中减去第二个操作数 A – B 将得到 -10 * 把两个操作数相乘 A * B 将得到 200 / 分子除以分母 B / A 将得到 2 % 取模运算符，整除后的余数 B % A 将得到 0 ++ 自增运算符，整数值增加 1 A++ 将得到 11 — 自减运算符，整数值减少 1 A– 将得到 9 实例 请看下面的实例，了解 C++ 中所有可用的算术运算符。</description></item><item><title>十一、Docker restart 重启容器</title><link>https://www.shellio.cc/docs/cloud-native/docker/11/</link><pubDate>Thu, 06 Oct 2022 22:42:23 +0800</pubDate><guid>https://www.shellio.cc/docs/cloud-native/docker/11/</guid><description>Docker 是一个开源的应用容器引擎，基于 Go 语言 并遵从 Apache2.0 协议开源
Docker 可以让开发者打包它们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化
Docker 使用完全使用沙箱机制，两个容器之间不会有任何接口 (这个有点像 iPhone 的 app ) ,更重要的是容器性能开销极低
学习前提 在继续阅读之前，我们希望你对 Linux 有一些基本的了解，包括
1、 会使用Linux常用的命令；
2、 知道大部分的Linux常识，比如终端、service、ip、用户、组等；
3、 熟练使用Ubuntu或者Centos或者MacOS种的一种昂；
如果你对这些知识还是一知半解，可以访问我们的 Linux 基础教程 先进行一些简单的了解
Docker的应用场景 1、 Web应用的自动化打包和发布；
2、 自动化测试和持续集成、发布；
3、 在服务型环境中部署和调整数据库或其他的后台应用；
4、 从头编译或者扩展现有的OpenShift或CloudFoundry平台来搭建自己的PaaS环境；
Docker 的优点 1、 简化程序；
因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 1Docker 让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的 Linux 机器上，便可以实现虚拟化 2Docker 改变了虚拟化的方式，使开发者可以直接将自己的成果放入 Docker 中进行管理 3方便快捷已经是 Docker 的最大优势，过去需要用数天乃至数周的 任务，在Docker容器的处理下，只需要数秒就能完成 2、 解决运维配置噩梦；
1在没有 Docker 之前，每一台机器，每一个要用到的依赖，几乎都要重新配置一遍 2比如新增一台 MySQL 数据库，就要从头开始配置所有环境 3有了 Docker 之后，只需要从仓库里把之前的 MySQL 镜像拉出来，直接使用 3、 节省开支；</description></item><item><title>C++ 注释</title><link>https://www.shellio.cc/docs/programing/c++/default/4/</link><pubDate>Thu, 06 Oct 2022 22:42:23 +0800</pubDate><guid>https://www.shellio.cc/docs/programing/c++/default/4/</guid><description>C++ 注释 程序的注释是解释性语句，您可以在 C++ 代码中包含注释，这将提高源代码的可读性。所有的编程语言都允许某种形式的注释。
C++支持单行注释和多行注释。注释中的所有字符会被 C++ 编译器忽略。
C++注释以 /* 开始，以 */ 终止。例如：
1/* 这是注释 */ 2/* C++ 注释也可以 3 * 跨行 4 */ 注释也能以 // 开始，直到行末为止。例如：
因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 1#include 2using namespace std; 3main() 4 cout &amp;lt;&amp;lt; &amp;#34;Hello World&amp;#34;; // 输出 Hello World return 0; 5} 当上面的代码被编译时，编译器会忽略 // prints Hello World，最后会产生以下结果：
1Hello World 在/* 和 */ 注释内部，// 字符没有特殊的含义。在 // 注释内，/* 和 */ 字符也没有特殊的含义。因此，您可以在一种注释内嵌套另一种注释。例如：
1/* 用于输出 Hello World 的注释 2cout &amp;lt;&amp;lt; &amp;#34;Hello World&amp;#34;; // 输出 Hello World */</description></item><item><title>四、CentOS Docker 安装</title><link>https://www.shellio.cc/docs/cloud-native/docker/4/</link><pubDate>Thu, 06 Oct 2022 22:42:23 +0800</pubDate><guid>https://www.shellio.cc/docs/cloud-native/docker/4/</guid><description>Docker 是一个开源的应用容器引擎，基于 Go 语言 并遵从 Apache2.0 协议开源
Docker 可以让开发者打包它们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化
Docker 使用完全使用沙箱机制，两个容器之间不会有任何接口 (这个有点像 iPhone 的 app ) ,更重要的是容器性能开销极低
学习前提 在继续阅读之前，我们希望你对 Linux 有一些基本的了解，包括
1、 会使用 Linux 常用的命令；
2、 知道大部分的 Linux 常识，比如终端、service、ip、用户、组等；
3、 熟练使用 Ubuntu 或者 Centos 或者 MacOS 种的一种昂；
如果你对这些知识还是一知半解，可以访问我们的 Linux 基础教程 先进行一些简单的了解
Docker 的应用场景 1、 Web 应用的自动化打包和发布；
2、 自动化测试和持续集成、发布；
3、 在服务型环境中部署和调整数据库或其他的后台应用；
4、 从头编译或者扩展现有的 OpenShift 或 CloudFoundry 平台来搭建自己的 PaaS 环境；
Docker 的优点 1、 简化程序；
1Docker 让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的 Linux 机器上，便可以实现虚拟化 2Docker 改变了虚拟化的方式，使开发者可以直接将自己的成果放入 Docker 中进行管理 3方便快捷已经是 Docker 的最大优势，过去需要用数天乃至数周的 任务，在Docker容器的处理下，只需要数秒就能完成 2、 解决运维配置噩梦；</description></item><item><title>C++ 标准库</title><link>https://www.shellio.cc/docs/programing/c++/default/40/</link><pubDate>Thu, 06 Oct 2022 22:42:23 +0800</pubDate><guid>https://www.shellio.cc/docs/programing/c++/default/40/</guid><description>C++ 标准库 C++标准库可以分为两部分：
标准函数库： 这个库是由通用的、独立的、不属于任何类的函数组成的。函数库继承自 C 语言。 面向对象类库： 这个库是类及其相关函数的集合。 C++标准库包含了所有的 C 标准库，为了支持类型安全，做了一定的添加和修改。
标准函数库 标准函数库分为以下几类：
输入/输出 I/O 字符串和字符处理 数学 时间、日期和本地化 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 动态分配 其他 宽字符函数 面向对象类库 标准的C++ 面向对象类库定义了大量支持一些常见操作的类，比如输入/输出 I/O、字符串处理、数值处理。面向对象类库包含以下内容：
标准的 C++ I/O 类 String 类 数值类 STL 容器类 STL 算法 STL 函数对象 STL 迭代器 STL 分配器 本地化库 异常处理类 杂项支持库</description></item><item><title>C++ 简介</title><link>https://www.shellio.cc/docs/programing/c++/default/42/</link><pubDate>Thu, 06 Oct 2022 22:42:23 +0800</pubDate><guid>https://www.shellio.cc/docs/programing/c++/default/42/</guid><description>在面试C++方面的工作时，经常会遇到各种面试题，这对应聘人员的知识掌握能力要求较高。本文将为大家带来的就是20道必须掌握的C++面试题，不要错过哦！
想要快速轻松掌握C++知识，请点击C++微课边学习边实践
问1：请用简单的语言告诉我C++ 是什么？
答：C++是在C语言的基础上开发的一种面向对象编程语言，应用广泛。C++支持多种编程范式 －－面向对象编程、泛型编程和过程化编程。 其编程领域众广，常用于系统开发，引擎开发等应用领域，是最受广大程序员受用的最强大编程语言之一,支持类：类、封装、重载等特性!
问2：C和C++的区别？
答：c++在c的基础上增添类，C是一个结构化语言，它的重点在于算法和数据结构。C程序的设计首要考虑的是如何通过一个过程，对输入（或环境条件）进行运算处理得到输出（或实现过程（事务）控制），而对于C++，首要考虑的是如何构造一个对象模型，让这个模型能够契合与之对应的问题域，这样就可以通过获取对象的状态信息得到输出或实现过程（事务）控制。
问3：什么是面向对象（OOP）？
答：面向对象是一种对现实世界理解和抽象的方法、思想，通过将需求要素转化为对象进行问题处理的一种思想。
问4：什么是多态？
答：多态是指相同的操作或函数、过程可作用于多种类型的对象上并获得不同的结果。不同的对象，收到同一消息可以产生不同的结果，这种现象称为多态。
问5：设计模式懂嘛，简单举个例子？
答：
设计模式（Design pattern）是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。
比如单例模式，保证一个类仅有一个实例，并提供一个访问它的全局访问点。
适用于：当类只能有一个实例而且客户可以从一个众所周知的访问点访问它时；当这个唯一实例应该是通过子类化可扩展的，并且客户应该无需更改代码就能使用一个扩展的实例时。
比如工厂模式，定义一个用于创建对象的接口，让子类决定实例化哪一个类。Factory Method 使一个类的实例化延迟到其子类。
适用于：当一个类不知道它所必须创建的对象的类的时候；当一个类希望由它的子类来指定它所创建的对象的时候；当类将创建对象的职责委托给多个帮助子类中的某一个，并且你希望将哪一个帮助子类是代理者这一信息局部化的时候。
问6：STL库用过吗？常见的STL容器有哪些？算法用过哪几个？
答：
STL包括两部分内容：容器和算法。（重要的还有融合这二者的迭代器）
容器，即存放数据的地方。比如array等。
在STL中，容器分为两类：序列式容器和关联式容器。
序列式容器，其中的元素不一定有序，但都可以被排序。如：vector、list、deque、stack、queue、heap、priority_queue、slist；
关联式容器，内部结构基本上是一颗平衡二叉树。所谓关联，指每个元素都有一个键值和一个实值，元素按照一定的规则存放。如：RB-tree、set、map、multiset、multimap、hashtable、hash_set、hash_map、hash_multiset、hash_multimap。
下面各选取一个作为说明。
vector：它是一个动态分配存储空间的容器。区别于c++中的array，array分配的空间是静态的，分配之后不能被改变，而vector会自动重分配（扩展）空间。
set：其内部元素会根据元素的键值自动被排序。区别于map，它的键值就是实值，而map可以同时拥有不同的键值和实值。
算法，如排序，复制……以及个容器特定的算法。这点不用过多介绍，主要看下面迭代器的内容。
迭代器是STL的精髓，我们这样描述它：迭代器提供了一种方法，使它能够按照顺序访问某个容器所含的各个元素，但无需暴露该容器的内部结构。它将容器和算法分开，好让这二者独立设计。
问7：数据结构会吗？项目开发过程中主要用到那些？
答：数据结构中主要会用到数组，链表，树（较少），也会用到栈和队列的思想。
问8：const知道吗？解释其作用。
答：
1、 const修饰类的成员变量，表示成员常量，不能被修改；
2、 const修饰函数承诺在本函数内部不会修改类内的数据成员，不会调用其它非const成员函数；
3、 如果const构成函数重载，const对象只能调用const函数，非const对象优先调用非const函数；
4、 const函数只能调用const函数非const函数可以调用const函数；
5、 类体外定义的const成员函数，在定义和声明处都需要const修饰符；
问9：类的static变量在什么时候初始化？函数的static变量在什么时候初始化？
答：类的静态成员变量在类实例化之前就已经存在了，并且分配了内存。函数的static变量在执行此函数时进行初始化。
问10：堆和栈的区别？堆和栈的生命周期？
答：
一、堆栈空间分配区别：
1、 栈（操作系统）：由操作系统自动分配释放，存放函数的参数值，局部变量的值等其操作方式类似于数据结构中的栈；
2、 堆（操作系统）：一般由程序员分配释放，若程序员不释放，程序结束时可能由OS回收，分配方式倒是类似于链表；
二、堆栈缓存方式区别：
1、 栈使用的是一级缓存，他们通常都是被调用时处于存储空间中，调用完毕立即释放；
2、 堆是存放在二级缓存中，生命周期由虚拟机的垃圾回收算法来决定（并不是一旦成为孤儿对象就能被回收）所以调用这些对象的速度要相对来得低一些；
三、堆栈数据结构区别：
堆（数据结构）：堆可以被看成是一棵树，如：堆排序；
栈（数据结构）：一种先进后出的数据结构。
问11：C和C++的区别？
答：
C++在C的基础上增添类
C是一个结构化语言，它的重点在于算法和数据结构。</description></item><item><title>C++ 简介</title><link>https://www.shellio.cc/docs/programing/c++/default/43/</link><pubDate>Thu, 06 Oct 2022 22:42:23 +0800</pubDate><guid>https://www.shellio.cc/docs/programing/c++/default/43/</guid><description>map是C++中的一个标准容器，她提供了很好一对一的关系，在一些程序中建立一个map可以起到事半功倍的效果，本文为大家总结了map的一些基本简单的操作！
1、map最基本的构造函数；
map mapstring; map mapint;
map&amp;lt;sring, char&amp;gt;mapstring; map&amp;lt; char ,string&amp;gt;mapchar;
map mapchar; map mapint；
2、map添加数据；
1 map&amp;lt;int ,string&amp;gt; maplive; 2 1.maplive.insert(pair&amp;lt;int,string&amp;gt;(102,&amp;#34;aclive&amp;#34;)); 3 2.maplive.insert(map&amp;lt;int,string&amp;gt;::value_type(321,&amp;#34;hai&amp;#34;)); 4 3, maplive[112]=&amp;#34;April&amp;#34;;//map中最简单最常用的插入添加！ 3、map中元素的查找：
find()函数返回一个迭代器指向键值为key的元素，如果没找到就返回指向map尾部的迭代器。
1 map&amp;lt;int ,string &amp;gt;::iterator l_it;; 2 l_it=maplive.find(112); 3 if(l_it==maplive.end()) 4 cout&amp;lt;&amp;lt;&amp;#34;we do not find 112&amp;#34;&amp;lt;&amp;lt;endl; 5 else cout&amp;lt;&amp;lt;&amp;#34;wo find 112&amp;#34;&amp;lt;&amp;lt;endl; 4、map中元素的删除：
如果删除112；
1 map&amp;lt;int ,string &amp;gt;::iterator l_it;; 2 l_it=maplive.find(112); 3 if(l_it==maplive.end()) 4 cout&amp;lt;&amp;lt;&amp;#34;we do not find 112&amp;#34;&amp;lt;&amp;lt;endl; 5 else maplive.erase(l_it); //delete 112; 5、map中 swap的用法：</description></item><item><title>C++ 简介</title><link>https://www.shellio.cc/docs/programing/c++/default/44/</link><pubDate>Thu, 06 Oct 2022 22:42:23 +0800</pubDate><guid>https://www.shellio.cc/docs/programing/c++/default/44/</guid><description>在c++中，vector是一个十分有用的容器。它能够像容器一样存放各种类型的对象，简单地说，vector是一个能够存放任意类型的动态数组，能够增加和压缩数据。
使用vector注意事项：
1、 如果你要表示的向量长度较长（需要为向量内部保存很多数），容易导致内存泄漏，而且效率会很低；
2、 Vector作为函数的参数或者返回值时，需要注意它的写法：；
1double Distance(vector&amp;lt;int&amp;gt;&amp;amp;a, vector&amp;lt;int&amp;gt;&amp;amp;b) 其中的“&amp;amp;”绝对不能少！！！
实例：
vector test;//建立一个vector，int为数组元素的数据类型，test为动态数组名
简单的使用方法如下：
1vector&amp;lt;int&amp;gt;test;//建立一个vector 2test.push_back(1); 3test.push_back(2);//把1和2压入vector，这样test[0]就是1,test[1]就是2 自己见到的实例：
1vector&amp;lt;vector&amp;lt;Point2f&amp;gt; &amp;gt; points; //定义一个二维数组 2points[0].size(); //指第一行的列数 1、基本操作
(1)头文件#include .
(2)创建vector对象，vector vec;
(3)尾部插入数字：vec.push_back(a);
(4)使用下标访问元素，cout&amp;laquo;vec[0]&amp;laquo;endl;记住下标是从0开始的。
(5)使用迭代器访问元素.
1vector&amp;lt;int&amp;gt;::iterator it; 2for(it=vec.begin();it!=vec.end();it++) 3 cout&amp;lt;&amp;lt;*it&amp;lt;&amp;lt;endl; (6)插入元素：vec.insert(vec.begin()+i,a);在第i+1个元素前面插入a;
(7)删除元素：vec.erase(vec.begin()+2);删除第3个元素
vec.erase(vec.begin()+i,vec.end()+j);删除区间[i,j-1];区间从0开始
(8)向量大小:vec.size();
(9)清空:vec.clear();
特别提示：这里有begin()与end()函数、front()与back()的差别
2、重要说明
vector的元素不仅仅可以是int,double,string,还可以是结构体，但是要注意：结构体要定义为全局的，否则会出错。
1#include&amp;lt;stdio.h&amp;gt; 2#include&amp;lt;algorithm&amp;gt; 3#include&amp;lt;vector&amp;gt; 4#include&amp;lt;iostream&amp;gt; 5using namespace std; 6typedef struct rect 7{ 8 int id; 9 int length; 10 int width; 11　//对于向量元素是结构体的，可在结构体内部定义比较函数，下面按照id,length,width升序排序。 12　bool operator&amp;lt; (const rect &amp;amp;a) const 13 { 14 if(id!</description></item><item><title>C++ 简介</title><link>https://www.shellio.cc/docs/programing/c++/default/45/</link><pubDate>Thu, 06 Oct 2022 22:42:23 +0800</pubDate><guid>https://www.shellio.cc/docs/programing/c++/default/45/</guid><description>本文将为大家带来的是几款简单实用的C++编译器（非IDE），希望大家喜欢。
GCC（GNU Compiler Collection）
官方网站: https://gcc.gnu.org/ GCC有Windows移植版本，比较出名的就是MinGW和TDM-GCC
GNU编译器套件（GNU Compiler Collection）包括C、C++、Objective-C、Fortran、Java、Ada和Go语言的前端，也包括了这些语言的库（如libstdc++、libgcj等等）。GCC的初衷是为GNU操作系统专门编写的一款编译器。GNU系统是彻底的自由软件。此处，“自由”的含义是它尊重用户的自由。
llvm+Clang
LLVM官方网站：http://llvm.org/
Clang官方网站：http://clang.llvm.org/get_started.html
LLVM是构架编译器(compiler)的框架系统，以C++编写而成，用于优化以任意程序语言编写的程序的编译时间(compile-time)、链接时间(link-time)、运行时间(run-time)以及空闲时间(idle-time)，对开发者保持开放，并兼容已有脚本。LLVM计划启动于2000年，最初由University of Illinois at Urbana-Champaign的Chris Lattner主持开展。2006年Chris Lattner加盟Apple Inc.并致力于LLVM在Apple开发体系中的应用。Apple也是LLVM计划的主要资助者.
LowLevel Virtual Machine (LLVM) 是一个开源的编译器架构，它已经被成功应用到多个应用领域。Clang ( 发音为 /kl??/) 是 LLVM 的一个编译器前端，它目前支持 C, C++, Objective-C 以及 Objective-C++ 等编程语言。Clang 对源程序进行词法分析和语义分析，并将分析结果转换为 Abstract Syntax Tree ( 抽象语法树 ) ，最后使用 LLVM 作为后端代码的生成器。
Clang 的开发目标是提供一个可以替代 GCC 的前端编译器。与 GCC 相比，Clang 是一个重新设计的编译器前端，具有一系列优点，例如模块化，代码简单易懂，占用内存小以及容易扩展和重用等。由于 Clang 在设计上的优异性，使得 Clang 非常适合用于设计源代码级别的分析和转化工具。Clang 也已经被应用到一些重要的开发领域，如 Static Analysis 是一个基于 Clang 的静态代码分析工具。
Watcom C/C++
官方网站：http://www.openwatcom.org/index.php/Download
在DOS开发环境中，Watcom C/C++ 编译器 以编译后的exe运行高速而著称，且首个支持Intel 80386 “保护模式”的编译器。于90年代中期，大批的雄心技术游戏(例如 Doom、Descent、Duke Nukem 3D 都以 Watcom C 写成）</description></item><item><title>C++ 有用的资源</title><link>https://www.shellio.cc/docs/programing/c++/default/41/</link><pubDate>Thu, 06 Oct 2022 22:42:23 +0800</pubDate><guid>https://www.shellio.cc/docs/programing/c++/default/41/</guid><description>C++ 有用的资源 以下资源包含了 C++ 有关的网站、书籍和文章。请使用它们来进一步学习 C++ 的知识。
C++ 有用的网站 C++ Programming Language Tutorials − C++ 编程语言教程。 C++ Programming − 这本书涵盖了 C++ 语言编程、软件交互设计、C++ 语言的现实生活应用。 C++ FAQ − C++ 常见问题 Free Country − Free Country 提供了免费的 C++ 源代码和 C++ 库，这些源代码和库涵盖了压缩、存档、游戏编程、标准模板库和 GUI 编程等 C++ 编程领域。 C and C++ Users Group − C 和 C++ 的用户团体提供了免费的涵盖各种编程领域 C++ 项目的源代码，包括 AI、动画、编译器、数据库、调试、加密、游戏、图形、GUI、语言工具、系统编程等。 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 C++ 有用的书籍</description></item><item><title>C++ 数据类型</title><link>https://www.shellio.cc/docs/programing/c++/default/5/</link><pubDate>Thu, 06 Oct 2022 22:42:23 +0800</pubDate><guid>https://www.shellio.cc/docs/programing/c++/default/5/</guid><description>C++ 数据类型 使用编程语言进行编程时，需要用到各种变量来存储各种信息。变量保留的是它所存储的值的内存位置。这意味着，当您创建一个变量时，就会在内存中保留一些空间。
您可能需要存储各种数据类型（比如字符型、宽字符型、整型、浮点型、双浮点型、布尔型等）的信息，操作系统会根据变量的数据类型，来分配内存和决定在保留内存中存储什么。
基本的内置类型 C++为程序员提供了种类丰富的内置数据类型和用户自定义的数据类型。下表列出了七种基本的 C++ 数据类型：
类型 关键字 布尔型 bool 字符型 char 整型 int 浮点型 float 双浮点型 double 无类型 void 宽字符型 wchar_t 一些基本类型可以使用一个或多个类型修饰符进行修饰：
signed unsigned short long 下表显示了各种变量类型在内存中存储值时需要占用的内存，以及该类型的变量所能存储的最大值和最小值。
**注意：**不同系统会有所差异。
类型 位 范围 char 1 个字节 -128 到 127 或者 0 到 255 unsigned char 1 个字节 0 到 255 signed char 1 个字节 -128 到 127 int 4 个字节 -2147483648 到 2147483647 unsigned int 4 个字节 0 到 4294967295 signed int 4 个字节 -2147483648 到 2147483647 short int 2 个字节 -32768 到 32767 unsigned short int 2 个字节 0 到 65,535 signed short int 2 个字节 -32768 到 32767 long int 8 个字节 -9,223,372,036,854,775,808 到 9,223,372,036,854,775,807 signed long int 8 个字节 -9,223,372,036,854,775,808 到 9,223,372,036,854,775,807 unsigned long int 8 个字节 0 to 18,446,744,073,709,551,615 float 4 个字节 +/- 3.</description></item><item><title>五、Windows 安装 Docker</title><link>https://www.shellio.cc/docs/cloud-native/docker/5/</link><pubDate>Thu, 06 Oct 2022 22:42:23 +0800</pubDate><guid>https://www.shellio.cc/docs/cloud-native/docker/5/</guid><description>Docker 是一个开源的应用容器引擎，基于 Go 语言 并遵从 Apache2.0 协议开源
Docker 可以让开发者打包它们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化
Docker 使用完全使用沙箱机制，两个容器之间不会有任何接口 (这个有点像 iPhone 的 app ) ,更重要的是容器性能开销极低
学习前提 在继续阅读之前，我们希望你对 Linux 有一些基本的了解，包括
1、 会使用Linux常用的命令；
2、 知道大部分的Linux常识，比如终端、service、ip、用户、组等；
3、 熟练使用Ubuntu或者Centos或者MacOS种的一种昂；
如果你对这些知识还是一知半解，可以访问我们的 Linux 基础教程 先进行一些简单的了解
Docker的应用场景 1、 Web应用的自动化打包和发布；
2、 自动化测试和持续集成、发布；
3、 在服务型环境中部署和调整数据库或其他的后台应用；
4、 从头编译或者扩展现有的OpenShift或CloudFoundry平台来搭建自己的PaaS环境；
Docker 的优点 1、 简化程序；
1Docker 让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的 Linux 机器上，便可以实现虚拟化 2Docker 改变了虚拟化的方式，使开发者可以直接将自己的成果放入 Docker 中进行管理 3方便快捷已经是 Docker 的最大优势，过去需要用数天乃至数周的 任务，在Docker容器的处理下，只需要数秒就能完成 2、 解决运维配置噩梦；
1在没有 Docker 之前，每一台机器，每一个要用到的依赖，几乎都要重新配置一遍 2比如新增一台 MySQL 数据库，就要从头开始配置所有环境 3有了 Docker 之后，只需要从仓库里把之前的 MySQL 镜像拉出来，直接使用 3、 节省开支；</description></item><item><title>C++ 简介</title><link>https://www.shellio.cc/docs/programing/c++/default/1/</link><pubDate>Thu, 06 Oct 2022 22:42:23 +0800</pubDate><guid>https://www.shellio.cc/docs/programing/c++/default/1/</guid><description>C++ 简介 C++是一种静态类型的、编译式的、通用的、大小写敏感的、不规则的编程语言，支持过程化编程、面向对象编程和泛型编程。
C++被认为是一种中级语言，它综合了高级语言和低级语言的特点。
C++是由 Bjarne Stroustrup 于 1979 年在新泽西州美利山贝尔实验室开始设计开发的。C++ 进一步扩充和完善了 C 语言，最初命名为带类的C，后来在 1983 年更名为 C++。
C++是 C 的一个超集，事实上，任何合法的 C 程序都是合法的 C++ 程序。
**注意：**使用静态类型的编程语言是在编译时执行类型检查，而不是在运行时执行类型检查。
面向对象程序设计 C++完全支持面向对象的程序设计，包括面向对象开发的四大特性：
封装 数据隐藏 继承 多态 标准库 标准的C++ 由三个重要部分组成：
核心语言，提供了所有构件块，包括变量、数据类型和常量，等等。 C++ 标准库，提供了大量的函数，用于操作文件、字符串等。 标准模板库（STL），提供了大量的方法，用于操作数据结构等。 ANSI 标准 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 ANSI 标准是为了确保 C++ 的便携性 —— 您所编写的代码在 Mac、UNIX、Windows、Alpha 计算机上都能通过编译。
由于ANSI 标准已稳定使用了很长的时间，所有主要的 C++ 编译器的制造商都支持 ANSI 标准。
学习 C++ 学习C++，关键是要理解概念，而不应过于深究语言的技术细节。
学习程序设计语言的目的是为了成为一个更好的程序员，也就是说，是为了能更有效率地设计和实现新系统，以及维护旧系统。
C++支持多种编程风格。您可以使用 Fortran、C、Smalltalk 等任意一种语言的编程风格来编写代码。每种风格都能有效地保证运行时间效率和空间效率。
C++ 的使用 基本上每个应用程序领域的程序员都有使用 C++。
C++通常用于编写设备驱动程序和其他要求实时性的直接操作硬件的软件。
C++广泛用于教学和研究。
任何一个使用苹果电脑或 Windows PC 机的用户都在间接地使用 C++，因为这些系统的主要用户接口是使用 C++ 编写的。</description></item><item><title>一、Docker 基础教程</title><link>https://www.shellio.cc/docs/cloud-native/docker/1/</link><pubDate>Thu, 06 Oct 2022 22:42:23 +0800</pubDate><guid>https://www.shellio.cc/docs/cloud-native/docker/1/</guid><description>Docker 是一个开源的应用容器引擎，基于 Go 语言 并遵从 Apache2.0 协议开源
Docker 可以让开发者打包它们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化
Docker 使用完全使用沙箱机制，两个容器之间不会有任何接口 (这个有点像 iPhone 的 app ) ,更重要的是容器性能开销极低
学习前提 在继续阅读之前，我们希望你对 Linux 有一些基本的了解，包括
因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 1、 会使用 Linux 常用的命令；
2、 知道大部分的 Linux 常识，比如终端、service、ip、用户、组等；
3、 熟练使用 Ubuntu 或者 Centos 或者 MacOS 种的一种昂；
如果你对这些知识还是一知半解，可以访问我们的 Linux 基础教程 先进行一些简单的了解
Docker 的应用场景 1、 Web 应用的自动化打包和发布；
2、 自动化测试和持续集成、发布；
3、 在服务型环境中部署和调整数据库或其他的后台应用；
4、 从头编译或者扩展现有的 OpenShift 或 CloudFoundry 平台来搭建自己的 PaaS 环境；
Docker 的优点 1、 简化程序；
1Docker 让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的 Linux 机器上，便可以实现虚拟化 2Docker 改变了虚拟化的方式，使开发者可以直接将自己的成果放入 Docker 中进行管理 3方便快捷已经是 Docker 的最大优势，过去需要用数天乃至数周的 任务，在Docker容器的处理下，只需要数秒就能完成 2、 解决运维配置噩梦；</description></item></channel></rss>