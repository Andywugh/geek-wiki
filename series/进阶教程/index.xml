<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>进阶教程 on 程序员安仔</title><link>https://www.hotmindshare.com/series/%E8%BF%9B%E9%98%B6%E6%95%99%E7%A8%8B/</link><description>Recent content in 进阶教程 on 程序员安仔</description><generator>Hugo -- gohugo.io</generator><language>zh-hans</language><copyright>粤ICP备2023148789号</copyright><lastBuildDate>Thu, 06 Oct 2022 22:42:23 +0800</lastBuildDate><atom:link href="https://www.hotmindshare.com/series/%E8%BF%9B%E9%98%B6%E6%95%99%E7%A8%8B/index.xml" rel="self" type="application/rss+xml"/><item><title>Java 中的异步计算</title><link>https://www.hotmindshare.com/docs/java/concurrency/default/8/</link><pubDate>Thu, 06 Oct 2022 22:42:23 +0800</pubDate><guid>https://www.hotmindshare.com/docs/java/concurrency/default/8/</guid><description>本文我们来了解下 Java 8 引入的 CompletableFuture 类，了解下该类提供的功能和用例。
Java 中的异步计算 异步计算很难推理的，因为我们的大脑是同步的，会将任何计算看成是一系列的同步计算。
我们在实现异步计算时，往往会把回调的动作分散在代码中或者深深地嵌套在彼此内部，这种情况下，当我们需要处理其中一个步骤中可能发生的错误时，情况变得更糟。
人生的一大悲剧是，尽管 Java 5 已经看到了这种恶性循环，提供了Future 接口作为异步计算的结果，但它没有提供任何方法来组合这些计算或处理可能的错误。
直到Java 8，才引入了 CompletableFuture 类。该类不仅实现了 Future 接口，还实现了 CompletionStage 接口。此接口定义了可与异步计算步骤组合的异步计算步骤契约。
官方文档真是拗口，简单来说，CompletionStage 接口规范了一个异步计算步骤如何与另一个异步计算步骤组合。
CompletableFuture 类还是一个集大成者，即是一个构建块，也是一个框架，提供了大约 50 种不同的方法来构造，组合，执行异步计算步骤和处理错误。
API数量如此之多，第一眼看到简直就傻眼了，不过好在它们可以分门别类，因为它们大多属于几个明确且不同的用例。
将 CompletableFuture 当作简单的 Future 使用 为什么可以 ？
因为CompletableFuture 类实现了 Future 接口，因此我们可以将其用作 Future 实现，但需要自己实现额外的完成逻辑。
例如，我们可以使用无任何参数的构造函数来创建此类的实例，用于表示未来的某些结果，然后将其交给使用者，并在将来的某个时间调用 complete() 方法完成。消费者可以使用 get() 方法来阻止当前线程，直到提供此结果。
1public Future&amp;lt;String&amp;gt; calculateAsync() throws InterruptedException { 2 CompletableFuture&amp;lt;String&amp;gt; completableFuture 3 = new CompletableFuture&amp;lt;&amp;gt;(); 4 Executors.newCachedThreadPool().submit(() -&amp;gt; { 5 Thread.sleep(500); 6 completableFuture.complete(&amp;#34;Hello&amp;#34;); 7 return null; 8 }); 9 return completableFuture; 上面的实例中，我们创建了一个创建 CompletableFuture 实例的方法，把计算分离到另一个线程中并立即返回 Future。当计算完成后，该方法通过将结果提供给 complete() 方法来完成 Future。</description></item><item><title>八、建造者模式 ( Builder Pattern )</title><link>https://www.hotmindshare.com/docs/code-design/8_miss/</link><pubDate>Thu, 06 Oct 2022 22:42:23 +0800</pubDate><guid>https://www.hotmindshare.com/docs/code-design/8_miss/</guid><description>建造者模式（Builder Pattern）使用多个简单的对象一步一步构建成一个复杂的对象
一个Builder 类会一步一步构造最终的对象，该 Builder 类是独立于其他对象的
建造者模式属于创建型模式，它提供了一种创建对象的最佳方式。
介绍 1、 意图：
将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示
2、 主要解决：
主要解决在软件系统中，有时候面临着”一个复杂对象”的创建工作，其通常由各个部分的子对象用一定的算法构成；由于需求的变化，这个复杂对象的各个部分经常面临着剧烈的变化，但是将它们组合在一起的算法却相对稳定
3、 何时使用：
一些基本部件不会变，而其组合经常变化的时候
4、 如何解决：
将变与不变分离开
5、 关键代码：
建造者：创建和提供实例
导演：管理建造出来的实例的依赖关系
6、 应用实例：
1、 去肯德基，汉堡、可乐、薯条、炸鸡翅等是不变的，而其组合是经常变化的，生成出所谓的”套餐”；
2、 JAVA中的StringBuilder；
7、 优点：
1、 建造者独立，易扩展；
2、 便于控制细节风险；
8、 缺点：
1、 产品必须有共同点，范围有限制；
2、 如内部变化复杂，会有很多的建造类；
9、 使用场景：
1、 需要生成的对象具有复杂的内部结构；
2、 需要生成的对象内部属性本身相互依赖；
10、 注意事项：
与工厂模式的区别是：建造者模式更加关注与零件装配的顺序
实现 我们以一家快餐店为例
一个典型的套餐可以是一个汉堡（Burger）和一杯冷饮（Cold drink）
汉堡（Burger）可以是素食汉堡（Veg Burger）或鸡肉汉堡（Chicken Burger），它们是包在纸盒中 冷饮（Cold drink）可以是可口可乐（coke）或百事可乐（pepsi），它们是装在瓶子中
创建一个表示食物条目（比如汉堡和冷饮）的 Item 接口和实现 Item 接口的实体类， 以及一个表示食物包装的 Packing 接口和实现 Packing 接口的实体类，汉堡是包在纸盒中，冷饮是装在瓶子中</description></item><item><title>ForkJoinPool 线程池</title><link>https://www.hotmindshare.com/docs/java/concurrency/default/2/</link><pubDate>Thu, 06 Oct 2022 22:42:23 +0800</pubDate><guid>https://www.hotmindshare.com/docs/java/concurrency/default/2/</guid><description>fork/join 框架是 Java 7 中引入的 ，它是一个工具，通过 「 分而治之 」 的方法尝试将所有可用的处理器内核使用起来帮助加速并行处理。
在实际使用过程中，这种 「 分而治之 」的方法意味着框架首先要 fork ，递归地将任务分解为较小的独立子任务，直到它们足够简单以便异步执行。然后，join 部分开始工作，将所有子任务的结果递归地连接成单个结果，或者在返回 void 的任务的情况下，程序只是等待每个子任务执行完毕。
为了提供有效的并行执行，fork/join 框架使用了一个名为 ForkJoinPool 的线程池，用于管理 ForkJoinWorkerThread 类型的工作线程。
ForkJoinPool 线程池 ForkJoinPool 是 fork/join 框架的核心，是 ExecutorService 的一个实现，用于管理工作线程，并提供了一些工具来帮助获取有关线程池状态和性能的信息。
工作线程一次只能执行一个任务。
ForkJoinPool 线程池并不会为每个子任务创建一个单独的线程，相反，池中的每个线程都有自己的双端队列用于存储任务 （ double-ended queue ）( 或 deque，发音 deck ）。
这种架构使用了一种名为工作窃取（ work-stealing ）算法来平衡线程的工作负载。
工作窃取（ work-stealing ）算法 要怎么解释 「 工作窃取算法 」 呢 ？
简单来说，就是 空闲的线程试图从繁忙线程的 deques 中 窃取 工作。
默认情况下，每个工作线程从其自己的双端队列中获取任务。但如果自己的双端队列中的任务已经执行完毕，双端队列为空时，工作线程就会从另一个忙线程的双端队列尾部或全局入口队列中获取任务，因为这是最大概率可能找到工作的地方。
这种方法最大限度地减少了线程竞争任务的可能性。它还减少了工作线程寻找任务的次数，因为它首先在最大可用的工作块上工作。
ForkJoinPool 线程池的实例化 Java 8 在Java 8 中，创建 ForkJoinPool 实例的最简单的方式就是使用其静态方法 commonPool()。</description></item><item><title>二、设计模式 – 简介</title><link>https://www.hotmindshare.com/docs/code-design/2/</link><pubDate>Thu, 06 Oct 2022 22:42:23 +0800</pubDate><guid>https://www.hotmindshare.com/docs/code-design/2/</guid><description>设计模式（Design pattern）是重构解决方案
这点很重要，尤其是现在 B/S 一统天下的局面，过早考虑设计模式，得不偿失
设计模式（Design pattern）代表了最佳的实践，通常被面向对象的软件开发人员所采用
很多教程都说设计模式是被有经验的人使用，其实只要定义了一个类，或多或少都在使用它们，而不是有没有经验 只是有经验的人知道自己在使用设计模式，而且知道怎么做的更好
设计模式是软件开发人员在软件开发过程中面临复杂度问题的一般问题的解决方案
这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的
设计模式是复杂度解决方案，不是小程序的解决方案(就一两个类文件，用设计模式那是增加复杂度)
设计模式是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结
使用设计模式是为了重用代码、让代码更容易被他人理解、保证代码可靠性
毫无疑问，设计模式于己于他人于系统都是多赢的，设计模式使代码编制真正工程化，设计模式是软件工程的基石，如同大厦的一块块砖石一样
项目中合理地运用设计模式可以完美地解决很多问题，每种模式在现实中都有相应的原理来与之对应，每种模式都描述了一个在我们周围不断重复发生的问题，以及该问题的核心解决方案，这也是设计模式能被广泛应用的原因
什么是 GOF（Gang of Four）？ 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 1994 年，Erich Gamma、Richard Helm、Ralph Johnson 和 John Vlissides 四人合著出版了一本名为 Design Patterns – Elements of Reusable Object-Oriented Software（中文译名：设计模式 – 可复用的面向对象软件元素） 的书
书名真的是误导人啊… 为啥不添加上重构两字
该书首次提到了软件开发中设计模式的概念
四位作者合称 GOF（四人帮，全拼 Gang of Four）
他们所提出的设计模式主要是基于以下的面向对象设计原则
1、 面向接口编程而不是对实现编程；
2、 优先使用对象组合而不是继承；
设计模式的使用 设计模式在软件开发中的两个主要用途
1、 开发人员的共同平台；
设计模式提供了一个标准的术语系统，且具体到特定的情景
例如，单例设计模式意味着使用单个对象，这样所有熟悉单例设计模式的开发人员都能使用单个对象，并且可以通过这种方式告诉对方，程序使用的是单例模式
2、 最佳的实践；
设计模式已经经历了很长一段时间的发展，它们提供了软件开发过程中面临的一般问题的最佳解决方案
学习这些模式有助于经验不足的开发人员通过一种简单快捷的方式来学习软件设计</description></item><item><title>二十、解释器模式 ( Interpreter Pattern )</title><link>https://www.hotmindshare.com/docs/code-design/20_miss/</link><pubDate>Thu, 06 Oct 2022 22:42:23 +0800</pubDate><guid>https://www.hotmindshare.com/docs/code-design/20_miss/</guid><description>解释器模式（Interpreter Pattern）实现了一个表达式接口，该接口解释一个特定的上下文
这种模式被用在 SQL 解析、符号处理引擎等
解释器模式提供了评估语言的语法或表达式的方式，它属于行为型模式
摘要 1、 意图：
给定一个语言，定义它的文法表示，并定义一个解释器，这个解释器使用该标识来解释语言中的句子
2、 主要解决：
对于一些固定文法构建一个解释句子的解释器
3、 何时使用：
如果一种特定类型的问题发生的频率足够高，那么可能就值得将该问题的各个实例表述为一个简单语言中的句子。这样就可以构建一个解释器，该解释器通过解释这些句子来解决该问题
4、 如何解决：
构件语法树，定义终结符与非终结符
5、 关键代码：
构件环境类，包含解释器之外的一些全局信息，一般是 HashMap
6、 应用实例：
编译器、运算表达式计算
7、 优点：
1、 可扩展性比较好，灵活；
2、 增加了新的解释表达式的方式；
3、 易于实现简单文法；
8、 缺点：
1、 可利用场景比较少；
2、 对于复杂的文法比较难维护；
3、 解释器模式会引起类膨胀；
4、 解释器模式采用递归调用方法；
9、 使用场景：
1、 可以将一个需要解释执行的语言中的句子表示为一个抽象语法树；
2、 一些重复出现的问题可以用一种简单的语言来进行表达；
3、 一个简单语法需要解释的场景；
10、 注意事项：
可利用场景比较少，JAVA 中如果碰到可以用 expression4J 代替
实现 1、 定义一个接口Expression和实现了Expression接口的实体类；
2、 定义作为上下文中主要解释器的TerminalExpression类，其他的类OrExpression、AndExpression用于创建组合式表达式；
3、 定义类InterpreterPatternDemo使用Expression类创建规则和演示表达式的解析；
范例 1. 创建一个表达式接口 Expression.java
1public interface Expression { 2 public boolean interpret(String context); 2.</description></item><item><title>二十八、模板模式 ( Template Pattern )</title><link>https://www.hotmindshare.com/docs/code-design/28_miss/</link><pubDate>Thu, 06 Oct 2022 22:42:23 +0800</pubDate><guid>https://www.hotmindshare.com/docs/code-design/28_miss/</guid><description>模板模式（Template Pattern）中，一个抽象类公开定义了执行它的方法的方式/模板。它的子类可以按需要重写方法实现，但调用将以抽象类中定义的方式进行
模板模式属于行为型模式
摘要 1、 意图：
1定义一个操作中的算法的骨架，而将一些步骤延迟到子类中 2模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤 2、 主要解决：
1一些方法通用，却在每一个子类都重新写了这一方法 3、 何时使用：
1有一些通用的方法 4、 如何解决：
1将这些通用算法抽象出来 5、 关键代码：
1在抽象类实现，其他步骤在子类实现 6、 应用实例：
11. 在造房子的时候，地基、走线、水管都一样，只有在建筑的后期才有加壁橱加栅栏等差异 22. 西游记里面菩萨定好的 81 难，这就是一个顶层的逻辑骨架 33. Spring 中对 Hibernate 的支持，将一些已经定好的方法封装起来，比如开启事务、获取 Session、关闭 Session 等，程序员不重复写那些已经规范好的代码，直接丢一个实体就可以保存 7、 优点：
11. 封装不变部分，扩展可变部分 22. 提取公共代码，便于维护 33. 行为由父类控制，子类实现 8、 缺点：
1每一个不同的实现都需要一个子类来实现，导致类的个数增加，使得系统更加庞大 9、 使用场景：
11. 有多个子类共有的方法，且逻辑相同 22. 重要的、复杂的方法，可以考虑作为模板方法 10、 注意事项：
1为防止恶意操作，一般模板方法都加上 final 关键词 实现 1、 创建一个定义操作的Game抽象类，其中，模板方法设置为final，这样它就不会被重写；
2、 定义类Cricket和Football扩展Game，重写了抽象类的方法；
3、 定义类TemplatePatternDemo使用Game来演示模板模式的用法；
范例 1. 创建一个抽象类，它的模板方法被设置为 final Game.java</description></item><item><title>二十二、中介者模式 ( Mediator Pattern )</title><link>https://www.hotmindshare.com/docs/code-design/22_miss/</link><pubDate>Thu, 06 Oct 2022 22:42:23 +0800</pubDate><guid>https://www.hotmindshare.com/docs/code-design/22_miss/</guid><description>中介者模式（Mediator Pattern）提供了一个中介类，该类通常处理不同类之间的通信，并支持松耦合，使代码易于维护
中介者模式是用来降低多个对象和类之间的通信复杂性
中介者模式属于行为型模式
介绍 1、 意图：
用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互
2、 主要解决：
对象与对象之间存在大量的关联关系，这样势必会导致系统的结构变得很复杂，同时若一个对象发生改变，我们也需要跟踪与之相关联的对象，同时做出相应的处理
3、 何时使用：
多个类相互耦合，形成了网状结构
4、 如何解决：
将上述网状结构分离为星型结构
5、 关键代码：
对象Colleague 之间的通信封装到一个类中单独处理
6、 应用实例：
1、 中国加入WTO之前是各个国家相互贸易，结构复杂，现在是各个国家通过WTO来互相贸易；
2、 机场调度系统；
3、 MVC框架，其中C（控制器）就是M（模型）和V（视图）的中介者；
7、 优点：
1、 降低了类的复杂度，将一对多转化成了一对一；
2、 各个类之间的解耦；
3、 符合迪米特原则；
8、 缺点：
中介者会庞大，变得复杂难以维护
9、 使用场景：
1、 系统中对象之间存在比较复杂的引用关系，导致它们之间的依赖关系结构混乱而且难以复用该对象；
2、 想通过一个中间类来封装多个类中的行为，而又不想生成太多的子类；
10、 注意事项：
不应当在职责混乱的时候使用
实现 我们通过聊天室实例来演示中介者模式：多个用户可以向聊天室发送消息，聊天室向所有的用户显示消息
1、 定义中介类ChatRoom；
2、 定义用户类User，User对象使用ChatRoom方法来分享他们的消息；
3、 定义MediatorPatternDemo类使用User对象来显示他们之间的通信；
范例 1. 创建中介类 ChatRoom.java
因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 1// author: DDKK.COM 弟弟快看，程序员编程资料站(ddkk.com) 2// Copyright © 2015-2065 ddkk.</description></item><item><title>二十九、访问者模式 ( Visitor Pattern )</title><link>https://www.hotmindshare.com/docs/code-design/29_miss/</link><pubDate>Thu, 06 Oct 2022 22:42:23 +0800</pubDate><guid>https://www.hotmindshare.com/docs/code-design/29_miss/</guid><description>访问者模式（Visitor Pattern）使用了一个访问者类，它改变了元素类的执行算法，通过这种方式，元素的执行算法可以随着访问者改变而改变
访问者模式中，元素对象已接受访问者对象，这样访问者对象就可以处理元素对象上的操作
访问者模式属于行为型模式
摘要 1、 意图：
主要将数据结构与数据操作分离
2、 主要解决：
稳定的数据结构和易变的操作耦合问题。
3、 何时使用：
需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而需要避免让这些操作”污染”这些对象的类，使用访问者模式将这些封装到类中
4、 如何解决：
在被访问的类里面加一个对外提供接待访问者的接口
5、 关键代码：
在数据基础类里面有一个方法接受访问者，将自身引用传入访问者
6、 应用实例：
您在朋友家做客，您是访问者，朋友接受您的访问，您通过朋友的描述，然后对朋友的描述做出一个判断，这就是访问者模式
7、 优点：
1、 符合单一职责原则；
2、 优秀的扩展性；
3、 灵活性；
8、 缺点：
1、 具体元素对访问者公布细节，违反了迪米特原则；
2、 具体元素变更比较困难；
3、 违反了依赖倒置原则，依赖了具体类，没有依赖抽象；
9、 使用场景：
1、 对象结构中对象对应的类很少改变，但经常需要在此对象结构上定义新的操作；
2、 需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而需要避免让这些操作“污染”这些对象的类，也不希望在增加新操作时修改这些类；
10、 注意事项：
访问者可以对功能进行统一，可以做报表、UI、拦截器与过滤器
实现 1、 创建一个定义接受操作的ComputerPart接口；
2、 定义类Keyboard、Mouse、Monitor和Computer实现ComputerPart接口；
3、 定义另一个接口ComputerPartVisitor，它定义了访问者类的操作；
4、 定义类Computer使用实体访问者来执行相应的动作；
5、 定义类VisitorPatternDemo使用Computer、ComputerPartVisitor类来演示访问者模式的用法；
范例 1. 定义一个表示元素的接口 ComputerPart.java
1// author: DDKK.COM 弟弟快看，程序员编程资料站(ddkk.com) 2// Copyright © 2015-2065 ddkk.</description></item><item><title>二十六、空对象模式 ( Null Object Pattern )</title><link>https://www.hotmindshare.com/docs/code-design/26_miss/</link><pubDate>Thu, 06 Oct 2022 22:42:23 +0800</pubDate><guid>https://www.hotmindshare.com/docs/code-design/26_miss/</guid><description>在空对象模式（Null Object Pattern）中，一个空对象取代 NULL 对象实例的检查
Null 对象不是检查空值，而是反应一个不做任何动作的关系，这样的 Null 对象也可以在数据不可用的时候提供默认的行为。
在空对象模式中，我们创建一个指定各种要执行的操作的抽象类和扩展该类的实体类，还创建一个未对该类做任何实现的空对象类，该空对象类将无缝地使用在需要检查空值的地方
实现 我们将创建一个定义操作（在这里，是客户的名称）的 AbstractCustomer 抽象类，和扩展了 AbstractCustomer 类的实体类
工厂类CustomerFactory 基于客户传递的名字来返回 RealCustomer 或 NullCustomer 对象
NullPatternDemo ，我们的演示类使用 CustomerFactory 来演示空对象模式的用法
范例 1. 创建一个抽象类 AbstractCustomer 1// author: DDKK.COM 弟弟快看，程序员编程资料站(ddkk.com) 2// Copyright © 2015-2065 ddkk.com. All rights reserved. 3package com.ddkk.gof; 4public abstract class AbstractCustomer 5 protected String name; 6 public abstract boolean isNil(); 7 public abstract String getName(); 2. 创建扩展了上述类的实体类 RealCustomer 1// author: DDKK.COM 弟弟快看，程序员编程资料站(ddkk.com) 2// Copyright © 2015-2065 ddkk.</description></item><item><title>二十七、策略模式 ( Strategy Pattern )</title><link>https://www.hotmindshare.com/docs/code-design/27_miss/</link><pubDate>Thu, 06 Oct 2022 22:42:23 +0800</pubDate><guid>https://www.hotmindshare.com/docs/code-design/27_miss/</guid><description>模板模式（Template Pattern）中，一个抽象类公开定义了执行它的方法的方式/模板。它的子类可以按需要重写方法实现，但调用将以抽象类中定义的方式进行
模板模式属于行为型模式
摘要 1、 意图：
定义一个操作中的算法的骨架，而将一些步骤延迟到子类中
模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤
2、 主要解决：
一些方法通用，却在每一个子类都重新写了这一方法
3、 何时使用：
有一些通用的方法
4、 如何解决：
将这些通用算法抽象出来
5、 关键代码：
在抽象类实现，其他步骤在子类实现
6、 应用实例：
1、 在造房子的时候，地基、走线、水管都一样，只有在建筑的后期才有加壁橱加栅栏等差异；
2、 西游记里面菩萨定好的81难，这就是一个顶层的逻辑骨架；
3、 Spring中对Hibernate的支持，将一些已经定好的方法封装起来，比如开启事务、获取Session、关闭Session等，程序员不重复写那些已经规范好的代码，直接丢一个实体就可以保存；
7、 优点：
1、 封装不变部分，扩展可变部分；
2、 提取公共代码，便于维护；
3、 行为由父类控制，子类实现；
8、 缺点：
每一个不同的实现都需要一个子类来实现，导致类的个数增加，使得系统更加庞大
9、 使用场景：
1、 有多个子类共有的方法，且逻辑相同；
2、 重要的、复杂的方法，可以考虑作为模板方法；
10、 注意事项：
为防止恶意操作，一般模板方法都加上 final 关键词
实现 1、 创建一个定义操作的Game抽象类，其中，模板方法设置为final，这样它就不会被重写；
2、 定义类Cricket和Football扩展Game，重写了抽象类的方法；
3、 定义类TemplatePatternDemo使用Game来演示模板模式的用法；
范例 1. 创建一个抽象类，它的模板方法被设置为 final Game.java
1// author: DDKK.COM 弟弟快看，程序员编程资料站(ddkk.com) 2// Copyright © 2015-2065 ddkk.</description></item><item><title>二十三、备忘录模式 ( Memento Pattern )</title><link>https://www.hotmindshare.com/docs/code-design/23_miss/</link><pubDate>Thu, 06 Oct 2022 22:42:23 +0800</pubDate><guid>https://www.hotmindshare.com/docs/code-design/23_miss/</guid><description>备忘录模式（Memento Pattern）保存一个对象的某个状态，以便在适当的时候恢复对象
备忘录模式属于行为型模式
摘要 1、 意图：
在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态
2、 主要解决：
所谓备忘录模式就是在不破坏封装的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样可以在以后将对象恢复到原先保存的状态
3、 何时使用：
很多时候我们总是需要记录一个对象的内部状态，这样做的目的就是为了允许用户取消不确定或者错误的操作，能够恢复到他原先的状态，使得他有”后悔药”可吃
4、 如何解决：
通过一个备忘录类专门存储对象状态
5、 关键代码：
客户不与备忘录类耦合，与备忘录管理类耦合
6、 应用实例：
1、 后悔药；
2、 打游戏时的存档；
3、 Windows里的ctri+z；
4、 IE中的后退；
5、 数据库的事务管理；
7、 优点：
1、 给用户提供了一种可以恢复状态的机制，可以使用户能够比较方便地回到某个历史的状态；
2、 实现了信息的封装，使得用户不需要关心状态的保存细节；
8、 缺点：
消耗资源
如果类的成员变量过多，势必会占用比较大的资源，而且每一次保存都会消耗一定的内存
9、 使用场景：
1、 需要保存/恢复数据的相关状态场景；
2、 提供一个可回滚的操作；
10、 注意事项：
1、 为了符合迪米特原则，还要增加一个管理备忘录的类；
2、 为了节约内存，可使用原型模式+备忘录模式；
实现 备忘录模式使用三个类 Memento 、 Originator 和 CareTaker
1、 定义类Memento包含了要被恢复的对象的状态；
2、 定义类Originator创建并在Memento对象中存储状态；
3、 定义类Caretaker对象负责从Memento中恢复对象的状态；
4、 最后使用MementoPatternDemo类使用CareTaker和Originator对象来显示对象的状态恢复；
范例 1. 创建 Memento 类 Memento.</description></item><item><title>二十四、观察者模式 ( Observer Pattern )</title><link>https://www.hotmindshare.com/docs/code-design/24_miss/</link><pubDate>Thu, 06 Oct 2022 22:42:23 +0800</pubDate><guid>https://www.hotmindshare.com/docs/code-design/24_miss/</guid><description>观察者模式 ( Observer Pattern ) 常用于对象间存在一对多关系时，比如，当一个对象被修改时，需要自动通知它的依赖对象
观察者模式属于行为型模式
摘要 1、 意图：
定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。
2、 主要解决：
一个对象状态改变给其他对象通知的问题，而且要考虑到易用和低耦合，保证高度的协作
3、 何时使用：
一个对象（目标对象）的状态发生改变，所有的依赖对象（观察者对象）都将得到通知，进行广播通知
4、 如何解决：
使用面向对象技术，可以将这种依赖关系弱化
5、 关键代码：
在抽象类里有一个 ArrayList 存放观察者们
6、 应用实例：
1、 拍卖的时候，拍卖师观察最高标价，然后通知给其他竞价者竞价；
2、 西游记里面悟空请求菩萨降服红孩儿，菩萨洒了一地水招来一个老乌龟，这个乌龟就是观察者，他观察菩萨洒水这个动作；
7、 优点：
1、 观察者和被观察者是抽象耦合的；
2、 建立一套触发机制；
8、 缺点：
1、 如果一个被观察者对象有很多的直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间；
2、 如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃；
3、 观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化；
9、 使用场景：
1、 有多个子类共有的方法，且逻辑相同；
2、 重要的、复杂的方法，可以考虑作为模板方法；
10、 注意事项：
1、 JAVA中已经有了对观察者模式的支持类；
2、 避免循环引用；
3、 如果顺序执行，某一观察者错误会导致系统卡壳，一般采用异步方式；
实现 观察者模式使用三个类 Subject、Observer 和 Client ：Subject 对象带有绑定观察者到 Client 对象和从 Client 对象解绑观察者的方法</description></item><item><title>二十五、状态模式 ( State Pattern )</title><link>https://www.hotmindshare.com/docs/code-design/25_miss/</link><pubDate>Thu, 06 Oct 2022 22:42:23 +0800</pubDate><guid>https://www.hotmindshare.com/docs/code-design/25_miss/</guid><description>状态模式（State Pattern）中类的行为是基于它的状态改变的
在状态模式中，我们创建表示各种状态的对象和一个行为随着状态对象改变而改变的 context 对象
状态模式属于行为型模式
摘要 1、 意图：
允许对象在内部状态发生改变时改变它的行为，对象看起来好像修改了它的类
2、 主要解决：
对象的行为依赖于它的状态（属性），并且可以根据它的状态改变而改变它的相关行为
3、 何时使用：
代码中包含大量与对象状态有关的条件语句
4、 如何解决：
将各种具体的状态类抽象出来
5、 关键代码：
通常命令模式的接口中只有一个方法。而状态模式的接口中有一个或者多个方法
而且，状态模式的实现类的方法，一般返回值，或者是改变实例变量的值
也就是说，状态模式一般和对象的状态有关。实现类的方法有不同的功能，覆盖接口中的方法
状态模式和命令模式一样，也可以用于消除 if…else 等条件选择语句
6、 应用实例：
1、 打篮球的时候运动员可以有正常状态、不正常状态和超常状态；
2、 曾侯乙编钟中，’钟是抽象接口’,’钟A’等是具体状态，’曾侯乙编钟’是具体环境（Context）；
7、 优点：
1、 封装了转换规则；
2、 枚举可能的状态，在枚举状态之前需要确定状态种类；
3、 将所有与某个状态有关的行为放到一个类中，并且可以方便地增加新的状态，只需要改变对象状态即可改变对象的行为；
4、 允许状态转换逻辑与状态对象合成一体，而不是某一个巨大的条件语句块；
5、 可以让多个环境对象共享一个状态对象，从而减少系统中对象的个数；
8、 缺点：
1、 状态模式的使用必然会增加系统类和对象的个数；
2、 状态模式的结构与实现都较为复杂，如果使用不当将导致程序结构和代码的混乱；
3、 状态模式对”开闭原则”的支持并不太好，对于可以切换状态的状态模式，增加新的状态类需要修改那些负责状态转换的源代码，否则无法切换到新增状态，而且修改某个状态类的行为也需修改对应类的源代码；
9、 使用场景：
1、 行为随状态改变而改变的场景；
2、 条件、分支语句的代替者；
10、 注意事项：
在行为受状态约束的时候使用状态模式，而且状态不超过 5 个
实现 我们将创建一个 State 接口和实现了 State 接口的实体状态类。</description></item><item><title>二十一、迭代器模式 ( Iterator Pattern )</title><link>https://www.hotmindshare.com/docs/code-design/21_miss/</link><pubDate>Thu, 06 Oct 2022 22:42:23 +0800</pubDate><guid>https://www.hotmindshare.com/docs/code-design/21_miss/</guid><description>迭代器模式（Iterator Pattern）用于顺序访问集合对象的元素，不需要知道集合对象的底层表示
迭代器模式是 Java 和 .Net 编程环境中非常常用的设计模式
迭代器模式属于行为型模式
介绍 1、 意图：
提供一种方法顺序访问一个聚合对象中各个元素, 而又无须暴露该对象的内部表示
2、 主要解决：
不同的方式来遍历整个整合对象
3、 何时使用：
遍历一个聚合对象
4、 如何解决：
把在元素之间游走的责任交给迭代器，而不是聚合对象
5、 关键代码：
定义接口：hasNext, next
6、 应用实例：
JAVA 中的 iterator
7、 优点：
1、 它支持以不同的方式遍历一个聚合对象；
2、 迭代器简化了聚合类；
3、 在同一个聚合上可以有多个遍历；
4、 在迭代器模式中，增加新的聚合类和迭代器类都很方便，无须修改原有代码；
8、 缺点：
由于迭代器模式将存储数据和遍历数据的职责分离，增加新的聚合类需要对应增加新的迭代器类，类的个数成对增加，这在一定程度上增加了系统的复杂性
9、 使用场景：
1、 访问一个聚合对象的内容而无须暴露它的内部表示；
2、 需要为聚合对象提供多种遍历方式；
3、 为遍历不同的聚合结构提供一个统一的接口；
10、 注意事项：
迭代器模式就是分离了集合对象的遍历行为，抽象出一个迭代器类来负责，这样既可以做到不暴露集合的内部结构，又可让外部代码透明地访问集合内部的数据
实现 1、 定义一个叙述导航方法的Iterator接口和一个返回迭代器的Container接口；
2、 实现了Container接口的实体类将负责实现Iterator接口；
3、 IteratorPatternDemo使用实体类NamesRepository来打印NamesRepository中存储为集合的Names；
范例 1. 创建接口 Iterator.java
1// author: DDKK.COM 弟弟快看，程序员编程资料站(ddkk.com) 2// Copyright © 2015-2065 ddkk.</description></item><item><title>组合 Futures</title><link>https://www.hotmindshare.com/docs/java/concurrency/default/9/</link><pubDate>Thu, 06 Oct 2022 22:42:23 +0800</pubDate><guid>https://www.hotmindshare.com/docs/java/concurrency/default/9/</guid><description>上一章节中我们讲解了 CompletableFuture 的一些基本用法，比如如何使用和如何处理异步计算结果。本章节我们继续，主要讲解如何使用 CompletableFuture 来组合异步计算的结果
组合 Futures CompletableFuture API 最吸引人的部分，应该是能够在一系列链式计算步骤中组合 CompletableFuture 实例。这种链式的结果本身就是CompletableFuture，允许进一步链接和组合。
这种方法在函数式语言中无处不在，通常被称为 「一元 ( monadic ) 设计模式 」。
CompletableFuture 提供了方法 thenCompose() 用于按顺序链接两个 Futures。该方法的参数是一个能够返回 CompletableFuture 实例的函数或表达式。而该函数或表达式的参数则是先前计算步骤的结果，这允许我们在下一个 CompletableFuture 的 lambda 中使用这个值。
例如下面这个示例
1CompletableFuture&amp;lt;String&amp;gt; completableFuture 2 = CompletableFuture.supplyAsync(() -&amp;gt; DDKK.COM 弟弟快看) 3 .thenCompose(s -&amp;gt; CompletableFuture.supplyAsync(() -&amp;gt; s + 程序员编程资料站)); 4assertEquals(&amp;#34;DDKK.COM 弟弟快看，程序员编程资料站&amp;#34;, completableFuture.get()); thenCompose() 方法与 thenApply() 一起实现了一元设计模式的基本构建块，它们与Java 8 中提供的 Stream 和 Optional 类的 map 和flatMap 方法密切相关。
两个方法都接收一个函数并将其应用于计算结果，但 thenCompose() （ flatMap() ）方法接收一个函数，该函数返回相同类型的另一个对象，这样，就允许将这些类的实例组合为构建块。
如果要执行两个独立的 Futures 并对其结果执行某些操作，可以使用 Future 的 thenCombine() 并传递能够接收两个参数的函数或表达式来处理这两个结果。</description></item><item><title>九、原型模式 ( Prototype Pattern )</title><link>https://www.hotmindshare.com/docs/code-design/9_miss/</link><pubDate>Thu, 06 Oct 2022 22:42:23 +0800</pubDate><guid>https://www.hotmindshare.com/docs/code-design/9_miss/</guid><description>原型模式（Prototype Pattern）是用于创建重复的对象，同时又能保证性能
原型模式实现了一个原型接口，该接口用于创建当前对象的克隆
当直接创建对象的代价比较大时，则采用这种模式
例如，一个对象需要在一个高代价的数据库操作之后被创建
我们可以缓存该对象，在下一个请求时返回它的克隆，在需要的时候更新数据库，以此来减少数据库调用
原型模式属于创建型模式，它提供了一种创建对象的最佳方式
摘要 1、 意图：
用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象
2、 主要解决：
在运行期建立和删除原型
3、 何时使用：
1、 当一个系统应该独立于它的产品创建，构成和表示时；
2、 当要实例化的类是在运行时刻指定时，例如，通过动态装载；
3、 为了避免创建一个与产品类层次平行的工厂类层次时；
4、 当一个类的实例只能有几个不同状态组合中的一种时建立相应数目的原型并克隆它们可能比每次用合适的状态手工实例化该类更方便一些；
4、 如何解决：
利用已有的一个原型对象，快速地生成和原型对象一样的实例
5、 关键代码：
1、 实现克隆操作，在JAVA继承Cloneable，重写clone()，在.NET中可以使用Object类的MemberwiseClone()方法来实现对象的浅拷贝或通过序列化的方式来实现深拷贝；
2、 原型模式同样用于隔离类对象的使用者和具体类型（易变类）之间的耦合关系，它同样要求这些”易变类”拥有稳定的接口；
6、 应用实例：
1、 细胞分裂；
2、 JAVA中的Objectclone()方法；
7、 优点：
1、 性能提高；
2、 逃避构造函数的约束；
8、 缺点：
1、 配备克隆方法需要对类的功能进行通盘考虑，这对于全新的类不是很难，但对于已有的类不一定很容易，特别当一个类引用不支持串行化的间接对象，或者引用含有循环结构的时候；
2、 必须实现Cloneable接口；
3、 逃避构造函数的约束；
9、 使用场景：
1、 资源优化场景；
2、 类初始化需要消化非常多的资源，这个资源包括数据、硬件资源等；
3、 性能和安全要求的场景；
4、 通过new产生一个对象需要非常繁琐的数据准备或访问权限，则可以使用原型模式；
5、 一个对象多个修改者的场景；
6、 一个对象需要提供给其他对象访问，而且各个调用者可能都需要修改其值时，可以考虑使用原型模式拷贝多个对象供调用者使用；
7、 在实际项目中，原型模式很少单独出现，一般是和工厂方法模式一起出现，通过clone的方法创建一个对象，然后由工厂方法提供给调用者；
原型模式已经与 Java 融为浑然一体，大家可以随手拿来使用</description></item><item><title/><link>https://www.hotmindshare.com/docs/java/concurrency/default/6/</link><pubDate>Thu, 06 Oct 2022 22:42:23 +0800</pubDate><guid>https://www.hotmindshare.com/docs/java/concurrency/default/6/</guid><description>ForkJoinPool 是Java 7 中引入的 fork/join 框架的核心之一。它解决了一个常见的问题： 如何在递归中生成多个任务。因为，即使是使用一个简单的 ThreadPoolExecutor ，也会在不断的递归中快速耗尽线程。因为每个任务或子任务都需要自己的线程来运行。
在fork/join 框架中，任何任务都可以生成 ( fork ) 多个子任务并使用 join() 方法等待它们的完成。fork/join 框架的好处是它不会为每个任务或子任务创建新线程，而是实现了 工作窃取 ( Work Stealing ) 算法。关于 fork/join 框架的详细信息，你可以访问我们的 一文秒懂 Java Fork/Join。
接下来，我们看一个使用 ForkJoinPool 遍历节点树并计算所有叶值之和的简单示例。在这个示例中，树是一个由节点，int 值和一组子节点组成。
1static class TreeNode { 2 int value; 3 Set&amp;lt;TreeNode&amp;gt; children; 4 TreeNode(int value, TreeNode... children) { 5 this.value = value; 6 this.children = Sets.newHashSet(children); 7 } 创建了树 TreeNode 之后，如果我们想要并行地对树中的所有值求和，我们需要实现一个 RecursiveTask&amp;lt;Integer&amp;gt; 接口。每个任务都接收自己的节点，并将其值添加到其子节点的值之和上。
要计算子节点值的总和，任务实现执行以下操作
1、 将子节点集合转换为流(stream)；
2、
因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 映射前面操作中创建的流，为每个元素创建一个新的CountingTask；</description></item><item><title>六、抽象工厂模式 ( Abstract Factory Pattern )</title><link>https://www.hotmindshare.com/docs/code-design/6_miss/</link><pubDate>Thu, 06 Oct 2022 22:42:23 +0800</pubDate><guid>https://www.hotmindshare.com/docs/code-design/6_miss/</guid><description>抽象工厂模式（Abstract Factory Pattern）是围绕一个超级工厂创建其他工厂
该超级工厂又称为其他工厂的工厂
在抽象工厂模式中，接口是负责创建一个相关对象的工厂，不需要显式指定它们的类
每个生成的工厂都能按照工厂模式提供对象
抽象工厂模式属于创建型模式，它提供了一种创建对象的最佳方式。
摘要 1、 意图：
提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类
2、 主要解决：
主要解决接口选择的问题
3、 何时使用：
系统的产品有多于一个的产品族，而系统只消费其中某一族的产品
4、 如何解决：
在一个产品族里面，定义多个产品
5、 关键代码：
在一个工厂里聚合多个同类产品
6、 应用实例：
工作了，为了参加一些聚会，肯定有两套或多套衣服吧，比如说有商务装（成套，一系列具体产品）、时尚装（成套，一系列具体产品），甚至对于一个家庭来说，可能有商务女装、商务男装、时尚女装、时尚男装，这些也都是成套的，即一系列具体产品
假设一种情况（现实中是不存在的，要不然，没法进入共产主义了，但有利于说明抽象工厂模式），在您的家中，某一个衣柜（具体工厂）只能存放某一种这样的衣服（成套，一系列具体产品），每次拿这种成套的衣服时也自然要从这个衣柜中取出了
用OO 的思想去理解，所有的衣柜（具体工厂）都是衣柜类的（抽象工厂）某一个，而每一件成套的衣服又包括具体的上衣（某一具体产品），裤子（某一具体产品），这些具体的上衣其实也都是上衣（抽象产品），具体的裤子也都是裤子（另一个抽象产品）
7、 优点：
缺点：
产品族扩展非常困难，要增加一个系列的某一产品，既要在抽象的 Creator 里加代码，又要在具体的里面加代码
9、 使用场景：
1、 QQ换皮肤，一整套一起换；
2、 生成不同操作系统的程序；
10、 注意事项：
产品族难扩展，产品等级易扩展
实现 1、 创建Shape和Color接口和实现这些接口的实体类；
2、 创建抽象工厂类AbstractFactory；
3、 定义工厂类ShapeFactory和ColorFactory，这两个工厂类都是扩展了AbstractFactory；
4、 创建一个工厂创造器/生成器类FactoryProducer；
5、 AbstractFactoryPatternDemo使用FactoryProducer来获取AbstractFactory对象；
它将向AbstractFactory 传递形状信息 Shape （ CIRCLE / RECTANGLE / SQUARE ），以便获取它所需对象的类型
同时它还向 AbstractFactory 传递颜色信息 Color （ RED / GREEN / BLUE ），以便获取它所需对象的类型</description></item><item><title>给 Maven 添加 Guava 依赖</title><link>https://www.hotmindshare.com/docs/java/concurrency/default/7/</link><pubDate>Thu, 06 Oct 2022 22:42:23 +0800</pubDate><guid>https://www.hotmindshare.com/docs/java/concurrency/default/7/</guid><description>Guava 是托管在 Github.com 上的流行的 Google 开源的 Java 线程池库。
Guava 包含了许多有用的并发类，同时还包含了几个方便的 ExecutorService 实现，但这些实现类都无法通过直接实例化或子类化来创建实例。取而代之的是提供了 MoreExecutors 助手类来创建它们的实例。
给 Maven 添加 Guava 依赖 为了将Google Guava 库包含进当前的项目中，需要将下面的依赖项添加到 Maven pom 文件中。
1&amp;lt;dependency&amp;gt; 2 &amp;lt;groupId&amp;gt;com.google.guava&amp;lt;/groupId&amp;gt; 3 &amp;lt;artifactId&amp;gt;guava&amp;lt;/artifactId&amp;gt; 4 &amp;lt;version&amp;gt;26.0&amp;lt;/version&amp;gt; 5&amp;lt;/dependency&amp;gt; 你可以在 Maven 中央仓库 中找到最新版本的 Guava 库
直接执行者和直接执行者服务 有时候，我们希望在当前线程或线程池中执行任务，具体在哪里取决于某些条件。这种情况下，你应该会更喜欢使用单个 Executor 接口，且只需切换实现即可。
虽然将当前线程中的任务的 Executor 或 ExecutorService 的提取出来单独实现并不困难，但它仍然需要编写一些样板代码。
值得庆幸的是，Guava 为我们提供了预定义的实例。
下面的范例演示了如何在同一个线程中执行任务。简单起见，提交的任务会将当前线程休眠 500 毫秒并阻塞当前线程，并在执行的调用完成后让结果立即可用
1 Executor executor = MoreExecutors.directExecutor(); 2AtomicBoolean executed = new AtomicBoolean(); 3executor.execute(() -&amp;gt; { 4 try { 5 Thread.</description></item><item><title>七、单例模式 ( Singleton Pattern )</title><link>https://www.hotmindshare.com/docs/code-design/7_miss/</link><pubDate>Thu, 06 Oct 2022 22:42:23 +0800</pubDate><guid>https://www.hotmindshare.com/docs/code-design/7_miss/</guid><description>单例模式（Singleton Pattern）提供了一种创建对象的最佳方式
单例模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建，这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象
单例模式设计要点 1、 单例类只能有一个实例；
2、 单例类必须自己创建自己的唯一实例；
3、 单例类必须给所有其他对象提供这一实例；
单例模式属于创建型模式
摘要 1、 意图：
保证一个类仅有一个实例，并提供一个访问它的全局访问点
2、 主要解决：
一个全局使用的类频繁地创建与销毁
3、 何时使用：
当您想控制实例数目，节省系统资源的时候
4、 如何解决：
判断系统是否已经有这个单例，如果有则返回，如果没有则创建
5、 关键代码：
构造函数是私有的
6、 应用实例：
1、 一个党只能有一个主席；
2、 Windows是多进程多线程的，在操作一个文件的时候，就不可避免地出现多个进程或线程同时操作一个文件的现象，所以所有文件的处理必须通过唯一的实例来进行；
3、 一些设备管理器常常设计为单例模式，比如一个电脑有两台打印机，在输出的时候就要处理不能两台打印机打印同一个文件；
7、 优点：
1、 在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例（比如管理学院首页页面缓存）；
2、 避免对资源的多重占用（比如写文件操作）；
8、 缺点：
没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化
9、 使用场景：
1、 要求生产唯一序列号；
2、 WEB中的计数器，不用每次刷新都在数据库里加一次，用单例先缓存起来；
3、 创建的一个对象需要消耗的资源过多，比如I/O与数据库的连接等；
10、 注意事项：
getInstance() 方法中需要使用同步锁 synchronized (Singleton.class) 防止多线程同时进入造成 instance 被多次实例化
实现 1、 创建一个SingleObject类，SingleObject类有它的私有构造函数和本身的一个静态实例SingleObject类提供了一个静态方法，供外界获取它的静态实例；
2、 SingletonPatternDemo使用SingleObject类来获取SingleObject对象；
范例 1. 创建一个 Singleton 类 SingleObject.</description></item><item><title>Java 中的线程池</title><link>https://www.hotmindshare.com/docs/java/concurrency/default/3/</link><pubDate>Thu, 06 Oct 2022 22:42:23 +0800</pubDate><guid>https://www.hotmindshare.com/docs/java/concurrency/default/3/</guid><description>本文我们将讲解 Java 中的线程池 ( Thread Pool )，从 Java 标准库中的线程池的不同实现开始，到 Google 开发的 Guava 库的前世今生。
本章节涉及到很多前几个章节中阐述的知识点。我们希望你是按照顺序阅读下来的，不然有些知识会一头雾水。
Java 语言的实现中，把 Java 线程一一映射到操作系统级的线程，而后者是操作系统的资源，这意味着，如果开发者毫无节制地创建线程，那么线程资源就会被快速的耗尽。
在Windows 操作系统上，每个线程要预留出 1m 的内存空间，意味着 2G 的内存理论上做多只能创建 2048 个线程。而在 Linux 上，最大线程数由常量 PTHREAD_THREADS_MAX 决定，一般为 1024。
出于模拟并行性的目的，Java 线程之间的上下文切换也由操作系统完成。因为线程上下文切换需要消耗时间，所以，一个简单的观点是：产生的线程越多，每个线程花在实际工作上的时间就越少。
为什么会有线程上下文切换？
一台电脑，运行起来后，它的 CPU 是固定的，05 年之前，还是单核时代，也就是一次只能运行一个线程，虽然随着时间的推移，现在的 CPU 已经有很多个核心，比如 8 核 16 核之类的。但相比于一个应用程序能够创建的线程数，那真的是太少了。而每个核心一次只能运行一个线程，所以多个线程需要运行时就需要来回不停的在多个线程间切换，这就是线程之间的上下文切换。
为了节制创建线程的数量，也为了节省创建线程的开销，因此提出了线程池的概念。线程池模式有助于节省多线程应用程序中的资源，还可以在某些预定义的限制内包含并行性。
当我们使用线程池时，我们可以以并行任务的形式编写并发代码并将其提交到线程池的实例中执行。
这个线程池实例控制了多个重用线程以执行这些任务。
这种线程池模式，允许我们控制应用程序创建的线程数，生命周期，以及计划任务的执行并将传入的任务保留在队列中。
Java 中的线程池 Executors、Executor 和 ExecutorService Executors 是一个帮助类，提供了创建几种预配置线程池实例的方法。如果你不需要应用任何自定义的微调，可以调用这些方法创建默认配置的线程池，因为它能节省很多时间和代码。
Executor 和 ExecutorService 接口则用于与 Java 中不同线程池的实现协同工作。通常，你应该将代码与线程池的实际实现分离，并在整个应用程序中使用这些接口。
Executor 接口提供了一个 execute() 方法将 Runnable 实例提交到线程池中执行。
下面的代码是一个快速示例，演示了如何使用 Executors API 获取包含了单个线程池和无限队列支持的 Executor 实例，以便按顺序执行任务。</description></item><item><title>三、设计模式 – 四大类型</title><link>https://www.hotmindshare.com/docs/code-design/3/</link><pubDate>Thu, 06 Oct 2022 22:42:23 +0800</pubDate><guid>https://www.hotmindshare.com/docs/code-design/3/</guid><description>设计模式（Design pattern）是重构解决方案
根据书Design Patterns – Elements of Reusable Object-Oriented Software（中文译名：设计模式 – 可复用的面向对象软件元素） 中和 J2EE 所提到的，总共有 23 +8 种设计模式
这些模式可以分为四大类：创建型模式（Creational Patterns）、结构型模式（Structural Patterns）、行为型模式（Behavioral Patterns）、J2EE 设计模式
1、 创建型模式；
这些设计模式提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用 new 运算符直接实例化对象
这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活
包括
1、 工厂模式（FactoryPattern）；
2、 抽象工厂模式（AbstractFactoryPattern）；
3、 单例模式（SingletonPattern）；
4、 建造者模式（BuilderPattern；
5、 原型模式（PrototypePattern）；
2、 结构型模式；
这些设计模式关注类和对象的组合
继承的概念被用来组合接口和定义组合对象获得新功能的方式
包括
1、 适配器模式（AdapterPattern）；
2、 桥接模式（BridgePattern）；
3、 过滤器模式（Filter、CriteriaPattern）；
4、 组合模式（CompositePattern）；
5、 装饰器模式（DecoratorPattern）；
6、 外观模式（FacadePattern）；
7、 享元模式（FlyweightPattern）；
8、 代理模式（ProxyPattern）；
因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 3、 行为型模式；
这些设计模式特别关注对象之间的通信
包括
1、 责任链模式（ChainofResponsibilityPattern）；
2、 命令模式（CommandPattern）；</description></item><item><title>三十、MVC 模式</title><link>https://www.hotmindshare.com/docs/code-design/30_miss/</link><pubDate>Thu, 06 Oct 2022 22:42:23 +0800</pubDate><guid>https://www.hotmindshare.com/docs/code-design/30_miss/</guid><description>MVC模式代表 Model-View-Controller（模型-视图-控制器） 模式
MVC模式用于应用程序的分层开发
Model（模型） - 模型代表一个存取数据的对象或 JAVA POJO 它也可以带有逻辑，在数据变化时更新控制器 View（视图） - 视图代表模型包含的数据的可视化 Controller（控制器） - 控制器作用于模型和视图上。它控制数据流向模型对象，并在数据变化时更新视图。它使视图与模型分离开 实现 1、 定义一个作为模型的Student对象；
2、 StudentView是一个把学生详细信息输出到控制台的视图类；
3、 StudentController是负责存储数据到Student对象中的控制器类，并相应地更新视图StudentView；
4、 最后类MVCPatternDemo使用StudentController来演示MVC模式的用法；
范例 1. 定义模型 Student.java
1// author: DDKK.COM 弟弟快看，程序员编程资料站(ddkk.com) 2// Copyright © 2015-2065 ddkk.com. All rights reserved. 3package com.ddkk.gof; 4public class Student { 5 private String rollNo; 6 private String name; 7 public String getRollNo() { 8 return rollNo; 9 } 10 public void setRollNo(String rollNo) { 11 this.</description></item><item><title>三十八、设计模式资源</title><link>https://www.hotmindshare.com/docs/code-design/38/</link><pubDate>Thu, 06 Oct 2022 22:42:23 +0800</pubDate><guid>https://www.hotmindshare.com/docs/code-design/38/</guid><description>本章列出了设计模式相关的网站、书籍和文章
设计模式相关的网站 Wiki Page for Design Patterns - 以一种非常通用的方式检查设计模式。 Java Programming/Design Patterns - 一篇关于设计模式的好文章。 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 The JavaTMTutorials - 该 Java 教程是为那些想用 Java 编程语言创建应用程序的编程人员提供的实用指南。 JavaTM2 SDK, Standard Edition - JavaTM2 SDK, Standard Edition 的官网。 Java DesignPatterns - 关于设计模式的短文。</description></item><item><title>三十二、组合实体模式 (Composite Entity Pattern)</title><link>https://www.hotmindshare.com/docs/code-design/32_miss/</link><pubDate>Thu, 06 Oct 2022 22:42:23 +0800</pubDate><guid>https://www.hotmindshare.com/docs/code-design/32_miss/</guid><description>组合实体模式（Composite Entity Pattern）用在 EJB 持久化机制中
一个组合实体是一个 EJB 实体 bean，代表了对象的图解
当更新一个组合实体时，内部依赖对象 beans 会自动更新，因为它们是由 EJB 实体 bean 管理的
以下是组合实体 bean 的参与者:
组合实体（Composite Entity） - 它是主要的实体 bean。它可以是粗粒的，或者可以包含一个粗粒度对象，用于持续生命周期 粗粒度对象（Coarse-Grained Object） - 该对象包含依赖对象。它有自己的生命周期，也能管理依赖对象的生命周期 依赖对象（Dependent Object） - 依赖对象是一个持续生命周期依赖于粗粒度对象的对象 策略（Strategies） - 策略表示如何实现组合实体 实现 1、 定义作为组合实体的CompositeEntity对象；
2、 定义CoarseGrainedObject是一个包含依赖对象的类；
3、 定义类CompositeEntityPatternDemo使用Client类来演示组合实体模式的用法；
范例 1. 创建依赖对象 DependentObject1.java
1// author: DDKK.COM 弟弟快看，程序员编程资料站(ddkk.com) 2// Copyright © 2015-2065 ddkk.com. All rights reserved. 3package com.ddkk.gof; 4public class DependentObject1 { 5 private String data; 6 public void setData(String data){ 7 this.</description></item><item><title>三十六、服务定位器模式 (Service Locator Pattern)</title><link>https://www.hotmindshare.com/docs/code-design/36_miss/</link><pubDate>Thu, 06 Oct 2022 22:42:23 +0800</pubDate><guid>https://www.hotmindshare.com/docs/code-design/36_miss/</guid><description>服务定位器模式（Service Locator Pattern）用于想使用 JNDI 查询定位各种服务的时候
考虑到为某个服务查找 JNDI 的代价很高，服务定位器模式充分利用了缓存技术
在首次请求某个服务时，服务定位器在 JNDI 中查找服务，并缓存该服务对象
当再次请求相同的服务时，服务定位器会在它的缓存中查找，这样可以在很大程度上提高应用程序的性能
以下是这种设计模式的实体
服务（Service） - 实际处理请求的服务。对这种服务的引用可以在 JNDI 服务器中查找到 Context / 初始的 Context - JNDI Context 带有对要查找的服务的引用 服务定位器（Service Locator） - 服务定位器是通过 JNDI 查找和缓存服务来获取服务的单点接触 缓存（Cache） - 缓存存储服务的引用，以便复用它们 客户端（Client） - Client 是通过 ServiceLocator 调用服务的对象 实现 创建 ServiceLocator 、 InitialContext 、 Cache 、 Service 作为表示实体的各种对象
Service1 和 Service2 表示实体服务
ServiceLocatorPatternDemo ，我们的演示类在这里是作为一个客户端，将使用 ServiceLocator 来演示服务定位器设计模式
范例 1. 创建服务接口 Service 1// author: DDKK.COM 弟弟快看，程序员编程资料站(ddkk.com) 2// Copyright © 2015-2065 ddkk.</description></item><item><title>三十七、传输对象模式 ( Transfer Object Pattern )</title><link>https://www.hotmindshare.com/docs/code-design/37_miss/</link><pubDate>Thu, 06 Oct 2022 22:42:23 +0800</pubDate><guid>https://www.hotmindshare.com/docs/code-design/37_miss/</guid><description>传输对象模式（Transfer Object Pattern）用于从客户端向服务器一次性传递带有多个属性的数据
传输对象也被称为数值对象，没有任何行为
传输对象是一个具有 getter/setter 方法的简单的 POJO 类，它是可序列化的，所以它可以通过网络传输
服务器端的业务类通常从数据库读取数据，然后填充 POJO，并把它发送到客户端或按值传递它
对于客户端，传输对象是只读的
客户端可以创建自己的传输对象，并把它传递给服务器，以便一次性更新数据库中的数值
以下是这种设计模式的实体:
业务对象（Business Object） - 为传输对象填充数据的业务服务 传输对象（Transfer Object） - 简单的 POJO，只有设置/获取属性的方法 客户端（Client） - 客户端可以发送请求或者发送传输对象到业务对象 实现 创建一个作为业务对象的 StudentBO 和作为传输对象的 StudentVO ，它们都代表了我们的实体
TransferObjectPatternDemo ，我们的演示类在这里是作为一个客户端，将使用 StudentBO 和 Student 来演示传输对象设计模式
范例 1. 创建传输对象 StudentVO 1// author: DDKK.COM 弟弟快看，程序员编程资料站(ddkk.com) 2// Copyright © 2015-2065 ddkk.com. All rights reserved. 3package com.ddkk.gof; 4public class StudentVO 5 private String name; 6 private int rollNo; 7 StudentVO(String name, int rollNo){ 8 this.</description></item><item><title>三十三、数据访问对象模式 ( Data Access Object )</title><link>https://www.hotmindshare.com/docs/code-design/33_miss/</link><pubDate>Thu, 06 Oct 2022 22:42:23 +0800</pubDate><guid>https://www.hotmindshare.com/docs/code-design/33_miss/</guid><description>数据访问对象模式（Data Access Object Pattern）或 DAO 模式用于把低级的数据访问 API 或操作从高级的业务服务中分离出来
数据访问模式涉及到的参与者有：
数据访问对象接口（Data Access Object Interface） - 该接口定义了在一个模型对象上要执行的标准操作 数据访问对象实体类（Data Access Object concrete class） - 该类实现了上述的接口。该类负责从数据源获取数据，数据源可以是数据库，也可以是 xml，或者是其他的存储机制 模型对象/数值对象（Model Object/Value Object） - 该对象是简单的 POJO，包含了 get/set 方法来存储通过使用 DAO 类检索到的数据 实现 1、 创建一个作为模型对象或数值对象的Student对象；
2、 定义StudentDao作为数据访问对象接口；
3、 定义StudentDaoImpl实现了数据访问对象接口的实体类；
4、 定义DaoPatternDemo使用StudentDao来演示数据访问对象模式的用法；
范例 1. 创建数值对象 Student.java
1// author: DDKK.COM 弟弟快看，程序员编程资料站(ddkk.com) 2// Copyright © 2015-2065 ddkk.com. All rights reserved. 3package com.ddkk.gof; 4public class Student { 5 private String name; 6 private int rollNo; 7 Student(String name, int rollNo){ 8 this.</description></item><item><title>三十四、前端控制器模式(Front Controller Pattern)</title><link>https://www.hotmindshare.com/docs/code-design/34_miss/</link><pubDate>Thu, 06 Oct 2022 22:42:23 +0800</pubDate><guid>https://www.hotmindshare.com/docs/code-design/34_miss/</guid><description>前端控制器模式（Front Controller Pattern）是用来提供一个集中的请求处理机制，所有的请求都将由一个单一的处理程序处理
该处理程序可以做认证/授权/记录日志，或者跟踪请求，然后把请求传给相应的处理程序
前端控制器模式涉及以下实体
前端控制器（Front Controller） - 处理应用程序所有类型请求的单个处理程序，应用程序可以是基于 web 的应用程序，也可以是基于桌面的应用程序。 调度器（Dispatcher） - 前端控制器可能使用一个调度器对象来调度请求到相应的具体处理程序。 视图（View） - 视图是为请求而创建的对象。 实现 1、 定义类FrontController、Dispatcher分别当作前端控制器和调度器；
2、 定义类HomeView和StudentView表示作为前端控制器接收到的请求而创建的视图；
3、 定义类FrontControllerPatternDemo使用FrontController演示前端控制器设计模式；
范例 1. 创建视图 HomeView.java
1// author: DDKK.COM 弟弟快看，程序员编程资料站(ddkk.com) 2// Copyright © 2015-2065 ddkk.com. All rights reserved. 3package com.ddkk.gof; 4public class HomeView { 5 public void show(){ 6 System.out.println(&amp;#34;Displaying Home Page&amp;#34;); 7 } StudentView.java
1// author: DDKK.COM 弟弟快看，程序员编程资料站(ddkk.com) 2// Copyright © 2015-2065 ddkk.com. All rights reserved. 3package com.</description></item><item><title>三十五、拦截过滤器模式 ( Intercepting Filter )</title><link>https://www.hotmindshare.com/docs/code-design/35_miss/</link><pubDate>Thu, 06 Oct 2022 22:42:23 +0800</pubDate><guid>https://www.hotmindshare.com/docs/code-design/35_miss/</guid><description>拦截过滤器模式（Intercepting Filter Pattern）用于对应用程序的请求或响应做一些预处理/后处理
定义过滤器，并在把请求传给实际目标应用程序之前应用在请求上
过滤器可以做认证/授权/记录日志，或者跟踪请求，然后把请求传给相应的处理程序
拦截过滤器模式涉及以下实体：
过滤器（Filter） - 过滤器在请求处理程序执行请求之前或之后，执行某些任务。 过滤器链（Filter Chain） - 过滤器链带有多个过滤器，并在 Target 上按照定义的顺序执行这些过滤器。 Target - Target 对象是请求处理程序。 过滤管理器（Filter Manager） - 过滤管理器管理过滤器和过滤器链。 客户端（Client） - Client 是向 Target 对象发送请求的对象。 实现 1、 定义类FilterChain、FilterManager、Target、Client作为表示实体的各种对象；
2、 定义类AuthenticationFilter和DebugFilter表示实体过滤器；
3、 定义类InterceptingFilterDemo使用Client来演示拦截过滤器设计模式；
范例 1. 创建过滤器接口 Filter Filter.java
1// author: DDKK.COM 弟弟快看，程序员编程资料站(ddkk.com) 2// Copyright © 2015-2065 ddkk.com. All rights reserved. 3package com.ddkk.gof; 4public interface Filter { 5 public void execute(String request); 2. 创建实体过滤器 AuthenticationFilter.java
1// author: DDKK.COM 弟弟快看，程序员编程资料站(ddkk.</description></item><item><title>三十一、业务代表模式(Business Delegate Pattern)</title><link>https://www.hotmindshare.com/docs/code-design/31_miss/</link><pubDate>Thu, 06 Oct 2022 22:42:23 +0800</pubDate><guid>https://www.hotmindshare.com/docs/code-design/31_miss/</guid><description>业务代表模式（Business Delegate Pattern）用于对表示层和业务层解耦
业务代表模式用来减少通信或对表示层代码中的业务层代码的远程查询功能
在业务层中我们有以下实体:
客户端（Client） - 表示层代码可以是 JSP、servlet 或 UI java 代码 业务代表（Business Delegate） - 一个为客户端实体提供的入口类，它提供了对业务服务方法的访问 查询服务（LookUp Service） - 查找服务对象负责获取相关的业务实现，并提供业务对象对业务代表对象的访问 业务服务（Business Service） - 业务服务接口。实现了该业务服务的实体类，提供了实际的业务实现逻辑 实现 1、 创建Client、BusinessDelegate、BusinessService、LookUpService、JMSService和EJBService来表示业务代表模式中的各种实体；
2、 定义类BusinessDelegatePatternDemo使用BusinessDelegate和Client来演示业务代表模式的用法；
范例 1. 创建 BusinessService 接口 BusinessService.java
1// author: DDKK.COM 弟弟快看，程序员编程资料站(ddkk.com) 2// Copyright © 2015-2065 ddkk.com. All rights reserved. 3package com.ddkk.gof; 4public interface BusinessService { 5 public void doProcessing(); 2. 创建实体服务类 EJBService.java
1// author: DDKK.COM 弟弟快看，程序员编程资料站(ddkk.com) 2// Copyright © 2015-2065 ddkk.com. All rights reserved.</description></item><item><title>Java 并发编程面试题</title><link>https://www.hotmindshare.com/docs/java/concurrency/default/10/</link><pubDate>Thu, 06 Oct 2022 22:42:23 +0800</pubDate><guid>https://www.hotmindshare.com/docs/java/concurrency/default/10/</guid><description>应聘Java 岗，总是免不了几个 Java 并发编程的面试题，不过大多数都局限在 java.util.concurrent 包下的知识和实现问题。本文针对 Java 并发相关的常见的面试题做一些解释。
Q1: 进程和线程的区别？ 这是一个非常基础的面试题，如果这道题没有回答的比较满意，一般情况下，面试官会认为应聘者在并发方面的基础只是不牢固，就不会继续深入询问其它并发问题了。
1、 进程和线程都是并发单元，但它们有一个根本区别：进程不共享公共内存，而线程则共享；
2、 从操作系统的角度来看，进程是一个独立的软件，在其自己的虚拟内存空间中运行任何一个多任务操作系统（这几乎意味着任何现代操作系统）都必须将内存中的进程分开，这样一个失败的进程就不会通过加扰公共内存来拖累所有其它进程因此，进程通常是隔离的，它们通过进程间通信进行协作，进程间通信由操作系统定义为一种中间API；
3、 相反，线程是应用程序的一部分，它与同一应用程序的其他线程共享公共内存使用公共内存可以减少大量开销，因此使用线程可以更快的交换数据和进行线程间协作；
关于进程间通讯那一块可以不用回答，如果你不懂的话，不必然会导致接下来的某个问题是 进程间通讯的的原理.
Q2: 如何创建一个线程实例并且运行它？ 这道题考察的是对 Runnable 的理解。
创建一个线程的实例，有两种方法可供选择:
1、 把Runnable的实例传递给Thread的构造函数并调用start()方法；
1Thread thread1 = new Thread(() -&amp;gt; 2 System.out.println(&amp;#34;Hello World from Runnable!&amp;#34;)); 3thread1.start(); Runnable是一个函数接口，因此可以作为 lambda 表达式传递
2、 因为线程本身也实现了Runnable接口，所以另一种创建线程的方法是创建一个匿名子类，覆写它的run()方法，然后调用start()；
1Thread thread2 = new Thread() { 2 @Override 3 public void run() { 4 System.out.println(&amp;#34;Hello World from subclass!&amp;#34;); 5 } 6}; 7thread2.start(); Q3: 描述线程的不同状态以及何时发生状态转换 ？ 这道题考察的是对线程生命周期的理解。</description></item><item><title>十、适配器模式 ( Adapter Pattern )</title><link>https://www.hotmindshare.com/docs/code-design/10_miss/</link><pubDate>Thu, 06 Oct 2022 22:42:23 +0800</pubDate><guid>https://www.hotmindshare.com/docs/code-design/10_miss/</guid><description>适配器模式（Adapter Pattern）是作为两个不兼容的接口之间的桥梁
适配器模式涉及到一个单一的类，该类负责加入独立的或不兼容的接口功能
举个真实的例子，读卡器是作为内存卡和笔记本之间的适配器。您将内存卡插入读卡器，再将读卡器插入笔记本，这样就可以通过笔记本来读取内存卡
适配器模式属于结构型模式，它结合了两个独立接口的功能
摘要 1、 意图：
将一个类的接口转换成客户希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作
2、 主要解决：
主要解决在软件系统中，常常要将一些”现存的对象”放到新的环境中，而新环境要求的接口是现对象不能满足的
3、 何时使用：
1、 系统需要使用现有的类，而此类的接口不符合系统的需要；
2、 想要建立一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作，这些源类不一定有一致的接口；
3、 通过接口转换，将一个类插入另一个类系中（比如老虎和飞禽，现在多了一个飞虎，在不增加实体的需求下，增加一个适配器，在里面包容一个虎对象，实现飞的接口）；
4、 如何解决：
继承或依赖（推荐）
5、 关键代码：
适配器继承或依赖已有的对象，实现想要的目标接口
6、 应用实例：
1、 美国电器110V，中国220V，就要有一个适配器将110V转化为220V；
2、 JAVAJDK1.1提供了Enumeration接口，而在1.2中提供了Iterator接口，想要使用1.2的JDK，则要将以前系统的Enumeration接口转化为Iterator接口，这时就需要适配器模式；
3、 在LINUX上运行WINDOWS程序；
4、 JAVA中的jdbc；
7、 优点：
1、 可以让任何两个没有关联的类一起运行；
2、 提高了类的复用；
3、 增加了类的透明度；
4、 灵活性好；
8、 缺点：
1、 过多地使用适配器，会让系统非常零乱，不易整体进行把握；
比如，明明看到调用的是 A 接口，其实内部被适配成了 B 接口的实现，一个系统如果太多出现这种情况，无异于一场灾难
因此如果不是很有必要，可以不使用适配器，而是直接对系统进行重构
2、 由于JAVA至多继承一个类，所以至多只能适配一个适配者类，而且目标类必须是抽象类；
9、 使用场景：
有动机地修改一个正常运行的系统的接口，这时应该考虑使用适配器模式。
10、 注意事项：
适配器不是在详细设计时添加的，而是解决正在服役的项目的问题
实现 1、 MediaPlayer接口和一个实现了MediaPlayer接口的实体类AudioPlayer默认情况下，AudioPlayer可以播放mp3格式的音频文件；
2、 接口AdvancedMediaPlayer和实现了AdvancedMediaPlayer接口的实体类该类可以播放vlc和mp4格式的文件；
3、 让AudioPlayer播放其他格式的音频文件为了实现这个功能，我们需要创建一个实现了MediaPlayer接口的适配器类MediaAdapter，并使用AdvancedMediaPlayer对象来播放所需的格式；</description></item><item><title>扩展一个线程 （ Thread 类 )</title><link>https://www.hotmindshare.com/docs/java/concurrency/default/18/</link><pubDate>Thu, 06 Oct 2022 22:42:23 +0800</pubDate><guid>https://www.hotmindshare.com/docs/java/concurrency/default/18/</guid><description>写Java 代码的时候，我们经常会有这样的疑问：我到底是实现一个 Runnable 呢，还是扩展一个 Thread 类？
你的答案是什么呢？ 那有没有标准答案呢？
答案是什么呢？
我们先来分析下，看看哪种方法在实践中更有意义以及为什么？
扩展一个线程 （ Thread 类 ) 简单起见，我们就来定义一个扩展自 Thread 的 SimpleThread 类
1public class SimpleThread extends Thread { 2 private String message; 3 // standard logger, constructor 4 @Override 5 public void run() { 6 log.info(message); 7 } 代码也真是简单了，然后我们看看如何运行这个 SimpleThread 类
1@Test 2public void givenAThread_whenRunIt_thenResult() 3 throws Exception { 4 Thread thread = new SimpleThread( 5 &amp;#34;SimpleThread executed using Thread&amp;#34;); 6 thread.start(); 7 thread.</description></item><item><title>十八、责任链模式 ( Chain of Responsibility)</title><link>https://www.hotmindshare.com/docs/code-design/18_miss/</link><pubDate>Thu, 06 Oct 2022 22:42:23 +0800</pubDate><guid>https://www.hotmindshare.com/docs/code-design/18_miss/</guid><description>责任链模式（Chain of Responsibility Pattern）为请求创建了一个接收者对象的链
责任链模式给予请求的类型，对请求的发送者和接收者进行解耦
责任链模式中通常每个接收者都包含对另一个接收者的引用，如果一个对象不能处理该请求，那么它会把相同的请求传给下一个接收者，依此类推
责任链模式属于行为型模式
摘要 1、 意图：
避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止
2、 主要解决：
职责链上的处理者负责处理请求，客户只需要将请求发送到职责链上即可，无须关心请求的处理细节和请求的传递，所以职责链将请求的发送者和请求的处理者解耦了
3、 何时使用：
在处理消息的时候以过滤很多道
4、 如何解决：
拦截的类都实现统一接口
5、 关键代码：
Handler 里面聚合它自己，在 HanleRequest 里判断是否合适，如果没达到条件则向下传递，向谁传递之前 set 进去
6、 应用实例：
1、 红楼梦中的”击鼓传花”；
2、 JS中的事件冒泡；
3、 JAVAWEB中ApacheTomcat对Encoding的处理，Struts2的拦截器，jspservlet的Filter；
7、 优点：
1、 降低耦合度它将请求的发送者和接收者解耦；
2、 简化了对象使得对象不需要知道链的结构；
3、 增强给对象指派职责的灵活性通过改变链内的成员或者调动它们的次序，允许动态地新增或者删除责任；
4、 增加新的请求处理类很方便；
8、 缺点：
1、 不能保证请求一定被接收；
2、 系统性能将受到一定影响，而且在进行代码调试时不太方便，可能会造成循环调用；
3、 可能不容易观察运行时的特征，有碍于除错；
9、 使用场景：
1、 有多个对象可以处理同一个请求，具体哪个对象处理该请求由运行时刻自动确定；
2、 在不明确指定接收者的情况下，向多个对象中的一个提交一个请求；
3、 可动态指定一组对象处理请求；
10、 注意事项：
在JAVA WEB 中遇到很多应用
实现 1、 定义抽象类AbstractLogger，带有详细的日志记录级别；</description></item><item><title>BlockingQueue 的队列类型</title><link>https://www.hotmindshare.com/docs/java/concurrency/default/12/</link><pubDate>Thu, 06 Oct 2022 22:42:23 +0800</pubDate><guid>https://www.hotmindshare.com/docs/java/concurrency/default/12/</guid><description>本文中，我们将介绍一个 java.util.concurrent 包提供的用于解决并发生产者 – 消费者问题的最有用的类 – BlockQueue。我们将介绍BlockingQueue 接口的 API 以及如何使用该接口的方法使编写并发程序更容易。
在本文的后面，我们将展示一个具有多个生产者线程和多个消费者线程的简单程序的示例。
BlockingQueue 的队列类型 java.util.concurrent 提供了两种类型的 BlockingQueue：
1、 无限队列（unboundedqueue）–几乎可以无限增长；
2、 有限队列（boundedqueue）–定义了最大容量；
无限队列 创建一个无限队列的方法很简单
1BlockingQueue&amp;lt;String&amp;gt; blockingQueue = new LinkedBlockingDeque&amp;lt;&amp;gt;(); 上面这段代码中，blockingQueue 的容量将设置为 Integer.MAX_VALUE 。
向无限队列添加元素的所有操作都将永远不会阻塞，因此它可以增长到非常大的容量。
使用无限 BlockingQueue 设计生产者 – 消费者模型时最重要的是 消费者应该能够像生产者向队列添加消息一样快地消费消息 。否则，内存可能会填满，然后就会得到一个 OutOfMemory 异常。
有限队列 第二种类型的队列是有限队列。我们可以通过将容量作为参数传递给构造函数来创建这样的队列
1BlockingQueue&amp;lt;String&amp;gt; blockingQueue = new LinkedBlockingDeque&amp;lt;&amp;gt;(10); 上面这句代码中，我们设置了 blockingQueue 的容量为 10 。这意味着当消费者尝试将元素添加到已经满了的队列时，结果取决于添加元素的方法（ offer() 、add() 、put() ) ，它将阻塞，直到有足够的空间可以插入元素。否则，添加操作将会失败。
使用有限队列是设计并发程序的好方法，因为当我们将元素插入到已经满了的队列时，这些操作需要等到消费者赶上并在队列中提供一些空间。这种机制可以让那个我们不做任何其它更改就可以实现节流。
BlockingQueue API BlockingQueue 接口的所有方法可以分为两大类：负责向队列添加元素的方法和检索这些元素的方法。
在队列满/空的情况下，来自这两个组的每个方法的行为都不同。
添加元素 BlockingQueue 提供了以下方法用于添加元素
方法 说明 add() 如果插入成功则返回 true，否则抛出 IllegalStateException 异常 put() 将指定的元素插入队列，如果队列满了，那么会阻塞直到有空间插入 offer() 如果插入成功则返回 true，否则返回 false offer(E e, long timeout, TimeUnit unit) 尝试将元素插入队列，如果队列已满，那么会阻塞直到有空间插入 检索元素 BlockingQueue 提供了以下方法用于检索元素</description></item><item><title>十二、过滤器模式 ( Filter Pattern )</title><link>https://www.hotmindshare.com/docs/code-design/12_miss/</link><pubDate>Thu, 06 Oct 2022 22:42:23 +0800</pubDate><guid>https://www.hotmindshare.com/docs/code-design/12_miss/</guid><description>过滤器模式（Filter Pattern）或允许开发人员使用不同的标准来过滤一组对象，通过逻辑运算以解耦的方式把它们连接起来
过滤器模式（Filter Pattern） 又称 标准模式（Criteria Pattern）
过滤器模式属于结构型模式，它结合多个标准来获得单一标准
实现 1、 创建一个Person对象、Criteria接口和实现了该接口的实体类，来过滤Person对象的列表；
2、 CriteriaPatternDemo使用Criteria对象，基于各种标准和它们的结合来过滤Person对象的列表；
范例 1. 创建一个类，在该类上应用标准 Person.java
1// author: DDKK.COM 弟弟快看，程序员编程资料站(ddkk.com) 2// Copyright © 2015-2065 ddkk.com. All rights reserved. 3package com.ddkk.gof; 4public class Person { 5 private String name; 6 private String gender; 7 private String maritalStatus; 8 public Person(String name,String gender,String maritalStatus){ 9 this.name = name; 10 this.gender = gender; 11 this.maritalStatus = maritalStatus; 12 } 13 public String getName() { 14 return name; 15 } 16 public String getGender() { 17 return gender; 18 } 19 public String getMaritalStatus() { 20 return maritalStatus; 21 } 2.</description></item><item><title>Java 中的线程同步 ( Thread Synchronization )</title><link>https://www.hotmindshare.com/docs/java/concurrency/default/19_miss/</link><pubDate>Thu, 06 Oct 2022 22:42:23 +0800</pubDate><guid>https://www.hotmindshare.com/docs/java/concurrency/default/19_miss/</guid><description>大家有没有发现，其实 「 一文秒懂 」 系列讲述的都是多线程并发开发的问题。这个话题太大了，估计没有上百篇文章都解释不清楚。
本文，我们来讲解下 Java 并发中的基础的基础，核心的核心，Java 并发编程中的最基本的机制之一 – 「 线程同步 」
为了方便你理解并发编程中的各种概念和术语，我们首先会来一阵扫盲，讨论一些基本的并发相关术语和方法。接着，我们将开发一个简单的应用程序，并在合格应用程序里处理并发问题，以方便大家理解和巩固 wait() 和 notify()。
Java 中的线程同步 ( Thread Synchronization ) 在并发编程中，在多线程环境下，多个线程可能会尝试修改同一资源。如果线程管理不当，这显然会导致一致性问题。
Java 中的哨兵块 ( guarded block ) Java 中，可以用来协调多个线程操作的一个工具是 「 哨兵块 」。这个哨兵块会在恢复执行前检查特定条件。
基于这种哨兵检查的思想，Java 在所有类的基类 Object 中提供了两个方法
方法 说明 Object.wait() 暂停一个线程 Object.notify() 唤醒一个线程 是不是有点难以理解，别担心，看下面这个图，这个图描绘了线程的的生命周期。
虽然从上图中可以看出，有多个方法可以控制一个线程的生命周期，但本章节，我们只讨论 notify() 方法和 wait() 方法
wait() 方法 对照上图，简单的说，当我们调用 wait() 时会强制当前线程等待，直到某个其它线程在同一个对象上调用 notify() 或 notifyAll() 方法。
因此，当前线程必须拥有对象的监视器。根据 Java docs 的说法，这可能发生在
我们已经为给定对象执行了同步实例方法 我们已经在给定对象上执行了 synchronized 块的主体 通过为 Class 类型的对象执行同步静态方法 请注意，一次只有一个活动线程可以拥有对象的监视器。</description></item><item><title>十九、命令模式 ( Command Pattern )</title><link>https://www.hotmindshare.com/docs/code-design/19_miss/</link><pubDate>Thu, 06 Oct 2022 22:42:23 +0800</pubDate><guid>https://www.hotmindshare.com/docs/code-design/19_miss/</guid><description>命令模式（Command Pattern）中请求以命令的形式包裹在对象中，并传给调用对象
调用对象寻找可以处理该命令的合适的对象，并把该命令传给相应的对象，该对象执行命令
命令模式是行为型模式，一种数据驱动的设计模式
摘要 1、 意图：
将一个请求封装成一个对象，从而使您可以用不同的请求对客户进行参数化
2、 主要解决：
在软件系统中，行为请求者与行为实现者通常是一种紧耦合的关系，但某些场合，比如需要对行为进行记录、撤销或重做、事务等处理时，这种无法抵御变化的紧耦合的设计就不太合适
3、 何时使用：
在某些场合，比如要对行为进行”记录、撤销/重做、事务”等处理，这种无法抵御变化的紧耦合是不合适的。在这种情况下，如何将”行为请求者”与”行为实现者”解耦？将一组行为抽象为对象，可以实现二者之间的松耦合
4、 如何解决：
通过调用者调用接受者执行命令，顺序：调用者→接受者→命令
5、 关键代码：
定义三个角色：
1、 received真正的命令执行对象；
2、 Command；
3、 invoker使用命令对象的入口；
6、 应用实例：
struts 1 中的 action 核心控制器 ActionServlet 只有一个，相当于 Invoker，而模型层的类会随着不同的应用有不同的模型类，相当于具体的 Command
7、 优点：
1、 降低了系统耦合度；
2、 新的命令可以很容易添加到系统中去；
8、 缺点：
使用命令模式可能会导致某些系统有过多的具体命令类
9、 使用场景：
几乎所有是命令的地方都可以使用命令模式
1、 GUI中每一个按钮都是一条命令；
2、 模拟CMD；
10、 注意事项：
系统需要支持命令的撤销(Undo)操作和恢复(Redo)操作，也可以考虑使用命令模式，见命令模式的扩展
实现 1、 定义一个命令的接口Order；
2、 定义作为请求的Stock类；
3、 定义实体命令类BuyStock和SellStock，实现了Order接口，执行实际的命令处理；
4、 定义作为调用对象的类Broker，它接受订单并能下订单，Broker对象使用命令模式，基于命令的类型确定哪个对象执行哪个命令；
5、 定义类CommandPatternDemo使用Broker类来演示命令模式；
范例 1. 创建一个命令接口 Order.</description></item><item><title>ThreadLocalRandom Via Random</title><link>https://www.hotmindshare.com/docs/java/concurrency/default/16/</link><pubDate>Thu, 06 Oct 2022 22:42:23 +0800</pubDate><guid>https://www.hotmindshare.com/docs/java/concurrency/default/16/</guid><description>随机数生成是一个非常常见的操作，而且 Java 也提供了 java.util.Random 类用于生成随机数，而且呢，这个类也是线程安全的，就是有一点不好，在多线程下，它的性能不佳。
为什么多线程下，Random 的性能不佳？
因为，它采用了多个线程共享一个 Random 实例。这样就会导致多个线程争用。
为了解决这个问题，Java 7 引入了 java.util.concurrent.ThreadLocalRandom 类，用于在多线程环境中生成随机数。
本文接下来的部分，就来看看如何 ThreadLocalRandom 如何执行以及如何在实际应用程序中使用它。
ThreadLocalRandom Via Random ThreadLocalRandom 是 ThreadLocal 类和 Random 类的组合，它与当前线程隔离，通过简单地避免对 Random 对象的任何并发访问，在多线程环境中实现了更好的性能。
也就是说，相比于 java.util.Random 类全局的提供随机数生成， 使用 ThreadLocalRandom，一个线程获得的随机数不受另一个线程的影响。
另一个与 Random 类不同的是，ThreadLocalRandom 不支持显式设置种子。因为它重写了从 Random 继承的 setSeed(long seed) 方法，会在调用时始终抛出 UnsupportedOperationException。
接下来我们看看如何使用 ThreadLocalRandom 生成随机 int、long 和 double 值。
使用 ThreadLocalRandom 生成随机数 根据Oracle 文档，我们只需要调用 ThreadLocalRandom.current() 方法，就能返回当前线程的 ThreadLocalRandom 实例。然后，我们可以通过实例的相关方法来生成随机值。
比如下面的代码，生成一个没有任何边界的随机 int 值
1int unboundedRandomValue = ThreadLocalRandom.current().nextInt()); 其实是有边界的，它的边界就是 int 的边界。</description></item><item><title>十六、享元模式 ( Flyweight Pattern )</title><link>https://www.hotmindshare.com/docs/code-design/16_miss/</link><pubDate>Thu, 06 Oct 2022 22:42:23 +0800</pubDate><guid>https://www.hotmindshare.com/docs/code-design/16_miss/</guid><description>享元模式（Flyweight Pattern）主要用于减少创建对象的数量，以减少内存占用和提高性能
享元模式尝试重用现有的同类对象，如果未找到匹配的对象，则创建新对象
这种类型的设计模式属于结构型模式，它提供了减少对象数量从而改善应用所需的对象结构的方式
摘要 1、 意图：
运用共享技术有效地支持大量细粒度的对象
2、 主要解决：
在有大量对象时，有可能会造成内存溢出，我们把其中共同的部分抽象出来，如果有相同的业务请求，直接返回在内存中已有的对象，避免重新创建
3、 何时使用：
1、 系统中有大量对象；
2、 这些对象消耗大量内存；
3、 这些对象的状态大部分可以外部化；
4、 这些对象可以按照内蕴状态分为很多组，当把外蕴对象从对象中剔除出来时，每一组对象都可以用一个对象来代替；
5、 系统不依赖于这些对象身份，这些对象是不可分辨的；
4、 如何解决：
用唯一标识码判断，如果在内存中有，则返回这个唯一标识码所标识的对象
5、 关键代码：
用HashMap 存储这些对象
6、 应用实例：
1、 JAVA中的String，如果有则返回，如果没有则创建一个字符串保存在字符串缓存池里面；
2、 数据库的数据池；
7、 优点：
大大减少对象的创建，降低系统的内存，使效率提高
8、 缺点：
提高了系统的复杂度，需要分离出外部状态和内部状态，而且外部状态具有固有化的性质，不应该随着内部状态的变化而变化，否则会造成系统的混乱
9、 使用场景：
1、 系统有大量相似对象；
2、 需要缓冲池的场景；
10、 注意事项：
1、 注意划分外部状态和内部状态，否则可能会引起线程安全问题；
2、 这些类必须有一个工厂对象加以控制；
实现 1、 定义一个Shape接口和实现了Shape接口的实体类Circle；
2、 定义工厂类ShapeFactory；
1*ShapeFactory* 有一个 *Circle* 的 *HashMap* ，其中键名为 *Circle* 对象的颜色 2无论何时接收到请求，都会创建一个特定颜色的圆 3*ShapeFactory* 检查它的 *HashMap* 中的 circle 对象，如果找到 *Circle* 对象，则返回该对象，否则将创建一个存储在 hashmap 中以备后续使用的新对象，并把该对象返回到客户端 3、 定义类FlyWeightPatternDemo使用ShapeFactory来获取Shape对象；</description></item><item><title>Java 中的多线程</title><link>https://www.hotmindshare.com/docs/java/concurrency/default/17_miss/</link><pubDate>Thu, 06 Oct 2022 22:42:23 +0800</pubDate><guid>https://www.hotmindshare.com/docs/java/concurrency/default/17_miss/</guid><description>本文中，我想详细的讨论下 Java 中的核心概念 – 线程的生命周期。我会使用一张我自制的图片加上实用的代码片段，一步一步的详细剖析线程的各个状态和各个状态之间如何转换。
Java 中的多线程 Java 语言中， 多线程是由 Thread 的核心概念驱动的。因为多线程中的每一个线程都相互独立，有着自己的生命周期和状态转换。
我们先来看一张草图，这图描述了 Java 线程的各种状态和转换过程。
是不是很杂乱无章？ 看不懂没关系，我们接下来会详细介绍各个状态。
Java 线程中的生命周期 Java 中，每一个线程都是 java.lang.Thread 类的实例。而且，Java 个线程生命周期中的各个状态都定义在 Thread 类的一个静态的 State 枚举中。
State 枚举定义了线程的所有潜在状态。总共有 6 个，分别对应者上图中的 6 个绿色背景的矩形和椭圆型。
NEW : 新创建的，且未调用 start() 方法开始执行的线程。 RUNNABLE : 已经在运行中的线程或正在等待资源分配的准备运行的线程。 BLOCKED : 等待获取进入或重新进入同步块或方法的监视器锁的线程。 WAITING : 等待其他一些线程执行特定操作，没有任何时间限制。 TIMED_WAITING: 等待某个其他线程在指定时间段内执行特定操作 TERMINATED : 线程完成了它的任务。 需要注意的是： 在任何给定的时间点，线程只能处于这些状态之一。
NEW 状态，应该很好理解，比如，车，厂家生产出来，只要还没被卖出过，那么它就是新的 ( NEW ) RUNNABLE 只要线程不出于其它状态，它就是 RUNNABLE 状态。怎么理解呢？ 车买来了，只要它没坏没出什么毛病没借给别人，那么它就出于可开状态，不管是呆在家里吃灰还是已经在上路运行。 WAITING : 无时间显示的等待其它线程完成任务时就处于这个状态，怎么理解呢？比如长假告诉公路大堵车，要等待别人前进了几个蜗牛步我们才能往前几个蜗牛步，有时候一等就是昏天暗地，可能长达几天，也可能，一辈子吧。 TIMED_WAITING : 一直处于 WAITING 总不是办法，所以可能会设置一个超时时间，如果过了时间，就不等待了。同样的，如果可以后退，那么我们在堵车的时候可能会等待那么十几分钟，发现确实走不了，就等了呗。 TERMINATED : 当一个线程结束了它的任务（可能完成了，也可能没完成）就会处于这个状态。如果拿车做比喻，那么当车彻底报废，已经再也不能上路了，就处于这个状态。 其实拿车作比喻感觉有点怪，我觉得拿追女朋友来做比喻比较恰当些。</description></item><item><title>十七、代理模式 ( Proxy Pattern )</title><link>https://www.hotmindshare.com/docs/code-design/17_miss/</link><pubDate>Thu, 06 Oct 2022 22:42:23 +0800</pubDate><guid>https://www.hotmindshare.com/docs/code-design/17_miss/</guid><description>代理模式（Proxy Pattern）使用一个类代表另一个类的功能
代理模式创建具有现有对象的对象，以便向外界提供功能接口
代理模式属于结构型模式
摘要 1、 意图：
为其他对象提供一种代理以控制对这个对象的访问
2、 主要解决：
在直接访问对象时带来的问题，比如说：要访问的对象在远程的机器上
在面向对象系统中，有些对象由于某些原因（比如对象创建开销很大，或者某些操作需要安全控制，或者需要进程外的访问），直接访问会给使用者或者系统结构带来很多麻烦，我们可以在访问此对象时加上一个对此对象的访问层
3、 何时使用：
想在访问一个类时做一些控制
4、 **如何解决：**增加中间层；
5、 **关键代码：**实现与被代理类组合；
6、 应用实例：
1、 买火车票不一定在火车站买，也可以去代售点；
2、 一张支票或银行存单是账户中资金的代理，支票在市场交易中用来代替现金，并提供对签发人账号上资金的控制；
3、 springaop；
7、 优点：
1、 职责清晰；
2、 高扩展性；
3、 智能化；
8、 缺点：
1、 由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢；
2、 实现代理模式需要额外的工作，有些代理模式的实现非常复杂；
9、 使用场景：
1、 远程代理；
2、 虚拟代理；
3、 Copy-on-Write代理；
4、 保护（ProtectorAccess）代理；
5、 Cache代理；
6、 防火墙（Firewall）代理；
7、 同步化（Synchronization）代理；
8、 智能引用（SmartReference）代理；
10、 注意事项：
1、 和适配器模式的区别：适配器模式主要改变所考虑对象的接口，而代理模式不能改变所代理类的接口；
2、 和装饰器模式的区别：装饰器模式为了增强功能，而代理模式是为了加以控制；
实现 1、 定义一个Image接口和实现了Image接口的实体类；
2、 定义代理类ProxyImage，减少RealImage对象加载的内存占用；</description></item><item><title>锁 ( lock ) 和同步块 ( synchronized block ) 之间的差异</title><link>https://www.hotmindshare.com/docs/java/concurrency/default/13/</link><pubDate>Thu, 06 Oct 2022 22:42:23 +0800</pubDate><guid>https://www.hotmindshare.com/docs/java/concurrency/default/13/</guid><description>对于Java 来讲，锁 （ Lock ) 是一种比标准同步块 （ synchronized block ） 更灵活，更复杂的线程同步机制。
其实，Java 1.5 就已经存在 Lock 接口了。这个 Lock 接口在 java.util.concurrent.lock 包中定义，提供了大量的锁操作。
本文中，我们将讲解 Lock 接口的不同实现并介绍如何在应用程序中使用锁。
锁 ( lock ) 和同步块 ( synchronized block ) 之间的差异 使用synchronized 块和使用 Lock API 之间几乎没有区别：
同步块完全包含在方法中 : 在独立的方法中，我们可以使用 Lock 提供的 lock() 和 unlock() 实现锁和解锁操作。 同步块不支持公平竞争，任何线程都可以获取释放的锁定，且不能指定优先级。但锁 ( Lock ) 就不一样了，可以通过指定公平属性来实现 Lock 中的公平性。这可以确保最长的等待线程被授予锁定权限。 如果线程无法访问同步块，则会阻塞该线程。Lock 则提供了 tryLock() 方法。线程只有在可用且不被任何其他线程保持时才获取锁定。这减少了线程等待锁定的阻塞时间。 处于 「 等待 」 状态以获取对同步块的访问的线程不能被中断。Lock 提供了一个 lockInterruptibly() 方法，可用于在等待锁定时中断线程。 从上面的对比来看，同步块的所有机制，锁 ( Lock ) 都有相应的 API 对应。</description></item><item><title>十三、组合模式 ( Composite Pattern )</title><link>https://www.hotmindshare.com/docs/code-design/13_miss/</link><pubDate>Thu, 06 Oct 2022 22:42:23 +0800</pubDate><guid>https://www.hotmindshare.com/docs/code-design/13_miss/</guid><description>组合模式（Composite Pattern），又叫部分整体模式，是用于把一组相似的对象当作一个单一的对象
组合模式依据树形结构来组合对象，用来表示部分以及整体层次
组合模式创建了一个包含自己对象组的类，该类提供了修改相同对象组的方式。
组合模式属于结构型模式，它创建了对象组的树形结构
摘要 1、 意图：
将对象组合成树形结构以表示”部分-整体”的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性
2、 主要解决：
它在我们树型结构的问题中，模糊了简单元素和复杂元素的概念，客户程序可以向处理简单元素一样来处理复杂元素，从而使得客户程序与复杂元素的内部结构解耦
3、 何时使用：
1、 您想表示对象的部分-整体层次结构（树形结构）；
2、 希望用户忽略组合对象与单个对象的不同，用户将统一地使用组合结构中的所有对象；
4、 如何解决：
树枝和叶子实现统一接口，树枝内部组合该接口
5、 关键代码：
树枝内部组合该接口，并且含有内部属性 List，里面放 Component
6、 应用实例：
1、 算术表达式包括操作数、操作符和另一个操作数，其中，另一个操作符也可以是操作树、操作符和另一个操作数；
2、 在JAVAAWT和SWING中，对于Button和Checkbox是树叶，Container是树枝；
7、 优点：
1、 高层模块调用简单；
2、 节点自由增加；
8、 缺点：
在使用组合模式时，其叶子和树枝的声明都是实现类，而不是接口，违反了依赖倒置原则
9、 使用场景：
部分、整体场景，如树形菜单，文件、文件夹的管理
10、 注意事项：
定义时为具体类
实现 1、 类Employee，该类被当作组合模型类；
2、 CompositePatternDemo类使用Employee类来添加部门层次结构，并打印所有员工；
范例 1. 创建 Employee 类，该类带有 Employee 对象的列表 Employee.java
1// author: DDKK.COM 弟弟快看，程序员编程资料站(ddkk.com) 2// Copyright © 2015-2065 ddkk.com. All rights reserved.</description></item><item><title>守护线程和用户线程的区别</title><link>https://www.hotmindshare.com/docs/java/concurrency/default/14/</link><pubDate>Thu, 06 Oct 2022 22:42:23 +0800</pubDate><guid>https://www.hotmindshare.com/docs/java/concurrency/default/14/</guid><description>在这篇简短的文章中，我们将讲解下 Java 中的守护线程，看看它们可以做什么。我们还将解释守护线程和用户线程之间的区别。
守护线程和用户线程的区别 Java 提供了两种类型的线程：守护线程 和 用户线程
用户线程 是高优先级线程。JVM 会在终止之前等待任何用户线程完成其任务。 用户线程 是低优先级线程。其唯一作用是为用户线程提供服务。 由于守护线程的作用是为用户线程提供服务，并且仅在用户线程运行时才需要，因此一旦所有用户线程完成执行，JVM 就会终止。也就是说 守护线程不会阻止 JVM 退出。
这也是为什么通常存在于守护线程中的无限循环不会导致问题，因为任何代码（包括 finally 块 ）都不会在所有用户线程完成执行后执行。
这也是为什么我们并不推荐 在守护线程中执行 I/O 任务 。因为可能导致无法正确关闭资源。
但是，守护线程并不是 100% 不能阻止 JVM 退出的。守护线程中设计不良的代码可能会阻止 JVM 退出。例如，在正在运行的守护线程上调用Thread.join() 可以阻止应用程序的关闭。
守护线程能用来做什么？ 常见的做法，就是将守护线程用于后台支持任务，比如垃圾回收、释放未使用对象的内存、从缓存中删除不需要的条目。
咦，按照这个解释，那么大多数 JVM 线程都是守护线程。
如何创建守护线程 ？ 守护线程也是一个线程，因此它的创建和启动其实和普通线程没什么区别？
要将普通线程设置为守护线程，方法很简单，只需要调用 Thread.setDaemon() 方法即可。
例如下面这段代码，假设我们继承 Thread 类创建了一个新类 NewThread 。那么我们就可以创建这个类的实例并设置为守护线程
1NewThread daemonThread = new NewThread(); 2daemonThread.setDaemon(true); 3daemonThread.start(); 在Java 语言中，线程的状态是自动继承的。任
因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 何线程都会继承创建它的线程的守护程序状态。怎么理解呢？
1、 如果一个线程是普通线程（用户线程），那么它创建的子线程默认也是普通线程（用户线程）；
2、 如果一个线程是守护线程，那么它创建的子线程默认也是守护线程；
因此，我们可以推演出： 由于主线程是用户线程，因此在 main() 方法内创建的任何线程默认为用户线程。</description></item><item><title>十四、装饰器模式 ( Decorator Pattern )</title><link>https://www.hotmindshare.com/docs/code-design/14_miss/</link><pubDate>Thu, 06 Oct 2022 22:42:23 +0800</pubDate><guid>https://www.hotmindshare.com/docs/code-design/14_miss/</guid><description>装饰器模式（Decorator Pattern）允许向一个现有的对象添加新的功能，同时又不改变其结构
装饰器模式创建了一个装饰类，用来包装原有的类，并在保持类方法签名完整性的前提下，提供了额外的功能
装饰器模式属于结构型模式，它是作为现有的类的一个包装
摘要 1、 意图：
动态地给一个对象添加一些额外的职责。就增加功能来说，装饰器模式相比生成子类更为灵活
2、 主要解决：
一般的，我们为了扩展一个类经常使用继承方式实现，由于继承为类引入静态特征，并且随着扩展功能的增多，子类会很膨胀
3、 何时使用：
在不想增加很多子类的情况下扩展类
4、 如何解决：
将具体功能职责划分，同时继承装饰者模式
5、 关键代码：
1、 Component类充当抽象角色，不应该具体实现；
2、 修饰类引用和继承Component类，具体扩展类重写父类方法；
6、 应用实例：
1、 孙悟空有72变，当他变成”庙宇”后，他的根本还是一只猴子，但是他又有了庙宇的功能；
2、 不论一幅画有没有画框都可以挂在墙上，但是通常都是有画框的，并且实际上是画框被挂在墙上在挂在墙上之前，画可以被蒙上玻璃，装到框子里；这时画、玻璃和画框形成了一个物体；
7、 优点：
装饰类和被装饰类可以独立发展，不会相互耦合，装饰模式是继承的一个替代模式，装饰模式可以动态扩展一个实现类的功能
8、 缺点：
多层装饰比较复杂
9、 使用场景：
1、 扩展一个类的功能；
2、 动态增加功能，动态撤销；
10、 注意事项：
1可代替继承 实现 1、 创建一个Shape接口和实现了Shape接口的实体类；
2、 创建一个实现了Shape接口的抽象装饰类ShapeDecorator，并把Shape对象作为它的实例变量；
3、 创建类RedShapeDecorator实现了ShapeDecorator实体类；
4、 创建类DecoratorPatternDemo使用RedShapeDecorator来装饰Shape对象；
范例 我们通过下面的范例来演示装饰器模式的用法，其中，我们将把一个形状装饰上不同的颜色，同时又不改变形状类
1. 创建一个接口 Shape.java
1// author: DDKK.COM 弟弟快看，程序员编程资料站(ddkk.com) 2// Copyright © 2015-2065 ddkk.com. All rights reserved. 3package com.</description></item><item><title>创建 Future</title><link>https://www.hotmindshare.com/docs/java/concurrency/default/15/</link><pubDate>Thu, 06 Oct 2022 22:42:23 +0800</pubDate><guid>https://www.hotmindshare.com/docs/java/concurrency/default/15/</guid><description>写了几篇 Java 一文秒懂 XXX 系列的文章后，对 Java 并发编程的设计思想真的是竖然起敬。
Future 定义在 java.util.concurrent 包中，这是一个接口，自 Java 1.5 以来一直存在的接口，用于处理异步调用和处理并发编程。
创建 Future 简单地说，Future 类表示异步计算的未来结果 – 在处理完成后最终将出现在 Future 中的结果。
是不是又很难理解，文字越少，内容越多。上面这句话的意思，就是主线程会创建一个 Future 接口的对象，然后启动并发线程，并告诉并发线程，一旦你执行完毕，就把结果存储在这个 Future 对象里。
因此，理解 Future 的第一步，就是要知道如何创建和返回 Future 实例。
一般情况下，我们会把长时间运行的逻辑放在异步线程中进行处理，这是使用 Future 接口最理想的场景。主线程只要简单的将异步任务封装在 Future 里，然后开始等待 Future 的完成，在这段等待的时间内，可以处理一些其它逻辑，一旦 Future 执行完毕，就可以从中获取执行的结果并进一步处理。
针对上面这种表述，我们来看看具体哪些场景可以使用 Future :
计算密集型（ 数学和科学计算 ） 操纵大数据结构（ 大数据 ） 远程方法调用（下载文件，HTML 爬取，Web 服务） 实现了 Future 的 FutureTask 我们先来看一段代码:
1public class SquareCalculator { 2 private ExecutorService executor 3 = Executors.newSingleThreadExecutor(); 4 public Future&amp;lt;Integer&amp;gt; calculate(Integer input) { 5 return executor.</description></item><item><title>十五、外观模式 ( Facade Pattern )</title><link>https://www.hotmindshare.com/docs/code-design/15_miss/</link><pubDate>Thu, 06 Oct 2022 22:42:23 +0800</pubDate><guid>https://www.hotmindshare.com/docs/code-design/15_miss/</guid><description>外观模式（Facade Pattern）隐藏系统的复杂性，并向客户端提供了一个客户端可以访问系统的接口
外观模式涉及到一个单一的类，该类提供了客户端请求的简化方法和对现有系统类方法的委托调用
外观模式属于结构型模式，它向现有的系统添加一个接口，来隐藏系统的复杂性
摘要 1、 意图：
为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用
2、 主要解决：
降低访问复杂系统的内部子系统时的复杂度，简化客户端与之的接口
3、 何时使用：
1、 客户端不需要知道系统内部的复杂联系，整个系统只需提供一个”接待员”即可；
2、 定义系统的入口；
4、 如何解决：
客户端不与系统耦合，外观类与系统耦合
5、 关键代码：
在客户端和复杂系统之间再加一层，这一层将调用顺序、依赖关系等处理好
6、 应用实例：
1、 去医院看病，可能要去挂号、门诊、划价、取药，让患者或患者家属觉得很复杂，如果有提供接待人员，只让接待人员来处理，就很方便；
2、 JAVA的三层开发模式；
7、 优点：
1、 减少系统相互依赖；
2、 提高灵活性；
3、 提高了安全性；
8、 缺点：
不符合开闭原则，如果要改东西很麻烦，继承重写都不合适
9、 使用场景：
1、 为复杂的模块或子系统提供外界访问的模块；
2、 子系统相对独立；
3、 预防低水平人员带来的风险；
10、 注意事项：
在层次化结构中，可以使用外观模式定义系统中每一层的入口
实现 1、 创建一个Shape接口和实现了Shape接口的实体类；
2、 定义一个外观类ShapeMaker；
3、 定义类ShapeMaker使用实体类来代表用户对这些类的调用；
4、 定义类FacadePatternDemo使用ShapeMaker类来显示结果；
范例 1. 创建一个接口 Shape.java
1// author: DDKK.COM 弟弟快看，程序员编程资料站(ddkk.com) 2// Copyright © 2015-2065 ddkk.</description></item><item><title>并发编程中使用 CountDownLatch</title><link>https://www.hotmindshare.com/docs/java/concurrency/default/11/</link><pubDate>Thu, 06 Oct 2022 22:42:23 +0800</pubDate><guid>https://www.hotmindshare.com/docs/java/concurrency/default/11/</guid><description>本章节我们来讨论下 java.util.concurrent.CountDownLatch 这个类，顺带演示下如何在一些实际例子中使用它。
CountDownLatch 类的作用呢？ 怎么说呢？ 简单来说，我们可以使用它来阻塞线程，直到其他线程完成给定任务。
并发编程中使用 CountDownLatch 简而言之，CountDownLatch 有一个计数器字段，我们可以根据需要减少它，因此，我们可以使用它来阻止调用线程，直到它被计数到零。
如果我们正在进行一些并行处理，我们可以使用与计数器相同的值来实例化 CountDownLatch，因为我们想要处理多个线程。然后，我们可以在每个线程完成后调用 countdown()，保证调用 await() 的依赖线程将阻塞，直到工作线程完成。
使用 CountDownLatch 等待线程池完成 我们通过创建一个 Worker 来尝试这个模式，并使用 CountDownLatch 字段来指示它何时完成
1public class Worker implements Runnable { 2 private List&amp;lt;String&amp;gt; outputScraper; 3 private CountDownLatch countDownLatch; 4 public Worker(List&amp;lt;String&amp;gt; outputScraper, CountDownLatch countDownLatch) { 5 this.outputScraper = outputScraper; 6 this.countDownLatch = countDownLatch; 7 } 8 @Override 9 public void run() { 10 doSomeWork(); 11 outputScraper.add(&amp;#34;Counted down&amp;#34;); 12 countDownLatch.countDown(); 13 } 然后，我们创建一个测试，以证明我们可以让 CountDownLatch 等待 Worker 实例完成</description></item><item><title>十一、桥接模式 ( Bridge Pattern )</title><link>https://www.hotmindshare.com/docs/code-design/11_miss/</link><pubDate>Thu, 06 Oct 2022 22:42:23 +0800</pubDate><guid>https://www.hotmindshare.com/docs/code-design/11_miss/</guid><description>桥接模式（Bridge Pattern）是用于把抽象化与实现化解耦，使得二者可以独立变化
桥接模式涉及到一个作为桥接的接口，使得实体类的功能独立于接口实现类，这两种类型的类可被结构化改变而互不影响
桥接模式属于结构型模式，它通过提供抽象化和实现化之间的桥接结构，来实现二者的解耦
摘要 1、 意图：
将抽象部分与实现部分分离，使它们都可以独立的变化
2、 主要解决：
在有多种可能会变化的情况下，用继承会造成类爆炸问题，扩展起来不灵活
3、 何时使用：
实现系统可能有多个角度分类，每一种角度都可能变化
4、 如何解决：
把这种多角度分类分离出来，让它们独立变化，减少它们之间耦合
5、 关键代码：
抽象类依赖实现类
6、 应用实例：
1、 猪八戒从天蓬元帅转世投胎到猪，转世投胎的机制将尘世划分为两个等级，即：灵魂和肉体，前者相当于抽象化，后者相当于实现化；
生灵通过功能的委派，调用肉体对象的功能，使得生灵可以动态地选择
2、 墙上的开关，可以看到的开关是抽象的，不用管里面具体怎么实现的；
7、 优点：
1、 抽象和实现的分离；
2、 优秀的扩展能力；
3、 实现细节对客户透明；
8、 缺点：
桥接模式的引入会增加系统的理解与设计难度，由于聚合关联关系建立在抽象层，要求开发者针对抽象进行设计与编程
9、 使用场景：
1、 如果一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性，避免在两个层次之间建立静态的继承联系，通过桥接模式可以使它们在抽象层建立一个关联关系；
2、 对于那些不希望使用继承或因为多层次继承导致系统类的个数急剧增加的系统，桥接模式尤为适用；
3、 一个类存在两个独立变化的维度，且这两个维度都需要进行扩展；
10、 注意事项：
对于两个独立变化的维度，使用桥接模式再适合不过了
实现 1、 创建一个作为桥接实现的DrawAPI接口和实现了DrawAPI接口的实体类RedCircle、GreenCircle；
2、 Shape是一个抽象类，将使用DrawAPI的对象；
3、 BridgePatternDemo使用Shape类来画出不同颜色的圆；
范例 我们通过下面的实例来演示桥接模式（Bridge Pattern）的用法: 可以使用相同的抽象类方法但是不同的桥接实现类，来画出不同颜色的圆
1. 创建桥接实现接口 DrawAPI.java
1// author: DDKK.COM 弟弟快看，程序员编程资料站(ddkk.com) 2// Copyright © 2015-2065 ddkk.</description></item><item><title>ThreadPoolExecutor</title><link>https://www.hotmindshare.com/docs/java/concurrency/default/4/</link><pubDate>Thu, 06 Oct 2022 22:42:23 +0800</pubDate><guid>https://www.hotmindshare.com/docs/java/concurrency/default/4/</guid><description>因为上一章节篇幅有限，所以我决定把 一文秒懂 Java 线程池 拆分为三篇文章单独介绍。本章节，我们就来看看 ThreadPoolExecutor 。
ThreadPoolExecutor ThreadPoolExecutor 是一个可被继承 ( extends ) 的线程池实现，包含了用于微调的许多参数和钩子。
我们并不会讨论 ThreadPoolExecutor 类中的所有的参数和钩子，只会讨论几个主要的配置参数：
1、 corePoolSize；
2、 maximumPoolSize；
3、 keepAliveTime；
ThreadPoolExecutor 创建的线程池由固定数量的核心线程组成，这些线程在 ThreadPoolExecutor 生命周期内始终存在，除此之外还有一些额外的线程可能会被创建，并会在不需要时主动销毁。corePoolSize 参数用于指定在线程池中实例化并保留的核心线程数。如果所有核心线程都忙，并且提交了更多任务，则允许线程池增长到 maximumPoolSize 。
keepAliveTime 参数是额外的线程（ 即，实例化超过 corePoolSize 的线程 ）在空闲状态下的存活时间。
这三个参数涵盖了广泛的使用场景，但最典型的配置是在 Executors 静态方法中预定义的。
Executors.newFixedThreadPool() 例如，Executors.newFixedThreadPool() 静态方法创建了一个 ThreadPoolExecutor ，它的参数 corePoolSize 和 maximumPoolSize 都是相等的，且参数 keepAliveTime 始终为 0 ，也就意味着此线程池中的线程数始终相同。
1ThreadPoolExecutor executor = 2 (ThreadPoolExecutor) Executors.newFixedThreadPool(2); 3executor.submit(() -&amp;gt; { 4 Thread.sleep(1000); 5 return null; 6}); 7executor.submit(() -&amp;gt; { 8 Thread.</description></item><item><title>四、设计模式 – 六大原则</title><link>https://www.hotmindshare.com/docs/code-design/4/</link><pubDate>Thu, 06 Oct 2022 22:42:23 +0800</pubDate><guid>https://www.hotmindshare.com/docs/code-design/4/</guid><description>在23 +8 中设计模式中，我们提炼出了 六大面向对象设计原则
我们可以不知道那数量繁多的设计模式，但一定要记住这 六大设计原则
1. 开闭原则（Open Close Principle） 开闭原则的意思是： 对扩展开放，对修改关闭
在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果
简言之，是为了使程序的扩展性好，易于维护和升级
想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点
2. 里氏代换原则（Liskov Substitution Principle） 里氏代换原则是面向对象设计的基本原则之一
里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现
因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 LSP是继承复用的基石，只有当派生类可以替换掉基类，且软件单位的功能不受到影响时，基类才能真正被复用，而派生类也能够在基类的基础上增加新的行为
里氏代换原则是对开闭原则的补充
实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范
3. 依赖倒转原则（Dependence Inversion Principle） 这个原则是开闭原则的基础，具体内容：针对接口编程，依赖于抽象而不依赖于具体
4. 接口隔离原则（Interface Segregation Principle） 这个原则的意思是：使用多个隔离的接口，比使用单个接口要好
它还有另外一个意思是：降低类之间的耦合度
由此可见，其实设计模式就是从大型软件架构出发、便于升级和维护的软件设计思想，它强调降低依赖，降低耦合
5. 迪米特法则，又称最少知道原则（Demeter Principle） 最少知道原则是指：一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。
6. 合成复用原则（Composite Reuse Principle） 合成复用原则是指：尽量使用合成/聚合的方式，而不是使用继承</description></item><item><title>范例 2</title><link>https://www.hotmindshare.com/docs/java/concurrency/default/5/</link><pubDate>Thu, 06 Oct 2022 22:42:23 +0800</pubDate><guid>https://www.hotmindshare.com/docs/java/concurrency/default/5/</guid><description>ScheduledThreadPoolExecutor 扩展自 一文秒懂 Java 线程池之 ThreadPoolExecutor 讲解的 了ThreadPoolExecutor 类，并且添加了其它方法实现了 ScheduledExecutorService 接口。
schedule() 方法允许在指定的延迟后执行一次任务 scheduleAtFixedRate() 方法允许在指定的初始延迟后执行任务，然后以一定的周期重复执行，其中 period 参数用于指定两个任务的开始时间之间的间隔时间，因此任务执行的频率是固定的。 scheduleWithFixedDelay() 方法类似于 scheduleAtFixedRate() ，它也重复执行给定的任务，但period 参数用于指定前一个任务的结束和下一个任务的开始之间的间隔时间。也就是指定下一个任务延时多久后才执行。执行频率可能会有所不同，具体取决于执行任何给定任务所需的时间。 静态方法 Executors.newScheduledThreadPool() 方法用于创建包含了指定 corePoolSize，无上限 maximumPoolSize 和 0 存活时间 keepAliveTime 的 ScheduledThreadPoolExecutor 实例。
例如下面的示例创建了一个包含了 5 个核心线程的 `S
因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 cheduledThreadPoolExecutor实例，且每隔 500 毫秒运行一个输出Hello World` 的任务
1ScheduledExecutorService executor = Executors.newScheduledThreadPool(5); 2executor.schedule(() -&amp;gt; { 3 System.out.println(&amp;#34;Hello World&amp;#34;); 4}, 500, TimeUnit.MILLISECONDS); 范例 2 下面的代码则演示了如何在 500 毫秒延迟后执行任务，然后每 100 毫秒重复执行一次。
1CountDownLatch lock = new CountDownLatch(3); 2ScheduledExecutorService executor = Executors.</description></item><item><title>五、工厂模式 ( Factory Pattern )</title><link>https://www.hotmindshare.com/docs/code-design/5_miss/</link><pubDate>Thu, 06 Oct 2022 22:42:23 +0800</pubDate><guid>https://www.hotmindshare.com/docs/code-design/5_miss/</guid><description>工厂模式（Factory Pattern）提供了一种创建对象的最佳方式
工厂模式在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象
工厂模式属于创建型模式
摘要 1、 意图：
定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行
2、 主要解决：
主要解决接口选择的问题
3、 何时使用：
我们明确地计划不同条件下创建不同实例时
4、 如何解决：
让其子类实现工厂接口，返回的也是一个抽象的产品
5、 关键代码：
创建过程在其子类执行
6、 应用实例：
1、 您需要一辆汽车，可以直接从工厂里面提货，而不用去管这辆汽车是怎么做出来的，以及这个汽车里面的具体实现；
2、 Hibernate换数据库只需换方言和驱动就可以；
7、 优点：
1、 一个调用者想创建一个对象，只要知道其名称就可以了；
2、 扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以；
3、 屏蔽产品的具体实现，调用者只关心产品的接口；
8、 缺点：
每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖
这并不是什么好事
9、 使用场景：
1、 日志记录器：记录可能记录到本地硬盘、系统事件、远程服务器等，用户可以选择记录日志到什么地方；
2、 数据库访问，当用户不知道最后系统采用哪一类数据库，以及数据库可能有变化时；
3、 设计一个连接服务器的框架，需要三个协议，”POP3″、”IMAP”、”HTTP”，可以把这三个作为产品类，共同实现一个接口；
10、 注意事项：
作为一种创建类模式，在任何需要生成复杂对象的地方，都可以使用工厂方法模式
有一点需要注意的地方就是复杂对象适合使用工厂模式，而简单对象，特别是只需要通过 new 就可以完成创建的对象，无需使用工厂模式。如果使用工厂模式，就需要引入一个工厂类，会增加系统的复杂度
实现 1、 创建一个Shape接口和实现Shape接口的实体类；
2、 下一步是定义工厂类ShapeFactory；
3、 FactoryPatternDemo使用ShapeFactory来获取Shape对象；
它将向ShapeFactory 传递信息（ CIRCLE / RECTANGLE / SQUARE ），以便获取它所需对象的类型
范例 1. 创建一个接口 Shape.</description></item><item><title>实例化 ExecutorService</title><link>https://www.hotmindshare.com/docs/java/concurrency/default/1/</link><pubDate>Thu, 06 Oct 2022 22:42:23 +0800</pubDate><guid>https://www.hotmindshare.com/docs/java/concurrency/default/1/</guid><description>ExecutorService 是 Java java.util.concurrent 包的重要组成部分，是 Java JDK 提供的框架，用于简化异步模式下任务的执行。
一般来说，ExecutorService 会自动提供一个线程池和相关 API，用于为其分配任务。
实例化 ExecutorService 实例化ExecutorService 的方式有两种：一种是工厂方法，另一种是直接创建。
Executors.newFixedThreadPool() 工厂方法创建 ExecutorService 实例 创建ExecutorService 实例的最简单方法是使用 Executors 类的提供的工厂方法。比如
1ExecutorService executor = Executors.newFixedThreadPool(10); 当然还有其它很多工厂方法，每种工厂方法都可以创建满足特定用例的预定义 ExecutorService 实例。你所需要做的就是找到自己想要的合适的方法。这些方法都在 Oracle 的 JDK 官方文档中有列出
直接创建 ExecutorService 的实例 因为ExecutorService 是只是一个接口，因此可以使用其任何实现类的实例。Java java.util.concurrent 包已经预定义了几种实现可供我们选择，或者你也可以创建自己的实现。
例如，ThreadPoolExecutor 类实现了 ExecutorService 接口并提供了一些构造函数用于配置执行程序服务及其内部池。
1ExecutorService executorService = 2 new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, 3 new LinkedBlockingQueue&amp;lt;Runnable&amp;gt;() 4); 你可能会注意到，上面的代码与工厂方法 newSingleThreadExecutor() 的 源代码 非常相似。对于大多数情况，不需要详细的手动配置。
将任务分配给 ExecutorService ExecutorService 可以执行 Runnable 和 Callable 任务。为了使本文简单易懂。我们将使用两个两个原始任务，如下面的代码所示。</description></item><item><title>设计模式</title><link>https://www.hotmindshare.com/docs/code-design/1/</link><pubDate>Thu, 06 Oct 2022 22:42:23 +0800</pubDate><guid>https://www.hotmindshare.com/docs/code-design/1/</guid><description>设计模式（Design pattern）是重构解决方案
这点很重要，尤其是现在 B/S 一统天下的局面，过早考虑设计模式，得不偿失
设计模式（Design pattern）代表了最佳的实践，通常被面向对象的软件开发人员所采用
很多教程都说设计模式是被有经验的人使用，其实只要定义了一个类，或多或少都在使用它们，而不是有没有经验 只是有经验的人知道自己在使用设计模式，而且知道怎么做的更好
设计模式是软件开发人员在软件开发过程中面临复杂度问题的一般问题的解决方案
这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的
因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 设计模式是复杂度解决方案，不是小程序的解决方案(就一两个类文件，用设计模式那是增加复杂度)
记住 设计模式（Design pattern）是重构解决方案不是开发的解决方案
设计模式的 6 大原则才是开发的解决方案
关于范例 因为我用的是包机制来开发，所以引入了 com.ddkk.gof 包，运行起来就有点复杂了 所以我们希望你使用 IDE 来测试范例，这样点击运行可以直接查看结果
如果是手动编译运行，比如工厂模式中的范例，则需要如下
1$ javac -d . src/main/com.ddkk/gof/FactoryPatternDemo.java 2$ java com.ddkk.gof.FactoryPatternDemo 在范例中的 编译运行以上 Java 范例 指的就是这两条命令
本教程将通过 Java 范例，一步一步讲解学习设计模式的概念
谁适合阅读本教程？ 无论您是新手，还是老手，本教程都值得一读
1、 对于那些具有丰富的开发经验的开发人员，学习设计模式有助于了解在软件开发过程中所面临的问题的最佳解决方案；
2、 对于那些经验不足的开发人员，学习设计模式有助于通过一种简单快捷的方式来学习软件设计；
总的来说，不推荐刚入门的开发者学习，哪怕把代码搞的一塌糊涂，也要先将功能完成，初学者，迈过坑是必然的，只有对自己编写的代码不满意，你才会体会到设计模式的重要性，也才能更加理解
阅读本教程前，我们希望需要了解的知识： 因为本教程的范例都是基于 Java 语言，所以我们希望你有一定的 Java 基础知识
如果你还不了解 Java 可以通过我们的 Java 基础教程 学习</description></item></channel></rss>