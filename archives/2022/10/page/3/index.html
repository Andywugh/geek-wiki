<!DOCTYPE html><html data-bs-theme="light" itemscope="" itemtype="http://schema.org/WebPage" lang="zh-hans"><head><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1"/><link rel="manifest" href="https://www.hotmindshare.com/manifest.webmanifest"/><link rel="alternate" type="application/rss+xml" href="https://www.hotmindshare.com/archives/2022/10/index.xml"/><meta name="description" content="十月"/><link rel="icon" href="/images/logo_hu3f5eb531558986e612421c7146e04118_941594_16x16_resize_box_3.png" sizes="16x16" type="image/png"/><link rel="icon" href="/images/logo_hu3f5eb531558986e612421c7146e04118_941594_32x32_resize_box_3.png" sizes="32x32" type="image/png"/><link rel="icon" href="/images/logo_hu3f5eb531558986e612421c7146e04118_941594_150x150_resize_box_3.png" sizes="150x150" type="image/png"/><link rel="apple-touch-icon" href="/images/logo_hu3f5eb531558986e612421c7146e04118_941594_180x180_resize_box_3.png" sizes="180x180" type="image/png"/><link rel="icon" href="/images/logo_hu3f5eb531558986e612421c7146e04118_941594_192x192_resize_box_3.png" sizes="192x192" type="image/png"/><link rel="mask-icon" href="/mask-icon.svg" color="#000000"/><meta property="og:title" content="十月"/><meta property="og:description" content="一个只爱折腾技术的普通人"/><meta property="og:type" content="website"/><meta property="og:url" content="https://www.hotmindshare.com/archives/2022/10/"/><meta itemprop="name" content="十月"/><meta itemprop="description" content="一个只爱折腾技术的普通人"/><meta name="twitter:card" content="summary"/><meta name="twitter:title" content="十月"/><meta name="twitter:description" content="一个只爱折腾技术的普通人"/><title>十月 - 3/5 - 2022 - 归档 - 程序员安仔</title>
<link href="/css/hb.3c67f855ccf80f01a3923f0fd3bd3203f1b4e2f740e3ce444e0ccab10e418d07.css" rel="stylesheet"/><script src="/js/init.577d4e90bff5601d5756fcf799b0e53568bf56cea3b80fe43f66c9d365e8100c.js" integrity="sha256-V31OkL/1YB1XVvz3mbDlNWi/Vs6juA/kP2bJ02XoEAw="></script><script>var _hmt=_hmt||[];(function(){var e,t=document.createElement("script");t.src="https://hm.baidu.com/hm.js?1cbf85f7bc76266af7bdac71374879bf",e=document.getElementsByTagName("script")[0],e.parentNode.insertBefore(t,e)})()</script><link rel="stylesheet" href="/css/search.ee67fb063f2e4be8eff1be9d9806279c3c3d43570b6266c759281faac3804b11.css"/></head><body><noscript><div class="alert alert-danger text-center rounded-0" role=alert><svg aria-hidden="true" class="bi bi-exclamation-square-fillbi bi-exclamation-square-fill hi-svg-inline me-2" fill="currentcolor" height="1em" viewBox="0 0 16 16" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M2 0A2 2 0 000 2v12a2 2 0 002 2h12a2 2 0 002-2V2a2 2 0 00-2-2zm6 4c.535.0.954.462.9.995l-.35 3.507a.552.552.0 01-1.1.0L7.1 4.995A.905.905.0 018 4m.002 6a1 1 0 110 2 1 1 0 010-2"/></svg>你的浏览器不支持 JavaScript。</div></noscript><header class="hb-header"><nav class="hb-header-nav navbar navbar-expand-lg"><div class="container-fluid"><a class="navbar-brand d-flex align-items-center" href="/"><img src="https://www.hotmindshare.com/images/logo_hu3f5eb531558986e612421c7146e04118_941594_0x64_resize_box_3.png" alt="Logo" width="64" height="64" class="hb-header-logo d-inline-block align-text-top me-2"/>程序员安仔</a><div class="d-flex order-5"><div class="search-modal-toggle hb-header-search-form position-relative d-flex ms-lg-1"><button type="button" class="hb-header-search-icon border-0 bg-transparent px-2" aria-label="Toggle search">
<svg aria-hidden="true" class="bi bi-searchbi bi-search hi-svg-inline" fill="currentcolor" height="1em" viewBox="0 0 16 16" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M11.742 10.344a6.5 6.5.0 10-1.397 1.398h-.001c.03.04.062.078.098.115l3.85 3.85a1 1 0 001.415-1.414l-3.85-3.85a1.007 1.007.0 00-.115-.1zM12 6.5a5.5 5.5.0 11-11 0 5.5 5.5.0 0111 0"></path></svg></button>
<input class="form-control rounded-5 d-none d-lg-block ms-lg-1" id="hb-header-search-input" placeholder="搜索"/>
<span class="hb-header-search-keys position-absolute d-none d-lg-block"><kbd>CTRL</kbd>
<kbd>K</kbd></span></div><button class="navbar-toggler border-0 shadow-none" type="button" data-bs-toggle="offcanvas" data-bs-target="#hb-header-content" aria-controls="hb-header-content" aria-label="Toggle navigation"><svg aria-hidden="true" class="bi bi-three-dotsbi bi-three-dots hi-svg-inline" fill="currentcolor" height="1.25em" viewBox="0 0 16 16" width="1.25em" xmlns="http://www.w3.org/2000/svg"><path d="M3 9.5a1.5 1.5.0 110-3 1.5 1.5.0 010 3m5 0a1.5 1.5.0 110-3 1.5 1.5.0 010 3m5 0a1.5 1.5.0 110-3 1.5 1.5.0 010 3"></path></svg></button></div><div class="offcanvas offcanvas-lg offcanvas-end" tabindex="-1" id="hb-header-content" aria-labelledby="hb-header-content-label"><div class="offcanvas-header"><h5 class="offcanvas-title" id="hb-header-content-label">程序员安仔</h5><button type="button" class="btn-close" data-bs-dismiss="offcanvas" aria-label="Close"></button></div><div class="offcanvas-body"><ul class="hb-header-menus navbar-nav flex-row flex-wrap"><li class="hb-header-menu nav-item col-6 col-lg-auto"><a class="nav-link" href="https://www.hotmindshare.com/docs/"><svg aria-hidden="true" class="bi bi-bookbi bi-book hi-svg-inline hb-header-menu-icon me-1" fill="currentcolor" height="1em" viewBox="0 0 16 16" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M1 2.828c.885-.37 2.154-.769 3.388-.893 1.33-.134 2.458.063 3.112.752v9.746c-.935-.53-2.12-.603-3.213-.493-1.18.12-2.37.461-3.287.811V2.828zm7.5-.141c.654-.689 1.782-.886 3.112-.752 1.234.124 2.503.523 3.388.893v9.923c-.918-.35-2.107-.692-3.287-.81-1.094-.111-2.278-.039-3.213.492V2.687zM8 1.783C7.015.936 5.587.81 4.287.94c-1.514.153-3.042.672-3.994 1.105A.5.5.0 000 2.5v11a.5.5.0 00.707.455c.882-.4 2.303-.881 3.68-1.02 1.409-.142 2.59.087 3.223.877a.5.5.0 00.78.0c.633-.79 1.814-1.019 3.222-.877 1.378.139 2.8.62 3.681 1.02A.5.5.0 0016 13.5v-11a.5.5.0 00-.293-.455c-.952-.433-2.48-.952-3.994-1.105C10.413.809 8.985.936 8 1.783"></path></svg>技术教程</a></li><li class="hb-header-menu dropdown nav-item col-12 col-lg-auto"><a class="nav-link pe-0 d-inline-flex align-items-center" href="/interview/"><svg aria-hidden="true" class="bi bi-journal-bookmark-fillbi bi-journal-bookmark-fill hi-svg-inline hb-header-menu-icon me-1" fill="currentcolor" height="1em" viewBox="0 0 16 16" width="1em" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M6 1h6v7a.5.5.0 01-.757.429L9 7.083 6.757 8.43A.5.5.0 016 8z"></path><path d="M3 0h10a2 2 0 012 2v12a2 2 0 01-2 2H3a2 2 0 01-2-2v-1h1v1a1 1 0 001 1h10a1 1 0 001-1V2a1 1 0 00-1-1H3A1 1 0 002 2v1H1V2a2 2 0 012-2"></path><path d="M1 5v-.5a.5.5.0 011 0V5h.5a.5.5.0 010 1h-2a.5.5.0 010-1zm0 3v-.5a.5.5.0 011 0V8h.5a.5.5.0 010 1h-2a.5.5.0 010-1zm0 3v-.5a.5.5.0 011 0v.5h.5a.5.5.0 010 1h-2a.5.5.0 010-1z"></path></svg>🔥面试指南</a>
<a class="nav-link ps-0 d-inline-flex" href="#" id="header-menu-interview" role="button" data-bs-toggle="dropdown" aria-expanded="false"><span class="visually-hidden">Toggle Dropdown</span><svg aria-hidden="true" class="bi bi-chevron-compact-downbi bi-chevron-compact-down hi-svg-inline" fill="currentcolor" height="16" viewBox="0 0 16 16" width="16" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M1.553 6.776a.5.5.0 01.67-.223L8 9.44l5.776-2.888a.5.5.0 11.448.894l-6 3a.5.5.0 01-.448.0l-6-3a.5.5.0 01-.223-.67z"></path></svg></a><ul class="hb-header-submenus dropdown-menu" aria-labelledby="header-menu-interview" data-bs-popper="none"><li class="column-span-all"><a class="hb-header-submenu dropdown-item d-flex align-items-center" href="https://www.hotmindshare.com/interview/v4/"><div class="dropdown-item-content"><div class="dropdown-item-title">综合面试指南第4版</div></div></a></li></ul></li><li class="hb-header-menu dropdown nav-item col-12 col-lg-auto active"><a class="nav-link pe-0 d-inline-flex align-items-center active" href="/blog/" aria-current="page"><svg aria-hidden="true" class="hi-svg-inline hb-header-menu-icon me-1" fill="currentcolor" height="1em" viewBox="0 0 512 512" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M192 32c0 17.7 14.3 32 32 32 123.7.0 224 100.3 224 224 0 17.7 14.3 32 32 32s32-14.3 32-32C512 128.9 383.1.0 224 0c-17.7.0-32 14.3-32 32zm0 96c0 17.7 14.3 32 32 32 70.7.0 128 57.3 128 128 0 17.7 14.3 32 32 32s32-14.3 32-32c0-106-86-192-192-192-17.7.0-32 14.3-32 32zM96 144c0-26.5-21.5-48-48-48S0 117.5.0 144V368c0 79.5 64.5 144 144 144s144-64.5 144-144-64.5-144-144-144H128v96h16c26.5.0 48 21.5 48 48s-21.5 48-48 48-48-21.5-48-48V144z"></path></svg>博客</a>
<a class="nav-link ps-0 d-inline-flex" href="#" id="header-menu-blog" role="button" data-bs-toggle="dropdown" aria-expanded="false"><span class="visually-hidden">Toggle Dropdown</span><svg aria-hidden="true" class="bi bi-chevron-compact-downbi bi-chevron-compact-down hi-svg-inline" fill="currentcolor" height="16" viewBox="0 0 16 16" width="16" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M1.553 6.776a.5.5.0 01.67-.223L8 9.44l5.776-2.888a.5.5.0 11.448.894l-6 3a.5.5.0 01-.448.0l-6-3a.5.5.0 01-.223-.67z"></path></svg></a><ul class="hb-header-submenus dropdown-menu" aria-labelledby="header-menu-blog" data-bs-popper="none"><li><a class="hb-header-submenu dropdown-item d-flex align-items-center" href="https://www.hotmindshare.com/series/"><div class="dropdown-item-icon d-flex align-items-center bg-body-secondary bg-gradient rounded me-2 p-2"><svg aria-hidden="true" class="bi bi-columnsbi bi-columns hi-svg-inline" fill="currentcolor" height="2em" viewBox="0 0 16 16" width="2em" xmlns="http://www.w3.org/2000/svg"><path d="M0 2a1 1 0 011-1h14a1 1 0 011 1v12a1 1 0 01-1 1H1a1 1 0 01-1-1zm8.5.0v8H15V2zm0 9v3H15v-3zm-1-9H1v3h6.5zM1 14h6.5V6H1z"></path></svg></div><div class="dropdown-item-content"><div class="dropdown-item-title mb-1">专栏</div><p class="dropdown-item-desc mb-0 text-wrap">所有专栏。</p></div></a></li><li><a class="hb-header-submenu dropdown-item d-flex align-items-center" href="https://www.hotmindshare.com/authors/"><div class="dropdown-item-icon d-flex align-items-center bg-body-secondary bg-gradient rounded me-2 p-2"><svg aria-hidden="true" class="bi bi-pencilbi bi-pencil hi-svg-inline" fill="currentcolor" height="2em" style="color:#0f5e97" viewBox="0 0 16 16" width="2em" xmlns="http://www.w3.org/2000/svg"><path d="M12.146.146a.5.5.0 01.708.0l3 3a.5.5.0 010 .708l-10 10a.5.5.0 01-.168.11l-5 2a.5.5.0 01-.65-.65l2-5a.5.5.0 01.11-.168l10-10zM11.207 2.5 13.5 4.793 14.793 3.5 12.5 1.207zm1.586 3L10.5 3.207 4 9.707V10h.5a.5.5.0 01.5.5v.5h.5a.5.5.0 01.5.5v.5h.293zm-9.761 5.175-.106.106-1.528 3.821 3.821-1.528.106-.106A.5.5.0 015 12.5V12h-.5a.5.5.0 01-.5-.5V11h-.5a.5.5.0 01-.468-.325z"></path></svg></div><div class="dropdown-item-content"><div class="dropdown-item-title mb-1">作者</div><p class="dropdown-item-desc mb-0 text-wrap">作者列表。</p></div></a></li><li><a class="hb-header-submenu dropdown-item d-flex align-items-center" href="https://www.hotmindshare.com/categories/"><div class="dropdown-item-icon d-flex align-items-center bg-body-secondary bg-gradient rounded me-2 p-2"><svg aria-hidden="true" class="bi bi-folderbi bi-folder hi-svg-inline" fill="currentcolor" height="2em" style="color:orange" viewBox="0 0 16 16" width="2em" xmlns="http://www.w3.org/2000/svg"><path d="M.54 3.87.5 3a2 2 0 012-2h3.672a2 2 0 011.414.586l.828.828A2 2 0 009.828 3h3.982a2 2 0 011.992 2.181l-.637 7A2 2 0 0113.174 14H2.826A2 2 0 01.835 12.181l-.637-7a1.99 1.99.0 01.342-1.31zM2.19 4a1 1 0 00-.996 1.09l.637 7a1 1 0 00.995.91h10.348a1 1 0 00.995-.91l.637-7A1 1 0 0013.81 4H2.19zm4.69-1.707A1 1 0 006.172 2H2.5a1 1 0 00-1 .981l.006.139C1.72 3.042 1.95 3 2.19 3h5.396l-.707-.707z"></path></svg></div><div class="dropdown-item-content"><div class="dropdown-item-title mb-1">分类</div><p class="dropdown-item-desc mb-0 text-wrap">所有分类。</p></div></a></li><li><a class="hb-header-submenu dropdown-item d-flex align-items-center active" href="https://www.hotmindshare.com/archives/"><div class="dropdown-item-icon d-flex align-items-center bg-body-secondary bg-gradient rounded me-2 p-2"><svg aria-hidden="true" class="bi bi-archivebi bi-archive hi-svg-inline" fill="currentcolor" height="2em" style="color:384955" viewBox="0 0 16 16" width="2em" xmlns="http://www.w3.org/2000/svg"><path d="M0 2a1 1 0 011-1h14a1 1 0 011 1v2a1 1 0 01-1 1v7.5A2.5 2.5.0 0112.5 15h-9A2.5 2.5.0 011 12.5V5A1 1 0 010 4zm2 3v7.5A1.5 1.5.0 003.5 14h9a1.5 1.5.0 001.5-1.5V5zm13-3H1v2h14zM5 7.5a.5.5.0 01.5-.5h5a.5.5.0 010 1h-5A.5.5.0 015 7.5"></path></svg></div><div class="dropdown-item-content"><div class="dropdown-item-title mb-1">归档</div><p class="dropdown-item-desc mb-0 text-wrap">文章归档。</p></div></a></li><li><a class="hb-header-submenu dropdown-item d-flex align-items-center" href="https://www.hotmindshare.com/tags/"><div class="dropdown-item-icon d-flex align-items-center bg-body-secondary bg-gradient rounded me-2 p-2"><svg aria-hidden="true" class="bi bi-tagsbi bi-tags hi-svg-inline" fill="currentcolor" height="2em" style="color:green" viewBox="0 0 16 16" width="2em" xmlns="http://www.w3.org/2000/svg"><path d="M3 2v4.586l7 7L14.586 9l-7-7zM2 2a1 1 0 011-1h4.586a1 1 0 01.707.293l7 7a1 1 0 010 1.414l-4.586 4.586a1 1 0 01-1.414.0l-7-7A1 1 0 012 6.586z"></path><path d="M5.5 5a.5.5.0 110-1 .5.5.0 010 1m0 1a1.5 1.5.0 100-3 1.5 1.5.0 000 3M1 7.086a1 1 0 00.293.707L8.75 15.25l-.043.043a1 1 0 01-1.414.0l-7-7A1 1 0 010 7.586V3a1 1 0 011-1z"></path></svg></div><div class="dropdown-item-content"><div class="dropdown-item-title mb-1">标签</div><p class="dropdown-item-desc mb-0 text-wrap">所有标签。</p></div></a></li></ul></li></ul><ul class="hb-header-panel navbar-nav flex-row flex-wrap"><li class="nav-item py-2 py-lg-1 col-12 col-lg-auto"><hr class="d-lg-none my-2 text-body-50"/></li><li class="nav-item col-6 col-lg-auto d-flex align-items-center"><a class="hb-social btn btn-link nav-link py-2 px-0 px-lg-2 d-flex justify-content-center align-items-center" href="mailto:andywuwu0728@gmail.com" target="_blank" rel="nofollow me" title="Email"><svg aria-hidden="true" class="bi bi-envelope-fillbi bi-envelope-fill hi-svg-inline hb-social-icon" fill="currentcolor" height="1em" viewBox="0 0 16 16" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M.05 3.555A2 2 0 012 2h12a2 2 0 011.95 1.555L8 8.414.05 3.555zM0 4.697v7.104l5.803-3.558zM6.761 8.83.191 12.857A2 2 0 002 14h12a2 2 0 001.808-1.144l-6.57-4.027L8 9.586l-1.239-.757zm3.436-.586L16 11.801V4.697l-5.803 3.546z"></path></svg><span class="hb-social-text d-lg-none ms-1">Email</span></a></li><li class="nav-item col-6 col-lg-auto d-flex align-items-center"><a class="hb-social btn btn-link nav-link py-2 px-0 px-lg-2 d-flex justify-content-center align-items-center" href="https://github.com/Andywugh" target="_blank" rel="nofollow me" title="GitHub"><svg aria-hidden="true" class="hi-svg-inline hb-social-icon" fill="currentcolor" height="1em" role="img" viewBox="0 0 24 24" width="1em" xmlns="http://www.w3.org/2000/svg"><title>GitHub</title><path d="M12 .297c-6.63.0-12 5.373-12 12 0 5.303 3.438 9.8 8.205 11.385.6.113.82-.258.82-.577.0-.285-.01-1.04-.015-2.04-3.338.724-4.042-1.61-4.042-1.61C4.422 18.07 3.633 17.7 3.633 17.7c-1.087-.744.084-.729.084-.729 1.205.084 1.838 1.236 1.838 1.236 1.07 1.835 2.809 1.305 3.495.998.108-.776.417-1.305.76-1.605-2.665-.3-5.466-1.332-5.466-5.93.0-1.31.465-2.38 1.235-3.22-.135-.303-.54-1.523.105-3.176.0.0 1.005-.322 3.3 1.23.96-.267 1.98-.399 3-.405 1.02.006 2.04.138 3 .405 2.28-1.552 3.285-1.23 3.285-1.23.645 1.653.24 2.873.12 3.176.765.84 1.23 1.91 1.23 3.22.0 4.61-2.805 5.625-5.475 5.92.42.36.81 1.096.81 2.22.0 1.606-.015 2.896-.015 3.286.0.315.21.69.825.57C20.565 22.092 24 17.592 24 12.297c0-6.627-5.373-12-12-12"></path></svg><span class="hb-social-text d-lg-none ms-1">GitHub</span></a></li><li class="nav-item col-6 col-lg-auto d-flex align-items-center"><a class="hb-social btn btn-link nav-link py-2 px-0 px-lg-2 d-flex justify-content-center align-items-center" href="/index.xml" target="_blank" rel="nofollow me" title="RSS"><svg aria-hidden="true" class="bi bi-rss-fillbi bi-rss-fill hi-svg-inline hb-social-icon" fill="currentcolor" height="1em" viewBox="0 0 16 16" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M2 0A2 2 0 000 2v12a2 2 0 002 2h12a2 2 0 002-2V2a2 2 0 00-2-2zm1.5 2.5c5.523.0 10 4.477 10 10a1 1 0 11-2 0 8 8 0 00-8-8 1 1 0 010-2m0 4a6 6 0 016 6 1 1 0 11-2 0 4 4 0 00-4-4 1 1 0 010-2m.5 7a1.5 1.5.0 110-3 1.5 1.5.0 010 3"></path></svg><span class="hb-social-text d-lg-none ms-1">RSS</span></a></li><li class="nav-item col-6 col-lg-auto d-flex align-items-center"><a class="hb-social btn btn-link nav-link py-2 px-0 px-lg-2 d-flex justify-content-center align-items-center" href="https://www.zhihu.com/people/Andywuwu" target="_blank" rel="nofollow me" title="知乎"><svg aria-hidden="true" class="hi-svg-inline hb-social-icon" fill="currentcolor" height="1em" role="img" viewBox="0 0 24 24" width="1em" xmlns="http://www.w3.org/2000/svg"><title>Zhihu</title><path d="M5.721.0C2.251.0.0 2.25.0 5.719V18.28C0 21.751 2.252 24 5.721 24h12.56C21.751 24 24 21.75 24 18.281V5.72C24 2.249 21.75.0 18.281.0zm1.964 4.078c-.271.73-.5 1.434-.68 2.11h4.587c.545-.006.445 1.168.445 1.171H9.384a58.104 58.104.0 01-.112 3.797h2.712c.388.023.393 1.251.393 1.266H9.183a9.223 9.223.0 01-.408 2.102l.757-.604c.452.456 1.512 1.712 1.906 2.177.473.681.063 2.081.063 2.081l-2.794-3.382c-.653 2.518-1.845 3.607-1.845 3.607-.523.468-1.58.82-2.64.516 2.218-1.73 3.44-3.917 3.667-6.497H4.491c0-.015.197-1.243.806-1.266h2.71c.024-.32.086-3.254.086-3.797H6.598c-.136.406-.158.447-.268.753-.594 1.095-1.603 1.122-1.907 1.155.906-1.821 1.416-3.6 1.591-4.064.425-1.124 1.671-1.125 1.671-1.125zM13.078 6h6.377v11.33h-2.573l-2.184 1.373-.401-1.373h-1.219zm1.313 1.219v8.86h.623l.263.937 1.455-.938h1.456v-8.86z"></path></svg><span class="hb-social-text d-lg-none ms-1">知乎</span></a></li><li class="nav-item py-2 py-lg-1 col-12 col-lg-auto"><div class="vr d-none d-lg-flex h-100 mx-lg-2 text-body"></div><hr class="d-lg-none my-2 text-body-50"/></li><li class="theme-toggle nav-item dropdown col-6 col-lg-auto d-flex flex-column justify-content-center"><button class="btn btn-link btn-theme-toggle nav-link py-2 px-0 px-lg-2 d-flex justify-content-start justify-content-lg-center align-items-center" data-style="switch" aria-expanded="false" title="主题">
<svg aria-hidden="true" class="bi bi-circle-halfbi bi-circle-half hi-svg-inline my-1 theme-toggle-icon" fill="currentcolor" height="1em" viewBox="0 0 16 16" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M8 15A7 7 0 108 1zm0 1A8 8 0 118 0a8 8 0 010 16"></path></svg><span class="d-lg-none ms-1 theme-name">主题</span></button><ul class="theme-toggle-menu dropdown-menu dropdown-menu-end"><li><button class="theme-toggle-item dropdown-item d-flex align-items-center justify-content-center" data-bs-theme-name="自动" data-bs-theme-value="auto">
<span class="theme-toggle-item-icon me-1 d-flex align-items-center"><svg aria-hidden="true" class="bi bi-circle-halfbi bi-circle-half hi-svg-inline my-1" fill="currentcolor" height="1em" viewBox="0 0 16 16" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M8 15A7 7 0 108 1zm0 1A8 8 0 118 0a8 8 0 010 16"></path></svg></span>自动</button></li><li><button class="theme-toggle-item dropdown-item d-flex align-items-center justify-content-center" data-bs-theme-name="暗色" data-bs-theme-value="dark">
<span class="theme-toggle-item-icon me-1 d-flex align-items-center"><svg aria-hidden="true" class="bi bi-moon-starsbi bi-moon-stars hi-svg-inline my-1" fill="currentcolor" height="1em" viewBox="0 0 16 16" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M6 .278a.768.768.0 01.08.858 7.208 7.208.0 00-.878 3.46c0 4.021 3.278 7.277 7.318 7.277.527.0 1.04-.055 1.533-.16a.787.787.0 01.81.316.733.733.0 01-.031.893A8.349 8.349.0 018.344 16C3.734 16 0 12.286.0 7.71.0 4.266 2.114 1.312 5.124.06A.752.752.0 016 .278M4.858 1.311A7.269 7.269.0 001.025 7.71c0 4.02 3.279 7.276 7.319 7.276a7.316 7.316.0 005.205-2.162c-.337.042-.68.063-1.029.063-4.61.0-8.343-3.714-8.343-8.29.0-1.167.242-2.278.681-3.286z"></path><path d="M10.794 3.148a.217.217.0 01.412.0l.387 1.162c.173.518.579.924 1.097 1.097l1.162.387a.217.217.0 010 .412l-1.162.387A1.734 1.734.0 0011.593 7.69l-.387 1.162a.217.217.0 01-.412.0l-.387-1.162A1.734 1.734.0 009.31 6.593l-1.162-.387a.217.217.0 010-.412l1.162-.387a1.734 1.734.0 001.097-1.097l.387-1.162zM13.863.099a.145.145.0 01.274.0l.258.774c.115.346.386.617.732.732l.774.258a.145.145.0 010 .274l-.774.258a1.156 1.156.0 00-.732.732l-.258.774a.145.145.0 01-.274.0l-.258-.774a1.156 1.156.0 00-.732-.732l-.774-.258a.145.145.0 010-.274l.774-.258c.346-.115.617-.386.732-.732L13.863.1z"></path></svg></span>暗色</button></li><li><button class="theme-toggle-item dropdown-item d-flex align-items-center justify-content-center" data-bs-theme-name="亮色" data-bs-theme-value="light">
<span class="theme-toggle-item-icon me-1 d-flex align-items-center"><svg aria-hidden="true" class="bi bi-brightness-highbi bi-brightness-high hi-svg-inline my-1" fill="currentcolor" height="1em" viewBox="0 0 16 16" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M8 11a3 3 0 110-6 3 3 0 010 6m0 1a4 4 0 100-8 4 4 0 000 8M8 0a.5.5.0 01.5.5v2a.5.5.0 01-1 0v-2A.5.5.0 018 0m0 13a.5.5.0 01.5.5v2a.5.5.0 01-1 0v-2A.5.5.0 018 13m8-5a.5.5.0 01-.5.5h-2a.5.5.0 010-1h2a.5.5.0 01.5.5M3 8a.5.5.0 01-.5.5h-2a.5.5.0 010-1h2A.5.5.0 013 8m10.657-5.657a.5.5.0 010 .707l-1.414 1.415a.5.5.0 11-.707-.708l1.414-1.414a.5.5.0 01.707.0m-9.193 9.193a.5.5.0 010 .707L3.05 13.657a.5.5.0 01-.707-.707l1.414-1.414a.5.5.0 01.707.0zm9.193 2.121a.5.5.0 01-.707.0l-1.414-1.414a.5.5.0 01.707-.707l1.414 1.414a.5.5.0 010 .707M4.464 4.465a.5.5.0 01-.707.0L2.343 3.05a.5.5.0 11.707-.707l1.414 1.414a.5.5.0 010 .708z"></path></svg></span>亮色</button></li></ul></li></ul></div></div></div></nav></header><div class="hb-main container"><div class="container-fluid px-0 mb-4"><nav aria-label="breadcrumb"><ol class="hb-breadcrumb breadcrumb"><li class="breadcrumb-item"><a href="/" title="程序员安仔的技术文档/博客">主页</a></li><li class="breadcrumb-item"><a href="/archives/" title="归档">归档</a></li><li class="breadcrumb-item"><a href="/archives/2022/" title="2022">2022</a></li><li class="breadcrumb-item active" aria-current="page"><a href="/archives/2022/10/" title="十月">十月</a></li></ol></nav></div><div class="archives border-start border-5 ps-4 pt-3 position-relative"><div class="archive border-1"><div class="archive-heading h4 mb-4 border-bottom pb-3 border-2"><a class="text-decoration-none" href="/archives/2022/">2022</a></div><div class="archive-subheading h5 mb-3"><a class="text-decoration-none" href="/archives/2022/10/">十月</a></div><div class="archive-posts border-top pt-3"><div class="hb-blog-posts row row-cols-1 row-cols-lg-2 row-cols-xl-3 g-3 mb-3"><div class="col"><div class="hb-blog-post-card card border-0 overflow-hidden h-100 hb-module mb-0"><div class="hb-blog-post-meta d-flex align-items-center"><a class="hb-blog-post-author-link text-decoration-none" href="/authors/andywu/" title="安图新"><picture><img class="hb-blog-author-img rounded-circle" src="https://cdn.hotmindshare.com/public%2Fandyng_1000x1000.png" alt="安图新" loading="lazy"/>
</picture></a><span class="hb-blog-post-date">2022年10月6日</span>
<span class="hb-blog-post-reading-time">2 分钟阅读</span>
<span class="hb-blog-post-section"><a class="badge bg-secondary text-decoration-none fw-normal" href="/docs/">技术教程</a></span></div><a class="card-img-top overflow-hidden border border-secondary-subtle text-body text-decoration-none mt-2" href="/docs/code-design/35_miss/"><picture><source srcset="/images/thumbnail_hu2c04c355e02fd9f63b765bcdb503cf1c_2284289_db4ab978a5e64c694fdda20c4098bfd2.webp" type="image/webp"/><img class="hb-blog-post-card-img" src="https://www.hotmindshare.com/images/thumbnail_hu2c04c355e02fd9f63b765bcdb503cf1c_2284289_0x360_resize_box_3.c4a823371e7699a6d0a45f2ed38908a1.png" alt="三十五、拦截过滤器模式 ( Intercepting Filter )" loading="lazy" height="360" width="630"/></picture></a><div class="card-body px-0 py-2 d-flex flex-column"><div class="hb-blog-post-title card-title h5 py-1"><a class="hb-blog-post-title-link d-block" title="三十五、拦截过滤器模式 ( Intercepting Filter )" href="/docs/code-design/35_miss/">三十五、拦截过滤器模式 ( Intercepting Filter )</a></div><div class="hb-blog-post-meta d-block text-nowrap text-truncate mb-2"><span class="hb-blog-post-taxonomy-meta"><a class="hb-blog-post-taxonomy hb-blog-post-taxonomy-category badge bg-secondary text-decoration-none fw-normal me-1" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a>
</span><span class="hb-blog-post-taxonomy-meta"><a class="hb-blog-post-taxonomy hb-blog-post-taxonomy-series badge bg-secondary text-decoration-none fw-normal me-1" href="/series/%E8%BF%9B%E9%98%B6%E6%95%99%E7%A8%8B/">进阶教程</a></span></div><div class="hb-blog-post-summary card-text text-secondary mb-auto">拦截过滤器模式（Intercepting Filter Pattern）用于对应用程序的请求或响应做一些预处理/后处理
定义过滤器，并在把请求传给实际目标应用程序之前应用在请求上
过滤器可以做认证/授权/记录日志，或者跟踪请求，然后把请求传给相应的处理程序
拦截过滤器模式涉及以下实体：
过滤器（Filter） - 过滤器在请求处理程序执行请求之前或之后，执行某些任务。 过滤器链（Filter Chain） - 过滤器链带有多个过滤器，并在 Target 上按照定义的顺序执行这些过滤器。 Target - Target 对象是请求处理程序。 过滤管理器（Filter Manager） - 过滤管理器管理过滤器和过滤器链。 客户端（Client） - Client 是向 Target 对象发送请求的对象。 实现 1、 定义类FilterChain、FilterManager、Target、Client作为表示实体的各种对象；
2、 定义类AuthenticationFilter和DebugFilter表示实体过滤器；
3、 定义类InterceptingFilterDemo使用Client来演示拦截过滤器设计模式；
范例 1. 创建过滤器接口 Filter Filter.java
1// author: DDKK.COM 弟弟快看，程序员编程资料站(ddkk.com) 2// Copyright © 2015-2065 ddkk.com. All rights reserved. 3package com.ddkk.gof; 4public interface Filter { 5 public void execute(String request); 2. 创建实体过滤器 AuthenticationFilter.java
1// author: DDKK.COM 弟弟快看，程序员编程资料站(ddkk.</div><div class="mt-2"><a class="text-secondary" href="/docs/code-design/35_miss/">阅读更多关于三十五、拦截过滤器模式 ( Intercepting Filter )的内容。</a></div></div></div></div><div class="col"><div class="hb-blog-post-card card border-0 overflow-hidden h-100 hb-module mb-0"><div class="hb-blog-post-meta d-flex align-items-center"><a class="hb-blog-post-author-link text-decoration-none" href="/authors/andywu/" title="安图新"><picture><img class="hb-blog-author-img rounded-circle" src="https://cdn.hotmindshare.com/public%2Fandyng_1000x1000.png" alt="安图新" loading="lazy"/>
</picture></a><span class="hb-blog-post-date">2022年10月6日</span>
<span class="hb-blog-post-reading-time">3 分钟阅读</span>
<span class="hb-blog-post-section"><a class="badge bg-secondary text-decoration-none fw-normal" href="/docs/">技术教程</a></span></div><a class="card-img-top overflow-hidden border border-secondary-subtle text-body text-decoration-none mt-2" href="/docs/programing/c++/default/35/"><picture><source srcset="/images/thumbnail_hu2c04c355e02fd9f63b765bcdb503cf1c_2284289_db4ab978a5e64c694fdda20c4098bfd2.webp" type="image/webp"/><img class="hb-blog-post-card-img" src="https://www.hotmindshare.com/images/thumbnail_hu2c04c355e02fd9f63b765bcdb503cf1c_2284289_0x360_resize_box_3.c4a823371e7699a6d0a45f2ed38908a1.png" alt="C++ 预处理器" loading="lazy" height="360" width="630"/></picture></a><div class="card-body px-0 py-2 d-flex flex-column"><div class="hb-blog-post-title card-title h5 py-1"><a class="hb-blog-post-title-link d-block" title="C++ 预处理器" href="/docs/programing/c++/default/35/">C++ 预处理器</a></div><div class="hb-blog-post-meta d-block text-nowrap text-truncate mb-2"><span class="hb-blog-post-taxonomy-meta"><a class="hb-blog-post-taxonomy hb-blog-post-taxonomy-category badge bg-secondary text-decoration-none fw-normal me-1" href="/categories/c++/">C++</a>
</span><span class="hb-blog-post-taxonomy-meta"><a class="hb-blog-post-taxonomy hb-blog-post-taxonomy-series badge bg-secondary text-decoration-none fw-normal me-1" href="/series/%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/">基础教程</a></span></div><div class="hb-blog-post-summary card-text text-secondary mb-auto">C++ 预处理器 预处理器是一些指令，指示编译器在实际编译之前所需完成的预处理。
所有的预处理器指令都是以井号（#）开头，只有空格字符可以出现在预处理指令之前。预处理指令不是 C++ 语句，所以它们不会以分号（;）结尾。
我们已经看到，之前所有的实例中都有 #include 指令。这个宏用于把头文件包含到源文件中。
C++ 还支持很多预处理指令，比如 #include、#define、#if、#else、#line 等，让我们一起看看这些重要指令。
#define 预处理 #define 预处理指令用于创建符号常量。该符号常量通常称为宏，指令的一般形式是：
1#define macro-name replacement-text 当这一行代码出现在一个文件中时，在该文件中后续出现的所有宏都将会在程序编译之前被替换为 replacement-text。例如：
1#include &lt;iostream&gt; 2using namespace std; 3#define PI 3.14159 4int main () 5 cout &lt;&lt; &#34;Value of PI :&#34; &lt;&lt; PI &lt;&lt; endl; 6 return 0; 现在，让我们测试这段代码，看看预处理的结果。假设源代码文件已经存在，接下来使用 -E 选项进行编译，并把结果重定向到 test.p。现在，如果您查看 test.p 文件，将会看到它已经包含大量的信息，而且在文件底部的值被改为如下：
1$gcc -E test.cpp &gt; test.p 2... 3int main () 4 cout &lt;&lt; &#34;Value of PI :&#34; &lt;&lt; 3.</div><div class="mt-2"><a class="text-secondary" href="/docs/programing/c++/default/35/">阅读更多关于C++ 预处理器的内容。</a></div></div></div></div><div class="col"><div class="hb-blog-post-card card border-0 overflow-hidden h-100 hb-module mb-0"><div class="hb-blog-post-meta d-flex align-items-center"><a class="hb-blog-post-author-link text-decoration-none" href="/authors/andywu/" title="安图新"><picture><img class="hb-blog-author-img rounded-circle" src="https://cdn.hotmindshare.com/public%2Fandyng_1000x1000.png" alt="安图新" loading="lazy"/>
</picture></a><span class="hb-blog-post-date">2022年10月6日</span>
<span class="hb-blog-post-reading-time">2 分钟阅读</span>
<span class="hb-blog-post-section"><a class="badge bg-secondary text-decoration-none fw-normal" href="/docs/">技术教程</a></span></div><a class="card-img-top overflow-hidden border border-secondary-subtle text-body text-decoration-none mt-2" href="/docs/code-design/34_miss/"><picture><source srcset="/images/thumbnail_hu2c04c355e02fd9f63b765bcdb503cf1c_2284289_db4ab978a5e64c694fdda20c4098bfd2.webp" type="image/webp"/><img class="hb-blog-post-card-img" src="https://www.hotmindshare.com/images/thumbnail_hu2c04c355e02fd9f63b765bcdb503cf1c_2284289_0x360_resize_box_3.c4a823371e7699a6d0a45f2ed38908a1.png" alt="三十四、前端控制器模式(Front Controller Pattern)" loading="lazy" height="360" width="630"/></picture></a><div class="card-body px-0 py-2 d-flex flex-column"><div class="hb-blog-post-title card-title h5 py-1"><a class="hb-blog-post-title-link d-block" title="三十四、前端控制器模式(Front Controller Pattern)" href="/docs/code-design/34_miss/">三十四、前端控制器模式(Front Controller Pattern)</a></div><div class="hb-blog-post-meta d-block text-nowrap text-truncate mb-2"><span class="hb-blog-post-taxonomy-meta"><a class="hb-blog-post-taxonomy hb-blog-post-taxonomy-category badge bg-secondary text-decoration-none fw-normal me-1" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a>
</span><span class="hb-blog-post-taxonomy-meta"><a class="hb-blog-post-taxonomy hb-blog-post-taxonomy-series badge bg-secondary text-decoration-none fw-normal me-1" href="/series/%E8%BF%9B%E9%98%B6%E6%95%99%E7%A8%8B/">进阶教程</a></span></div><div class="hb-blog-post-summary card-text text-secondary mb-auto">前端控制器模式（Front Controller Pattern）是用来提供一个集中的请求处理机制，所有的请求都将由一个单一的处理程序处理
该处理程序可以做认证/授权/记录日志，或者跟踪请求，然后把请求传给相应的处理程序
前端控制器模式涉及以下实体
前端控制器（Front Controller） - 处理应用程序所有类型请求的单个处理程序，应用程序可以是基于 web 的应用程序，也可以是基于桌面的应用程序。 调度器（Dispatcher） - 前端控制器可能使用一个调度器对象来调度请求到相应的具体处理程序。 视图（View） - 视图是为请求而创建的对象。 实现 1、 定义类FrontController、Dispatcher分别当作前端控制器和调度器；
2、 定义类HomeView和StudentView表示作为前端控制器接收到的请求而创建的视图；
3、 定义类FrontControllerPatternDemo使用FrontController演示前端控制器设计模式；
范例 1. 创建视图 HomeView.java
1// author: DDKK.COM 弟弟快看，程序员编程资料站(ddkk.com) 2// Copyright © 2015-2065 ddkk.com. All rights reserved. 3package com.ddkk.gof; 4public class HomeView { 5 public void show(){ 6 System.out.println(&#34;Displaying Home Page&#34;); 7 } StudentView.java
1// author: DDKK.COM 弟弟快看，程序员编程资料站(ddkk.com) 2// Copyright © 2015-2065 ddkk.com. All rights reserved. 3package com.</div><div class="mt-2"><a class="text-secondary" href="/docs/code-design/34_miss/">阅读更多关于三十四、前端控制器模式(Front Controller Pattern)的内容。</a></div></div></div></div><div class="col"><div class="hb-blog-post-card card border-0 overflow-hidden h-100 hb-module mb-0"><div class="hb-blog-post-meta d-flex align-items-center"><a class="hb-blog-post-author-link text-decoration-none" href="/authors/andywu/" title="安图新"><picture><img class="hb-blog-author-img rounded-circle" src="https://cdn.hotmindshare.com/public%2Fandyng_1000x1000.png" alt="安图新" loading="lazy"/>
</picture></a><span class="hb-blog-post-date">2022年10月6日</span>
<span class="hb-blog-post-reading-time">2 分钟阅读</span>
<span class="hb-blog-post-section"><a class="badge bg-secondary text-decoration-none fw-normal" href="/docs/">技术教程</a></span></div><a class="card-img-top overflow-hidden border border-secondary-subtle text-body text-decoration-none mt-2" href="/docs/programing/c++/default/34/"><picture><source srcset="/images/thumbnail_hu2c04c355e02fd9f63b765bcdb503cf1c_2284289_db4ab978a5e64c694fdda20c4098bfd2.webp" type="image/webp"/><img class="hb-blog-post-card-img" src="https://www.hotmindshare.com/images/thumbnail_hu2c04c355e02fd9f63b765bcdb503cf1c_2284289_0x360_resize_box_3.c4a823371e7699a6d0a45f2ed38908a1.png" alt="C++ 模板" loading="lazy" height="360" width="630"/></picture></a><div class="card-body px-0 py-2 d-flex flex-column"><div class="hb-blog-post-title card-title h5 py-1"><a class="hb-blog-post-title-link d-block" title="C++ 模板" href="/docs/programing/c++/default/34/">C++ 模板</a></div><div class="hb-blog-post-meta d-block text-nowrap text-truncate mb-2"><span class="hb-blog-post-taxonomy-meta"><a class="hb-blog-post-taxonomy hb-blog-post-taxonomy-category badge bg-secondary text-decoration-none fw-normal me-1" href="/categories/c++/">C++</a>
</span><span class="hb-blog-post-taxonomy-meta"><a class="hb-blog-post-taxonomy hb-blog-post-taxonomy-series badge bg-secondary text-decoration-none fw-normal me-1" href="/series/%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/">基础教程</a></span></div><div class="hb-blog-post-summary card-text text-secondary mb-auto">C++ 模板 模板是泛型编程的基础，泛型编程即以一种独立于任何特定类型的方式编写代码。
模板是创建泛型类或函数的蓝图或公式。库容器，比如迭代器和算法，都是泛型编程的例子，它们都使用了模板的概念。
每个容器都有一个单一的定义，比如 向量，我们可以定义许多不同类型的向量，比如 vector 或 vector 。
您可以使用模板来定义函数和类，接下来让我们一起来看看如何使用。
函数模板 模板函数定义的一般形式如下所示：
1template &lt;class type&gt; ret-type func-name(parameter list) 2 // 函数的主体 3} 在这里，type 是函数所使用的数据类型的占位符名称。这个名称可以在函数定义中使用。
下面是函数模板的实例，返回两个数中的最大值：
1#include &lt;iostream&gt; 2#include &lt;string&gt; 3using namespace std; 4template &lt;typename T&gt; 5inline T const&amp; Max (T const&amp; a, T const&amp; b) 6{ 7 return a &lt; b ? b:a; 8} 9int main () 10 int i = 39; 11 int j = 20; 12 cout &lt;&lt; &#34;Max(i, j): &#34; &lt;&lt; Max(i, j) &lt;&lt; endl; 13 double f1 = 13.</div><div class="mt-2"><a class="text-secondary" href="/docs/programing/c++/default/34/">阅读更多关于C++ 模板的内容。</a></div></div></div></div><div class="col"><div class="hb-blog-post-card card border-0 overflow-hidden h-100 hb-module mb-0"><div class="hb-blog-post-meta d-flex align-items-center"><a class="hb-blog-post-author-link text-decoration-none" href="/authors/andywu/" title="安图新"><picture><img class="hb-blog-author-img rounded-circle" src="https://cdn.hotmindshare.com/public%2Fandyng_1000x1000.png" alt="安图新" loading="lazy"/>
</picture></a><span class="hb-blog-post-date">2022年10月6日</span>
<span class="hb-blog-post-reading-time">3 分钟阅读</span>
<span class="hb-blog-post-section"><a class="badge bg-secondary text-decoration-none fw-normal" href="/docs/">技术教程</a></span></div><a class="card-img-top overflow-hidden border border-secondary-subtle text-body text-decoration-none mt-2" href="/docs/code-design/33_miss/"><picture><source srcset="/images/thumbnail_hu2c04c355e02fd9f63b765bcdb503cf1c_2284289_db4ab978a5e64c694fdda20c4098bfd2.webp" type="image/webp"/><img class="hb-blog-post-card-img" src="https://www.hotmindshare.com/images/thumbnail_hu2c04c355e02fd9f63b765bcdb503cf1c_2284289_0x360_resize_box_3.c4a823371e7699a6d0a45f2ed38908a1.png" alt="三十三、数据访问对象模式 ( Data Access Object )" loading="lazy" height="360" width="630"/></picture></a><div class="card-body px-0 py-2 d-flex flex-column"><div class="hb-blog-post-title card-title h5 py-1"><a class="hb-blog-post-title-link d-block" title="三十三、数据访问对象模式 ( Data Access Object )" href="/docs/code-design/33_miss/">三十三、数据访问对象模式 ( Data Access Object )</a></div><div class="hb-blog-post-meta d-block text-nowrap text-truncate mb-2"><span class="hb-blog-post-taxonomy-meta"><a class="hb-blog-post-taxonomy hb-blog-post-taxonomy-category badge bg-secondary text-decoration-none fw-normal me-1" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a>
</span><span class="hb-blog-post-taxonomy-meta"><a class="hb-blog-post-taxonomy hb-blog-post-taxonomy-series badge bg-secondary text-decoration-none fw-normal me-1" href="/series/%E8%BF%9B%E9%98%B6%E6%95%99%E7%A8%8B/">进阶教程</a></span></div><div class="hb-blog-post-summary card-text text-secondary mb-auto">数据访问对象模式（Data Access Object Pattern）或 DAO 模式用于把低级的数据访问 API 或操作从高级的业务服务中分离出来
数据访问模式涉及到的参与者有：
数据访问对象接口（Data Access Object Interface） - 该接口定义了在一个模型对象上要执行的标准操作 数据访问对象实体类（Data Access Object concrete class） - 该类实现了上述的接口。该类负责从数据源获取数据，数据源可以是数据库，也可以是 xml，或者是其他的存储机制 模型对象/数值对象（Model Object/Value Object） - 该对象是简单的 POJO，包含了 get/set 方法来存储通过使用 DAO 类检索到的数据 实现 1、 创建一个作为模型对象或数值对象的Student对象；
2、 定义StudentDao作为数据访问对象接口；
3、 定义StudentDaoImpl实现了数据访问对象接口的实体类；
4、 定义DaoPatternDemo使用StudentDao来演示数据访问对象模式的用法；
范例 1. 创建数值对象 Student.java
1// author: DDKK.COM 弟弟快看，程序员编程资料站(ddkk.com) 2// Copyright © 2015-2065 ddkk.com. All rights reserved. 3package com.ddkk.gof; 4public class Student { 5 private String name; 6 private int rollNo; 7 Student(String name, int rollNo){ 8 this.</div><div class="mt-2"><a class="text-secondary" href="/docs/code-design/33_miss/">阅读更多关于三十三、数据访问对象模式 ( Data Access Object )的内容。</a></div></div></div></div><div class="col"><div class="hb-blog-post-card card border-0 overflow-hidden h-100 hb-module mb-0"><div class="hb-blog-post-meta d-flex align-items-center"><a class="hb-blog-post-author-link text-decoration-none" href="/authors/andywu/" title="安图新"><picture><img class="hb-blog-author-img rounded-circle" src="https://cdn.hotmindshare.com/public%2Fandyng_1000x1000.png" alt="安图新" loading="lazy"/>
</picture></a><span class="hb-blog-post-date">2022年10月6日</span>
<span class="hb-blog-post-reading-time">2 分钟阅读</span>
<span class="hb-blog-post-section"><a class="badge bg-secondary text-decoration-none fw-normal" href="/docs/">技术教程</a></span></div><a class="card-img-top overflow-hidden border border-secondary-subtle text-body text-decoration-none mt-2" href="/docs/programing/c++/default/33/"><picture><source srcset="/images/thumbnail_hu2c04c355e02fd9f63b765bcdb503cf1c_2284289_db4ab978a5e64c694fdda20c4098bfd2.webp" type="image/webp"/><img class="hb-blog-post-card-img" src="https://www.hotmindshare.com/images/thumbnail_hu2c04c355e02fd9f63b765bcdb503cf1c_2284289_0x360_resize_box_3.c4a823371e7699a6d0a45f2ed38908a1.png" alt="C++ 命名空间" loading="lazy" height="360" width="630"/></picture></a><div class="card-body px-0 py-2 d-flex flex-column"><div class="hb-blog-post-title card-title h5 py-1"><a class="hb-blog-post-title-link d-block" title="C++ 命名空间" href="/docs/programing/c++/default/33/">C++ 命名空间</a></div><div class="hb-blog-post-meta d-block text-nowrap text-truncate mb-2"><span class="hb-blog-post-taxonomy-meta"><a class="hb-blog-post-taxonomy hb-blog-post-taxonomy-category badge bg-secondary text-decoration-none fw-normal me-1" href="/categories/c++/">C++</a>
</span><span class="hb-blog-post-taxonomy-meta"><a class="hb-blog-post-taxonomy hb-blog-post-taxonomy-series badge bg-secondary text-decoration-none fw-normal me-1" href="/series/%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/">基础教程</a></span></div><div class="hb-blog-post-summary card-text text-secondary mb-auto">C++ 命名空间 假设这样一种情况，当一个班上有两个名叫 Zara 的学生时，为了明确区分它们，我们在使用名字之外，不得不使用一些额外的信息，比如他们的家庭住址，或者他们父母的名字等等。
同样的情况也出现在 C++ 应用程序中。例如，您可能会写一个名为 xyz() 的函数，在另一个可用的库中也存在一个相同的函数 xyz()。这样，编译器就无法判断您所使用的是哪一个 xyz() 函数。
因此，引入了命名空间这个概念，专门用于解决上面的问题，它可作为附加信息来区分不同库中相同名称的函数、类、变量等。使用了命名空间即定义了上下文。本质上，命名空间就是定义了一个范围。
定义命名空间 命名空间的定义使用关键字 namespace，后跟命名空间的名称，如下所示：
1namespace namespace_name { 2 // 代码声明 为了调用带有命名空间的函数或变量，需要在前面加上命名空间的名称，如下所示：
1name::code; // code 可以是变量或函数 让我们来看看命名空间如何为变量或函数等实体定义范围：
1#include &lt;iostream&gt; 2using namespace std; 3// 第一个命名空间 4namespace first_space{ 5 void func(){ 6 cout &lt;&lt; &#34;Inside first_space&#34; &lt;&lt; endl; 7 } 8// 第二个命名空间 9namespace second_space{ 10 void func(){ 11 cout &lt;&lt; &#34;Inside second_space&#34; &lt;&lt; endl; 12 } 13int main () 14 // 调用第一个命名空间中的函数 15 first_space::func(); 16 // 调用第二个命名空间中的函数 17 second_space::func(); 18 return 0; 当上面的代码被编译和执行时，它会产生下列结果：</div><div class="mt-2"><a class="text-secondary" href="/docs/programing/c++/default/33/">阅读更多关于C++ 命名空间的内容。</a></div></div></div></div><div class="col"><div class="hb-blog-post-card card border-0 overflow-hidden h-100 hb-module mb-0"><div class="hb-blog-post-meta d-flex align-items-center"><a class="hb-blog-post-author-link text-decoration-none" href="/authors/andywu/" title="安图新"><picture><img class="hb-blog-author-img rounded-circle" src="https://cdn.hotmindshare.com/public%2Fandyng_1000x1000.png" alt="安图新" loading="lazy"/>
</picture></a><span class="hb-blog-post-date">2022年10月6日</span>
<span class="hb-blog-post-reading-time">2 分钟阅读</span>
<span class="hb-blog-post-section"><a class="badge bg-secondary text-decoration-none fw-normal" href="/docs/">技术教程</a></span></div><a class="card-img-top overflow-hidden border border-secondary-subtle text-body text-decoration-none mt-2" href="/docs/code-design/37_miss/"><picture><source srcset="/images/thumbnail_hu2c04c355e02fd9f63b765bcdb503cf1c_2284289_db4ab978a5e64c694fdda20c4098bfd2.webp" type="image/webp"/><img class="hb-blog-post-card-img" src="https://www.hotmindshare.com/images/thumbnail_hu2c04c355e02fd9f63b765bcdb503cf1c_2284289_0x360_resize_box_3.c4a823371e7699a6d0a45f2ed38908a1.png" alt="三十七、传输对象模式 ( Transfer Object Pattern )" loading="lazy" height="360" width="630"/></picture></a><div class="card-body px-0 py-2 d-flex flex-column"><div class="hb-blog-post-title card-title h5 py-1"><a class="hb-blog-post-title-link d-block" title="三十七、传输对象模式 ( Transfer Object Pattern )" href="/docs/code-design/37_miss/">三十七、传输对象模式 ( Transfer Object Pattern )</a></div><div class="hb-blog-post-meta d-block text-nowrap text-truncate mb-2"><span class="hb-blog-post-taxonomy-meta"><a class="hb-blog-post-taxonomy hb-blog-post-taxonomy-category badge bg-secondary text-decoration-none fw-normal me-1" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a>
</span><span class="hb-blog-post-taxonomy-meta"><a class="hb-blog-post-taxonomy hb-blog-post-taxonomy-series badge bg-secondary text-decoration-none fw-normal me-1" href="/series/%E8%BF%9B%E9%98%B6%E6%95%99%E7%A8%8B/">进阶教程</a></span></div><div class="hb-blog-post-summary card-text text-secondary mb-auto">传输对象模式（Transfer Object Pattern）用于从客户端向服务器一次性传递带有多个属性的数据
传输对象也被称为数值对象，没有任何行为
传输对象是一个具有 getter/setter 方法的简单的 POJO 类，它是可序列化的，所以它可以通过网络传输
服务器端的业务类通常从数据库读取数据，然后填充 POJO，并把它发送到客户端或按值传递它
对于客户端，传输对象是只读的
客户端可以创建自己的传输对象，并把它传递给服务器，以便一次性更新数据库中的数值
以下是这种设计模式的实体:
业务对象（Business Object） - 为传输对象填充数据的业务服务 传输对象（Transfer Object） - 简单的 POJO，只有设置/获取属性的方法 客户端（Client） - 客户端可以发送请求或者发送传输对象到业务对象 实现 创建一个作为业务对象的 StudentBO 和作为传输对象的 StudentVO ，它们都代表了我们的实体
TransferObjectPatternDemo ，我们的演示类在这里是作为一个客户端，将使用 StudentBO 和 Student 来演示传输对象设计模式
范例 1. 创建传输对象 StudentVO 1// author: DDKK.COM 弟弟快看，程序员编程资料站(ddkk.com) 2// Copyright © 2015-2065 ddkk.com. All rights reserved. 3package com.ddkk.gof; 4public class StudentVO 5 private String name; 6 private int rollNo; 7 StudentVO(String name, int rollNo){ 8 this.</div><div class="mt-2"><a class="text-secondary" href="/docs/code-design/37_miss/">阅读更多关于三十七、传输对象模式 ( Transfer Object Pattern )的内容。</a></div></div></div></div><div class="col"><div class="hb-blog-post-card card border-0 overflow-hidden h-100 hb-module mb-0"><div class="hb-blog-post-meta d-flex align-items-center"><a class="hb-blog-post-author-link text-decoration-none" href="/authors/andywu/" title="安图新"><picture><img class="hb-blog-author-img rounded-circle" src="https://cdn.hotmindshare.com/public%2Fandyng_1000x1000.png" alt="安图新" loading="lazy"/>
</picture></a><span class="hb-blog-post-date">2022年10月6日</span>
<span class="hb-blog-post-reading-time">5 分钟阅读</span>
<span class="hb-blog-post-section"><a class="badge bg-secondary text-decoration-none fw-normal" href="/docs/">技术教程</a></span></div><a class="card-img-top overflow-hidden border border-secondary-subtle text-body text-decoration-none mt-2" href="/docs/programing/c++/default/37/"><picture><source srcset="/images/thumbnail_hu2c04c355e02fd9f63b765bcdb503cf1c_2284289_db4ab978a5e64c694fdda20c4098bfd2.webp" type="image/webp"/><img class="hb-blog-post-card-img" src="https://www.hotmindshare.com/images/thumbnail_hu2c04c355e02fd9f63b765bcdb503cf1c_2284289_0x360_resize_box_3.c4a823371e7699a6d0a45f2ed38908a1.png" alt="C++ 多线程" loading="lazy" height="360" width="630"/></picture></a><div class="card-body px-0 py-2 d-flex flex-column"><div class="hb-blog-post-title card-title h5 py-1"><a class="hb-blog-post-title-link d-block" title="C++ 多线程" href="/docs/programing/c++/default/37/">C++ 多线程</a></div><div class="hb-blog-post-meta d-block text-nowrap text-truncate mb-2"><span class="hb-blog-post-taxonomy-meta"><a class="hb-blog-post-taxonomy hb-blog-post-taxonomy-category badge bg-secondary text-decoration-none fw-normal me-1" href="/categories/c++/">C++</a>
</span><span class="hb-blog-post-taxonomy-meta"><a class="hb-blog-post-taxonomy hb-blog-post-taxonomy-series badge bg-secondary text-decoration-none fw-normal me-1" href="/series/%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/">基础教程</a></span></div><div class="hb-blog-post-summary card-text text-secondary mb-auto">C++ 多线程 多线程是多任务处理的一种特殊形式，多任务处理允许让电脑同时运行两个或两个以上的程序。在一般情况下，有两种类型的多任务处理：基于进程和基于线程。
基于进程的多任务处理处理的是程序的并发执行。基于线程的多任务处理的是同一程序的片段的并发执行。
多线程程序包含可以同时运行的两个或多个部分。这样的程序中的每个部分称为一个线程，每个线程定义了一个单独的执行路径。
C++不包含多线程应用程序的任何内置支持。相反，它完全依赖于操作系统来提供此功能。
本教程假设您使用的是 Linux 操作系统，我们要使用 POSIX 编写多线程 C++ 程序。POSIX Threads 或 Pthreads 提供的 API 可在多种类 Unix POSIX 系统上可用，比如 FreeBSD、NetBSD、GNU/Linux、Mac OS X 和 Solaris。
创建线程 有下面的例程，我们可以用它来创建一个 POSIX 线程：
1#include &lt;pthread.h&gt; 2pthread_create (thread, attr, start_routine, arg) 在这里，pthread_create 创建一个新的线程，并让它可执行。这个例程可在代码内的任何地方被调用任意次数。下面是关于参数的说明：
参数 描述 thread 一个不透明的、唯一的标识符，用来标识例程返回的新线程。 attr 一个不透明的属性对象，可以被用来设置线程属性。您可以指定线程属性对象，也可以使用默认值 NULL。 start_routine C++ 例程，一旦线程被创建就会执行。 arg 一个可能传递给 start_routine 的参数。它必须通过把引用作为指针强制转换为 void 类型进行传递。如果没有传递参数，则使用 NULL。 一个进程可以创建的最大线程数是依赖于实现的。线程一旦被创建，就是同等的，而且可以创建其他线程。线程之间没有隐含层次或依赖。
终止线程 有下面的例程，我们可以用它来终止一个 POSIX 线程：
1#include &lt;pthread.h&gt; 2pthread_exit (status) 在这里，pthread_exit 用于显式地退出一个线程。通常情况下，pthread_exit() 例程是在线程完成工作后无需继续存在时被调用。
如果main() 是在它所创建的线程之前结束，并通过 pthread_exit() 退出，那么其他线程将继续执行。否则，它们将在 main() 结束时自动被终止。</div><div class="mt-2"><a class="text-secondary" href="/docs/programing/c++/default/37/">阅读更多关于C++ 多线程的内容。</a></div></div></div></div><div class="col"><div class="hb-blog-post-card card border-0 overflow-hidden h-100 hb-module mb-0"><div class="hb-blog-post-meta d-flex align-items-center"><a class="hb-blog-post-author-link text-decoration-none" href="/authors/andywu/" title="安图新"><picture><img class="hb-blog-author-img rounded-circle" src="https://cdn.hotmindshare.com/public%2Fandyng_1000x1000.png" alt="安图新" loading="lazy"/>
</picture></a><span class="hb-blog-post-date">2022年10月6日</span>
<span class="hb-blog-post-reading-time">3 分钟阅读</span>
<span class="hb-blog-post-section"><a class="badge bg-secondary text-decoration-none fw-normal" href="/docs/">技术教程</a></span></div><a class="card-img-top overflow-hidden border border-secondary-subtle text-body text-decoration-none mt-2" href="/docs/code-design/36_miss/"><picture><source srcset="/images/thumbnail_hu2c04c355e02fd9f63b765bcdb503cf1c_2284289_db4ab978a5e64c694fdda20c4098bfd2.webp" type="image/webp"/><img class="hb-blog-post-card-img" src="https://www.hotmindshare.com/images/thumbnail_hu2c04c355e02fd9f63b765bcdb503cf1c_2284289_0x360_resize_box_3.c4a823371e7699a6d0a45f2ed38908a1.png" alt="三十六、服务定位器模式 (Service Locator Pattern)" loading="lazy" height="360" width="630"/></picture></a><div class="card-body px-0 py-2 d-flex flex-column"><div class="hb-blog-post-title card-title h5 py-1"><a class="hb-blog-post-title-link d-block" title="三十六、服务定位器模式 (Service Locator Pattern)" href="/docs/code-design/36_miss/">三十六、服务定位器模式 (Service Locator Pattern)</a></div><div class="hb-blog-post-meta d-block text-nowrap text-truncate mb-2"><span class="hb-blog-post-taxonomy-meta"><a class="hb-blog-post-taxonomy hb-blog-post-taxonomy-category badge bg-secondary text-decoration-none fw-normal me-1" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a>
</span><span class="hb-blog-post-taxonomy-meta"><a class="hb-blog-post-taxonomy hb-blog-post-taxonomy-series badge bg-secondary text-decoration-none fw-normal me-1" href="/series/%E8%BF%9B%E9%98%B6%E6%95%99%E7%A8%8B/">进阶教程</a></span></div><div class="hb-blog-post-summary card-text text-secondary mb-auto">服务定位器模式（Service Locator Pattern）用于想使用 JNDI 查询定位各种服务的时候
考虑到为某个服务查找 JNDI 的代价很高，服务定位器模式充分利用了缓存技术
在首次请求某个服务时，服务定位器在 JNDI 中查找服务，并缓存该服务对象
当再次请求相同的服务时，服务定位器会在它的缓存中查找，这样可以在很大程度上提高应用程序的性能
以下是这种设计模式的实体
服务（Service） - 实际处理请求的服务。对这种服务的引用可以在 JNDI 服务器中查找到 Context / 初始的 Context - JNDI Context 带有对要查找的服务的引用 服务定位器（Service Locator） - 服务定位器是通过 JNDI 查找和缓存服务来获取服务的单点接触 缓存（Cache） - 缓存存储服务的引用，以便复用它们 客户端（Client） - Client 是通过 ServiceLocator 调用服务的对象 实现 创建 ServiceLocator 、 InitialContext 、 Cache 、 Service 作为表示实体的各种对象
Service1 和 Service2 表示实体服务
ServiceLocatorPatternDemo ，我们的演示类在这里是作为一个客户端，将使用 ServiceLocator 来演示服务定位器设计模式
范例 1. 创建服务接口 Service 1// author: DDKK.COM 弟弟快看，程序员编程资料站(ddkk.com) 2// Copyright © 2015-2065 ddkk.</div><div class="mt-2"><a class="text-secondary" href="/docs/code-design/36_miss/">阅读更多关于三十六、服务定位器模式 (Service Locator Pattern)的内容。</a></div></div></div></div><div class="col"><div class="hb-blog-post-card card border-0 overflow-hidden h-100 hb-module mb-0"><div class="hb-blog-post-meta d-flex align-items-center"><a class="hb-blog-post-author-link text-decoration-none" href="/authors/andywu/" title="安图新"><picture><img class="hb-blog-author-img rounded-circle" src="https://cdn.hotmindshare.com/public%2Fandyng_1000x1000.png" alt="安图新" loading="lazy"/>
</picture></a><span class="hb-blog-post-date">2022年10月6日</span>
<span class="hb-blog-post-reading-time">2 分钟阅读</span>
<span class="hb-blog-post-section"><a class="badge bg-secondary text-decoration-none fw-normal" href="/docs/">技术教程</a></span></div><a class="card-img-top overflow-hidden border border-secondary-subtle text-body text-decoration-none mt-2" href="/docs/programing/c++/default/36/"><picture><source srcset="/images/thumbnail_hu2c04c355e02fd9f63b765bcdb503cf1c_2284289_db4ab978a5e64c694fdda20c4098bfd2.webp" type="image/webp"/><img class="hb-blog-post-card-img" src="https://www.hotmindshare.com/images/thumbnail_hu2c04c355e02fd9f63b765bcdb503cf1c_2284289_0x360_resize_box_3.c4a823371e7699a6d0a45f2ed38908a1.png" alt="C++ 信号处理" loading="lazy" height="360" width="630"/></picture></a><div class="card-body px-0 py-2 d-flex flex-column"><div class="hb-blog-post-title card-title h5 py-1"><a class="hb-blog-post-title-link d-block" title="C++ 信号处理" href="/docs/programing/c++/default/36/">C++ 信号处理</a></div><div class="hb-blog-post-meta d-block text-nowrap text-truncate mb-2"><span class="hb-blog-post-taxonomy-meta"><a class="hb-blog-post-taxonomy hb-blog-post-taxonomy-category badge bg-secondary text-decoration-none fw-normal me-1" href="/categories/c++/">C++</a>
</span><span class="hb-blog-post-taxonomy-meta"><a class="hb-blog-post-taxonomy hb-blog-post-taxonomy-series badge bg-secondary text-decoration-none fw-normal me-1" href="/series/%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/">基础教程</a></span></div><div class="hb-blog-post-summary card-text text-secondary mb-auto">C++ 信号处理 信号是由操作系统传给进程的中断，会提早终止一个程序。在 UNIX、LINUX、Mac OS X 或 Windows 系统上，可以通过按 Ctrl+C 产生中断。
有些信号不能被程序捕获，但是下表所列信号可以在程序中捕获，并可以基于信号采取适当的动作。这些信号是定义在 C++ 头文件 中。
信号 描述 SIGABRT 程序的异常终止，如调用 abort。 SIGFPE 错误的算术运算，比如除以零或导致溢出的操作。 SIGILL 检测非法指令。 SIGINT 接收到交互注意信号。 SIGSEGV 非法访问内存。 SIGTERM 发送到程序的终止请求。 signal() 函数 C++信号处理库提供了 signal 函数，用来捕获突发事件。以下是 signal() 函数的语法：
1void (*signal (int sig, void (*func)(int)))(int); 这个函数接收两个参数：第一个参数是一个整数，代表了信号的编号；第二个参数是一个指向信号处理函数的指针。
让我们编写一个简单的 C++ 程序，使用 signal() 函数捕获 SIGINT 信号。不管您想在程序中捕获什么信号，您都必须使用 signal 函数来注册信号，并将其与信号处理程序相关联。看看下面的实例：
1#include &lt;iostream&gt; 2#include &lt;csignal&gt; 3#include &lt;unistd.h&gt; 4using namespace std; 5void signalHandler( int signum ) 6 cout &lt;&lt; &#34;Interrupt signal (&#34; &lt;&lt; signum &lt;&lt; &#34;) received.</div><div class="mt-2"><a class="text-secondary" href="/docs/programing/c++/default/36/">阅读更多关于C++ 信号处理的内容。</a></div></div></div></div><div class="col"><div class="hb-blog-post-card card border-0 overflow-hidden h-100 hb-module mb-0"><div class="hb-blog-post-meta d-flex align-items-center"><a class="hb-blog-post-author-link text-decoration-none" href="/authors/andywu/" title="安图新"><picture><img class="hb-blog-author-img rounded-circle" src="https://cdn.hotmindshare.com/public%2Fandyng_1000x1000.png" alt="安图新" loading="lazy"/>
</picture></a><span class="hb-blog-post-date">2022年10月6日</span>
<span class="hb-blog-post-reading-time">2 分钟阅读</span>
<span class="hb-blog-post-section"><a class="badge bg-secondary text-decoration-none fw-normal" href="/docs/">技术教程</a></span></div><a class="card-img-top overflow-hidden border border-secondary-subtle text-body text-decoration-none mt-2" href="/docs/programing/c++/default/39/"><picture><source srcset="/images/thumbnail_hu2c04c355e02fd9f63b765bcdb503cf1c_2284289_db4ab978a5e64c694fdda20c4098bfd2.webp" type="image/webp"/><img class="hb-blog-post-card-img" src="https://www.hotmindshare.com/images/thumbnail_hu2c04c355e02fd9f63b765bcdb503cf1c_2284289_0x360_resize_box_3.c4a823371e7699a6d0a45f2ed38908a1.png" alt="C++ STL 教程" loading="lazy" height="360" width="630"/></picture></a><div class="card-body px-0 py-2 d-flex flex-column"><div class="hb-blog-post-title card-title h5 py-1"><a class="hb-blog-post-title-link d-block" title="C++ STL 教程" href="/docs/programing/c++/default/39/">C++ STL 教程</a></div><div class="hb-blog-post-meta d-block text-nowrap text-truncate mb-2"><span class="hb-blog-post-taxonomy-meta"><a class="hb-blog-post-taxonomy hb-blog-post-taxonomy-category badge bg-secondary text-decoration-none fw-normal me-1" href="/categories/c++/">C++</a>
</span><span class="hb-blog-post-taxonomy-meta"><a class="hb-blog-post-taxonomy hb-blog-post-taxonomy-series badge bg-secondary text-decoration-none fw-normal me-1" href="/series/%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/">基础教程</a></span></div><div class="hb-blog-post-summary card-text text-secondary mb-auto">C++ STL 教程 在前面的章节中，我们已经学习了 C++ 模板的概念。C++ STL（标准模板库）是一套功能强大的 C++ 模板类，提供了通用的模板类和函数，这些模板类和函数可以实现多种流行和常用的算法和数据结构，如向量、链表、队列、栈。
C++标准模板库的核心包括以下三个组件：
组件 描述 容器（Containers） 容器是用来管理某一类对象的集合。C++ 提供了各种不同类型的容器，比如 deque、list、vector、map 等。 算法（Algorithms） 算法作用于容器。它们提供了执行各种操作的方式，包括对容器内容执行初始化、排序、搜索和转换等操作。 迭代器（terators） 迭代器用于遍历对象集合的元素。这些集合可能是容器，也可能是容器的子集。 这三个组件都带有丰富的预定义函数，帮助我们通过简单的方式处理复杂的任务。
下面的程序演示了向量容器（一个 C++ 标准的模板），它与数组十分相似，唯一不同的是，向量在需要扩展大小的时候，会自动处理它自己的存储需求：
1#include &lt;iostream&gt; 2#include &lt;vector&gt; 3using namespace std; 4int main() 5 // 创建一个向量存储 int 6 vector&lt;int&gt; vec; 7 int i; 8 // 显示 vec 的原始大小 9 cout &lt;&lt; &#34;vector size = &#34; &lt;&lt; vec.size() &lt;&lt; endl; 10 // 推入 5 个值到向量中 11 for(i = 0; i &lt; 5; i++){ 12 vec.</div><div class="mt-2"><a class="text-secondary" href="/docs/programing/c++/default/39/">阅读更多关于C++ STL 教程的内容。</a></div></div></div></div><div class="col"><div class="hb-blog-post-card card border-0 overflow-hidden h-100 hb-module mb-0"><div class="hb-blog-post-meta d-flex align-items-center"><a class="hb-blog-post-author-link text-decoration-none" href="/authors/andywu/" title="安图新"><picture><img class="hb-blog-author-img rounded-circle" src="https://cdn.hotmindshare.com/public%2Fandyng_1000x1000.png" alt="安图新" loading="lazy"/>
</picture></a><span class="hb-blog-post-date">2022年10月6日</span>
<span class="hb-blog-post-reading-time">2 分钟阅读</span>
<span class="hb-blog-post-section"><a class="badge bg-secondary text-decoration-none fw-normal" href="/docs/">技术教程</a></span></div><a class="card-img-top overflow-hidden border border-secondary-subtle text-body text-decoration-none mt-2" href="/docs/code-design/32_miss/"><picture><source srcset="/images/thumbnail_hu2c04c355e02fd9f63b765bcdb503cf1c_2284289_db4ab978a5e64c694fdda20c4098bfd2.webp" type="image/webp"/><img class="hb-blog-post-card-img" src="https://www.hotmindshare.com/images/thumbnail_hu2c04c355e02fd9f63b765bcdb503cf1c_2284289_0x360_resize_box_3.c4a823371e7699a6d0a45f2ed38908a1.png" alt="三十二、组合实体模式 (Composite Entity Pattern)" loading="lazy" height="360" width="630"/></picture></a><div class="card-body px-0 py-2 d-flex flex-column"><div class="hb-blog-post-title card-title h5 py-1"><a class="hb-blog-post-title-link d-block" title="三十二、组合实体模式 (Composite Entity Pattern)" href="/docs/code-design/32_miss/">三十二、组合实体模式 (Composite Entity Pattern)</a></div><div class="hb-blog-post-meta d-block text-nowrap text-truncate mb-2"><span class="hb-blog-post-taxonomy-meta"><a class="hb-blog-post-taxonomy hb-blog-post-taxonomy-category badge bg-secondary text-decoration-none fw-normal me-1" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a>
</span><span class="hb-blog-post-taxonomy-meta"><a class="hb-blog-post-taxonomy hb-blog-post-taxonomy-series badge bg-secondary text-decoration-none fw-normal me-1" href="/series/%E8%BF%9B%E9%98%B6%E6%95%99%E7%A8%8B/">进阶教程</a></span></div><div class="hb-blog-post-summary card-text text-secondary mb-auto">组合实体模式（Composite Entity Pattern）用在 EJB 持久化机制中
一个组合实体是一个 EJB 实体 bean，代表了对象的图解
当更新一个组合实体时，内部依赖对象 beans 会自动更新，因为它们是由 EJB 实体 bean 管理的
以下是组合实体 bean 的参与者:
组合实体（Composite Entity） - 它是主要的实体 bean。它可以是粗粒的，或者可以包含一个粗粒度对象，用于持续生命周期 粗粒度对象（Coarse-Grained Object） - 该对象包含依赖对象。它有自己的生命周期，也能管理依赖对象的生命周期 依赖对象（Dependent Object） - 依赖对象是一个持续生命周期依赖于粗粒度对象的对象 策略（Strategies） - 策略表示如何实现组合实体 实现 1、 定义作为组合实体的CompositeEntity对象；
2、 定义CoarseGrainedObject是一个包含依赖对象的类；
3、 定义类CompositeEntityPatternDemo使用Client类来演示组合实体模式的用法；
范例 1. 创建依赖对象 DependentObject1.java
1// author: DDKK.COM 弟弟快看，程序员编程资料站(ddkk.com) 2// Copyright © 2015-2065 ddkk.com. All rights reserved. 3package com.ddkk.gof; 4public class DependentObject1 { 5 private String data; 6 public void setData(String data){ 7 this.</div><div class="mt-2"><a class="text-secondary" href="/docs/code-design/32_miss/">阅读更多关于三十二、组合实体模式 (Composite Entity Pattern)的内容。</a></div></div></div></div><div class="col"><div class="hb-blog-post-card card border-0 overflow-hidden h-100 hb-module mb-0"><div class="hb-blog-post-meta d-flex align-items-center"><a class="hb-blog-post-author-link text-decoration-none" href="/authors/andywu/" title="安图新"><picture><img class="hb-blog-author-img rounded-circle" src="https://cdn.hotmindshare.com/public%2Fandyng_1000x1000.png" alt="安图新" loading="lazy"/>
</picture></a><span class="hb-blog-post-date">2022年10月6日</span>
<span class="hb-blog-post-reading-time">2 分钟阅读</span>
<span class="hb-blog-post-section"><a class="badge bg-secondary text-decoration-none fw-normal" href="/docs/">技术教程</a></span></div><a class="card-img-top overflow-hidden border border-secondary-subtle text-body text-decoration-none mt-2" href="/docs/programing/c++/default/32/"><picture><source srcset="/images/thumbnail_hu2c04c355e02fd9f63b765bcdb503cf1c_2284289_db4ab978a5e64c694fdda20c4098bfd2.webp" type="image/webp"/><img class="hb-blog-post-card-img" src="https://www.hotmindshare.com/images/thumbnail_hu2c04c355e02fd9f63b765bcdb503cf1c_2284289_0x360_resize_box_3.c4a823371e7699a6d0a45f2ed38908a1.png" alt="C++ 动态内存" loading="lazy" height="360" width="630"/></picture></a><div class="card-body px-0 py-2 d-flex flex-column"><div class="hb-blog-post-title card-title h5 py-1"><a class="hb-blog-post-title-link d-block" title="C++ 动态内存" href="/docs/programing/c++/default/32/">C++ 动态内存</a></div><div class="hb-blog-post-meta d-block text-nowrap text-truncate mb-2"><span class="hb-blog-post-taxonomy-meta"><a class="hb-blog-post-taxonomy hb-blog-post-taxonomy-category badge bg-secondary text-decoration-none fw-normal me-1" href="/categories/c++/">C++</a>
</span><span class="hb-blog-post-taxonomy-meta"><a class="hb-blog-post-taxonomy hb-blog-post-taxonomy-series badge bg-secondary text-decoration-none fw-normal me-1" href="/series/%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/">基础教程</a></span></div><div class="hb-blog-post-summary card-text text-secondary mb-auto">C++ 动态内存 了解动态内存在 C++ 中是如何工作的是成为一名合格的 C++ 程序员必不可少的。C++ 程序中的内存分为两个部分：
**栈：**在函数内部声明的所有变量都将占用栈内存。 **堆：**这是程序中未使用的内存，在程序运行时可用于动态分配内存。 很多时候，您无法提前预知需要多少内存来存储某个定义变量中的特定信息，所需内存的大小需要在运行时才能确定。
在C++ 中，您可以使用特殊的运算符为给定类型的变量在运行时分配堆内的内存，这会返回所分配的空间地址。这种运算符即 new 运算符。
如果您不需要动态分配内存，可以使用 delete 运算符，删除之前由 new 运算符分配的内存。
new 和 delete 运算符 下面是使用 new 运算符来为任意的数据类型动态分配内存的通用语法：
1new data-type; 在这里，data-type 可以是包括数组在内的任意内置的数据类型，也可以是包括类或结构在内的用户自定义的任何数据类型。让我们先来看下内置的数据类型。例如，我们可以定义一个指向 double 类型的指针，然后请求内存，该内存在执行时被分配。我们可以按照下面的语句使用 new 运算符来完成这点：
1double* pvalue = NULL; // 初始化为 null 的指针 2pvalue = new double; // 为变量请求内存 如果自由存储区已被用完，可能无法成功分配内存。所以建议检查 new 运算符是否返回 NULL 指针，并采取以下适当的操作：
1double* pvalue = NULL; 2if( !(pvalue = new double )) 3 cout &lt;&lt; &#34;Error: out of memory.</div><div class="mt-2"><a class="text-secondary" href="/docs/programing/c++/default/32/">阅读更多关于C++ 动态内存的内容。</a></div></div></div></div><div class="col"><div class="hb-blog-post-card card border-0 overflow-hidden h-100 hb-module mb-0"><div class="hb-blog-post-meta d-flex align-items-center"><a class="hb-blog-post-author-link text-decoration-none" href="/authors/andywu/" title="安图新"><picture><img class="hb-blog-author-img rounded-circle" src="https://cdn.hotmindshare.com/public%2Fandyng_1000x1000.png" alt="安图新" loading="lazy"/>
</picture></a><span class="hb-blog-post-date">2022年10月6日</span>
<span class="hb-blog-post-reading-time">1 分钟阅读</span>
<span class="hb-blog-post-section"><a class="badge bg-secondary text-decoration-none fw-normal" href="/docs/">技术教程</a></span></div><a class="card-img-top overflow-hidden border border-secondary-subtle text-body text-decoration-none mt-2" href="/docs/code-design/38/"><picture><source srcset="/images/thumbnail_hu2c04c355e02fd9f63b765bcdb503cf1c_2284289_db4ab978a5e64c694fdda20c4098bfd2.webp" type="image/webp"/><img class="hb-blog-post-card-img" src="https://www.hotmindshare.com/images/thumbnail_hu2c04c355e02fd9f63b765bcdb503cf1c_2284289_0x360_resize_box_3.c4a823371e7699a6d0a45f2ed38908a1.png" alt="三十八、设计模式资源" loading="lazy" height="360" width="630"/></picture></a><div class="card-body px-0 py-2 d-flex flex-column"><div class="hb-blog-post-title card-title h5 py-1"><a class="hb-blog-post-title-link d-block" title="三十八、设计模式资源" href="/docs/code-design/38/">三十八、设计模式资源</a></div><div class="hb-blog-post-meta d-block text-nowrap text-truncate mb-2"><span class="hb-blog-post-taxonomy-meta"><a class="hb-blog-post-taxonomy hb-blog-post-taxonomy-category badge bg-secondary text-decoration-none fw-normal me-1" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a>
</span><span class="hb-blog-post-taxonomy-meta"><a class="hb-blog-post-taxonomy hb-blog-post-taxonomy-series badge bg-secondary text-decoration-none fw-normal me-1" href="/series/%E8%BF%9B%E9%98%B6%E6%95%99%E7%A8%8B/">进阶教程</a></span></div><div class="hb-blog-post-summary card-text text-secondary mb-auto">本章列出了设计模式相关的网站、书籍和文章
设计模式相关的网站 Wiki Page for Design Patterns - 以一种非常通用的方式检查设计模式。 Java Programming/Design Patterns - 一篇关于设计模式的好文章。 因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 The JavaTMTutorials - 该 Java 教程是为那些想用 Java 编程语言创建应用程序的编程人员提供的实用指南。 JavaTM2 SDK, Standard Edition - JavaTM2 SDK, Standard Edition 的官网。 Java DesignPatterns - 关于设计模式的短文。</div></div></div></div><div class="col"><div class="hb-blog-post-card card border-0 overflow-hidden h-100 hb-module mb-0"><div class="hb-blog-post-meta d-flex align-items-center"><a class="hb-blog-post-author-link text-decoration-none" href="/authors/andywu/" title="安图新"><picture><img class="hb-blog-author-img rounded-circle" src="https://cdn.hotmindshare.com/public%2Fandyng_1000x1000.png" alt="安图新" loading="lazy"/>
</picture></a><span class="hb-blog-post-date">2022年10月6日</span>
<span class="hb-blog-post-reading-time">9 分钟阅读</span>
<span class="hb-blog-post-section"><a class="badge bg-secondary text-decoration-none fw-normal" href="/docs/">技术教程</a></span></div><a class="card-img-top overflow-hidden border border-secondary-subtle text-body text-decoration-none mt-2" href="/docs/programing/c++/default/38/"><picture><source srcset="/images/thumbnail_hu2c04c355e02fd9f63b765bcdb503cf1c_2284289_db4ab978a5e64c694fdda20c4098bfd2.webp" type="image/webp"/><img class="hb-blog-post-card-img" src="https://www.hotmindshare.com/images/thumbnail_hu2c04c355e02fd9f63b765bcdb503cf1c_2284289_0x360_resize_box_3.c4a823371e7699a6d0a45f2ed38908a1.png" alt="C++ Web 编程" loading="lazy" height="360" width="630"/></picture></a><div class="card-body px-0 py-2 d-flex flex-column"><div class="hb-blog-post-title card-title h5 py-1"><a class="hb-blog-post-title-link d-block" title="C++ Web 编程" href="/docs/programing/c++/default/38/">C++ Web 编程</a></div><div class="hb-blog-post-meta d-block text-nowrap text-truncate mb-2"><span class="hb-blog-post-taxonomy-meta"><a class="hb-blog-post-taxonomy hb-blog-post-taxonomy-category badge bg-secondary text-decoration-none fw-normal me-1" href="/categories/c++/">C++</a>
</span><span class="hb-blog-post-taxonomy-meta"><a class="hb-blog-post-taxonomy hb-blog-post-taxonomy-series badge bg-secondary text-decoration-none fw-normal me-1" href="/series/%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/">基础教程</a></span></div><div class="hb-blog-post-summary card-text text-secondary mb-auto">C++ Web 编程 什么是 CGI？ 公共网关接口（CGI），是一套标准，定义了信息是如何在 Web 服务器和客户端脚本之间进行交换的。 CGI 规范目前是由 NCSA 维护的，NCSA 定义 CGI 如下： 公共网关接口（CGI），是一种用于外部网关程序与信息服务器（如 HTTP 服务器）对接的接口标准。 目前的版本是 CGI/1.1，CGI/1.2 版本正在推进中。 Web 浏览 为了更好地了解 CGI 的概念，让我们点击一个超链接，浏览一个特定的网页或 URL，看看会发生什么。
您的浏览器联系上 HTTP Web 服务器，并请求 URL，即文件名。 Web 服务器将解析 URL，并查找文件名。如果找到请求的文件，Web 服务器会把文件发送回浏览器，否则发送一条错误消息，表明您请求了一个错误的文件。 Web 浏览器从 Web 服务器获取响应，并根据接收到的响应来显示文件或错误消息。 然而，以这种方式搭建起来的 HTTP 服务器，不管何时请求目录中的某个文件，HTTP 服务器发送回来的不是该文件，而是以程序形式执行，并把执行产生的输出发送回浏览器显示出来。
公共网关接口（CGI），是使得应用程序（称为 CGI 程序或 CGI 脚本）能够与 Web 服务器以及客户端进行交互的标准协议。这些 CGI 程序可以用 Python、PERL、Shell、C 或 C++ 等进行编写。
CGI 架构图 下图演示了 CGI 的架构：
Web 服务器配置 在您进行 CGI 编程之前，请确保您的 Web 服务器支持 CGI，并已配置成可以处理 CGI 程序。所有由 HTTP 服务器执行的 CGI 程序，都必须在预配置的目录中。该目录称为 CGI 目录，按照惯例命名为 /var/www/cgi-bin。虽然 CGI 文件是 C++ 可执行文件，但是按照惯例它的扩展名是 .</div><div class="mt-2"><a class="text-secondary" href="/docs/programing/c++/default/38/">阅读更多关于C++ Web 编程的内容。</a></div></div></div></div><div class="col"><div class="hb-blog-post-card card border-0 overflow-hidden h-100 hb-module mb-0"><div class="hb-blog-post-meta d-flex align-items-center"><a class="hb-blog-post-author-link text-decoration-none" href="/authors/andywu/" title="安图新"><picture><img class="hb-blog-author-img rounded-circle" src="https://cdn.hotmindshare.com/public%2Fandyng_1000x1000.png" alt="安图新" loading="lazy"/>
</picture></a><span class="hb-blog-post-date">2022年10月6日</span>
<span class="hb-blog-post-reading-time">2 分钟阅读</span>
<span class="hb-blog-post-section"><a class="badge bg-secondary text-decoration-none fw-normal" href="/docs/">技术教程</a></span></div><a class="card-img-top overflow-hidden border border-secondary-subtle text-body text-decoration-none mt-2" href="/docs/code-design/30_miss/"><picture><source srcset="/images/thumbnail_hu2c04c355e02fd9f63b765bcdb503cf1c_2284289_db4ab978a5e64c694fdda20c4098bfd2.webp" type="image/webp"/><img class="hb-blog-post-card-img" src="https://www.hotmindshare.com/images/thumbnail_hu2c04c355e02fd9f63b765bcdb503cf1c_2284289_0x360_resize_box_3.c4a823371e7699a6d0a45f2ed38908a1.png" alt="三十、MVC 模式" loading="lazy" height="360" width="630"/></picture></a><div class="card-body px-0 py-2 d-flex flex-column"><div class="hb-blog-post-title card-title h5 py-1"><a class="hb-blog-post-title-link d-block" title="三十、MVC 模式" href="/docs/code-design/30_miss/">三十、MVC 模式</a></div><div class="hb-blog-post-meta d-block text-nowrap text-truncate mb-2"><span class="hb-blog-post-taxonomy-meta"><a class="hb-blog-post-taxonomy hb-blog-post-taxonomy-category badge bg-secondary text-decoration-none fw-normal me-1" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a>
</span><span class="hb-blog-post-taxonomy-meta"><a class="hb-blog-post-taxonomy hb-blog-post-taxonomy-series badge bg-secondary text-decoration-none fw-normal me-1" href="/series/%E8%BF%9B%E9%98%B6%E6%95%99%E7%A8%8B/">进阶教程</a></span></div><div class="hb-blog-post-summary card-text text-secondary mb-auto">MVC模式代表 Model-View-Controller（模型-视图-控制器） 模式
MVC模式用于应用程序的分层开发
Model（模型） - 模型代表一个存取数据的对象或 JAVA POJO 它也可以带有逻辑，在数据变化时更新控制器 View（视图） - 视图代表模型包含的数据的可视化 Controller（控制器） - 控制器作用于模型和视图上。它控制数据流向模型对象，并在数据变化时更新视图。它使视图与模型分离开 实现 1、 定义一个作为模型的Student对象；
2、 StudentView是一个把学生详细信息输出到控制台的视图类；
3、 StudentController是负责存储数据到Student对象中的控制器类，并相应地更新视图StudentView；
4、 最后类MVCPatternDemo使用StudentController来演示MVC模式的用法；
范例 1. 定义模型 Student.java
1// author: DDKK.COM 弟弟快看，程序员编程资料站(ddkk.com) 2// Copyright © 2015-2065 ddkk.com. All rights reserved. 3package com.ddkk.gof; 4public class Student { 5 private String rollNo; 6 private String name; 7 public String getRollNo() { 8 return rollNo; 9 } 10 public void setRollNo(String rollNo) { 11 this.</div><div class="mt-2"><a class="text-secondary" href="/docs/code-design/30_miss/">阅读更多关于三十、MVC 模式的内容。</a></div></div></div></div><div class="col"><div class="hb-blog-post-card card border-0 overflow-hidden h-100 hb-module mb-0"><div class="hb-blog-post-meta d-flex align-items-center"><a class="hb-blog-post-author-link text-decoration-none" href="/authors/andywu/" title="安图新"><picture><img class="hb-blog-author-img rounded-circle" src="https://cdn.hotmindshare.com/public%2Fandyng_1000x1000.png" alt="安图新" loading="lazy"/>
</picture></a><span class="hb-blog-post-date">2022年10月6日</span>
<span class="hb-blog-post-reading-time">1 分钟阅读</span>
<span class="hb-blog-post-section"><a class="badge bg-secondary text-decoration-none fw-normal" href="/docs/">技术教程</a></span></div><a class="card-img-top overflow-hidden border border-secondary-subtle text-body text-decoration-none mt-2" href="/docs/cloud-native/docker/30/"><picture><source srcset="/images/thumbnail_hu2c04c355e02fd9f63b765bcdb503cf1c_2284289_db4ab978a5e64c694fdda20c4098bfd2.webp" type="image/webp"/><img class="hb-blog-post-card-img" src="https://www.hotmindshare.com/images/thumbnail_hu2c04c355e02fd9f63b765bcdb503cf1c_2284289_0x360_resize_box_3.c4a823371e7699a6d0a45f2ed38908a1.png" alt="三十、Docker 命令大全" loading="lazy" height="360" width="630"/></picture></a><div class="card-body px-0 py-2 d-flex flex-column"><div class="hb-blog-post-title card-title h5 py-1"><a class="hb-blog-post-title-link d-block" title="三十、Docker 命令大全" href="/docs/cloud-native/docker/30/">三十、Docker 命令大全</a></div><div class="hb-blog-post-meta d-block text-nowrap text-truncate mb-2"><span class="hb-blog-post-taxonomy-meta"><a class="hb-blog-post-taxonomy hb-blog-post-taxonomy-category badge bg-secondary text-decoration-none fw-normal me-1" href="/categories/%E4%BA%91%E5%8E%9F%E7%94%9F/">云原生</a>
</span><span class="hb-blog-post-taxonomy-meta"><a class="hb-blog-post-taxonomy hb-blog-post-taxonomy-category badge bg-secondary text-decoration-none fw-normal me-1" href="/categories/docker/">Docker</a>
</span><span class="hb-blog-post-taxonomy-meta"><a class="hb-blog-post-taxonomy hb-blog-post-taxonomy-series badge bg-secondary text-decoration-none fw-normal me-1" href="/series/%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/">基础教程</a></span></div><div class="hb-blog-post-summary card-text text-secondary mb-auto">Docker 是一个开源的应用容器引擎，基于 Go 语言 并遵从 Apache2.0 协议开源
Docker 可以让开发者打包它们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化
Docker 使用完全使用沙箱机制，两个容器之间不会有任何接口 (这个有点像 iPhone 的 app ) ,更重要的是容器性能开销极低
学习前提 在继续阅读之前，我们希望你对 Linux 有一些基本的了解，包括
1、 会使用Linux常用的命令；
2、 知道大部分的Linux常识，比如终端、service、ip、用户、组等；
3、 熟练使用Ubuntu或者Centos或者MacOS种的一种昂；
如果你对这些知识还是一知半解，可以访问我们的 Linux 基础教程 先进行一些简单的了解
Docker的应用场景 1、 Web应用的自动化打包和发布；
2、 自动化测试和持续集成、发布；
3、 在服务型环境中部署和调整数据库或其他的后台应用；
4、 从头编译或者扩展现有的OpenShift或CloudFoundry平台来搭建自己的PaaS环境；
Docker 的优点 1、 简化程序；
1Docker 让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的 Linux 机器上，便可以实现虚拟化 2Docker 改变了虚拟化的方式，使开发者可以直接将自己的成果放入 Docker 中进行管理 3方便快捷已经是 Docker 的最大优势，过去需要用数天乃至数周的 任务，在Docker容器的处理下，只需要数秒就能完成 2、 解决运维配置噩梦；
1在没有 Docker 之前，每一台机器，每一个要用到的依赖，几乎都要重新配置一遍 2比如新增一台 MySQL 数据库，就要从头开始配置所有环境 3有了 Docker 之后，只需要从仓库里把之前的 MySQL 镜像拉出来，直接使用 3、 节省开支；</div><div class="mt-2"><a class="text-secondary" href="/docs/cloud-native/docker/30/">阅读更多关于三十、Docker 命令大全的内容。</a></div></div></div></div><div class="col"><div class="hb-blog-post-card card border-0 overflow-hidden h-100 hb-module mb-0"><div class="hb-blog-post-meta d-flex align-items-center"><a class="hb-blog-post-author-link text-decoration-none" href="/authors/andywu/" title="安图新"><picture><img class="hb-blog-author-img rounded-circle" src="https://cdn.hotmindshare.com/public%2Fandyng_1000x1000.png" alt="安图新" loading="lazy"/>
</picture></a><span class="hb-blog-post-date">2022年10月6日</span>
<span class="hb-blog-post-reading-time">2 分钟阅读</span>
<span class="hb-blog-post-section"><a class="badge bg-secondary text-decoration-none fw-normal" href="/docs/">技术教程</a></span></div><a class="card-img-top overflow-hidden border border-secondary-subtle text-body text-decoration-none mt-2" href="/docs/programing/c++/default/30/"><picture><source srcset="/images/thumbnail_hu2c04c355e02fd9f63b765bcdb503cf1c_2284289_db4ab978a5e64c694fdda20c4098bfd2.webp" type="image/webp"/><img class="hb-blog-post-card-img" src="https://www.hotmindshare.com/images/thumbnail_hu2c04c355e02fd9f63b765bcdb503cf1c_2284289_0x360_resize_box_3.c4a823371e7699a6d0a45f2ed38908a1.png" alt="C++ 文件和流" loading="lazy" height="360" width="630"/></picture></a><div class="card-body px-0 py-2 d-flex flex-column"><div class="hb-blog-post-title card-title h5 py-1"><a class="hb-blog-post-title-link d-block" title="C++ 文件和流" href="/docs/programing/c++/default/30/">C++ 文件和流</a></div><div class="hb-blog-post-meta d-block text-nowrap text-truncate mb-2"><span class="hb-blog-post-taxonomy-meta"><a class="hb-blog-post-taxonomy hb-blog-post-taxonomy-category badge bg-secondary text-decoration-none fw-normal me-1" href="/categories/c++/">C++</a>
</span><span class="hb-blog-post-taxonomy-meta"><a class="hb-blog-post-taxonomy hb-blog-post-taxonomy-series badge bg-secondary text-decoration-none fw-normal me-1" href="/series/%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/">基础教程</a></span></div><div class="hb-blog-post-summary card-text text-secondary mb-auto">C++ 文件和流 到目前为止，我们已经使用了 iostream 标准库，它提供了 cin 和 cout 方法分别用于从标准输入读取流和向标准输出写入流。
本教程介绍如何从文件读取流和向文件写入流。这就需要用到 C++ 中另一个标准库 fstream，它定义了三个新的数据类型：
数据类型 描述 ofstream 该数据类型表示输出文件流，用于创建文件并向文件写入信息。 ifstream 该数据类型表示输入文件流，用于从文件读取信息。 fstream 该数据类型通常表示文件流，且同时具有 ofstream 和 ifstream 两种功能，这意味着它可以创建文件，向文件写入信息，从文件读取信息。 要在C++ 中进行文件处理，必须在 C++ 源代码文件中包含头文件 和 。
打开文件 在从文件读取信息或者向文件写入信息之前，必须先打开文件。ofstream 和 fstream 对象都可以用来打开文件进行写操作，如果只需要打开文件进行读操作，则使用 ifstream 对象。
下面是open() 函数的标准语法，open() 函数是 fstream、ifstream 和 ofstream 对象的一个成员。
1void open(const char *filename, ios::openmode mode); 在这里，open() 成员函数的第一参数指定要打开的文件的名称和位置，第二个参数定义文件被打开的模式。
模式标志 描述 ios::app 追加模式。所有写入都追加到文件末尾。 ios::ate 文件打开后定位到文件末尾。 ios::in 打开文件用于读取。 ios::out 打开文件用于写入。 ios::trunc 如果该文件已经存在，其内容将在打开文件之前被截断，即把文件长度设为 0。 您可以把以上两种或两种以上的模式结合使用。例如，如果您想要以写入模式打开文件，并希望截断文件，以防文件已存在，那么您可以使用下面的语法：
1ofstream outfile; 2outfile.open(&#34;file.dat&#34;, ios::out | ios::trunc ); 类似地，您如果想要打开一个文件用于读写，可以使用下面的语法：</div><div class="mt-2"><a class="text-secondary" href="/docs/programing/c++/default/30/">阅读更多关于C++ 文件和流的内容。</a></div></div></div></div><div class="col"><div class="hb-blog-post-card card border-0 overflow-hidden h-100 hb-module mb-0"><div class="hb-blog-post-meta d-flex align-items-center"><a class="hb-blog-post-author-link text-decoration-none" href="/authors/andywu/" title="安图新"><picture><img class="hb-blog-author-img rounded-circle" src="https://cdn.hotmindshare.com/public%2Fandyng_1000x1000.png" alt="安图新" loading="lazy"/>
</picture></a><span class="hb-blog-post-date">2022年10月6日</span>
<span class="hb-blog-post-reading-time">1 分钟阅读</span>
<span class="hb-blog-post-section"><a class="badge bg-secondary text-decoration-none fw-normal" href="/docs/">技术教程</a></span></div><a class="card-img-top overflow-hidden border border-secondary-subtle text-body text-decoration-none mt-2" href="/docs/code-design/3/"><picture><source srcset="/images/thumbnail_hu2c04c355e02fd9f63b765bcdb503cf1c_2284289_db4ab978a5e64c694fdda20c4098bfd2.webp" type="image/webp"/><img class="hb-blog-post-card-img" src="https://www.hotmindshare.com/images/thumbnail_hu2c04c355e02fd9f63b765bcdb503cf1c_2284289_0x360_resize_box_3.c4a823371e7699a6d0a45f2ed38908a1.png" alt="三、设计模式 – 四大类型" loading="lazy" height="360" width="630"/></picture></a><div class="card-body px-0 py-2 d-flex flex-column"><div class="hb-blog-post-title card-title h5 py-1"><a class="hb-blog-post-title-link d-block" title="三、设计模式 – 四大类型" href="/docs/code-design/3/">三、设计模式 – 四大类型</a></div><div class="hb-blog-post-meta d-block text-nowrap text-truncate mb-2"><span class="hb-blog-post-taxonomy-meta"><a class="hb-blog-post-taxonomy hb-blog-post-taxonomy-category badge bg-secondary text-decoration-none fw-normal me-1" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a>
</span><span class="hb-blog-post-taxonomy-meta"><a class="hb-blog-post-taxonomy hb-blog-post-taxonomy-series badge bg-secondary text-decoration-none fw-normal me-1" href="/series/%E8%BF%9B%E9%98%B6%E6%95%99%E7%A8%8B/">进阶教程</a></span></div><div class="hb-blog-post-summary card-text text-secondary mb-auto">设计模式（Design pattern）是重构解决方案
根据书Design Patterns – Elements of Reusable Object-Oriented Software（中文译名：设计模式 – 可复用的面向对象软件元素） 中和 J2EE 所提到的，总共有 23 +8 种设计模式
这些模式可以分为四大类：创建型模式（Creational Patterns）、结构型模式（Structural Patterns）、行为型模式（Behavioral Patterns）、J2EE 设计模式
1、 创建型模式；
这些设计模式提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用 new 运算符直接实例化对象
这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活
包括
1、 工厂模式（FactoryPattern）；
2、 抽象工厂模式（AbstractFactoryPattern）；
3、 单例模式（SingletonPattern）；
4、 建造者模式（BuilderPattern；
5、 原型模式（PrototypePattern）；
2、 结构型模式；
这些设计模式关注类和对象的组合
继承的概念被用来组合接口和定义组合对象获得新功能的方式
包括
1、 适配器模式（AdapterPattern）；
2、 桥接模式（BridgePattern）；
3、 过滤器模式（Filter、CriteriaPattern）；
4、 组合模式（CompositePattern）；
5、 装饰器模式（DecoratorPattern）；
6、 外观模式（FacadePattern）；
7、 享元模式（FlyweightPattern）；
8、 代理模式（ProxyPattern）；
因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 3、 行为型模式；
这些设计模式特别关注对象之间的通信
包括
1、 责任链模式（ChainofResponsibilityPattern）；
2、 命令模式（CommandPattern）；</div><div class="mt-2"><a class="text-secondary" href="/docs/code-design/3/">阅读更多关于三、设计模式 – 四大类型的内容。</a></div></div></div></div><div class="col"><div class="hb-blog-post-card card border-0 overflow-hidden h-100 hb-module mb-0"><div class="hb-blog-post-meta d-flex align-items-center"><a class="hb-blog-post-author-link text-decoration-none" href="/authors/andywu/" title="安图新"><picture><img class="hb-blog-author-img rounded-circle" src="https://cdn.hotmindshare.com/public%2Fandyng_1000x1000.png" alt="安图新" loading="lazy"/>
</picture></a><span class="hb-blog-post-date">2022年10月6日</span>
<span class="hb-blog-post-reading-time">3 分钟阅读</span>
<span class="hb-blog-post-section"><a class="badge bg-secondary text-decoration-none fw-normal" href="/docs/">技术教程</a></span></div><a class="card-img-top overflow-hidden border border-secondary-subtle text-body text-decoration-none mt-2" href="/docs/cloud-native/docker/3/"><picture><source srcset="/images/thumbnail_hu2c04c355e02fd9f63b765bcdb503cf1c_2284289_db4ab978a5e64c694fdda20c4098bfd2.webp" type="image/webp"/><img class="hb-blog-post-card-img" src="https://www.hotmindshare.com/images/thumbnail_hu2c04c355e02fd9f63b765bcdb503cf1c_2284289_0x360_resize_box_3.c4a823371e7699a6d0a45f2ed38908a1.png" alt="三、Ubuntu 安装 Docker" loading="lazy" height="360" width="630"/></picture></a><div class="card-body px-0 py-2 d-flex flex-column"><div class="hb-blog-post-title card-title h5 py-1"><a class="hb-blog-post-title-link d-block" title="三、Ubuntu 安装 Docker" href="/docs/cloud-native/docker/3/">三、Ubuntu 安装 Docker</a></div><div class="hb-blog-post-meta d-block text-nowrap text-truncate mb-2"><span class="hb-blog-post-taxonomy-meta"><a class="hb-blog-post-taxonomy hb-blog-post-taxonomy-category badge bg-secondary text-decoration-none fw-normal me-1" href="/categories/%E4%BA%91%E5%8E%9F%E7%94%9F/">云原生</a>
</span><span class="hb-blog-post-taxonomy-meta"><a class="hb-blog-post-taxonomy hb-blog-post-taxonomy-category badge bg-secondary text-decoration-none fw-normal me-1" href="/categories/docker/">Docker</a>
</span><span class="hb-blog-post-taxonomy-meta"><a class="hb-blog-post-taxonomy hb-blog-post-taxonomy-series badge bg-secondary text-decoration-none fw-normal me-1" href="/series/%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/">基础教程</a></span></div><div class="hb-blog-post-summary card-text text-secondary mb-auto">Docker 是一个开源的应用容器引擎，基于 Go 语言 并遵从 Apache2.0 协议开源
Docker 可以让开发者打包它们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化
Docker 使用完全使用沙箱机制，两个容器之间不会有任何接口 (这个有点像 iPhone 的 app ) ,更重要的是容器性能开销极低
学习前提 在继续阅读之前，我们希望你对 Linux 有一些基本的了解，包括
1、 会使用 Linux 常用的命令；
2、 知道大部分的 Linux 常识，比如终端、service、ip、用户、组等；
3、 熟练使用 Ubuntu 或者 Centos 或者 MacOS 种的一种昂；
如果你对这些知识还是一知半解，可以访问我们的 Linux 基础教程 先进行一些简单的了解
Docker 的应用场景 1、 Web 应用的自动化打包和发布；
2、 自动化测试和持续集成、发布；
3、 在服务型环境中部署和调整数据库或其他的后台应用；
4、 从头编译或者扩展现有的 OpenShift 或 CloudFoundry 平台来搭建自己的 PaaS 环境；
Docker 的优点 1、 简化程序；
1Docker 让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的 Linux 机器上，便可以实现虚拟化 2Docker 改变了虚拟化的方式，使开发者可以直接将自己的成果放入 Docker 中进行管理 3方便快捷已经是 Docker 的最大优势，过去需要用数天乃至数周的 任务，在Docker容器的处理下，只需要数秒就能完成 2、 解决运维配置噩梦；</div><div class="mt-2"><a class="text-secondary" href="/docs/cloud-native/docker/3/">阅读更多关于三、Ubuntu 安装 Docker的内容。</a></div></div></div></div><div class="col"><div class="hb-blog-post-card card border-0 overflow-hidden h-100 hb-module mb-0"><div class="hb-blog-post-meta d-flex align-items-center"><a class="hb-blog-post-author-link text-decoration-none" href="/authors/andywu/" title="安图新"><picture><img class="hb-blog-author-img rounded-circle" src="https://cdn.hotmindshare.com/public%2Fandyng_1000x1000.png" alt="安图新" loading="lazy"/>
</picture></a><span class="hb-blog-post-date">2022年10月6日</span>
<span class="hb-blog-post-reading-time">1 分钟阅读</span>
<span class="hb-blog-post-section"><a class="badge bg-secondary text-decoration-none fw-normal" href="/docs/">技术教程</a></span></div><a class="card-img-top overflow-hidden border border-secondary-subtle text-body text-decoration-none mt-2" href="/docs/java/concurrency/default/3/"><picture><source srcset="/images/thumbnail_hu2c04c355e02fd9f63b765bcdb503cf1c_2284289_db4ab978a5e64c694fdda20c4098bfd2.webp" type="image/webp"/><img class="hb-blog-post-card-img" src="https://www.hotmindshare.com/images/thumbnail_hu2c04c355e02fd9f63b765bcdb503cf1c_2284289_0x360_resize_box_3.c4a823371e7699a6d0a45f2ed38908a1.png" alt="Java 中的线程池" loading="lazy" height="360" width="630"/></picture></a><div class="card-body px-0 py-2 d-flex flex-column"><div class="hb-blog-post-title card-title h5 py-1"><a class="hb-blog-post-title-link d-block" title="Java 中的线程池" href="/docs/java/concurrency/default/3/">Java 中的线程池</a></div><div class="hb-blog-post-meta d-block text-nowrap text-truncate mb-2"><span class="hb-blog-post-taxonomy-meta"><a class="hb-blog-post-taxonomy hb-blog-post-taxonomy-category badge bg-secondary text-decoration-none fw-normal me-1" href="/categories/java/">Java</a>
</span><span class="hb-blog-post-taxonomy-meta"><a class="hb-blog-post-taxonomy hb-blog-post-taxonomy-category badge bg-secondary text-decoration-none fw-normal me-1" href="/categories/java%E5%B9%B6%E5%8F%91/">Java并发</a>
</span><span class="hb-blog-post-taxonomy-meta"><a class="hb-blog-post-taxonomy hb-blog-post-taxonomy-series badge bg-secondary text-decoration-none fw-normal me-1" href="/series/%E8%BF%9B%E9%98%B6%E6%95%99%E7%A8%8B/">进阶教程</a></span></div><div class="hb-blog-post-summary card-text text-secondary mb-auto">本文我们将讲解 Java 中的线程池 ( Thread Pool )，从 Java 标准库中的线程池的不同实现开始，到 Google 开发的 Guava 库的前世今生。
本章节涉及到很多前几个章节中阐述的知识点。我们希望你是按照顺序阅读下来的，不然有些知识会一头雾水。
Java 语言的实现中，把 Java 线程一一映射到操作系统级的线程，而后者是操作系统的资源，这意味着，如果开发者毫无节制地创建线程，那么线程资源就会被快速的耗尽。
在Windows 操作系统上，每个线程要预留出 1m 的内存空间，意味着 2G 的内存理论上做多只能创建 2048 个线程。而在 Linux 上，最大线程数由常量 PTHREAD_THREADS_MAX 决定，一般为 1024。
出于模拟并行性的目的，Java 线程之间的上下文切换也由操作系统完成。因为线程上下文切换需要消耗时间，所以，一个简单的观点是：产生的线程越多，每个线程花在实际工作上的时间就越少。
为什么会有线程上下文切换？
一台电脑，运行起来后，它的 CPU 是固定的，05 年之前，还是单核时代，也就是一次只能运行一个线程，虽然随着时间的推移，现在的 CPU 已经有很多个核心，比如 8 核 16 核之类的。但相比于一个应用程序能够创建的线程数，那真的是太少了。而每个核心一次只能运行一个线程，所以多个线程需要运行时就需要来回不停的在多个线程间切换，这就是线程之间的上下文切换。
为了节制创建线程的数量，也为了节省创建线程的开销，因此提出了线程池的概念。线程池模式有助于节省多线程应用程序中的资源，还可以在某些预定义的限制内包含并行性。
当我们使用线程池时，我们可以以并行任务的形式编写并发代码并将其提交到线程池的实例中执行。
这个线程池实例控制了多个重用线程以执行这些任务。
这种线程池模式，允许我们控制应用程序创建的线程数，生命周期，以及计划任务的执行并将传入的任务保留在队列中。
Java 中的线程池 Executors、Executor 和 ExecutorService Executors 是一个帮助类，提供了创建几种预配置线程池实例的方法。如果你不需要应用任何自定义的微调，可以调用这些方法创建默认配置的线程池，因为它能节省很多时间和代码。
Executor 和 ExecutorService 接口则用于与 Java 中不同线程池的实现协同工作。通常，你应该将代码与线程池的实际实现分离，并在整个应用程序中使用这些接口。
Executor 接口提供了一个 execute() 方法将 Runnable 实例提交到线程池中执行。
下面的代码是一个快速示例，演示了如何使用 Executors API 获取包含了单个线程池和无限队列支持的 Executor 实例，以便按顺序执行任务。</div><div class="mt-2"><a class="text-secondary" href="/docs/java/concurrency/default/3/">阅读更多关于Java 中的线程池的内容。</a></div></div></div></div><div class="col"><div class="hb-blog-post-card card border-0 overflow-hidden h-100 hb-module mb-0"><div class="hb-blog-post-meta d-flex align-items-center"><a class="hb-blog-post-author-link text-decoration-none" href="/authors/andywu/" title="安图新"><picture><img class="hb-blog-author-img rounded-circle" src="https://cdn.hotmindshare.com/public%2Fandyng_1000x1000.png" alt="安图新" loading="lazy"/>
</picture></a><span class="hb-blog-post-date">2022年10月6日</span>
<span class="hb-blog-post-reading-time">2 分钟阅读</span>
<span class="hb-blog-post-section"><a class="badge bg-secondary text-decoration-none fw-normal" href="/docs/">技术教程</a></span></div><a class="card-img-top overflow-hidden border border-secondary-subtle text-body text-decoration-none mt-2" href="/docs/programing/c++/default/3/"><picture><source srcset="/images/thumbnail_hu2c04c355e02fd9f63b765bcdb503cf1c_2284289_db4ab978a5e64c694fdda20c4098bfd2.webp" type="image/webp"/><img class="hb-blog-post-card-img" src="https://www.hotmindshare.com/images/thumbnail_hu2c04c355e02fd9f63b765bcdb503cf1c_2284289_0x360_resize_box_3.c4a823371e7699a6d0a45f2ed38908a1.png" alt="C++ 基本语法" loading="lazy" height="360" width="630"/></picture></a><div class="card-body px-0 py-2 d-flex flex-column"><div class="hb-blog-post-title card-title h5 py-1"><a class="hb-blog-post-title-link d-block" title="C++ 基本语法" href="/docs/programing/c++/default/3/">C++ 基本语法</a></div><div class="hb-blog-post-meta d-block text-nowrap text-truncate mb-2"><span class="hb-blog-post-taxonomy-meta"><a class="hb-blog-post-taxonomy hb-blog-post-taxonomy-category badge bg-secondary text-decoration-none fw-normal me-1" href="/categories/c++/">C++</a>
</span><span class="hb-blog-post-taxonomy-meta"><a class="hb-blog-post-taxonomy hb-blog-post-taxonomy-series badge bg-secondary text-decoration-none fw-normal me-1" href="/series/%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/">基础教程</a></span></div><div class="hb-blog-post-summary card-text text-secondary mb-auto">C++ 基本语法 C++程序可以定义为对象的集合，这些对象通过调用彼此的方法进行交互。现在让我们简要地看一下什么是类、对象，方法、即时变量。
对象 – 对象具有状态和行为。例如：一只狗的状态 – 颜色、名称、品种，行为 – 摇动、叫唤、吃。对象是类的实例。 类 – 类可以定义为描述对象行为/状态的模板/蓝图。 方法 – 从基本上说，一个方法表示一种行为。一个类可以包含多个方法。可以在方法中写入逻辑、操作数据以及执行所有的动作。 即时变量 – 每个对象都有其独特的即时变量。对象的状态是由这些即时变量的值创建的。 C++ 程序结构 让我们看一段简单的代码，可以输出单词 Hello World。
1#include &lt;iostream&gt; 2using namespace std; 3// main() 是程序开始执行的地方 4int main() 5 cout &lt;&lt; &#34;Hello World&#34;; // 输出 Hello World return 0; 6} 接下来我们讲解一下上面这段程序：
C++ 语言定义了一些头文件，这些头文件包含了程序中必需的或有用的信息。上面这段程序中，包含了头文件 。 行 using namespace std; 告诉编译器使用 std 命名空间。命名空间是 C++ 中一个相对新的概念。 下一行 // main() 是程序开始执行的地方 是一个单行注释。单行注释以 // 开头，在行末结束。 下一行 int main() 是主函数，程序从这里开始执行。 下一行 cout « “Hello World”; 会在屏幕上显示消息 “Hello World”。 下一行 return 0; 终止 main( )函数，并向调用进程返回值 0。 编译 &amp; 执行 C++ 程序 接下来让我们看看如何把源代码保存在一个文件中，以及如何编译并运行它。下面是简单的步骤：</div><div class="mt-2"><a class="text-secondary" href="/docs/programing/c++/default/3/">阅读更多关于C++ 基本语法的内容。</a></div></div></div></div><div class="col"><div class="hb-blog-post-card card border-0 overflow-hidden h-100 hb-module mb-0"><div class="hb-blog-post-meta d-flex align-items-center"><a class="hb-blog-post-author-link text-decoration-none" href="/authors/andywu/" title="安图新"><picture><img class="hb-blog-author-img rounded-circle" src="https://cdn.hotmindshare.com/public%2Fandyng_1000x1000.png" alt="安图新" loading="lazy"/>
</picture></a><span class="hb-blog-post-date">2022年10月6日</span>
<span class="hb-blog-post-reading-time">3 分钟阅读</span>
<span class="hb-blog-post-section"><a class="badge bg-secondary text-decoration-none fw-normal" href="/docs/">技术教程</a></span></div><a class="card-img-top overflow-hidden border border-secondary-subtle text-body text-decoration-none mt-2" href="/docs/code-design/7_miss/"><picture><source srcset="/images/thumbnail_hu2c04c355e02fd9f63b765bcdb503cf1c_2284289_db4ab978a5e64c694fdda20c4098bfd2.webp" type="image/webp"/><img class="hb-blog-post-card-img" src="https://www.hotmindshare.com/images/thumbnail_hu2c04c355e02fd9f63b765bcdb503cf1c_2284289_0x360_resize_box_3.c4a823371e7699a6d0a45f2ed38908a1.png" alt="七、单例模式 ( Singleton Pattern )" loading="lazy" height="360" width="630"/></picture></a><div class="card-body px-0 py-2 d-flex flex-column"><div class="hb-blog-post-title card-title h5 py-1"><a class="hb-blog-post-title-link d-block" title="七、单例模式 ( Singleton Pattern )" href="/docs/code-design/7_miss/">七、单例模式 ( Singleton Pattern )</a></div><div class="hb-blog-post-meta d-block text-nowrap text-truncate mb-2"><span class="hb-blog-post-taxonomy-meta"><a class="hb-blog-post-taxonomy hb-blog-post-taxonomy-category badge bg-secondary text-decoration-none fw-normal me-1" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a>
</span><span class="hb-blog-post-taxonomy-meta"><a class="hb-blog-post-taxonomy hb-blog-post-taxonomy-series badge bg-secondary text-decoration-none fw-normal me-1" href="/series/%E8%BF%9B%E9%98%B6%E6%95%99%E7%A8%8B/">进阶教程</a></span></div><div class="hb-blog-post-summary card-text text-secondary mb-auto">单例模式（Singleton Pattern）提供了一种创建对象的最佳方式
单例模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建，这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象
单例模式设计要点 1、 单例类只能有一个实例；
2、 单例类必须自己创建自己的唯一实例；
3、 单例类必须给所有其他对象提供这一实例；
单例模式属于创建型模式
摘要 1、 意图：
保证一个类仅有一个实例，并提供一个访问它的全局访问点
2、 主要解决：
一个全局使用的类频繁地创建与销毁
3、 何时使用：
当您想控制实例数目，节省系统资源的时候
4、 如何解决：
判断系统是否已经有这个单例，如果有则返回，如果没有则创建
5、 关键代码：
构造函数是私有的
6、 应用实例：
1、 一个党只能有一个主席；
2、 Windows是多进程多线程的，在操作一个文件的时候，就不可避免地出现多个进程或线程同时操作一个文件的现象，所以所有文件的处理必须通过唯一的实例来进行；
3、 一些设备管理器常常设计为单例模式，比如一个电脑有两台打印机，在输出的时候就要处理不能两台打印机打印同一个文件；
7、 优点：
1、 在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例（比如管理学院首页页面缓存）；
2、 避免对资源的多重占用（比如写文件操作）；
8、 缺点：
没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化
9、 使用场景：
1、 要求生产唯一序列号；
2、 WEB中的计数器，不用每次刷新都在数据库里加一次，用单例先缓存起来；
3、 创建的一个对象需要消耗的资源过多，比如I/O与数据库的连接等；
10、 注意事项：
getInstance() 方法中需要使用同步锁 synchronized (Singleton.class) 防止多线程同时进入造成 instance 被多次实例化
实现 1、 创建一个SingleObject类，SingleObject类有它的私有构造函数和本身的一个静态实例SingleObject类提供了一个静态方法，供外界获取它的静态实例；
2、 SingletonPatternDemo使用SingleObject类来获取SingleObject对象；
范例 1. 创建一个 Singleton 类 SingleObject.</div><div class="mt-2"><a class="text-secondary" href="/docs/code-design/7_miss/">阅读更多关于七、单例模式 ( Singleton Pattern )的内容。</a></div></div></div></div><div class="col"><div class="hb-blog-post-card card border-0 overflow-hidden h-100 hb-module mb-0"><div class="hb-blog-post-meta d-flex align-items-center"><a class="hb-blog-post-author-link text-decoration-none" href="/authors/andywu/" title="安图新"><picture><img class="hb-blog-author-img rounded-circle" src="https://cdn.hotmindshare.com/public%2Fandyng_1000x1000.png" alt="安图新" loading="lazy"/>
</picture></a><span class="hb-blog-post-date">2022年10月6日</span>
<span class="hb-blog-post-reading-time">1 分钟阅读</span>
<span class="hb-blog-post-section"><a class="badge bg-secondary text-decoration-none fw-normal" href="/docs/">技术教程</a></span></div><a class="card-img-top overflow-hidden border border-secondary-subtle text-body text-decoration-none mt-2" href="/docs/java/concurrency/default/7/"><picture><source srcset="/images/thumbnail_hu2c04c355e02fd9f63b765bcdb503cf1c_2284289_db4ab978a5e64c694fdda20c4098bfd2.webp" type="image/webp"/><img class="hb-blog-post-card-img" src="https://www.hotmindshare.com/images/thumbnail_hu2c04c355e02fd9f63b765bcdb503cf1c_2284289_0x360_resize_box_3.c4a823371e7699a6d0a45f2ed38908a1.png" alt="给 Maven 添加 Guava 依赖" loading="lazy" height="360" width="630"/></picture></a><div class="card-body px-0 py-2 d-flex flex-column"><div class="hb-blog-post-title card-title h5 py-1"><a class="hb-blog-post-title-link d-block" title="给 Maven 添加 Guava 依赖" href="/docs/java/concurrency/default/7/">给 Maven 添加 Guava 依赖</a></div><div class="hb-blog-post-meta d-block text-nowrap text-truncate mb-2"><span class="hb-blog-post-taxonomy-meta"><a class="hb-blog-post-taxonomy hb-blog-post-taxonomy-category badge bg-secondary text-decoration-none fw-normal me-1" href="/categories/java/">Java</a>
</span><span class="hb-blog-post-taxonomy-meta"><a class="hb-blog-post-taxonomy hb-blog-post-taxonomy-category badge bg-secondary text-decoration-none fw-normal me-1" href="/categories/java%E5%B9%B6%E5%8F%91/">Java并发</a>
</span><span class="hb-blog-post-taxonomy-meta"><a class="hb-blog-post-taxonomy hb-blog-post-taxonomy-series badge bg-secondary text-decoration-none fw-normal me-1" href="/series/%E8%BF%9B%E9%98%B6%E6%95%99%E7%A8%8B/">进阶教程</a></span></div><div class="hb-blog-post-summary card-text text-secondary mb-auto">Guava 是托管在 Github.com 上的流行的 Google 开源的 Java 线程池库。
Guava 包含了许多有用的并发类，同时还包含了几个方便的 ExecutorService 实现，但这些实现类都无法通过直接实例化或子类化来创建实例。取而代之的是提供了 MoreExecutors 助手类来创建它们的实例。
给 Maven 添加 Guava 依赖 为了将Google Guava 库包含进当前的项目中，需要将下面的依赖项添加到 Maven pom 文件中。
1&lt;dependency&gt; 2 &lt;groupId&gt;com.google.guava&lt;/groupId&gt; 3 &lt;artifactId&gt;guava&lt;/artifactId&gt; 4 &lt;version&gt;26.0&lt;/version&gt; 5&lt;/dependency&gt; 你可以在 Maven 中央仓库 中找到最新版本的 Guava 库
直接执行者和直接执行者服务 有时候，我们希望在当前线程或线程池中执行任务，具体在哪里取决于某些条件。这种情况下，你应该会更喜欢使用单个 Executor 接口，且只需切换实现即可。
虽然将当前线程中的任务的 Executor 或 ExecutorService 的提取出来单独实现并不困难，但它仍然需要编写一些样板代码。
值得庆幸的是，Guava 为我们提供了预定义的实例。
下面的范例演示了如何在同一个线程中执行任务。简单起见，提交的任务会将当前线程休眠 500 毫秒并阻塞当前线程，并在执行的调用完成后让结果立即可用
1 Executor executor = MoreExecutors.directExecutor(); 2AtomicBoolean executed = new AtomicBoolean(); 3executor.execute(() -&gt; { 4 try { 5 Thread.</div><div class="mt-2"><a class="text-secondary" href="/docs/java/concurrency/default/7/">阅读更多关于给 Maven 添加 Guava 依赖的内容。</a></div></div></div></div><div class="col"><div class="hb-blog-post-card card border-0 overflow-hidden h-100 hb-module mb-0"><div class="hb-blog-post-meta d-flex align-items-center"><a class="hb-blog-post-author-link text-decoration-none" href="/authors/andywu/" title="安图新"><picture><img class="hb-blog-author-img rounded-circle" src="https://cdn.hotmindshare.com/public%2Fandyng_1000x1000.png" alt="安图新" loading="lazy"/>
</picture></a><span class="hb-blog-post-date">2022年10月6日</span>
<span class="hb-blog-post-reading-time">4 分钟阅读</span>
<span class="hb-blog-post-section"><a class="badge bg-secondary text-decoration-none fw-normal" href="/docs/">技术教程</a></span></div><a class="card-img-top overflow-hidden border border-secondary-subtle text-body text-decoration-none mt-2" href="/docs/cloud-native/docker/7/"><picture><source srcset="/images/thumbnail_hu2c04c355e02fd9f63b765bcdb503cf1c_2284289_db4ab978a5e64c694fdda20c4098bfd2.webp" type="image/webp"/><img class="hb-blog-post-card-img" src="https://www.hotmindshare.com/images/thumbnail_hu2c04c355e02fd9f63b765bcdb503cf1c_2284289_0x360_resize_box_3.c4a823371e7699a6d0a45f2ed38908a1.png" alt="七、Docker 容器" loading="lazy" height="360" width="630"/></picture></a><div class="card-body px-0 py-2 d-flex flex-column"><div class="hb-blog-post-title card-title h5 py-1"><a class="hb-blog-post-title-link d-block" title="七、Docker 容器" href="/docs/cloud-native/docker/7/">七、Docker 容器</a></div><div class="hb-blog-post-meta d-block text-nowrap text-truncate mb-2"><span class="hb-blog-post-taxonomy-meta"><a class="hb-blog-post-taxonomy hb-blog-post-taxonomy-category badge bg-secondary text-decoration-none fw-normal me-1" href="/categories/%E4%BA%91%E5%8E%9F%E7%94%9F/">云原生</a>
</span><span class="hb-blog-post-taxonomy-meta"><a class="hb-blog-post-taxonomy hb-blog-post-taxonomy-category badge bg-secondary text-decoration-none fw-normal me-1" href="/categories/docker/">Docker</a>
</span><span class="hb-blog-post-taxonomy-meta"><a class="hb-blog-post-taxonomy hb-blog-post-taxonomy-series badge bg-secondary text-decoration-none fw-normal me-1" href="/series/%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/">基础教程</a></span></div><div class="hb-blog-post-summary card-text text-secondary mb-auto">Docker 是一个开源的应用容器引擎，基于 Go 语言 并遵从 Apache2.0 协议开源
Docker 可以让开发者打包它们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化
Docker 使用完全使用沙箱机制，两个容器之间不会有任何接口 (这个有点像 iPhone 的 app ) ,更重要的是容器性能开销极低
学习前提 在继续阅读之前，我们希望你对 Linux 有一些基本的了解，包括
1、 会使用Linux常用的命令；
2、 知道大部分的Linux常识，比如终端、service、ip、用户、组等；
3、 熟练使用Ubuntu或者Centos或者MacOS种的一种昂；
如果你对这些知识还是一知半解，可以访问我们的 Linux 基础教程 先进行一些简单的了解
Docker的应用场景 1、 Web应用的自动化打包和发布；
2、 自动化测试和持续集成、发布；
3、 在服务型环境中部署和调整数据库或其他的后台应用；
4、 从头编译或者扩展现有的OpenShift或CloudFoundry平台来搭建自己的PaaS环境；
Docker 的优点 1、 简化程序；
1Docker 让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的 Linux 机器上，便可以实现虚拟化 2Docker 改变了虚拟化的方式，使开发者可以直接将自己的成果放入 Docker 中进行管理 3方便快捷已经是 Docker 的最大优势，过去需要用数天乃至数周的 任务，在Docker容器的处理下，只需要数秒就能完成 2、 解决运维配置噩梦；
1在没有 Docker 之前，每一台机器，每一个要用到的依赖，几乎都要重新配置一遍 2比如新增一台 MySQL 数据库，就要从头开始配置所有环境 3有了 Docker 之后，只需要从仓库里把之前的 MySQL 镜像拉出来，直接使用 3、 节省开支；</div><div class="mt-2"><a class="text-secondary" href="/docs/cloud-native/docker/7/">阅读更多关于七、Docker 容器的内容。</a></div></div></div></div><div class="col"><div class="hb-blog-post-card card border-0 overflow-hidden h-100 hb-module mb-0"><div class="hb-blog-post-meta d-flex align-items-center"><a class="hb-blog-post-author-link text-decoration-none" href="/authors/andywu/" title="安图新"><picture><img class="hb-blog-author-img rounded-circle" src="https://cdn.hotmindshare.com/public%2Fandyng_1000x1000.png" alt="安图新" loading="lazy"/>
</picture></a><span class="hb-blog-post-date">2022年10月6日</span>
<span class="hb-blog-post-reading-time">1 分钟阅读</span>
<span class="hb-blog-post-section"><a class="badge bg-secondary text-decoration-none fw-normal" href="/docs/">技术教程</a></span></div><a class="card-img-top overflow-hidden border border-secondary-subtle text-body text-decoration-none mt-2" href="/docs/programing/c++/default/7/"><picture><source srcset="/images/thumbnail_hu2c04c355e02fd9f63b765bcdb503cf1c_2284289_db4ab978a5e64c694fdda20c4098bfd2.webp" type="image/webp"/><img class="hb-blog-post-card-img" src="https://www.hotmindshare.com/images/thumbnail_hu2c04c355e02fd9f63b765bcdb503cf1c_2284289_0x360_resize_box_3.c4a823371e7699a6d0a45f2ed38908a1.png" alt="C++ 变量作用域" loading="lazy" height="360" width="630"/></picture></a><div class="card-body px-0 py-2 d-flex flex-column"><div class="hb-blog-post-title card-title h5 py-1"><a class="hb-blog-post-title-link d-block" title="C++ 变量作用域" href="/docs/programing/c++/default/7/">C++ 变量作用域</a></div><div class="hb-blog-post-meta d-block text-nowrap text-truncate mb-2"><span class="hb-blog-post-taxonomy-meta"><a class="hb-blog-post-taxonomy hb-blog-post-taxonomy-category badge bg-secondary text-decoration-none fw-normal me-1" href="/categories/c++/">C++</a>
</span><span class="hb-blog-post-taxonomy-meta"><a class="hb-blog-post-taxonomy hb-blog-post-taxonomy-series badge bg-secondary text-decoration-none fw-normal me-1" href="/series/%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/">基础教程</a></span></div><div class="hb-blog-post-summary card-text text-secondary mb-auto">C++ 变量作用域 作用域是程序的一个区域，一般来说有三个地方可以声明变量：
在函数或一个代码块内部声明的变量，称为局部变量。 在函数参数的定义中声明的变量，称为形式参数。 在所有函数外部声明的变量，称为全局变量。 我们将在后续的章节中学习什么是函数和参数。本章我们先来讲解声明是局部变量和全局变量。
局部变量 在函数或一个代码块内部声明的变量，称为局部变量。它们只能被函数内部或者代码块内部的语句使用。下面的实例使用了局部变量：
1#include &lt;iostream&gt; 2using namespace std; 3int main () 4 // 局部变量声明 5 int a, b; 6 int c; 7 // 实际初始化 8 a = 10; 9 b = 20; 10 c = a + b; 11 cout &lt;&lt; c; return 0; 12} 全局变量 在所有函数外部定义的变量（通常是在程序的头部），称为全局变量。全局变量的值在程序的整个生命周期内都是有效的。
全局变量可以被任何函数访问。也就是说，全局变量一旦声明，在整个程序中都是可用的。下面的实例使用了全局变量和局部变量：
1#include &lt;iostream&gt; 2using namespace std; 3// 全局变量声明 4int g; 5int main () 6 // 局部变量声明 7 int a, b; 8 // 实际初始化 9 a = 10; 10 b = 20; 11 g = a + b; 12 cout &lt;&lt; g; return 0; 13 } 在程序中，局部变量和全局变量的名称可以相同，但是在函数内，局部变量的值会覆盖全局变量的值。下面是一个实例：</div><div class="mt-2"><a class="text-secondary" href="/docs/programing/c++/default/7/">阅读更多关于C++ 变量作用域的内容。</a></div></div></div></div><div class="col"><div class="hb-blog-post-card card border-0 overflow-hidden h-100 hb-module mb-0"><div class="hb-blog-post-meta d-flex align-items-center"><a class="hb-blog-post-author-link text-decoration-none" href="/authors/andywu/" title="安图新"><picture><img class="hb-blog-author-img rounded-circle" src="https://cdn.hotmindshare.com/public%2Fandyng_1000x1000.png" alt="安图新" loading="lazy"/>
</picture></a><span class="hb-blog-post-date">2022年10月6日</span>
<span class="hb-blog-post-reading-time">4 分钟阅读</span>
<span class="hb-blog-post-section"><a class="badge bg-secondary text-decoration-none fw-normal" href="/docs/">技术教程</a></span></div><a class="card-img-top overflow-hidden border border-secondary-subtle text-body text-decoration-none mt-2" href="/docs/code-design/6_miss/"><picture><source srcset="/images/thumbnail_hu2c04c355e02fd9f63b765bcdb503cf1c_2284289_db4ab978a5e64c694fdda20c4098bfd2.webp" type="image/webp"/><img class="hb-blog-post-card-img" src="https://www.hotmindshare.com/images/thumbnail_hu2c04c355e02fd9f63b765bcdb503cf1c_2284289_0x360_resize_box_3.c4a823371e7699a6d0a45f2ed38908a1.png" alt="六、抽象工厂模式 ( Abstract Factory Pattern )" loading="lazy" height="360" width="630"/></picture></a><div class="card-body px-0 py-2 d-flex flex-column"><div class="hb-blog-post-title card-title h5 py-1"><a class="hb-blog-post-title-link d-block" title="六、抽象工厂模式 ( Abstract Factory Pattern )" href="/docs/code-design/6_miss/">六、抽象工厂模式 ( Abstract Factory Pattern )</a></div><div class="hb-blog-post-meta d-block text-nowrap text-truncate mb-2"><span class="hb-blog-post-taxonomy-meta"><a class="hb-blog-post-taxonomy hb-blog-post-taxonomy-category badge bg-secondary text-decoration-none fw-normal me-1" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a>
</span><span class="hb-blog-post-taxonomy-meta"><a class="hb-blog-post-taxonomy hb-blog-post-taxonomy-series badge bg-secondary text-decoration-none fw-normal me-1" href="/series/%E8%BF%9B%E9%98%B6%E6%95%99%E7%A8%8B/">进阶教程</a></span></div><div class="hb-blog-post-summary card-text text-secondary mb-auto">抽象工厂模式（Abstract Factory Pattern）是围绕一个超级工厂创建其他工厂
该超级工厂又称为其他工厂的工厂
在抽象工厂模式中，接口是负责创建一个相关对象的工厂，不需要显式指定它们的类
每个生成的工厂都能按照工厂模式提供对象
抽象工厂模式属于创建型模式，它提供了一种创建对象的最佳方式。
摘要 1、 意图：
提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类
2、 主要解决：
主要解决接口选择的问题
3、 何时使用：
系统的产品有多于一个的产品族，而系统只消费其中某一族的产品
4、 如何解决：
在一个产品族里面，定义多个产品
5、 关键代码：
在一个工厂里聚合多个同类产品
6、 应用实例：
工作了，为了参加一些聚会，肯定有两套或多套衣服吧，比如说有商务装（成套，一系列具体产品）、时尚装（成套，一系列具体产品），甚至对于一个家庭来说，可能有商务女装、商务男装、时尚女装、时尚男装，这些也都是成套的，即一系列具体产品
假设一种情况（现实中是不存在的，要不然，没法进入共产主义了，但有利于说明抽象工厂模式），在您的家中，某一个衣柜（具体工厂）只能存放某一种这样的衣服（成套，一系列具体产品），每次拿这种成套的衣服时也自然要从这个衣柜中取出了
用OO 的思想去理解，所有的衣柜（具体工厂）都是衣柜类的（抽象工厂）某一个，而每一件成套的衣服又包括具体的上衣（某一具体产品），裤子（某一具体产品），这些具体的上衣其实也都是上衣（抽象产品），具体的裤子也都是裤子（另一个抽象产品）
7、 优点：
缺点：
产品族扩展非常困难，要增加一个系列的某一产品，既要在抽象的 Creator 里加代码，又要在具体的里面加代码
9、 使用场景：
1、 QQ换皮肤，一整套一起换；
2、 生成不同操作系统的程序；
10、 注意事项：
产品族难扩展，产品等级易扩展
实现 1、 创建Shape和Color接口和实现这些接口的实体类；
2、 创建抽象工厂类AbstractFactory；
3、 定义工厂类ShapeFactory和ColorFactory，这两个工厂类都是扩展了AbstractFactory；
4、 创建一个工厂创造器/生成器类FactoryProducer；
5、 AbstractFactoryPatternDemo使用FactoryProducer来获取AbstractFactory对象；
它将向AbstractFactory 传递形状信息 Shape （ CIRCLE / RECTANGLE / SQUARE ），以便获取它所需对象的类型
同时它还向 AbstractFactory 传递颜色信息 Color （ RED / GREEN / BLUE ），以便获取它所需对象的类型</div><div class="mt-2"><a class="text-secondary" href="/docs/code-design/6_miss/">阅读更多关于六、抽象工厂模式 ( Abstract Factory Pattern )的内容。</a></div></div></div></div><div class="col"><div class="hb-blog-post-card card border-0 overflow-hidden h-100 hb-module mb-0"><div class="hb-blog-post-meta d-flex align-items-center"><a class="hb-blog-post-author-link text-decoration-none" href="/authors/andywu/" title="安图新"><picture><img class="hb-blog-author-img rounded-circle" src="https://cdn.hotmindshare.com/public%2Fandyng_1000x1000.png" alt="安图新" loading="lazy"/>
</picture></a><span class="hb-blog-post-date">2022年10月6日</span>
<span class="hb-blog-post-reading-time">1 分钟阅读</span>
<span class="hb-blog-post-section"><a class="badge bg-secondary text-decoration-none fw-normal" href="/docs/">技术教程</a></span></div><a class="card-img-top overflow-hidden border border-secondary-subtle text-body text-decoration-none mt-2" href="/docs/java/concurrency/default/6/"><picture><source srcset="/images/thumbnail_hu2c04c355e02fd9f63b765bcdb503cf1c_2284289_db4ab978a5e64c694fdda20c4098bfd2.webp" type="image/webp"/><img class="hb-blog-post-card-img" src="https://www.hotmindshare.com/images/thumbnail_hu2c04c355e02fd9f63b765bcdb503cf1c_2284289_0x360_resize_box_3.c4a823371e7699a6d0a45f2ed38908a1.png" alt="" loading="lazy" height="360" width="630"/></picture></a><div class="card-body px-0 py-2 d-flex flex-column"><div class="hb-blog-post-title card-title h5 py-1"><a class="hb-blog-post-title-link d-block" title="" href="/docs/java/concurrency/default/6/"></a></div><div class="hb-blog-post-meta d-block text-nowrap text-truncate mb-2"><span class="hb-blog-post-taxonomy-meta"><a class="hb-blog-post-taxonomy hb-blog-post-taxonomy-category badge bg-secondary text-decoration-none fw-normal me-1" href="/categories/java/">Java</a>
</span><span class="hb-blog-post-taxonomy-meta"><a class="hb-blog-post-taxonomy hb-blog-post-taxonomy-category badge bg-secondary text-decoration-none fw-normal me-1" href="/categories/java%E5%B9%B6%E5%8F%91/">Java并发</a>
</span><span class="hb-blog-post-taxonomy-meta"><a class="hb-blog-post-taxonomy hb-blog-post-taxonomy-series badge bg-secondary text-decoration-none fw-normal me-1" href="/series/%E8%BF%9B%E9%98%B6%E6%95%99%E7%A8%8B/">进阶教程</a></span></div><div class="hb-blog-post-summary card-text text-secondary mb-auto">ForkJoinPool 是Java 7 中引入的 fork/join 框架的核心之一。它解决了一个常见的问题： 如何在递归中生成多个任务。因为，即使是使用一个简单的 ThreadPoolExecutor ，也会在不断的递归中快速耗尽线程。因为每个任务或子任务都需要自己的线程来运行。
在fork/join 框架中，任何任务都可以生成 ( fork ) 多个子任务并使用 join() 方法等待它们的完成。fork/join 框架的好处是它不会为每个任务或子任务创建新线程，而是实现了 工作窃取 ( Work Stealing ) 算法。关于 fork/join 框架的详细信息，你可以访问我们的 一文秒懂 Java Fork/Join。
接下来，我们看一个使用 ForkJoinPool 遍历节点树并计算所有叶值之和的简单示例。在这个示例中，树是一个由节点，int 值和一组子节点组成。
1static class TreeNode { 2 int value; 3 Set&lt;TreeNode&gt; children; 4 TreeNode(int value, TreeNode... children) { 5 this.value = value; 6 this.children = Sets.newHashSet(children); 7 } 创建了树 TreeNode 之后，如果我们想要并行地对树中的所有值求和，我们需要实现一个 RecursiveTask&lt;Integer&gt; 接口。每个任务都接收自己的节点，并将其值添加到其子节点的值之和上。
要计算子节点值的总和，任务实现执行以下操作
1、 将子节点集合转换为流(stream)；
2、
因初次访问，为防止爬虫和人机识别，请关注微信公众号，回复:‘验证码‘获取验证码来解锁全文 解锁内容 映射前面操作中创建的流，为每个元素创建一个新的CountingTask；</div><div class="mt-2"><a class="text-secondary" href="/docs/java/concurrency/default/6/">阅读更多关于的内容。</a></div></div></div></div><div class="col"><div class="hb-blog-post-card card border-0 overflow-hidden h-100 hb-module mb-0"><div class="hb-blog-post-meta d-flex align-items-center"><a class="hb-blog-post-author-link text-decoration-none" href="/authors/andywu/" title="安图新"><picture><img class="hb-blog-author-img rounded-circle" src="https://cdn.hotmindshare.com/public%2Fandyng_1000x1000.png" alt="安图新" loading="lazy"/>
</picture></a><span class="hb-blog-post-date">2022年10月6日</span>
<span class="hb-blog-post-reading-time">3 分钟阅读</span>
<span class="hb-blog-post-section"><a class="badge bg-secondary text-decoration-none fw-normal" href="/docs/">技术教程</a></span></div><a class="card-img-top overflow-hidden border border-secondary-subtle text-body text-decoration-none mt-2" href="/docs/cloud-native/docker/6/"><picture><source srcset="/images/thumbnail_hu2c04c355e02fd9f63b765bcdb503cf1c_2284289_db4ab978a5e64c694fdda20c4098bfd2.webp" type="image/webp"/><img class="hb-blog-post-card-img" src="https://www.hotmindshare.com/images/thumbnail_hu2c04c355e02fd9f63b765bcdb503cf1c_2284289_0x360_resize_box_3.c4a823371e7699a6d0a45f2ed38908a1.png" alt="六、Docker run 运行镜像" loading="lazy" height="360" width="630"/></picture></a><div class="card-body px-0 py-2 d-flex flex-column"><div class="hb-blog-post-title card-title h5 py-1"><a class="hb-blog-post-title-link d-block" title="六、Docker run 运行镜像" href="/docs/cloud-native/docker/6/">六、Docker run 运行镜像</a></div><div class="hb-blog-post-meta d-block text-nowrap text-truncate mb-2"><span class="hb-blog-post-taxonomy-meta"><a class="hb-blog-post-taxonomy hb-blog-post-taxonomy-category badge bg-secondary text-decoration-none fw-normal me-1" href="/categories/%E4%BA%91%E5%8E%9F%E7%94%9F/">云原生</a>
</span><span class="hb-blog-post-taxonomy-meta"><a class="hb-blog-post-taxonomy hb-blog-post-taxonomy-category badge bg-secondary text-decoration-none fw-normal me-1" href="/categories/docker/">Docker</a>
</span><span class="hb-blog-post-taxonomy-meta"><a class="hb-blog-post-taxonomy hb-blog-post-taxonomy-series badge bg-secondary text-decoration-none fw-normal me-1" href="/series/%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/">基础教程</a></span></div><div class="hb-blog-post-summary card-text text-secondary mb-auto">Docker 是一个开源的应用容器引擎，基于 Go 语言 并遵从 Apache2.0 协议开源
Docker 可以让开发者打包它们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化
Docker 使用完全使用沙箱机制，两个容器之间不会有任何接口 (这个有点像 iPhone 的 app ) ,更重要的是容器性能开销极低
学习前提 在继续阅读之前，我们希望你对 Linux 有一些基本的了解，包括
1、 会使用Linux常用的命令；
2、 知道大部分的Linux常识，比如终端、service、ip、用户、组等；
3、 熟练使用Ubuntu或者Centos或者MacOS种的一种昂；
如果你对这些知识还是一知半解，可以访问我们的 Linux 基础教程 先进行一些简单的了解
Docker的应用场景 1、 Web应用的自动化打包和发布；
2、 自动化测试和持续集成、发布；
3、 在服务型环境中部署和调整数据库或其他的后台应用；
4、 从头编译或者扩展现有的OpenShift或CloudFoundry平台来搭建自己的PaaS环境；
Docker 的优点 1、 简化程序；
1Docker 让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的 Linux 机器上，便可以实现虚拟化 2Docker 改变了虚拟化的方式，使开发者可以直接将自己的成果放入 Docker 中进行管理 3方便快捷已经是 Docker 的最大优势，过去需要用数天乃至数周的 任务，在Docker容器的处理下，只需要数秒就能完成 2、 解决运维配置噩梦；
1在没有 Docker 之前，每一台机器，每一个要用到的依赖，几乎都要重新配置一遍 2比如新增一台 MySQL 数据库，就要从头开始配置所有环境 3有了 Docker 之后，只需要从仓库里把之前的 MySQL 镜像拉出来，直接使用 3、 节省开支；</div><div class="mt-2"><a class="text-secondary" href="/docs/cloud-native/docker/6/">阅读更多关于六、Docker run 运行镜像的内容。</a></div></div></div></div><div class="col"><div class="hb-blog-post-card card border-0 overflow-hidden h-100 hb-module mb-0"><div class="hb-blog-post-meta d-flex align-items-center"><a class="hb-blog-post-author-link text-decoration-none" href="/authors/andywu/" title="安图新"><picture><img class="hb-blog-author-img rounded-circle" src="https://cdn.hotmindshare.com/public%2Fandyng_1000x1000.png" alt="安图新" loading="lazy"/>
</picture></a><span class="hb-blog-post-date">2022年10月6日</span>
<span class="hb-blog-post-reading-time">2 分钟阅读</span>
<span class="hb-blog-post-section"><a class="badge bg-secondary text-decoration-none fw-normal" href="/docs/">技术教程</a></span></div><a class="card-img-top overflow-hidden border border-secondary-subtle text-body text-decoration-none mt-2" href="/docs/programing/c++/default/6/"><picture><source srcset="/images/thumbnail_hu2c04c355e02fd9f63b765bcdb503cf1c_2284289_db4ab978a5e64c694fdda20c4098bfd2.webp" type="image/webp"/><img class="hb-blog-post-card-img" src="https://www.hotmindshare.com/images/thumbnail_hu2c04c355e02fd9f63b765bcdb503cf1c_2284289_0x360_resize_box_3.c4a823371e7699a6d0a45f2ed38908a1.png" alt="C++ 变量类型" loading="lazy" height="360" width="630"/></picture></a><div class="card-body px-0 py-2 d-flex flex-column"><div class="hb-blog-post-title card-title h5 py-1"><a class="hb-blog-post-title-link d-block" title="C++ 变量类型" href="/docs/programing/c++/default/6/">C++ 变量类型</a></div><div class="hb-blog-post-meta d-block text-nowrap text-truncate mb-2"><span class="hb-blog-post-taxonomy-meta"><a class="hb-blog-post-taxonomy hb-blog-post-taxonomy-category badge bg-secondary text-decoration-none fw-normal me-1" href="/categories/c++/">C++</a>
</span><span class="hb-blog-post-taxonomy-meta"><a class="hb-blog-post-taxonomy hb-blog-post-taxonomy-series badge bg-secondary text-decoration-none fw-normal me-1" href="/series/%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/">基础教程</a></span></div><div class="hb-blog-post-summary card-text text-secondary mb-auto">C++ 变量类型 变量其实只不过是程序可操作的存储区的名称。C++ 中每个变量都有指定的类型，类型决定了变量存储的大小和布局，该范围内的值都可以存储在内存中，运算符可应用于变量上。
变量的名称可以由字母、数字和下划线字符组成。它必须以字母或下划线开头。大写字母和小写字母是不同的，因为 C++ 是大小写敏感的。
基于前一章讲解的基本类型，有以下几种基本的变量类型，将在下一章中进行讲解：
类型 描述 bool 存储值 true 或 false。 char 通常是一个八位字节（一个字节）。这是一个整数类型。 int 对机器而言，整数的最自然的大小。 float 单精度浮点值。 double 双精度浮点值。 void 表示类型的缺失。 wchar_t 宽字符类型。 C++也允许定义各种其他类型的变量，比如枚举、指针、数组、引用、数据结构、类等等，这将会在后续的章节中进行讲解。
下面我们将讲解如何定义、声明和使用各种类型的变量。
C++ 中的变量定义 变量定义就是告诉编译器在何处创建变量的存储，以及如何创建变量的存储。变量定义指定一个数据类型，并包含了该类型的一个或多个变量的列表，如下所示：
1type variable_list; 在这里，type 必须是一个有效的 C++ 数据类型，可以是 char、w_char、int、float、double、bool 或任何用户自定义的对象，variable_list 可以由一个或多个标识符名称组成，多个标识符之间用逗号分隔。下面列出几个有效的声明：
1int i, j, k; 2char c, ch; 3float f, salary; 4double d; 行 int i, j, k; 声明并定义了变量 i、j 和 k，这指示编译器创建类型为 int 的名为 i、j、k 的变量。
变量可以在声明的时候被初始化（指定一个初始值）。初始化器由一个等号，后跟一个常量表达式组成，如下所示：
1type variable_name = value; 下面列举几个实例：</div><div class="mt-2"><a class="text-secondary" href="/docs/programing/c++/default/6/">阅读更多关于C++ 变量类型的内容。</a></div></div></div></div></div></div></div><div class="border-1"><nav class="hb-blog-pagination mb-3" aria-label="Page navigation"><ul class="pagination flex-wrap justify-content-center"><li class="page-item"><a class="page-link" href="/archives/2022/10/page/2/" aria-label="前一页"><span aria-hidden="true">«</span></a></li><li class="page-item"><a class="page-link" href="/archives/2022/10/">1</a></li><li class="page-item"><a class="page-link" href="/archives/2022/10/page/2/">2</a></li><li class="page-item active"><a class="page-link" href="/archives/2022/10/page/3/">3</a></li><li class="page-item"><a class="page-link" href="/archives/2022/10/page/4/">4</a></li><li class="page-item"><a class="page-link" href="/archives/2022/10/page/5/">5</a></li><li class="page-item"><a class="page-link" href="/archives/2022/10/page/4/" aria-label="下一页"><span aria-hidden="true">»</span></a></li></ul></nav></div></div></div><footer class="hb-footer pt-4 pt-md-5 pb-2 pb-md-3 bg-body-tertiary"><div class="container-fluid container-lg px-4 px-md-3"><div class="row"><div class="hb-footer-site-info col mb-2 text-center"><div class="h5">程序员安仔</div><ul class="list-unstyled small mb-2"><li class="mt-2">一个只爱折腾技术的普通人</li><li class="mt-2">粤ICP备2023148789号</li></ul><div class="hb-footer-socials d-flex mb-2 justify-content-center flex-wrap"><a class="hb-social p-2" href="mailto:andywuwu0728@gmail.com" target="_blank" rel="nofollow me" title="Email"><svg aria-hidden="true" class="bi bi-envelope-fillbi bi-envelope-fill hi-svg-inline hb-social-icon" fill="currentcolor" height="1.75em" style="color:%!s(bool=true)" viewBox="0 0 16 16" width="1.75em" xmlns="http://www.w3.org/2000/svg"><path d="M.05 3.555A2 2 0 012 2h12a2 2 0 011.95 1.555L8 8.414.05 3.555zM0 4.697v7.104l5.803-3.558zM6.761 8.83.191 12.857A2 2 0 002 14h12a2 2 0 001.808-1.144l-6.57-4.027L8 9.586l-1.239-.757zm3.436-.586L16 11.801V4.697l-5.803 3.546z"></path></svg></a><a class="hb-social p-2" href="https://github.com/Andywugh" target="_blank" rel="nofollow me" title="GitHub"><svg aria-hidden="true" class="hi-svg-inline hb-social-icon" fill="currentcolor" height="1.75em" role="img" style="color:%!s(bool=true)" viewBox="0 0 24 24" width="1.75em" xmlns="http://www.w3.org/2000/svg"><title>GitHub</title><path d="M12 .297c-6.63.0-12 5.373-12 12 0 5.303 3.438 9.8 8.205 11.385.6.113.82-.258.82-.577.0-.285-.01-1.04-.015-2.04-3.338.724-4.042-1.61-4.042-1.61C4.422 18.07 3.633 17.7 3.633 17.7c-1.087-.744.084-.729.084-.729 1.205.084 1.838 1.236 1.838 1.236 1.07 1.835 2.809 1.305 3.495.998.108-.776.417-1.305.76-1.605-2.665-.3-5.466-1.332-5.466-5.93.0-1.31.465-2.38 1.235-3.22-.135-.303-.54-1.523.105-3.176.0.0 1.005-.322 3.3 1.23.96-.267 1.98-.399 3-.405 1.02.006 2.04.138 3 .405 2.28-1.552 3.285-1.23 3.285-1.23.645 1.653.24 2.873.12 3.176.765.84 1.23 1.91 1.23 3.22.0 4.61-2.805 5.625-5.475 5.92.42.36.81 1.096.81 2.22.0 1.606-.015 2.896-.015 3.286.0.315.21.69.825.57C20.565 22.092 24 17.592 24 12.297c0-6.627-5.373-12-12-12"></path></svg></a><a class="hb-social p-2" href="/index.xml" target="_blank" rel="nofollow me" title="RSS"><svg aria-hidden="true" class="bi bi-rss-fillbi bi-rss-fill hi-svg-inline hb-social-icon" fill="currentcolor" height="1.75em" style="color:%!s(bool=true)" viewBox="0 0 16 16" width="1.75em" xmlns="http://www.w3.org/2000/svg"><path d="M2 0A2 2 0 000 2v12a2 2 0 002 2h12a2 2 0 002-2V2a2 2 0 00-2-2zm1.5 2.5c5.523.0 10 4.477 10 10a1 1 0 11-2 0 8 8 0 00-8-8 1 1 0 010-2m0 4a6 6 0 016 6 1 1 0 11-2 0 4 4 0 00-4-4 1 1 0 010-2m.5 7a1.5 1.5.0 110-3 1.5 1.5.0 010 3"></path></svg></a><a class="hb-social p-2" href="https://www.zhihu.com/people/Andywuwu" target="_blank" rel="nofollow me" title="知乎"><svg aria-hidden="true" class="hi-svg-inline hb-social-icon" fill="currentcolor" height="1.75em" role="img" style="color:#056de8" viewBox="0 0 24 24" width="1.75em" xmlns="http://www.w3.org/2000/svg"><title>Zhihu</title><path d="M5.721.0C2.251.0.0 2.25.0 5.719V18.28C0 21.751 2.252 24 5.721 24h12.56C21.751 24 24 21.75 24 18.281V5.72C24 2.249 21.75.0 18.281.0zm1.964 4.078c-.271.73-.5 1.434-.68 2.11h4.587c.545-.006.445 1.168.445 1.171H9.384a58.104 58.104.0 01-.112 3.797h2.712c.388.023.393 1.251.393 1.266H9.183a9.223 9.223.0 01-.408 2.102l.757-.604c.452.456 1.512 1.712 1.906 2.177.473.681.063 2.081.063 2.081l-2.794-3.382c-.653 2.518-1.845 3.607-1.845 3.607-.523.468-1.58.82-2.64.516 2.218-1.73 3.44-3.917 3.667-6.497H4.491c0-.015.197-1.243.806-1.266h2.71c.024-.32.086-3.254.086-3.797H6.598c-.136.406-.158.447-.268.753-.594 1.095-1.603 1.122-1.907 1.155.906-1.821 1.416-3.6 1.591-4.064.425-1.124 1.671-1.125 1.671-1.125zM13.078 6h6.377v11.33h-2.573l-2.184 1.373-.401-1.373h-1.219zm1.313 1.219v8.86h.623l.263.937 1.455-.938h1.456v-8.86z"></path></svg></a></div></div></div></div></footer><script src="/js/hb.19ff2dd5085ae395c8501e5aef2fbcc49e7612473405d8eb7352b40a406e9daf.js" integrity="sha256-Gf8t1Qha45XIUB5a7y+8xJ52Ekc0Bdjrc1K0CkBuna8=" defer=""></script><script src="/js/search.60c6325701a1a087903f75b2304b1bb0ff0572506d58f09d2f9ce6c41cc85908.js" defer=""></script><script>"serviceWorker"in navigator&&window.addEventListener("DOMContentLoaded",function(){navigator.serviceWorker.register("/sw.js")})</script></body></html>